infix operator %= {
    associativity right
    precedence 90
    assignment
}

infix operator >= {
    associativity none
    precedence 130
}

infix operator += {
    associativity right
    precedence 90
    assignment
}

infix operator -= {
    associativity right
    precedence 90
    assignment
}

infix operator ... {
    associativity none
    precedence 135
}

infix operator /= {
    associativity right
    precedence 90
    assignment
}

infix operator && {
    associativity left
    precedence 120
}

infix operator &* {
    associativity left
    precedence 150
}

infix operator &+ {
    associativity left
    precedence 140
}

infix operator &- {
    associativity left
    precedence 140
}

infix operator === {
    associativity none
    precedence 130
}

infix operator ..< {
    associativity none
    precedence 135
}

infix operator == {
    associativity none
    precedence 130
}

infix operator ^= {
    associativity right
    precedence 90
    assignment
}

infix operator ?? {
    associativity right
    precedence 131
}

infix operator ^ {
    associativity left
    precedence 140
}

infix operator > {
    associativity none
    precedence 130
}

infix operator &= {
    associativity right
    precedence 90
    assignment
}

infix operator % {
    associativity left
    precedence 150
}

infix operator & {
    associativity left
    precedence 150
}

infix operator *= {
    associativity right
    precedence 90
    assignment
}

infix operator * {
    associativity left
    precedence 150
}

infix operator != {
    associativity none
    precedence 130
}

infix operator + {
    associativity left
    precedence 140
}

infix operator >> {
    associativity none
    precedence 160
}

infix operator - {
    associativity left
    precedence 140
}

infix operator / {
    associativity left
    precedence 150
}

infix operator <<= {
    associativity right
    precedence 90
    assignment
}

infix operator | {
    associativity left
    precedence 140
}

infix operator < {
    associativity none
    precedence 130
}

infix operator || {
    associativity left
    precedence 110
}

infix operator << {
    associativity none
    precedence 160
}

infix operator |= {
    associativity right
    precedence 90
    assignment
}

infix operator >>= {
    associativity right
    precedence 90
    assignment
}

infix operator <= {
    associativity none
    precedence 130
}

infix operator ~> {
    associativity left
    precedence 255
}

infix operator !== {
    associativity none
    precedence 130
}

infix operator ~= {
    associativity none
    precedence 130
}

prefix operator -- {
}

prefix operator ++ {
}

prefix operator - {
}

prefix operator + {
}

prefix operator ! {
}

prefix operator ~ {
}

postfix operator -- {
}

postfix operator ++ {
}

/// Performs a logical NOT operation on a Boolean value.
///
/// The logical NOT operator (`!`) inverts a Boolean value. If the value is
/// `true`, the result of the operation is `false`; if the value is `false`,
/// the result is `true`. For example:
///
///     var printedMessage = false
///
///     if !printedMessage {
///         print("You look nice today!")
///         printedMessage = true
///     }
///     // Prints "You look nice today!"
///
/// - Parameter a: The Boolean value to negate.
prefix public func !<T : Boolean>(a: T) -> Bool

/// Performs a logical NOT operation on a Boolean value.
///
/// The logical NOT operator (`!`) inverts a Boolean value. If the value is
/// `true`, the result of the operation is `false`; if the value is `false`,
/// the result is `true`.
///
///     var printedMessage = false
///
///     if !printedMessage {
///         print("You look nice today!")
///         printedMessage = true
///     }
///     // Prints "You look nice today!"
///
/// - Parameter a: The Boolean value to negate.
prefix public func !(a: Bool) -> Bool

/// Returns `true` if the arrays do not contain the same elements.
public func !=<Element : Equatable>(lhs: ArraySlice<Element>, rhs: ArraySlice<Element>) -> Bool

/// Returns `true` if the arrays do not contain the same elements.
public func !=<Element : Equatable>(lhs: ContiguousArray<Element>, rhs: ContiguousArray<Element>) -> Bool

/// Returns `true` if the arrays do not contain the same elements.
public func !=<Element : Equatable>(lhs: [Element], rhs: [Element]) -> Bool

/// Returns `false` iff `t0` is identical to `t1`; i.e. if they are both
/// `nil` or they both represent the same type.
public func !=(t0: Swift.Any.Type?, t1: Swift.Any.Type?) -> Bool

/// Returns a Boolean value indicating whether the two arguments are not equal.
///
/// - Parameters:
///   - lhs: A raw-representable instance.
///   - rhs: A second raw-representable instance.
public func !=<T : RawRepresentable where T.RawValue : Equatable>(lhs: T, rhs: T) -> Bool

/// Returns a Boolean value indicating whether the two arguments are not equal.
///
/// - Parameters:
///   - lhs: A raw-representable instance.
///   - rhs: A second raw-representable instance.
public func !=<T : Equatable where T : RawRepresentable, T.RawValue : Equatable>(lhs: T, rhs: T) -> Bool

public func !=<Base : Collection>(lhs: LazyFilterIndex<Base>, rhs: LazyFilterIndex<Base>) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have unequal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func !=(lhs: UInt8, rhs: UInt8) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have unequal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func !=(lhs: Int8, rhs: Int8) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have unequal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func !=(lhs: UInt16, rhs: UInt16) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have unequal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func !=(lhs: Int16, rhs: Int16) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have unequal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func !=(lhs: UInt32, rhs: UInt32) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have unequal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func !=(lhs: Int32, rhs: Int32) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have unequal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func !=(lhs: UInt64, rhs: UInt64) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have unequal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func !=(lhs: Int64, rhs: Int64) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have unequal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func !=(lhs: UInt, rhs: UInt) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have unequal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func !=(lhs: Int, rhs: Int) -> Bool

public func !=<Key : Equatable, Value : Equatable>(lhs: [Key : Value], rhs: [Key : Value]) -> Bool

public func !=<T : Equatable>(lhs: T?, rhs: T?) -> Bool

public func !=<T>(lhs: T?, rhs: _OptionalNilComparisonType) -> Bool

public func !=<T>(lhs: _OptionalNilComparisonType, rhs: T?) -> Bool

/// Returns a Boolean value indicating whether two values are not equal.
///
/// Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
/// implies that `a == b` is `false`.
///
/// This is the default implementation of the is-not-equal-to operator (`!=`)
/// for any type that conforms to `Equatable`.
///
/// - Parameters:
///   - lhs: A value to compare.
///   - rhs: Another value to compare.
public func !=<T : Equatable>(lhs: T, rhs: T) -> Bool

public func !=(lhs: AnyIndex, rhs: AnyIndex) -> Bool

/// Returns `true` iff any component of `lhs` is not equal to the corresponding
/// component of `rhs`.
public func !=<A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable, F : Equatable>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool

/// Returns `true` iff any component of `lhs` is not equal to the corresponding
/// component of `rhs`.
public func !=<A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool

/// Returns `true` iff any component of `lhs` is not equal to the corresponding
/// component of `rhs`.
public func !=<A : Equatable, B : Equatable, C : Equatable, D : Equatable>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool

/// Returns `true` iff any component of `lhs` is not equal to the corresponding
/// component of `rhs`.
public func !=<A : Equatable, B : Equatable, C : Equatable>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool

/// Returns `true` iff any component of `lhs` is not equal to the corresponding
/// component of `rhs`.
public func !=<A : Equatable, B : Equatable>(lhs: (A, B), rhs: (A, B)) -> Bool

/// Returns `false` iff `lhs` and `rhs` store the same underlying collection.
public func !==<L : AnyCollectionProtocol, R : AnyCollectionProtocol>(lhs: L, rhs: R) -> Bool

public func !==(lhs: AnyObject?, rhs: AnyObject?) -> Bool

public func %(lhs: UInt8, rhs: UInt8) -> UInt8

public func %(lhs: Int8, rhs: Int8) -> Int8

public func %(lhs: UInt16, rhs: UInt16) -> UInt16

public func %(lhs: Int16, rhs: Int16) -> Int16

public func %(lhs: UInt32, rhs: UInt32) -> UInt32

public func %(lhs: Int32, rhs: Int32) -> Int32

public func %(lhs: UInt64, rhs: UInt64) -> UInt64

public func %(lhs: Int64, rhs: Int64) -> Int64

public func %(lhs: UInt, rhs: UInt) -> UInt

public func %(lhs: Int, rhs: Int) -> Int

/// Divides `lhs` and `rhs`, returning the remainder and trapping in case of
/// arithmetic overflow (except in -Ounchecked builds).
public func %<T : _IntegerArithmetic>(lhs: T, rhs: T) -> T

/// Divides `lhs` and `rhs` and stores the remainder in `lhs`, trapping in
/// case of arithmetic overflow (except in -Ounchecked builds).
public func %=<T : _IntegerArithmetic>(lhs: inout T, rhs: T)

/// Returns the intersection of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func &(lhs: UInt, rhs: UInt) -> UInt

/// Returns the intersection of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func &(lhs: Int, rhs: Int) -> Int

/// Returns the intersection of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func &(lhs: UInt8, rhs: UInt8) -> UInt8

/// Returns the intersection of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func &(lhs: Int8, rhs: Int8) -> Int8

/// Returns the intersection of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func &(lhs: UInt16, rhs: UInt16) -> UInt16

/// Returns the intersection of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func &(lhs: Int16, rhs: Int16) -> Int16

/// Returns the intersection of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func &(lhs: UInt32, rhs: UInt32) -> UInt32

/// Returns the intersection of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func &(lhs: Int32, rhs: Int32) -> Int32

/// Returns the intersection of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func &(lhs: UInt64, rhs: UInt64) -> UInt64

/// Returns the intersection of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func &(lhs: Int64, rhs: Int64) -> Int64

public func &&<T : Boolean>(lhs: T, rhs: @autoclosure () throws -> Bool) rethrows -> Bool

/// Performs a logical AND operation on two Boolean values.
///
/// The logical AND operator (`&&`) combines two Boolean values and returns
/// `true` if both of the values are `true`. If either of the values is
/// `false`, the operator returns `false`.
///
/// This operator uses short-circuit evaluation: The left-hand side (`lhs`) is
/// evaluated first, and the right-hand side (`rhs`) is evaluated only if
/// `lhs` evaluates to `true`. For example:
///
///     let measurements = [7.44, 6.51, 4.74, 5.88, 6.27, 6.12, 7.76]
///     let sum = measurements.reduce(0, combine: +)
///
///     if measurements.count > 0 && sum / Double(measurements.count) < 6.5 {
///         print("Average measurement is less than 6.5")
///     }
///     // Prints "Average measurement is less than 6.5"
///
/// In this example, `lhs` tests whether `measurements.count` is greater than
/// zero. Evaluation of the `&&` operator is one of the following:
///
/// - When `measurements.count` is equal to zero, `lhs` evaluates to `false`
///   and `rhs` is not evaluated, preventing a divide-by-zero error in the
///   expression `sum / Double(measurements.count)`. The result of the
///   operation is `false`.
/// - When `measurements.count` is greater than zero, `lhs` evaluates to `true`
///   and `rhs` is evaluated. The result of evaluating `rhs` is the result of
///   the `&&` operation.
///
/// - Parameters:
///   - lhs: The left-hand side of the operation.
///   - rhs: The right-hand side of the operation.
public func &&<T : Boolean, U : Boolean>(lhs: T, rhs: @autoclosure () throws -> U) rethrows -> Bool

/// Multiplies `lhs` and `rhs`, silently discarding any overflow.
public func &*<T : _IntegerArithmetic>(lhs: T, rhs: T) -> T

/// Adds `lhs` and `rhs`, silently discarding any overflow.
public func &+<T : _IntegerArithmetic>(lhs: T, rhs: T) -> T

/// Subtracts `lhs` and `rhs`, silently discarding any overflow.
public func &-<T : _IntegerArithmetic>(lhs: T, rhs: T) -> T

/// Calculates the intersection of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func &=(lhs: inout Int8, rhs: Int8)

/// Calculates the intersection of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func &=(lhs: inout UInt16, rhs: UInt16)

/// Calculates the intersection of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func &=(lhs: inout Int16, rhs: Int16)

/// Calculates the intersection of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func &=(lhs: inout UInt8, rhs: UInt8)

/// Calculates the intersection of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func &=(lhs: inout Int32, rhs: Int32)

/// Calculates the intersection of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func &=(lhs: inout UInt64, rhs: UInt64)

/// Calculates the intersection of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func &=(lhs: inout Int64, rhs: Int64)

/// Calculates the intersection of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func &=(lhs: inout UInt, rhs: UInt)

/// Calculates the intersection of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func &=(lhs: inout Int, rhs: Int)

/// Calculates the intersections of bits sets in the two arguments and stores
/// the result in the first argument.
///
/// - Parameters:
///   - lhs: A value to update with the intersections of bits set in the two
///     arguments.
///   - rhs: Another value.
public func &=<T : BitwiseOperations>(lhs: inout T, rhs: T)

/// Calculates the intersection of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func &=(lhs: inout UInt32, rhs: UInt32)

public func *(lhs: Int16, rhs: Int16) -> Int16

/// Multiplies `lhs` and `rhs`, returning the result and trapping in case of
/// arithmetic overflow (except in -Ounchecked builds).
public func *<T : _IntegerArithmetic>(lhs: T, rhs: T) -> T

public func *(lhs: Float80, rhs: Float80) -> Float80

public func *(lhs: Double, rhs: Double) -> Double

public func *(lhs: Float, rhs: Float) -> Float

public func *<T : FloatingPoint>(lhs: T, rhs: T) -> T

public func *(lhs: Int, rhs: Int) -> Int

public func *(lhs: UInt, rhs: UInt) -> UInt

public func *(lhs: Int64, rhs: Int64) -> Int64

public func *(lhs: UInt64, rhs: UInt64) -> UInt64

public func *(lhs: Int32, rhs: Int32) -> Int32

public func *(lhs: UInt32, rhs: UInt32) -> UInt32

public func *(lhs: UInt16, rhs: UInt16) -> UInt16

public func *(lhs: Int8, rhs: Int8) -> Int8

public func *(lhs: UInt8, rhs: UInt8) -> UInt8

public func *=(lhs: inout Int, rhs: Int)

public func *=(lhs: inout UInt, rhs: UInt)

public func *=(lhs: inout Int64, rhs: Int64)

public func *=(lhs: inout UInt64, rhs: UInt64)

public func *=(lhs: inout Int32, rhs: Int32)

public func *=(lhs: inout UInt32, rhs: UInt32)

public func *=(lhs: inout Int16, rhs: Int16)

public func *=(lhs: inout UInt16, rhs: UInt16)

public func *=(lhs: inout Int8, rhs: Int8)

public func *=(lhs: inout UInt8, rhs: UInt8)

public func *=<T : FloatingPoint>(lhs: inout T, rhs: T)

/// Multiplies `lhs` and `rhs` and stores the result in `lhs`, trapping in
/// case of arithmetic overflow (except in -Ounchecked builds).
public func *=<T : _IntegerArithmetic>(lhs: inout T, rhs: T)

public func *=(lhs: inout Float, rhs: Float)

public func *=(lhs: inout Float80, rhs: Float80)

public func *=(lhs: inout Double, rhs: Double)

public func +<Pointee>(lhs: Int, rhs: UnsafePointer<Pointee>) -> UnsafePointer<Pointee>

public func +<Pointee>(lhs: Int, rhs: UnsafeMutablePointer<Pointee>) -> UnsafeMutablePointer<Pointee>

public func +<Pointee>(lhs: UnsafeMutablePointer<Pointee>, rhs: Int) -> UnsafeMutablePointer<Pointee>

public func +(lhs: String, rhs: String) -> String

public func +<T : UnsignedInteger>(lhs: T._DisallowMixedSignArithmetic, rhs: T) -> T

public func +<T : UnsignedInteger>(lhs: T, rhs: T._DisallowMixedSignArithmetic) -> T

public func +<T : Strideable>(lhs: T.Stride, rhs: T) -> T

public func +<T : Strideable>(lhs: T, rhs: T.Stride) -> T

/// Creates a new collection by concatenating the elements of two collections.
///
/// The two arguments must have the same `Element` type. For example, you can
/// concatenate the elements of two integer arrays.
///
///     let lowerNumbers = [1, 2, 3, 4]
///     let higherNumbers: ContiguousArray = [5, 6, 7, 8, 9, 10]
///     let allNumbers = lowerNumbers + higherNumbers
///     print(allNumbers)
///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
///
/// The resulting collection has the type of the argument on the left-hand
/// side. In the example above, `moreNumbers` has the same type as `numbers`,
/// which is `[Int]`.
///
/// - Parameters:
///   - lhs: A range-replaceable collection.
///   - rhs: Another range-replaceable collection.
public func +<RRC1 : RangeReplaceableCollection, RRC2 : RangeReplaceableCollection where RRC1.Iterator.Element == RRC2.Iterator.Element>(lhs: RRC1, rhs: RRC2) -> RRC1

/// Creates a new collection by concatenating the elements of a sequence and a
/// collection.
///
/// The two arguments must have the same `Element` type. For example, you can
/// concatenate the elements of a `Range<Int>` instance and an integer array.
///
///     let numbers = [7, 8, 9, 10]
///     let moreNumbers = 1...6 + numbers
///     print(moreNumbers)
///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
///
/// The resulting collection has the type of argument on the right-hand side.
/// In the example above, `moreNumbers` has the same type as `numbers`, which
/// is `[Int]`.
///
/// - Parameters:
///   - lhs: A collection or finite sequence.
///   - rhs: A range-replaceable collection.
public func +<C : RangeReplaceableCollection, S : Sequence where S.Iterator.Element == C.Iterator.Element>(lhs: S, rhs: C) -> C

/// Creates a new collection by concatenating the elements of a collection and
/// a sequence.
///
/// The two arguments must have the same `Element` type. For example, you can
/// concatenate the elements of an integer array and a `Range<Int>` instance.
///
///     let numbers = [1, 2, 3, 4]
///     let moreNumbers = numbers + 5...10
///     print(moreNumbers)
///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
///
/// The resulting collection has the type of the argument on the left-hand
/// side. In the example above, `moreNumbers` has the same type as `numbers`,
/// which is `[Int]`.
///
/// - Parameters:
///   - lhs: A range-replaceable collection.
///   - rhs: A collection or finite sequence.
public func +<C : RangeReplaceableCollection, S : Sequence where S.Iterator.Element == C.Iterator.Element>(lhs: C, rhs: S) -> C

prefix public func +<T : SignedNumber>(x: T) -> T

/// Adds `lhs` and `rhs`, returning the result and trapping in case of
/// arithmetic overflow (except in -Ounchecked builds).
public func +<T : _IntegerArithmetic>(lhs: T, rhs: T) -> T

public func +(lhs: Float80, rhs: Float80) -> Float80

prefix public func +(x: Float80) -> Float80

public func +(lhs: Double, rhs: Double) -> Double

prefix public func +(x: Double) -> Double

public func +(lhs: Float, rhs: Float) -> Float

prefix public func +(x: Float) -> Float

public func +<T : FloatingPoint>(lhs: T, rhs: T) -> T

prefix public func +<T : FloatingPoint>(x: T) -> T

public func +(lhs: Int, rhs: Int) -> Int

public func +(lhs: UInt, rhs: UInt) -> UInt

public func +(lhs: Int64, rhs: Int64) -> Int64

public func +(lhs: UInt64, rhs: UInt64) -> UInt64

public func +(lhs: Int32, rhs: Int32) -> Int32

public func +<Pointee>(lhs: UnsafePointer<Pointee>, rhs: Int) -> UnsafePointer<Pointee>

public func +(lhs: Int16, rhs: Int16) -> Int16

public func +(lhs: UInt16, rhs: UInt16) -> UInt16

public func +(lhs: Int8, rhs: Int8) -> Int8

public func +(lhs: UInt8, rhs: UInt8) -> UInt8

public func +(lhs: UInt32, rhs: UInt32) -> UInt32

public func +=(lhs: inout Int32, rhs: Int32)

/// Appends the elements of a collection to a `ContiguousArray` instance.
///
/// Use this operator to append the elements of a collection to the end of
/// a `ContiguousArray` instance with same `Element` type. This example appends
/// the elements of a `Range<Int>` instance to an array of integers.
///
///     var numbers = [1, 2, 3, 4, 5]
///     numbers += 10...15
///     print(numbers)
///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
///
/// - Parameters:
///   - lhs: The array to append to.
///   - rhs: A collection.
///
/// - Complexity: O(*n*), where *n* is the length of the resulting array.
public func +=<C : Collection>(lhs: inout ContiguousArray<C.Iterator.Element>, rhs: C)

/// Appends the elements of a sequence to a `ContiguousArray` instance.
///
/// Use this operator to append the elements of a sequence to the end of
/// a `ContiguousArray` instance with same `Element` type. This example appends
/// the elements of a `Range<Int>` instance to an array of integers.
///
///     var numbers = [1, 2, 3, 4, 5]
///     numbers += 10...15
///     print(numbers)
///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
///
/// - Parameters:
///   - lhs: The array to append to.
///   - rhs: A collection or finite sequence.
///
/// - Complexity: O(*n*), where *n* is the length of the resulting array.
public func +=<S : Sequence>(lhs: inout ContiguousArray<S.Iterator.Element>, rhs: S)

/// Appends the elements of a sequence to an `ArraySlice` instance.
///
/// Use this operator to append the elements of a sequence to the end of
/// an `ArraySlice` instance with same `Element` type. This example appends
/// the elements of a `Range<Int>` instance to an array of integers.
///
///     var numbers = [1, 2, 3, 4, 5]
///     numbers += 10...15
///     print(numbers)
///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
///
/// - Parameters:
///   - lhs: The array to append to.
///   - rhs: A collection or finite sequence.
///
/// - Complexity: O(*n*), where *n* is the length of the resulting array.
public func +=<S : Sequence>(lhs: inout ArraySlice<S.Iterator.Element>, rhs: S)

/// Appends the elements of a collection to an `ArraySlice` instance.
///
/// Use this operator to append the elements of a collection to the end of
/// an `ArraySlice` instance with same `Element` type. This example appends
/// the elements of a `Range<Int>` instance to an array of integers.
///
///     var numbers = [1, 2, 3, 4, 5]
///     numbers += 10...15
///     print(numbers)
///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
///
/// - Parameters:
///   - lhs: The array to append to.
///   - rhs: A collection.
///
/// - Complexity: O(*n*), where *n* is the length of the resulting array.
public func +=<C : Collection>(lhs: inout ArraySlice<C.Iterator.Element>, rhs: C)

/// Appends the elements of a sequence to an array.
///
/// Use this operator to append the elements of a sequence to the end of
/// an array with same `Element` type. This example appends
/// the elements of a `Range<Int>` instance to an array of integers.
///
///     var numbers = [1, 2, 3, 4, 5]
///     numbers += 10...15
///     print(numbers)
///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
///
/// - Parameters:
///   - lhs: The array to append to.
///   - rhs: A collection or finite sequence.
///
/// - Complexity: O(*n*), where *n* is the length of the resulting array.
public func +=<S : Sequence>(lhs: inout [S.Iterator.Element], rhs: S)

/// Appends the elements of a collection to an array.
///
/// Use this operator to append the elements of a collection to the end of
/// an array with same `Element` type. This example appends
/// the elements of a `Range<Int>` instance to an array of integers.
///
///     var numbers = [1, 2, 3, 4, 5]
///     numbers += 10...15
///     print(numbers)
///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
///
/// - Parameters:
///   - lhs: The array to append to.
///   - rhs: A collection.
///
/// - Complexity: O(*n*), where *n* is the length of the resulting array.
public func +=<C : Collection>(lhs: inout [C.Iterator.Element], rhs: C)

/// Append the elements of `rhs` to `lhs`.
public func +=<Element, C : Collection where C.Iterator.Element == Element>(lhs: inout _ContiguousArrayBuffer<Element>, rhs: C)

public func +=(lhs: inout UInt8, rhs: UInt8)

public func +=(lhs: inout Int8, rhs: Int8)

public func +=(lhs: inout UInt16, rhs: UInt16)

public func +=(lhs: inout Int16, rhs: Int16)

public func +=(lhs: inout UInt32, rhs: UInt32)

public func +=(lhs: inout UInt64, rhs: UInt64)

public func +=<Pointee>(lhs: inout UnsafePointer<Pointee>, rhs: Int)

public func +=<Pointee>(lhs: inout UnsafeMutablePointer<Pointee>, rhs: Int)

public func +=(lhs: inout String, rhs: String)

public func +=<T : UnsignedInteger>(lhs: inout T, rhs: T._DisallowMixedSignArithmetic)

public func +=<T : Strideable>(lhs: inout T, rhs: T.Stride)

/// Adds `lhs` and `rhs` and stores the result in `lhs`, trapping in
/// case of arithmetic overflow (except in -Ounchecked builds).
public func +=<T : _IntegerArithmetic>(lhs: inout T, rhs: T)

public func +=(lhs: inout Float80, rhs: Float80)

public func +=(lhs: inout Double, rhs: Double)

public func +=(lhs: inout Float, rhs: Float)

public func +=<T : FloatingPoint>(lhs: inout T, rhs: T)

public func +=(lhs: inout Int, rhs: Int)

public func +=(lhs: inout UInt, rhs: UInt)

public func +=(lhs: inout Int64, rhs: Int64)

prefix public func -(x: Float80) -> Float80

public func -<T : FloatingPoint>(lhs: T, rhs: T) -> T

public func -(lhs: Float80, rhs: Float80) -> Float80

/// Subtracts `lhs` and `rhs`, returning the result and trapping in case of
/// arithmetic overflow (except in -Ounchecked builds).
public func -<T : _IntegerArithmetic>(lhs: T, rhs: T) -> T

prefix public func -<T : SignedNumber>(x: T) -> T

public func -<T : Strideable>(lhs: T, rhs: T.Stride) -> T

public func -<T : Strideable>(lhs: T, rhs: T) -> T.Stride

public func -<T : _DisallowMixedSignArithmetic>(lhs: T, rhs: T._DisallowMixedSignArithmetic) -> T

public func -<T : _DisallowMixedSignArithmetic>(lhs: T, rhs: T) -> T._DisallowMixedSignArithmetic

public func -<Pointee>(lhs: UnsafeMutablePointer<Pointee>, rhs: Int) -> UnsafeMutablePointer<Pointee>

public func -<Pointee>(lhs: UnsafeMutablePointer<Pointee>, rhs: UnsafeMutablePointer<Pointee>) -> Int

public func -<Pointee>(lhs: UnsafePointer<Pointee>, rhs: Int) -> UnsafePointer<Pointee>

public func -(lhs: Double, rhs: Double) -> Double

public func -(lhs: Float, rhs: Float) -> Float

prefix public func -(x: Float) -> Float

public func -<Pointee>(lhs: UnsafePointer<Pointee>, rhs: UnsafePointer<Pointee>) -> Int

prefix public func -<T : FloatingPoint>(x: T) -> T

public func -(lhs: Int, rhs: Int) -> Int

public func -(lhs: UInt, rhs: UInt) -> UInt

public func -(lhs: Int64, rhs: Int64) -> Int64

public func -(lhs: UInt64, rhs: UInt64) -> UInt64

public func -(lhs: Int32, rhs: Int32) -> Int32

public func -(lhs: UInt32, rhs: UInt32) -> UInt32

public func -(lhs: Int16, rhs: Int16) -> Int16

public func -(lhs: UInt16, rhs: UInt16) -> UInt16

public func -(lhs: Int8, rhs: Int8) -> Int8

public func -(lhs: UInt8, rhs: UInt8) -> UInt8

prefix public func -(x: Double) -> Double

public func -=<Pointee>(lhs: inout UnsafePointer<Pointee>, rhs: Int)

public func -=(lhs: inout Int8, rhs: Int8)

public func -=<Pointee>(lhs: inout UnsafeMutablePointer<Pointee>, rhs: Int)

public func -=<T : UnsignedInteger>(lhs: inout T, rhs: T._DisallowMixedSignArithmetic)

public func -=<T : Strideable>(lhs: inout T, rhs: T.Stride)

/// Subtracts `lhs` and `rhs` and stores the result in `lhs`, trapping in
/// case of arithmetic overflow (except in -Ounchecked builds).
public func -=<T : _IntegerArithmetic>(lhs: inout T, rhs: T)

public func -=(lhs: inout Float80, rhs: Float80)

public func -=(lhs: inout Double, rhs: Double)

public func -=(lhs: inout Float, rhs: Float)

public func -=<T : FloatingPoint>(lhs: inout T, rhs: T)

public func -=(lhs: inout Int, rhs: Int)

public func -=(lhs: inout UInt, rhs: UInt)

public func -=(lhs: inout Int64, rhs: Int64)

public func -=(lhs: inout UInt64, rhs: UInt64)

public func -=(lhs: inout Int32, rhs: Int32)

public func -=(lhs: inout UInt32, rhs: UInt32)

public func -=(lhs: inout Int16, rhs: Int16)

public func -=(lhs: inout UInt16, rhs: UInt16)

public func -=(lhs: inout UInt8, rhs: UInt8)

/// Returns a countable closed range that contains both of its bounds.
///
/// For example:
/// 
///     let singleDigits = 0...9
///     print(singleDigits.contains(9))
///     // Prints "true"
///
/// - Parameters:
///   - minimum: The lower bound for the range.
///   - maximum: The upper bound for the range.
public func ...<Bound : protocol<Comparable, _Strideable> where Bound.Stride : SignedInteger>(minimum: Bound, maximum: Bound) -> CountableClosedRange<Bound>

/// Returns a closed range that contains both of its bounds.
///
/// For example:
///
///     let lowercase = "a"..."z"
///     print(lowercase.contains("z"))
///     // Prints "true"
///
/// - Parameters:
///   - minimum: The lower bound for the range.
///   - maximum: The upper bound for the range.
public func ...<Bound : Comparable>(minimum: Bound, maximum: Bound) -> ClosedRange<Bound>

/// Returns a countable half-open range that contains its lower bound but not
/// its upper bound.
///
/// For example:
///
///     let upToFive = 0..<5
///     print(upToFive.contains(3))         // Prints "true"
///     print(upToFive.contains(5))         // Prints "false"
///
/// - Parameters:
///   - minimum: The lower bound for the range.
///   - maximum: The upper bound for the range.
public func ..<<Bound where Bound : Comparable, Bound.Stride : Integer>(minimum: Bound, maximum: Bound) -> CountableRange<Bound>

/// Returns a half-open range that contains its lower bound but not its upper
/// bound.
///
/// For example:
///
///     let lessThanFive = 0.0..<5.0
///     print(lessThanFive.contains(3.14))  // Prints "true"
///     print(lessThanFive.contains(5.0))   // Prints "false"
///
/// - Parameters:
///   - minimum: The lower bound for the range.
///   - maximum: The upper bound for the range.
public func ..<<Bound : Comparable>(minimum: Bound, maximum: Bound) -> Range<Bound>

public func /(lhs: Double, rhs: Double) -> Double

public func /(lhs: UInt8, rhs: UInt8) -> UInt8

public func /(lhs: Int8, rhs: Int8) -> Int8

public func /(lhs: UInt16, rhs: UInt16) -> UInt16

public func /(lhs: Int16, rhs: Int16) -> Int16

public func /(lhs: UInt32, rhs: UInt32) -> UInt32

public func /(lhs: Int32, rhs: Int32) -> Int32

public func /(lhs: UInt64, rhs: UInt64) -> UInt64

public func /(lhs: Int64, rhs: Int64) -> Int64

public func /(lhs: UInt, rhs: UInt) -> UInt

public func /(lhs: Int, rhs: Int) -> Int

public func /<T : FloatingPoint>(lhs: T, rhs: T) -> T

public func /(lhs: Float, rhs: Float) -> Float

public func /(lhs: Float80, rhs: Float80) -> Float80

/// Divides `lhs` and `rhs`, returning the result and trapping in case of
/// arithmetic overflow (except in -Ounchecked builds).
public func /<T : _IntegerArithmetic>(lhs: T, rhs: T) -> T

public func /=<T : FloatingPoint>(lhs: inout T, rhs: T)

public func /=(lhs: inout Float, rhs: Float)

public func /=(lhs: inout Double, rhs: Double)

public func /=(lhs: inout Float80, rhs: Float80)

/// Divides `lhs` and `rhs` and stores the result in `lhs`, trapping in
/// case of arithmetic overflow (except in -Ounchecked builds).
public func /=<T : _IntegerArithmetic>(lhs: inout T, rhs: T)

/// Returns a Boolean value that indicates whether
/// the first argument is less than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <(lhs: Int16, rhs: Int16) -> Bool

public func <<Key : Hashable, Value>(lhs: DictionaryIndex<Key, Value>, rhs: DictionaryIndex<Key, Value>) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `<` the second tuple iff `a1 < b1` or
/// (`a1 == b1` and `(a2, ..., aN) < (b2, ..., bN)`).
public func <<A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable, F : Comparable>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `<` the second tuple iff `a1 < b1` or
/// (`a1 == b1` and `(a2, ..., aN) < (b2, ..., bN)`).
public func <<A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `<` the second tuple iff `a1 < b1` or
/// (`a1 == b1` and `(a2, ..., aN) < (b2, ..., bN)`).
public func <<A : Comparable, B : Comparable, C : Comparable, D : Comparable>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `<` the second tuple iff `a1 < b1` or
/// (`a1 == b1` and `(a2, ..., aN) < (b2, ..., bN)`).
public func <<A : Comparable, B : Comparable, C : Comparable>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `<` the second tuple iff `a1 < b1` or
/// (`a1 == b1` and `(a2, ..., aN) < (b2, ..., bN)`).
public func <<A : Comparable, B : Comparable>(lhs: (A, B), rhs: (A, B)) -> Bool

public func <<BaseElements>(lhs: FlattenCollectionIndex<BaseElements>, rhs: FlattenCollectionIndex<BaseElements>) -> Bool

public func <(lhs: AnyIndex, rhs: AnyIndex) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <(lhs: UInt, rhs: UInt) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <(lhs: Int64, rhs: Int64) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <(lhs: UInt64, rhs: UInt64) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <(lhs: Int32, rhs: Int32) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <(lhs: UInt32, rhs: UInt32) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <(lhs: UInt16, rhs: UInt16) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <(lhs: Int8, rhs: Int8) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <(lhs: UInt8, rhs: UInt8) -> Bool

public func <<Base : Collection>(lhs: LazyFilterIndex<Base>, rhs: LazyFilterIndex<Base>) -> Bool

public func <<B>(lhs: ClosedRangeIndex<B>, rhs: ClosedRangeIndex<B>) -> Bool

public func <(lhs: Character, rhs: Character) -> Bool

/// Lexicographic comparison of version components.
public func <(lhs: _SwiftNSOperatingSystemVersion, rhs: _SwiftNSOperatingSystemVersion) -> Bool

public func <<Pointee>(lhs: UnsafePointer<Pointee>, rhs: UnsafePointer<Pointee>) -> Bool

public func <<Pointee>(lhs: UnsafeMutablePointer<Pointee>, rhs: UnsafeMutablePointer<Pointee>) -> Bool

public func <(lhs: UnicodeScalar, rhs: UnicodeScalar) -> Bool

public func <(lhs: String.UTF8View.Index, rhs: String.UTF8View.Index) -> Bool

public func <(lhs: String.UTF16View.Index, rhs: String.UTF16View.Index) -> Bool

public func <(lhs: String.UnicodeScalarView.Index, rhs: String.UnicodeScalarView.Index) -> Bool

public func <<BaseElements>(lhs: FlattenBidirectionalCollectionIndex<BaseElements>, rhs: FlattenBidirectionalCollectionIndex<BaseElements>) -> Bool

public func <<T : FloatingPoint>(lhs: T, rhs: T) -> Bool

public func <<Element : Hashable>(lhs: SetIndex<Element>, rhs: SetIndex<Element>) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <(lhs: Int, rhs: Int) -> Bool

public func <<T where T.RawValue : Comparable>(lhs: T, rhs: T) -> Bool

public func <<T : Comparable>(lhs: T?, rhs: T?) -> Bool

public func <(lhs: ObjectIdentifier, rhs: ObjectIdentifier) -> Bool

public func <<Base : Collection>(lhs: ReversedIndex<Base>, rhs: ReversedIndex<Base>) -> Bool

public func <<Base : Collection>(lhs: ReversedRandomAccessIndex<Base>, rhs: ReversedRandomAccessIndex<Base>) -> Bool

/// Compare two `Strideable`s.
public func <<T : Strideable>(x: T, y: T) -> Bool

public func <(lhs: String, rhs: String) -> Bool

public func <(lhs: Index, rhs: Index) -> Bool

public func <<(lhs: UInt16, rhs: UInt16) -> UInt16

public func <<(lhs: Int8, rhs: Int8) -> Int8

public func <<(lhs: UInt8, rhs: UInt8) -> UInt8

public func <<(lhs: UInt, rhs: UInt) -> UInt

public func <<(lhs: Int16, rhs: Int16) -> Int16

public func <<(lhs: UInt32, rhs: UInt32) -> UInt32

public func <<(lhs: Int32, rhs: Int32) -> Int32

public func <<(lhs: UInt64, rhs: UInt64) -> UInt64

public func <<(lhs: Int64, rhs: Int64) -> Int64

public func <<(lhs: Int, rhs: Int) -> Int

public func <<=(lhs: inout Int, rhs: Int)

public func <<=(lhs: inout UInt, rhs: UInt)

public func <<=(lhs: inout Int64, rhs: Int64)

public func <<=(lhs: inout UInt64, rhs: UInt64)

public func <<=(lhs: inout UInt8, rhs: UInt8)

public func <<=(lhs: inout Int8, rhs: Int8)

public func <<=(lhs: inout UInt16, rhs: UInt16)

public func <<=(lhs: inout Int16, rhs: Int16)

public func <<=(lhs: inout UInt32, rhs: UInt32)

public func <<=(lhs: inout Int32, rhs: Int32)

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `<=` the second tuple iff `a1 < b1` or
/// (`a1 == b1` and `(a2, ..., aN) <= (b2, ..., bN)`).
public func <=<A : Comparable, B : Comparable, C : Comparable>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `<=` the second tuple iff `a1 < b1` or
/// (`a1 == b1` and `(a2, ..., aN) <= (b2, ..., bN)`).
public func <=<A : Comparable, B : Comparable>(lhs: (A, B), rhs: (A, B)) -> Bool

public func <=(lhs: AnyIndex, rhs: AnyIndex) -> Bool

/// Returns a Boolean value indicating whether the value of the first argument
/// is less than or equal to that of the second argument.
///
/// This is the default implementation of the less-than-or-equal-to
/// operator (`<=`) for any type that conforms to `Comparable`.
///
/// - Parameters:
///   - lhs: A value to compare.
///   - rhs: Another value to compare.
public func <=<T : Comparable>(lhs: T, rhs: T) -> Bool

public func <=<T : Comparable>(lhs: T?, rhs: T?) -> Bool

public func <=<T where T.RawValue : Comparable>(lhs: T, rhs: T) -> Bool

public func <=<T : FloatingPoint>(lhs: T, rhs: T) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <=(lhs: Int, rhs: Int) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <=(lhs: UInt, rhs: UInt) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <=(lhs: Int64, rhs: Int64) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <=(lhs: UInt64, rhs: UInt64) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <=(lhs: Int32, rhs: Int32) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <=(lhs: UInt32, rhs: UInt32) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <=(lhs: Int16, rhs: Int16) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <=(lhs: UInt16, rhs: UInt16) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <=(lhs: Int8, rhs: Int8) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is less than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func <=(lhs: UInt8, rhs: UInt8) -> Bool

public func <=<Base : Collection>(lhs: LazyFilterIndex<Base>, rhs: LazyFilterIndex<Base>) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `<=` the second tuple iff `a1 < b1` or
/// (`a1 == b1` and `(a2, ..., aN) <= (b2, ..., bN)`).
public func <=<A : Comparable, B : Comparable, C : Comparable, D : Comparable>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `<=` the second tuple iff `a1 < b1` or
/// (`a1 == b1` and `(a2, ..., aN) <= (b2, ..., bN)`).
public func <=<A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `<=` the second tuple iff `a1 < b1` or
/// (`a1 == b1` and `(a2, ..., aN) <= (b2, ..., bN)`).
public func <=<A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable, F : Comparable>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool

public func ==<T>(lhs: T?, rhs: _OptionalNilComparisonType) -> Bool

public func ==<T>(lhs: _OptionalNilComparisonType, rhs: T?) -> Bool

public func ==<Bound>(lhs: Range<Bound>, rhs: Range<Bound>) -> Bool

public func ==<Bound>(lhs: CountableRange<Bound>, rhs: CountableRange<Bound>) -> Bool

public func ==<Bound>(lhs: ClosedRange<Bound>, rhs: ClosedRange<Bound>) -> Bool

public func ==<Bound>(lhs: CountableClosedRange<Bound>, rhs: CountableClosedRange<Bound>) -> Bool

public func ==(x: ObjectIdentifier, y: ObjectIdentifier) -> Bool

public func ==<Base : Collection>(lhs: ReversedIndex<Base>, rhs: ReversedIndex<Base>) -> Bool

public func ==<Base : Collection>(lhs: ReversedRandomAccessIndex<Base>, rhs: ReversedRandomAccessIndex<Base>) -> Bool

public func ==<T : Strideable>(x: T, y: T) -> Bool

public func ==(lhs: String, rhs: String) -> Bool

public func ==(lhs: Index, rhs: Index) -> Bool

public func ==(lhs: String.UnicodeScalarView.Index, rhs: String.UnicodeScalarView.Index) -> Bool

public func ==(lhs: String.UTF16View.Index, rhs: String.UTF16View.Index) -> Bool

public func ==(lhs: String.UTF8View.Index, rhs: String.UTF8View.Index) -> Bool

public func ==(lhs: UnicodeDecodingResult, rhs: UnicodeDecodingResult) -> Bool

public func ==(lhs: UnicodeScalar, rhs: UnicodeScalar) -> Bool

public func ==<Pointee>(lhs: UnsafeMutablePointer<Pointee>, rhs: UnsafeMutablePointer<Pointee>) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have equal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func ==(lhs: Int16, rhs: Int16) -> Bool

public func ==<Pointee>(lhs: UnsafePointer<Pointee>, rhs: UnsafePointer<Pointee>) -> Bool

public func ==(lhs: _SwiftNSOperatingSystemVersion, rhs: _SwiftNSOperatingSystemVersion) -> Bool

/// Returns `true` iff `lhs` and `rhs` wrap equal underlying indices.
///
/// - Precondition: The types of indices wrapped by `lhs` and `rhs` are
///   identical.
public func ==(lhs: AnyIndex, rhs: AnyIndex) -> Bool

/// Returns `true` iff each component of `lhs` is equal to the corresponding
/// component of `rhs`.
public func ==<A : Equatable, B : Equatable>(lhs: (A, B), rhs: (A, B)) -> Bool

/// Returns `true` iff each component of `lhs` is equal to the corresponding
/// component of `rhs`.
public func ==<A : Equatable, B : Equatable, C : Equatable>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool

/// Returns `true` iff each component of `lhs` is equal to the corresponding
/// component of `rhs`.
public func ==<A : Equatable, B : Equatable, C : Equatable, D : Equatable>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool

/// Returns `true` iff each component of `lhs` is equal to the corresponding
/// component of `rhs`.
public func ==<A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool

/// Returns `true` iff each component of `lhs` is equal to the corresponding
/// component of `rhs`.
public func ==<A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable, F : Equatable>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have equal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func ==(lhs: UInt16, rhs: UInt16) -> Bool

public func ==<T : Equatable>(lhs: T?, rhs: T?) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have equal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func ==(lhs: UInt32, rhs: UInt32) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have equal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func ==(lhs: Int8, rhs: Int8) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have equal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func ==(lhs: Int32, rhs: Int32) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have equal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func ==(lhs: UInt8, rhs: UInt8) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have equal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func ==(lhs: UInt64, rhs: UInt64) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have equal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func ==(lhs: Int64, rhs: Int64) -> Bool

public func ==<Base : Collection>(lhs: LazyFilterIndex<Base>, rhs: LazyFilterIndex<Base>) -> Bool

public func ==<Element>(lhs: EmptyCollection<Element>, rhs: EmptyCollection<Element>) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have equal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func ==(lhs: UInt, rhs: UInt) -> Bool

/// Returns a Boolean value that indicates whether
/// the two arguments have equal values.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func ==(lhs: Int, rhs: Int) -> Bool

public func ==<BaseElements>(lhs: FlattenCollectionIndex<BaseElements>, rhs: FlattenCollectionIndex<BaseElements>) -> Bool

public func ==(lhs: OpaquePointer, rhs: OpaquePointer) -> Bool

public func ==<BaseElements>(lhs: FlattenBidirectionalCollectionIndex<BaseElements>, rhs: FlattenBidirectionalCollectionIndex<BaseElements>) -> Bool

public func ==<T : FloatingPoint>(lhs: T, rhs: T) -> Bool

public func ==<B>(lhs: ClosedRangeIndex<B>, rhs: ClosedRangeIndex<B>) -> Bool

/// Returns a Boolean value indicating whether two sets have equal elements.
///
/// - Parameters:
///   - lhs: A set.
///   - rhs: Another set.
/// - Returns: `true` if the `lhs` and `rhs` have the same elements; otherwise,
///   `false`.
public func ==<Element : Hashable>(lhs: Set<Element>, rhs: Set<Element>) -> Bool

/// Returns a Boolean value indicating whether the two arguments are equal.
///
/// - Parameters:
///   - lhs: A raw-representable instance.
///   - rhs: A second raw-representable instance.
public func ==<T : RawRepresentable where T.RawValue : Equatable>(lhs: T, rhs: T) -> Bool

public func ==(lhs: Character, rhs: Character) -> Bool

/// Returns `true` iff `t0` is identical to `t1`; i.e. if they are both
/// `nil` or they both represent the same type.
public func ==(t0: Swift.Any.Type?, t1: Swift.Any.Type?) -> Bool

public func ==<Pointee>(lhs: AutoreleasingUnsafeMutablePointer<Pointee>, rhs: AutoreleasingUnsafeMutablePointer<Pointee>) -> Bool

public func ==<Key : Equatable, Value : Equatable>(lhs: [Key : Value], rhs: [Key : Value]) -> Bool

public func ==(lhs: Bool, rhs: Bool) -> Bool

/// Returns `true` if these arrays contain the same elements.
public func ==<Element : Equatable>(lhs: [Element], rhs: [Element]) -> Bool

/// Returns `true` if these arrays contain the same elements.
public func ==<Element : Equatable>(lhs: ArraySlice<Element>, rhs: ArraySlice<Element>) -> Bool

/// Returns `true` if these arrays contain the same elements.
public func ==<Element : Equatable>(lhs: ContiguousArray<Element>, rhs: ContiguousArray<Element>) -> Bool

public func ==<Element : Hashable>(lhs: SetIndex<Element>, rhs: SetIndex<Element>) -> Bool

public func ==<Key : Hashable, Value>(lhs: DictionaryIndex<Key, Value>, rhs: DictionaryIndex<Key, Value>) -> Bool

public func ==<Value, Element>(lhs: _HeapBuffer<Value, Element>, rhs: _HeapBuffer<Value, Element>) -> Bool

public func ==<Value, Element>(lhs: ManagedBufferPointer<Value, Element>, rhs: ManagedBufferPointer<Value, Element>) -> Bool

/// Returns `true` iff `lhs` and `rhs` store the same underlying collection.
public func ===<L : AnyCollectionProtocol, R : AnyCollectionProtocol>(lhs: L, rhs: R) -> Bool

/// Returns `true` iff `lhs` and `rhs` are references to the same object
/// instance (in other words, are identical pointers).
///
/// - SeeAlso: `Equatable`, `==`
public func ===(lhs: AnyObject?, rhs: AnyObject?) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `>` the second tuple iff `a1 > b1` or
/// (`a1 == b1` and `(a2, ..., aN) > (b2, ..., bN)`).
public func ><A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable, F : Comparable>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `>` the second tuple iff `a1 > b1` or
/// (`a1 == b1` and `(a2, ..., aN) > (b2, ..., bN)`).
public func ><A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `>` the second tuple iff `a1 > b1` or
/// (`a1 == b1` and `(a2, ..., aN) > (b2, ..., bN)`).
public func ><A : Comparable, B : Comparable, C : Comparable, D : Comparable>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `>` the second tuple iff `a1 > b1` or
/// (`a1 == b1` and `(a2, ..., aN) > (b2, ..., bN)`).
public func ><A : Comparable, B : Comparable, C : Comparable>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `>` the second tuple iff `a1 > b1` or
/// (`a1 == b1` and `(a2, ..., aN) > (b2, ..., bN)`).
public func ><A : Comparable, B : Comparable>(lhs: (A, B), rhs: (A, B)) -> Bool

public func >(lhs: AnyIndex, rhs: AnyIndex) -> Bool

/// Returns a Boolean value indicating whether the value of the first argument
/// is greater than that of the second argument.
///
/// This is the default implementation of the greater-than operator (`>`) for
/// any type that conforms to `Comparable`.
///
/// - Parameters:
///   - lhs: A value to compare.
///   - rhs: Another value to compare.
public func ><T : Comparable>(lhs: T, rhs: T) -> Bool

public func ><T : Comparable>(lhs: T?, rhs: T?) -> Bool

public func ><T where T.RawValue : Comparable>(lhs: T, rhs: T) -> Bool

public func ><T : FloatingPoint>(lhs: T, rhs: T) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >(lhs: Int, rhs: Int) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >(lhs: UInt, rhs: UInt) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >(lhs: Int64, rhs: Int64) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >(lhs: UInt64, rhs: UInt64) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >(lhs: Int32, rhs: Int32) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >(lhs: UInt32, rhs: UInt32) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >(lhs: Int16, rhs: Int16) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >(lhs: UInt16, rhs: UInt16) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >(lhs: Int8, rhs: Int8) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >(lhs: UInt8, rhs: UInt8) -> Bool

public func ><Base : Collection>(lhs: LazyFilterIndex<Base>, rhs: LazyFilterIndex<Base>) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `>=` the second tuple iff `a1 > b1` or
/// (`a1 == b1` and `(a2, ..., aN) >= (b2, ..., bN)`).
public func >=<A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >=(lhs: UInt, rhs: UInt) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >=(lhs: Int8, rhs: Int8) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >=(lhs: UInt16, rhs: UInt16) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >=(lhs: Int16, rhs: Int16) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >=(lhs: UInt8, rhs: UInt8) -> Bool

public func >=<Base : Collection>(lhs: LazyFilterIndex<Base>, rhs: LazyFilterIndex<Base>) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >=(lhs: UInt32, rhs: UInt32) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >=(lhs: Int32, rhs: Int32) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >=(lhs: UInt64, rhs: UInt64) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >=(lhs: Int64, rhs: Int64) -> Bool

/// Returns a Boolean value that indicates whether
/// the first argument is greater than or equal to the second argument.
///
/// - SeeAlso: `Equatable`, `Comparable`
public func >=(lhs: Int, rhs: Int) -> Bool

public func >=<T : FloatingPoint>(lhs: T, rhs: T) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `>=` the second tuple iff `a1 > b1` or
/// (`a1 == b1` and `(a2, ..., aN) >= (b2, ..., bN)`).
public func >=<A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable, F : Comparable>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool

public func >=<T where T.RawValue : Comparable>(lhs: T, rhs: T) -> Bool

public func >=<T : Comparable>(lhs: T?, rhs: T?) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `>=` the second tuple iff `a1 > b1` or
/// (`a1 == b1` and `(a2, ..., aN) >= (b2, ..., bN)`).
public func >=<A : Comparable, B : Comparable, C : Comparable, D : Comparable>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool

/// Returns a Boolean value indicating whether the value of the first argument
/// is greater than or equal to that of the second argument.
///
/// This is the default implementation of the greater-than-or-equal-to operator
/// (`>=`) for any type that conforms to `Comparable`.
///
/// - Parameters:
///   - lhs: A value to compare.
///   - rhs: Another value to compare.
/// - Returns: `true` if `lhs` is greater than or equal to `rhs`; otherwise,
///   `false`.
public func >=<T : Comparable>(lhs: T, rhs: T) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `>=` the second tuple iff `a1 > b1` or
/// (`a1 == b1` and `(a2, ..., aN) >= (b2, ..., bN)`).
public func >=<A : Comparable, B : Comparable, C : Comparable>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool

/// A [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order)
/// over tuples of `Comparable` elements.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the
/// first tuple is `>=` the second tuple iff `a1 > b1` or
/// (`a1 == b1` and `(a2, ..., aN) >= (b2, ..., bN)`).
public func >=<A : Comparable, B : Comparable>(lhs: (A, B), rhs: (A, B)) -> Bool

public func >=(lhs: AnyIndex, rhs: AnyIndex) -> Bool

public func >=(lhs: _SwiftNSOperatingSystemVersion, rhs: _SwiftNSOperatingSystemVersion) -> Bool

public func >>(lhs: Int16, rhs: Int16) -> Int16

public func >>(lhs: UInt32, rhs: UInt32) -> UInt32

public func >>(lhs: Int32, rhs: Int32) -> Int32

public func >>(lhs: UInt16, rhs: UInt16) -> UInt16

public func >>(lhs: UInt64, rhs: UInt64) -> UInt64

public func >>(lhs: UInt8, rhs: UInt8) -> UInt8

public func >>(lhs: Int8, rhs: Int8) -> Int8

public func >>(lhs: Int64, rhs: Int64) -> Int64

public func >>(lhs: UInt, rhs: UInt) -> UInt

public func >>(lhs: Int, rhs: Int) -> Int

public func >>=(lhs: inout Int32, rhs: Int32)

public func >>=(lhs: inout UInt, rhs: UInt)

public func >>=(lhs: inout Int64, rhs: Int64)

public func >>=(lhs: inout UInt64, rhs: UInt64)

public func >>=(lhs: inout Int, rhs: Int)

public func >>=(lhs: inout UInt8, rhs: UInt8)

public func >>=(lhs: inout Int8, rhs: Int8)

public func >>=(lhs: inout UInt16, rhs: UInt16)

public func >>=(lhs: inout Int16, rhs: Int16)

public func >>=(lhs: inout UInt32, rhs: UInt32)

/// Performs a nil-coalescing operation, returning the wrapped value of an
/// `Optional` instance or a default value.
///
/// A nil-coalescing operation unwraps the left-hand side if it has a value, or
/// it returns the right-hand side as a default. The result of this operation
/// will have the nonoptional type of the left-hand side's `Wrapped` type.
///
/// This operator uses short-circuit evaluation: `optional` is checked first,
/// and `defaultValue` is evaluated only if `optional` is `nil`. For example:
///
///     func getDefault() -> Int {
///         print("Calculating default...")
///         return 42
///     }
///
///     let goodNumber = Int("100") ?? getDefault()
///     // goodNumber == 100
///
///     let notSoGoodNumber = Int("invalid-input") ?? getDefault()
///     // Prints "Calculating default..."
///     // notSoGoodNumber == 42
///
/// In this example, `goodNumber` is assigned a value of `100` because
/// `Int("100")` succeeded in returning a non-`nil` result. When
/// `notSoGoodNumber` is initialized, `Int("invalid-input")` fails and returns
/// `nil`, and so the `getDefault()` method is called to supply a default
/// value.
///
/// - Parameters:
///   - optional: An optional value.
///   - defaultValue: A value to use as a default. `defaultValue` is the same
///     type as the `Wrapped` type of `optional`.
public func ??<T>(optional: T?, defaultValue: @autoclosure () throws -> T) rethrows -> T

/// Performs a nil-coalescing operation, returning the wrapped value of an
/// `Optional` instance or a default `Optional` value.
///
/// A nil-coalescing operation unwraps the left-hand side if it has a value, or
/// returns the right-hand side as a default. The result of this operation
/// will be the same type as its arguments.
///
/// This operator uses short-circuit evaluation: `optional` is checked first,
/// and `defaultValue` is evaluated only if `optional` is `nil`. For example:
///
///     let goodNumber = Int("100") ?? Int("42")
///     print(goodNumber)
///     // Prints "Optional(100)"
///
///     let notSoGoodNumber = Int("invalid-input") ?? Int("42")
///     print(notSoGoodNumber)
///     // Prints "Optional(42)"
///
/// In this example, `goodNumber` is assigned a value of `100` because
/// `Int("100")` succeeds in returning a non-`nil` result. When
/// `notSoGoodNumber` is initialized, `Int("invalid-input")` fails and returns
/// `nil`, and so `Int("42")` is called to supply a default value.
///
/// Because the result of this nil-coalescing operation is itself an optional
/// value, you can chain default values by using `??` multiple times. The
/// first optional value that isn't `nil` stops the chain and becomes the
/// result of the whole expression. The next example tries to find the correct
/// text for a greeting in two separate dictionaries before falling back to a
/// static default.
///
///     let greeting = userPrefs[greetingKey] ??
///         defaults[greetingKey] ?? "Greetings!"
///
/// If `userPrefs[greetingKey]` has a value, that value is assigned to
/// `greeting`. If not, any value in `defaults[greetingKey]` will succeed, and
/// if not that, `greeting` will be set to the non-optional default value,
/// `"Greetings!"`.
///
/// - Parameters:
///   - optional: An optional value.
///   - defaultValue: A value to use as a default. `defaultValue` and
///     `optional` have the same type.
public func ??<T>(optional: T?, defaultValue: @autoclosure () throws -> T?) rethrows -> T?

/// A type that supports an "absolute value" function.
public protocol AbsoluteValuable : SignedNumber {

    /// Returns the absolute value of `x`.
    public static func abs(_ x: Self) -> Self
}

/// The protocol to which all types implicitly conform.
///
/// The `Any` protocol can be used as the concrete type for an instance of any
/// type in Swift: a class, struct, or enumeration; a metatype, such as
/// `Int.self`; a tuple with any types of components; or a closure or function
/// type.
///
/// Casting Any Instances to a Known Type
/// =====================================
///
/// When you use `Any` as a concrete type, you must cast your instance back to
/// a known type before you can access its properties or methods. Instances
/// with a concrete type of `Any` maintain their original dynamic type and can
/// be cast to that type using one of the type-cast operators (`as`, `as?`, or
/// `as!`). 
/// 
/// For example, use `as?` to conditionally downcast the first object
/// in a heterogeneous array to a `String`.
///
///     let mixed: [Any] = ["one", "two", 3, true, {(x: Int) -> Int in x * 2 }]
///
///     let first = = numberObjects.firstObject
///     if let first = mixed.first as? String {
///         print("The first item, '\(first)', is a String")
///     }
///     // Prints("The first item, 'one', is a String")
///
/// If you have prior knowledge that an `Any` instance is an instance of
/// a particular type, you can use the `as!` operator to unconditionally
/// downcast. Performing an invalid cast results in a runtime error.
///
///     let second = mixed[1] as! String
///     print("'\(second)' is also a String")
///     // Prints "'two' is also a String"
///
/// In a `switch` statement, a value is cast to a type only when pattern
/// matching with that type succeeds. For that reason, you use the `as`
/// operator instead of the conditional `as?` or unconditional `as!`
/// operators.
///
///     for item in mixed {
///         switch item {
///         case let s as String:
///             print("String: \(s)")
///         case let i as Int:
///             print("Integer: \(i)")
///         case let b as Bool:
///             print("Bool: \(b)")
///         case let f as Int -> Int:
///             print("Function: 2 * 5 = \(f(5))")
///         default:
///             print("Unrecognized type")
///         }
///     }
///     // Prints "String: one"
///     // Prints "String: two"
///     // Prints "Integer: 3"
///     // Prints "Bool: true"
///     // Prints "Function: 2 * 5 = 10"
///     
/// - SeeAlso: `AnyObject`, `AnyClass`
public typealias Any = protocol<>

/// A type-erased wrapper over any collection with indices that
/// support bidirectional traversal.
///
/// Forwards operations to an arbitrary underlying collection having the
/// same `Element` type, hiding the specifics of the underlying
/// `Collection`.
///
/// - SeeAlso: `AnyRandomAccessCollection`, `AnyForwardCollection`
public struct AnyBidirectionalCollection<Element> : AnyCollectionProtocol, BidirectionalCollection {

    /// Creates an `AnyBidirectionalCollection` that
    /// stores `base` as its underlying collection.
    ///
    /// - Complexity: O(1).
    public init<C : BidirectionalCollection where C.Iterator.Element == Element, C.SubSequence : BidirectionalCollection, C.SubSequence.Iterator.Element == Element, C.SubSequence.Index == C.Index, C.SubSequence.Indices : BidirectionalCollection, C.SubSequence.Indices.Iterator.Element == C.Index, C.SubSequence.Indices.Index == C.Index, C.SubSequence.Indices.SubSequence == C.SubSequence.Indices, C.SubSequence.SubSequence == C.SubSequence, C.Indices : BidirectionalCollection, C.Indices.Iterator.Element == C.Index, C.Indices.Index == C.Index, C.Indices.SubSequence == C.Indices>(_ base: C)

    /// Creates an `AnyBidirectionalCollection` having the same underlying
    /// collection as `other`.
    ///
    /// - Postcondition: The result is `===` to `other`.
    ///
    /// - Complexity: O(1).
    public init(_ other: AnyBidirectionalCollection<Element>)

    /// Creates an `AnyBidirectionalCollection` that
    /// stores `base` as its underlying collection.
    ///
    /// - Complexity: O(1).
    public init<C : RandomAccessCollection where C.Iterator.Element == Element, C.SubSequence : RandomAccessCollection, C.SubSequence.Iterator.Element == Element, C.SubSequence.Index == C.Index, C.SubSequence.Indices : RandomAccessCollection, C.SubSequence.Indices.Iterator.Element == C.Index, C.SubSequence.Indices.Index == C.Index, C.SubSequence.Indices.SubSequence == C.SubSequence.Indices, C.SubSequence.SubSequence == C.SubSequence, C.Indices : RandomAccessCollection, C.Indices.Iterator.Element == C.Index, C.Indices.Index == C.Index, C.Indices.SubSequence == C.Indices>(_ base: C)

    /// Creates an `AnyBidirectionalCollection` having the same underlying
    /// collection as `other`.
    ///
    /// - Postcondition: The result is `===` to `other`.
    ///
    /// - Complexity: O(1).
    public init(_ other: AnyRandomAccessCollection<Element>)

    /// If the underlying collection stored by `other` satisfies
    /// `BidirectionalCollection`, creates an `AnyBidirectionalCollection` having the same
    /// underlying collection as `other`.  Otherwise, the result is
    /// `nil`.
    ///
    /// - Complexity: O(1).
    public init?(_ other: AnyCollection<Element>)

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = AnyIndex

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = IntMax

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: AnyIndex { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: AnyIndex { get }

    /// Accesses the element indicated by `position`.
    ///
    /// - Precondition: `position` indicates a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: AnyIndex) -> Element { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<AnyIndex>) -> AnyBidirectionalCollection<Element> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: AnyIndex) -> AnyIndex

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout AnyIndex)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyIndex, offsetBy n: IntMax) -> AnyIndex

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position. The
    /// operation doesn't require going beyond the limiting `s.endIndex` value,
    /// so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -> AnyIndex?

    /// Offsets the given index by the specified distance.
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: `true` if `i` has been offset by exactly `n` steps without
    ///   going beyond `limit`; otherwise, `false`. When the return value is
    ///   `false`, the value of `i` is equal to `limit`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -> Bool

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: AnyIndex, to end: AnyIndex) -> IntMax

    /// The number of elements.
    ///
    /// - Complexity: O(N).
    public var count: IntMax { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Element? { get }

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: AnyIndex) -> AnyIndex

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout AnyIndex)

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Element? { get }
}

extension AnyBidirectionalCollection {

    /// Returns an iterator over the elements of this collection.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> AnyIterator<Element>

    /// A value less than or equal to the number of elements in
    /// the sequence, calculated nondestructively.
    ///
    /// - Complexity: O(1)
    public var underestimatedCount: Int { get }

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercaseString }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.characters.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: @noescape (Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.characters.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter includeElement: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `includeElement` allowed.
    public func filter(_ includeElement: @noescape (Element) throws -> Bool) rethrows -> [Element]

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: @noescape (Element) throws -> Swift.Void) rethrows

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the sequence.
    public func dropFirst(_ n: Int) -> AnyBidirectionalCollection<Element>

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> AnyBidirectionalCollection<Element>

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> AnyBidirectionalCollection<Element>

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number
    /// of elements in the sequence, the result contains all the elements in
    /// the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of this sequence with
    ///   at most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> AnyBidirectionalCollection<Element>

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate. Elements that are
    /// used to split the sequence are not returned as part of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.characters.split(isSeparator: { $0 == " " })
    ///                          .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don't", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.characters.split(maxSplits: 1, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.characters.split(omittingEmptySubsequences: false, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, isSeparator: @noescape (Element) throws -> Bool) rethrows -> [AnyBidirectionalCollection<Element>]
}

extension AnyBidirectionalCollection {
}

/// The protocol to which all class types implicitly conform.
///
/// You can use the `AnyClass` protocol as the concrete type for an instance of
/// any class. When you do, all known `@objc` class methods and properties are
/// available as implicitly unwrapped optional methods and properties,
/// respectively. For example:
///
///     class IntegerRef {
///         @objc class func getDefaultValue() -> Int {
///             return 42
///         }
///     }
///
///     func getDefaultValue(_ c: AnyClass) -> Int? {
///         return c.getDefaultValue?()
///     }
///
/// The `getDefaultValue(_:)` function uses optional chaining to safely call
/// the implicitly unwrapped class method on `c`. Calling the function with
/// different class types shows how the `getDefaultValue()` class method is
/// only conditionally available.
///
///     print(getDefaultValue(IntegerRef.self))
///     // Prints "Optional(42)"
///
///     print(getDefaultValue(NSString.self))
///     // Prints "nil"
///
/// - SeeAlso: `AnyObject`, `Any`
public typealias AnyClass = AnyObject.Type

/// A type-erased wrapper over any collection with indices that
/// support forward traversal.
///
/// Forwards operations to an arbitrary underlying collection having the
/// same `Element` type, hiding the specifics of the underlying
/// `Collection`.
///
/// - SeeAlso: `AnyBidirectionalCollection`, `AnyRandomAccessCollection`
public struct AnyCollection<Element> : AnyCollectionProtocol, Collection {

    /// Creates an `AnyCollection` that
    /// stores `base` as its underlying collection.
    ///
    /// - Complexity: O(1).
    public init<C : Collection where C.Iterator.Element == Element, C.SubSequence : Collection, C.SubSequence.Iterator.Element == Element, C.SubSequence.Index == C.Index, C.SubSequence.Indices : Collection, C.SubSequence.Indices.Iterator.Element == C.Index, C.SubSequence.Indices.Index == C.Index, C.SubSequence.Indices.SubSequence == C.SubSequence.Indices, C.SubSequence.SubSequence == C.SubSequence, C.Indices : Collection, C.Indices.Iterator.Element == C.Index, C.Indices.Index == C.Index, C.Indices.SubSequence == C.Indices>(_ base: C)

    /// Creates an `AnyForwardCollection` having the same underlying
    /// collection as `other`.
    ///
    /// - Postcondition: The result is `===` to `other`.
    ///
    /// - Complexity: O(1).
    public init(_ other: AnyCollection<Element>)

    /// Creates an `AnyCollection` that
    /// stores `base` as its underlying collection.
    ///
    /// - Complexity: O(1).
    public init<C : BidirectionalCollection where C.Iterator.Element == Element, C.SubSequence : BidirectionalCollection, C.SubSequence.Iterator.Element == Element, C.SubSequence.Index == C.Index, C.SubSequence.Indices : BidirectionalCollection, C.SubSequence.Indices.Iterator.Element == C.Index, C.SubSequence.Indices.Index == C.Index, C.SubSequence.Indices.SubSequence == C.SubSequence.Indices, C.SubSequence.SubSequence == C.SubSequence, C.Indices : BidirectionalCollection, C.Indices.Iterator.Element == C.Index, C.Indices.Index == C.Index, C.Indices.SubSequence == C.Indices>(_ base: C)

    /// Creates an `AnyForwardCollection` having the same underlying
    /// collection as `other`.
    ///
    /// - Postcondition: The result is `===` to `other`.
    ///
    /// - Complexity: O(1).
    public init(_ other: AnyBidirectionalCollection<Element>)

    /// Creates an `AnyCollection` that
    /// stores `base` as its underlying collection.
    ///
    /// - Complexity: O(1).
    public init<C : RandomAccessCollection where C.Iterator.Element == Element, C.SubSequence : RandomAccessCollection, C.SubSequence.Iterator.Element == Element, C.SubSequence.Index == C.Index, C.SubSequence.Indices : RandomAccessCollection, C.SubSequence.Indices.Iterator.Element == C.Index, C.SubSequence.Indices.Index == C.Index, C.SubSequence.Indices.SubSequence == C.SubSequence.Indices, C.SubSequence.SubSequence == C.SubSequence, C.Indices : RandomAccessCollection, C.Indices.Iterator.Element == C.Index, C.Indices.Index == C.Index, C.Indices.SubSequence == C.Indices>(_ base: C)

    /// Creates an `AnyForwardCollection` having the same underlying
    /// collection as `other`.
    ///
    /// - Postcondition: The result is `===` to `other`.
    ///
    /// - Complexity: O(1).
    public init(_ other: AnyRandomAccessCollection<Element>)

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = AnyIndex

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = IntMax

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: AnyIndex { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: AnyIndex { get }

    /// Accesses the element indicated by `position`.
    ///
    /// - Precondition: `position` indicates a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: AnyIndex) -> Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<AnyIndex>) -> AnyCollection<Element> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: AnyIndex) -> AnyIndex

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout AnyIndex)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyIndex, offsetBy n: IntMax) -> AnyIndex

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -> AnyIndex?

    /// Offsets the given index by the specified distance.
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: `true` if `i` has been offset by exactly `n` steps without
    ///   going beyond `limit`; otherwise, `false`. When the return value is
    ///   `false`, the value of `i` is equal to `limit`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -> Bool

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: AnyIndex, to end: AnyIndex) -> IntMax

    /// The number of elements.
    ///
    /// - Complexity: O(N).
    public var count: IntMax { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Element? { get }
}

extension AnyCollection {

    /// Returns an iterator over the elements of this collection.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> AnyIterator<Element>

    /// A value less than or equal to the number of elements in
    /// the sequence, calculated nondestructively.
    ///
    /// - Complexity: O(1)
    public var underestimatedCount: Int { get }

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercaseString }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.characters.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: @noescape (Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.characters.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter includeElement: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `includeElement` allowed.
    public func filter(_ includeElement: @noescape (Element) throws -> Bool) rethrows -> [Element]

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: @noescape (Element) throws -> Swift.Void) rethrows

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the sequence.
    public func dropFirst(_ n: Int) -> AnyCollection<Element>

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> AnyCollection<Element>

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> AnyCollection<Element>

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number
    /// of elements in the sequence, the result contains all the elements in
    /// the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of this sequence with
    ///   at most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> AnyCollection<Element>

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate. Elements that are
    /// used to split the sequence are not returned as part of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.characters.split(isSeparator: { $0 == " " })
    ///                          .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don't", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.characters.split(maxSplits: 1, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.characters.split(omittingEmptySubsequences: false, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, isSeparator: @noescape (Element) throws -> Bool) rethrows -> [AnyCollection<Element>]
}

extension AnyCollection {
}

/// A protocol for `AnyCollection<Element>`,
/// `AnyBidirectionalCollection<Element>`, and
/// `AnyRandomAccessCollection<Element>`.
///
/// This protocol can be considered an implementation detail of the
/// `===` and `!==` implementations for these types.
public protocol AnyCollectionProtocol : Collection {
}

/// A wrapper over an underlying index that hides
/// the specific underlying type.
///
/// - SeeAlso: `AnyCollection`
public struct AnyIndex : Comparable {

    /// Creates a new index wrapping `base`.
    public init<BaseIndex : Comparable>(_ base: BaseIndex)
}

/// A type-erased iterator of `Element`.
///
/// This iterator forwards its `next()` method to an arbitrary underlying
/// iterator having the same `Element` type, hiding the specifics of the
/// underlying `IteratorProtocol`.
///
/// - SeeAlso: `AnySequence`
public struct AnyIterator<Element> : IteratorProtocol {

    /// Creates an iterator that wraps `base` but whose type depends only on the
    /// type of `I.Element`.
    ///
    /// Example:
    ///
    ///     func digits() -> AnyIterator<String> {
    ///       let lazyStrings = (0..<10).lazy.map { String($0) }
    ///
    ///       // This is a really complicated type of no interest to our
    ///       // clients.
    ///       let iterator: MapSequenceIterator<RangeIterator<Int>, String>
    ///         = lazyStrings.makeIterator()
    ///       return AnyIterator(iterator)
    ///     }
    public init<I : IteratorProtocol where I.Element == Element>(_ base: I)

    /// Creates an iterator whose `next` method invokes `body` and returns the
    /// result.
    ///
    /// Example:
    ///
    ///     var x = 7
    ///     let iterator = AnyIterator { x < 15 ? x++ : nil }
    ///     let a = Array(iterator) // [ 7, 8, 9, 10, 11, 12, 13, 14 ]
    public init(_ body: () -> Element?)

    /// Advances to the next element and returns it, or `nil` if no next
    /// element exists.
    public func next() -> Element?
}

/// Every `IteratorProtocol` can also be a `Sequence`.  Note that
/// traversing the sequence consumes the iterator.
extension AnyIterator : Sequence {
}

/// The protocol to which all classes implicitly conform.
///
/// You use `AnyObject` when you need the flexibility of an untyped object or
/// when you use bridged Objective-C methods and properties that return an
/// untyped result. `AnyObject` can be used as the concrete type for an
/// instance of any class, class type, or class-only protocol. For example:
///
///     class FloatRef {
///         let value: Float
///         init(_ value: Float) {
///             self.value = value
///         }
///     }
///
///     let x = FloatRef(2.3)
///     let y: AnyObject = x
///     let z: AnyObject = FloatRef.self
///
/// `AnyObject` can also be used as the concrete type for an instance of a type
/// that bridges to an Objective-C class. Many value types in Swift bridge to
/// Objective-C counterparts, like `String` and `Int`.
///
///     let s: AnyObject = "This is a bridged string."
///     print(s is NSString)
///     // Prints "true"
///
///     let v: AnyObject = 100
///     print(v.dynamicType)
///     // Prints "__NSCFNumber"
///
/// The flexible behavior of the `AnyObject` protocol is similar to
/// Objective-C's `id` type. For this reason, imported Objective-C types
/// frequently use `AnyObject` as the type for properties, method parameters,
/// and return values.
///
/// Casting AnyObject Instances to a Known Type
/// ===========================================
///
/// Objects with a concrete type of `AnyObject` maintain a specific dynamic
/// type and can be cast to that type using one of the type-cast operators
/// (`as`, `as?`, or `as!`).
///
/// In the code samples that follow, the elements of the `NSArray` instance
/// `numberObjects` have `AnyObject` as their type. The first example uses the
/// conditional downcast operator (`as?`) to conditionally cast the first
/// object in the `numberObjects` array to an instance of Swift's `String`
/// type.
///
///     let numberObjects: NSArray = ["one", "two", 3, 4]
///
///     let first: AnyObject = numberObjects[0]
///     if let first = first as? String {
///         print("The first object, '\(first)', is a String")
///     }
///     // Prints("The first object, 'one', is a String")
///
/// If you have prior knowledge that an `AnyObject` instance has a particular
/// type, you can use the unconditional downcast operator (`as!`). Performing
/// an invalid cast triggers a runtime error.
///
///     let second = numberObjects.object(at: 1) as! String
///     print("'\(second)' is also a String")
///     // Prints "'two' is also a String"
///
///     let badCase = numberObjects.object(at: 2) as! NSDate
///     // Runtime error
///
/// Casting is always safe in the context of a `switch` statement.
///
///     for object in numberObjects {
///         switch object {
///         case let x as String:
///             print("'\(x)' is a String")
///         default:
///             print("'\(object)' is not a String")
///         }
///     }
///     // Prints "'one' is a String"
///     // Prints "'two' is a String"
///     // Prints "'3' is not a String"
///     // Prints "'4' is not a String"
///
/// You can call a method that takes an `AnyObject` parameter with an instance
/// of any class, `@objc` protocol, or type that bridges to Objective-C. In
/// the following example, the `toFind` constant is of type `Int`, which
/// bridges to `NSNumber` when passed to an `NSArray` method that expects an
/// `AnyObject` parameter:
///
///     let toFind = 3
///     let i = numberObjects.index(of: toFind)
///     if i != NSNotFound {
///         print("Found '\(numberObjects[i])' at index \(i)")
///     } else {
///         print("Couldn't find \(toFind)")
///     }
///     // Prints "Found '3' at index 2"
///
/// Accessing Objective-C Methods and Properties
/// ============================================
///
/// When you use `AnyObject` as a concrete type, you have at your disposal
/// every `@objc` method and property---that is, methods and properties
/// imported from Objective-C or marked with the `@objc` attribute. Because
/// Swift can't guarantee at compile time that these methods and properties
/// are actually available on an `AnyObject` instance's underlying type, these
/// `@objc` symbols are available as implicitly unwrapped optional methods and
/// properties, respectively.
///
/// This example defines an `IntegerRef` type with an `@objc` method named
/// `getIntegerValue`.
///
///     class IntegerRef {
///         let value: Int
///         init(_ value: Int) {
///             self.value = value
///         }
///
///         @objc func getIntegerValue() -> Int {
///             return value
///         }
///     }
///
///     func getObject() -> AnyObject {
///         return IntegerRef(100)
///     }
///
///     let x: AnyObject = getObject()
///
/// In the example, `x` has a static type of `AnyObject` and a dynamic type of
/// `IntegerRef`. You can use optional chaining to call the `@objc` method
/// `getIntegerValue()` on `x` safely. If you're sure of the dynamic type of
/// `x`, you can call `getIntegerValue()` directly.
///
///     let possibleValue = x.getIntegerValue?()
///     print(possibleValue)
///     // Prints "Optional(100)"
///
///     let certainValue = x.getIntegerValue()
///     print(certainValue)
///     // Prints "100"
///
/// If the dynamic type of `x` doesn't implement a `getIntegerValue()` method,
/// the system returns a runtime error when you initialize `certainValue`.
///
/// Alternatively, if you need to test whether `x.getValue()` exists, use
/// optional binding before calling the method.
///
///     if let f = x.getIntegerValue {
///         print("The value of 'x' is \(f())")
///     } else {
///         print("'x' does not have a 'getIntegerValue()' method")
///     }
///     // Prints "The value of 'x' is 100"
///
/// - SeeAlso: `AnyClass`, `Any`
@objc public protocol AnyObject {
}

/// A type-erased wrapper over any collection with indices that
/// support random access traversal.
///
/// Forwards operations to an arbitrary underlying collection having the
/// same `Element` type, hiding the specifics of the underlying
/// `Collection`.
///
/// - SeeAlso: `AnyForwardCollection`, `AnyBidirectionalCollection`
public struct AnyRandomAccessCollection<Element> : AnyCollectionProtocol, RandomAccessCollection {

    /// Creates an `AnyRandomAccessCollection` that
    /// stores `base` as its underlying collection.
    ///
    /// - Complexity: O(1).
    public init<C : RandomAccessCollection where C.Iterator.Element == Element, C.SubSequence : RandomAccessCollection, C.SubSequence.Iterator.Element == Element, C.SubSequence.Index == C.Index, C.SubSequence.Indices : RandomAccessCollection, C.SubSequence.Indices.Iterator.Element == C.Index, C.SubSequence.Indices.Index == C.Index, C.SubSequence.Indices.SubSequence == C.SubSequence.Indices, C.SubSequence.SubSequence == C.SubSequence, C.Indices : RandomAccessCollection, C.Indices.Iterator.Element == C.Index, C.Indices.Index == C.Index, C.Indices.SubSequence == C.Indices>(_ base: C)

    /// Creates an `AnyRandomAccessCollection` having the same underlying
    /// collection as `other`.
    ///
    /// - Postcondition: The result is `===` to `other`.
    ///
    /// - Complexity: O(1).
    public init(_ other: AnyRandomAccessCollection<Element>)

    /// If the underlying collection stored by `other` satisfies
    /// `RandomAccessCollection`, creates an `AnyRandomAccessCollection` having the same
    /// underlying collection as `other`.  Otherwise, the result is
    /// `nil`.
    ///
    /// - Complexity: O(1).
    public init?(_ other: AnyCollection<Element>)

    /// If the underlying collection stored by `other` satisfies
    /// `RandomAccessCollection`, creates an `AnyRandomAccessCollection` having the same
    /// underlying collection as `other`.  Otherwise, the result is
    /// `nil`.
    ///
    /// - Complexity: O(1).
    public init?(_ other: AnyBidirectionalCollection<Element>)

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = AnyIndex

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = IntMax

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: AnyIndex { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: AnyIndex { get }

    /// Accesses the element indicated by `position`.
    ///
    /// - Precondition: `position` indicates a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: AnyIndex) -> Element { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<AnyIndex>) -> AnyRandomAccessCollection<Element> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: AnyIndex) -> AnyIndex

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout AnyIndex)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyIndex, offsetBy n: IntMax) -> AnyIndex

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position. The
    /// operation doesn't require going beyond the limiting `s.endIndex` value,
    /// so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -> AnyIndex?

    /// Offsets the given index by the specified distance.
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: `true` if `i` has been offset by exactly `n` steps without
    ///   going beyond `limit`; otherwise, `false`. When the return value is
    ///   `false`, the value of `i` is equal to `limit`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout AnyIndex, offsetBy n: IntMax, limitedBy limit: AnyIndex) -> Bool

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: AnyIndex, to end: AnyIndex) -> IntMax

    /// The number of elements.
    ///
    /// - Complexity: O(1).
    public var count: IntMax { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Element? { get }

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: AnyIndex) -> AnyIndex

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout AnyIndex)

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Element? { get }
}

extension AnyRandomAccessCollection {

    /// Returns an iterator over the elements of this collection.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> AnyIterator<Element>

    /// A value less than or equal to the number of elements in
    /// the sequence, calculated nondestructively.
    ///
    /// - Complexity: O(1)
    public var underestimatedCount: Int { get }

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercaseString }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.characters.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: @noescape (Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.characters.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter includeElement: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `includeElement` allowed.
    public func filter(_ includeElement: @noescape (Element) throws -> Bool) rethrows -> [Element]

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: @noescape (Element) throws -> Swift.Void) rethrows

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the sequence.
    public func dropFirst(_ n: Int) -> AnyRandomAccessCollection<Element>

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> AnyRandomAccessCollection<Element>

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> AnyRandomAccessCollection<Element>

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number
    /// of elements in the sequence, the result contains all the elements in
    /// the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of this sequence with
    ///   at most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> AnyRandomAccessCollection<Element>

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate. Elements that are
    /// used to split the sequence are not returned as part of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.characters.split(isSeparator: { $0 == " " })
    ///                          .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don't", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.characters.split(maxSplits: 1, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.characters.split(omittingEmptySubsequences: false, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, isSeparator: @noescape (Element) throws -> Bool) rethrows -> [AnyRandomAccessCollection<Element>]
}

extension AnyRandomAccessCollection {
}

/// A type-erased sequence.
///
/// Forwards operations to an arbitrary underlying sequence having the
/// same `Element` type, hiding the specifics of the underlying
/// `Sequence`.
///
/// - SeeAlso: `AnyIterator`
public struct AnySequence<Element> : Sequence {

    /// Creates a new sequence that wraps and forwards operations to `base`.
    public init<S : Sequence where S.Iterator.Element == Element, S.SubSequence : Sequence, S.SubSequence.Iterator.Element == Element, S.SubSequence.SubSequence == S.SubSequence>(_ base: S)

    /// Creates a sequence whose `makeIterator()` method forwards to
    /// `makeUnderlyingIterator`.
    public init<I : IteratorProtocol where I.Element == Element>(_ makeUnderlyingIterator: () -> I)
}

extension AnySequence {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> AnyIterator<Element>

    /// A value less than or equal to the number of elements in
    /// the sequence, calculated nondestructively.
    ///
    /// - Complexity: O(1)
    public var underestimatedCount: Int { get }

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercaseString }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.characters.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: @noescape (Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.characters.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter includeElement: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `includeElement` allowed.
    public func filter(_ includeElement: @noescape (Element) throws -> Bool) rethrows -> [Element]

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: @noescape (Element) throws -> Swift.Void) rethrows

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the sequence.
    public func dropFirst(_ n: Int) -> AnySequence<Element>

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> AnySequence<Element>

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> AnySequence<Element>

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number
    /// of elements in the sequence, the result contains all the elements in
    /// the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of this sequence with
    ///   at most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> AnySequence<Element>

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate. Elements that are
    /// used to split the sequence are not returned as part of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.characters.split(isSeparator: { $0 == " " })
    ///                          .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don't", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.characters.split(maxSplits: 1, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.characters.split(omittingEmptySubsequences: false, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, isSeparator: @noescape (Element) throws -> Bool) rethrows -> [AnySequence<Element>]
}

extension AnySequence {
}

/// An ordered, random-access collection.
///
/// Arrays are one of the most commonly used data types in an app. You use
/// arrays to organize your app's data. Specifically, you use the `Array`
/// type to hold elements of a single type, the array's `Element` type. An
/// array's elements can be anything from an integer to a string to a
/// class.
///
/// Swift makes it easy to create arrays in your code using an array
/// literal: simply surround a comma-separated list of values with square
/// brackets. Without any other information, Swift creates an array that
/// includes the specified values, automatically inferring the array's
/// `Element` type. For example:
///
///     // An array of 'Int' elements
///     let oddNumbers = [1, 3, 5, 7, 9, 11, 13, 15]
///
///     // An array of 'String' elements
///     let streets = ["Albemarle", "Brandywine", "Chesapeake"]
///
/// You can create an empty array by specifying the `Element` type of your
/// array in the declaration. For example:
///
///     // Shortened forms are preferred
///     var emptyDoubles: [Double] = []
///
///     // The full type name is also allowed
///     var emptyFloats: Array<Float> = Array()
///
/// If you need an array that is preinitialized with a fixed number of
/// default values, use the `Array(repeating:count:)` initializer.
///
///     var digitCounts = Array(repeating: 0, count: 10)
///     print(digitCounts)
///     // Prints "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
///
/// Accessing Array Values
/// ======================
///
/// When you need to perform an operation on all of an array's elements, use
/// a `for`-`in` loop to iterate through the array's contents.
///
///     for street in streets {
///         print("I don't live on \(street).")
///     }
///     // Prints "I don't live on Albemarle."
///     // Prints "I don't live on Brandywine."
///     // Prints "I don't live on Chesapeake."
///
/// Use the `isEmpty` property to check quickly whether an array has any
/// elements, or use the `count` property to find the number of elements in
/// the array.
///
///     if oddNumbers.isEmpty {
///         print("I don't know any odd numbers.")
///     } else {
///         print("I know \(oddNumbers.count) odd numbers.")
///     }
///     // Prints "I know 8 odd numbers."
///
/// Use the `first` and `last` properties for safe access to the value of the
/// array's first and last elements. If the array is empty, these properties
/// are `nil`.
///
///     if let firstElement = oddNumbers.first, lastElement = oddNumbers.last {
///         print(firstElement, lastElement, separator: ", ")
///     }
///     // Prints "1, 15"
///
///     print(emptyDoubles.first, emptyDoubles.last, separator: ", ")
///     // Prints "nil, nil"
///
/// You can access individual array elements through a subscript. The first
/// element of a nonempty array is always at index zero. You can
/// subscript an array with any integer from zero up to, but not including,
/// the count of the array. Using a negative number or an index equal to or
/// greater than `count` triggers a runtime error. For example:
///
///     print(oddNumbers[0], oddNumbers[3], separator: ", ")
///     // Prints "1, 7"
///
///     print(emptyDoubles[0])
///     // Triggers runtime error: Index out of range
///
/// See the `Sequence`, `Collection`, and `RangeReplaceableCollection`
/// protocols for more methods available to arrays.
///
/// Adding and Removing Elements
/// ============================
///
/// Suppose you need to store a list of the names of students that are
/// signed up for a class you're teaching. During the registration period,
/// you need to add and remove names as students add and drop the class.
///
///     var students = ["Ben", "Ivy", "Jordell"]
///
/// More students are signing up. Add single elements to the end of an array
/// by using the `append(_:)` method. Add multiple elements at once by passing
/// another array or a sequence of any kind to the `append(contentsOf:)`
/// method.
///
///     students.append("Maxime")
///     students.append(contentsOf: ["Shakia", "William"])
///
///     print(students)
///     // Prints "["Ben", "Ivy", "Jordell", "Maxime", "Shakia", "William"]"
///
/// Another last-minute addition! Add new elements into the middle of the
/// array by using the `insert(_:at:)` method for single elements and
/// by using `insert(contentsOf:at:)` to insert multiple elements from another
/// collection or array literal. The elements at that index and later are
/// shifted back to make room.
///
///     // Welcome, Liam!
///     students.insert("Liam", at: 3)
///
/// A couple of students can't take your class after all. Use the
/// `removeLast()` and `remove(at:)` methods to remove their names
/// from the array.
///
///     // Ben's family is moving to another state
///     students.remove(at: 0)
///
///     // William is signing up for a different class
///     students.removeLast()
///
///     print(students)
///     // Prints "["Ivy", "Jordell", "Liam", "Maxime", "Shakia"]"
///
/// On the first day, you learn that Maxime really prefers to go by Max.
/// Replace an existing element with a new value by assigning to the
/// subscript.
///
///     if let i = students.index(of: "Maxime") {
///         students[i] = "Max"
///     }
///
/// Growing the Size of an Array
/// ----------------------------
///
/// Every array reserves a specific amount of memory to hold its contents. When
/// you add elements to an array and that array begins to exceed its reserved
/// capacity, the array allocates a larger region of memory and copies its
/// elements into the new storage. The new storage is a multiple of the
/// old storage's size. This exponential growth strategy means that appending
/// an element happens in constant time, averaging the performance of many
/// append operations. Append operations that trigger reallocation have a
/// performance cost, but they occur less and less often as the array grows
/// larger.
///
/// If you know approximately how many elements you will need to store, use
/// the `reserveCapacity(_:)` method before appending to the array to avoid
/// intermediate reallocations. Use the `capacity` and `count` properties
/// to determine how many more elements the array can store without
/// allocating larger storage.
///
/// For arrays of most `Element` types, this storage is a contiguous block
/// of memory. For arrays with an `Element` type that is a class or `@objc`
/// protocol type, this storage can be a contiguous block of memory or an
/// instance of `NSArray`. Because any arbitrary subclass of `NSArray` can
/// become an `Array`, there are no guarantees about representation or
/// efficiency in this case.
///
/// Modifying Copies of Arrays
/// ==========================
///
/// Each array has an independent value that includes the values of all of
/// its elements. For simple types such as integers and other structures,
/// this means that when you change a value in one array, the value of that
/// element does not change in any copies of the array. For example:
///
///     var numbers = [1, 2, 3, 4, 5]
///     var numbersCopy = numbers
///     numbers[0] = 100
///     print(numbers)
///     // Prints "[100, 2, 3, 4, 5]"
///     print(numbersCopy)
///     // Prints "[1, 2, 3, 4, 5]"
///
/// If the elements in an array are instances of a class, the semantics are
/// the same, though they might appear different at first. In this case,
/// the values stored in the array are references to objects that live
/// outside the array. If you change a reference to an object in one array,
/// only that array has a reference to the new object. However, if two
/// arrays contain references to the same object, you can observe changes
/// to that object's properties from both arrays. For example:
///
///     // An integer type with reference semantics
///     class IntegerReference {
///         var value = 10
///     }
///     var firstIntegers = [IntegerReference(), IntegerReference()]
///     var secondIntegers = firstIntegers
///
///     // Modifications to an instance are visible from either array
///     firstIntegers[0].value = 100
///     print(secondIntegers[0].value)
///     // Prints "100"
///
///     // Replacements, additions, and removals are still visible
///     // only in the modified array
///     firstIntegers[0] = IntegerReference()
///     print(firstIntegers[0].value)
///     // Prints "10"
///     print(secondIntegers[0].value)
///     // Prints "100"
///
/// Arrays, like all variable-size collections in the standard library, use
/// copy-on-write optimization. Multiple copies of an array share the same
/// storage until you modify one of the copies. When that happens, the
/// array being modified replaces its storage with a uniquely owned copy of
/// itself, which is then modified in place. Optimizations are sometimes
/// applied that can reduce the amount of copying.
///
/// This means that if an array is sharing storage with other copies, the
/// first mutating operation on that array incurs the cost of copying the
/// array. An array that is the sole owner of its storage can perform
/// mutating operations in place.
///
/// In the example below, a `numbers` array is created along with two copies
/// that share the same storage. When the original `numbers` array is
/// modified, it makes a unique copy of its storage before making the
/// modification. Further modifications to `numbers` are made in place,
/// while the two copies continue to share the original storage.
///
///     var numbers = [1, 2, 3, 4, 5]
///     var firstCopy = numbers
///     var secondCopy = numbers
///
///     // The storage for 'numbers' is copied here
///     numbers[0] = 100
///     numbers[1] = 200
///     numbers[2] = 300
///     // 'numbers' is [100, 200, 300, 4, 5]
///     // 'firstCopy' and 'secondCopy' are [1, 2, 3, 4, 5]
///
/// Bridging Between Array and NSArray
/// ==================================
///
/// When you need to access APIs that expect data in an `NSArray` instance
/// instead of `Array`, use the type-cast operator (`as`) to bridge your
/// instance. For bridging to be possible, the `Element` type of your array
/// must be a class, an `@objc` protocol (a protocol imported from Objective-C
/// or marked with the `@objc` attribute), or a type that bridges to a
/// Foundation type.
///
/// The following example shows how you can bridge an `Array` instance to
/// `NSArray` to use the `write(to:atomically:)` method. In this
/// example, the `colors` array can be bridged to `NSArray` because its
/// `String` elements bridge to `NSString`. The compiler prevents bridging
/// the `moreColors` array, on the other hand, because its `Element` type
/// is `Optional<String>`, which does *not* bridge to a Foundation type.
///
///     let colors = ["periwinkle", "rose", "moss"]
///     let moreColors: [String?] = ["ochre", "pine"]
///
///     let url = NSURL(fileURLWithPath: "names.plist")
///     (colors as NSArray).write(to: url, atomically: true)
///     // true
///
///     (moreColors as NSArray).write(to: url, atomically: true)
///     // error: cannot convert value of type '[String?]' to type 'NSArray'
///
/// Bridging from `Array` to `NSArray` takes O(1) time and O(1) space if the
/// array's elements are already instances of a class or an `@objc`
/// protocol; otherwise, it takes O(n) time and space.
///
/// Bridging from `NSArray` to `Array` first calls the `copy(with:)`
/// (`- copyWithZone:` in Objective-C) method on the array to get an immutable
/// copy and then performs additional Swift bookkeeping work that takes O(1)
/// time. For instances of `NSArray` that are already immutable,
/// `copy(with:)` usually returns the same array in O(1) time; otherwise,
/// the copying performance is unspecified. The instances of `NSArray` and
/// `Array` share storage using the same copy-on-write optimization that is
/// used when two instances of `Array` share storage.
///
/// - Note: The `ContiguousArray` and `ArraySlice` types are not bridged;
///   instances of those types always have a contiguous block of memory as
///   their storage.
/// - SeeAlso: `ContiguousArray`, `ArraySlice`, `Sequence`, `Collection`,
///   `RangeReplaceableCollection`
public struct Array<Element> : RandomAccessCollection, MutableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Int

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying a `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<[Element]>

    /// The position of the first element in a nonempty array.
    ///
    /// For an instance of `Array`, `startIndex` is always zero. If the array
    /// is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The array's "past the end" position---that is, the position one greater
    /// than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of an array, use the
    /// half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let i = numbers.index(of: 30) {
    ///         print(numbers[i ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the array is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Int) -> Int

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Int)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1)
    public func index(_ i: Int, offsetBy n: Int) -> Int

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position. The
    /// operation doesn't require going beyond the limiting `numbers.endIndex`
    /// value, so it succeeds.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex,
    ///                           offsetBy: 4,
    ///                           limitedBy: numbers.endIndex)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// The next example attempts to retrieve an index ten positions from
    /// `numbers.startIndex`, but fails, because that distance is beyond the
    /// index passed as `limit`.
    ///
    ///     let j = numbers.index(numbers.startIndex,
    ///                           offsetBy: 10,
    ///                           limitedBy: numbers.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Complexity: O(1)
    public func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -> Int?

    /// Returns the distance between two indices.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`.
    public func distance(from start: Int, to end: Int) -> Int

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = CountableRange<Int>

    /// Accesses the element at the specified position.
    ///
    /// For example:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// - Parameter index: The position of the element to access. `index` must be
    ///   greater than or equal to `startIndex` and less than `endIndex`.
    ///
    /// - Complexity: Reading an element from an array is O(1). Writing is O(1)
    ///   unless the array's storage is shared with another array, in which case
    ///   writing is O(*n*), where *n* is the length of the array.
    ///   If the array uses a bridged `NSArray` instance as its storage, the
    ///   efficiency is unspecified.
    public subscript(index: Int) -> Element

    /// Accesses a contiguous subrange of the array's elements.
    ///
    /// The returned `ArraySlice` instance uses the same indices for the same
    /// elements as the original array. In particular, that slice, unlike an
    /// array, may have a nonzero `startIndex` and an `endIndex` that is not
    /// equal to `count`. Always use the slice's `startIndex` and `endIndex`
    /// properties instead of assuming that its indices start or end at a
    /// particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let i = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[i!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of integers. The bounds of the range must be
    ///   valid indices of the array.
    ///
    /// - SeeAlso: `ArraySlice`
    public subscript(bounds: Range<Int>) -> ArraySlice<Element>
}

extension Array : ArrayLiteralConvertible {

    /// Creates an array from the given array literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler
    /// when you use an array literal. Instead, create a new array by using an
    /// array literal as its value. To do this, enclose a comma-separated list of
    /// values in square brackets.
    ///
    /// Here, an array of strings is created from an array literal holding
    /// only strings.
    ///
    ///     let ingredients = ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///
    /// - Parameter elements: A variadic list of elements of the new array.
    public init(arrayLiteral elements: Element...)
}

extension Array : RangeReplaceableCollection {

    /// Creates a new, empty array.
    ///
    /// This is equivalent to initializing with an empty array literal.
    /// For example:
    ///
    ///     var emptyArray = Array<Int>()
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    ///
    ///     emptyArray = []
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    public init()

    /// Creates an array containing the elements of a sequence.
    ///
    /// You can use this initializer to create an array from any other type that
    /// conforms to the `Sequence` protocol. For example, you might want to
    /// create an array with the integers from 1 through 7. Use this initializer
    /// around a range instead of typing all those numbers in an array literal.
    ///
    ///     let numbers = Array(1...7)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7]"
    ///
    /// You can also use this initializer to convert a complex sequence or
    /// collection type back to an array. For example, the `keys` property of
    /// a dictionary isn't an array with its own storage, it's a collection
    /// that maps its elements from the dictionary only when they're
    /// accessed, saving the time and space needed to allocate an array. If
    /// you need to pass those keys to a method that takes an array, however,
    /// use this initializer to convert that list from its type of
    /// `LazyMapCollection<Dictionary<String, Int>, Int>` to a simple
    /// `[String]`.
    ///
    ///     func cacheImagesWithNames(names: [String]) {
    ///         // custom image loading and caching
    ///      }
    /// 
    ///     let namedHues: [String: Int] = ["Vermillion": 18, "Magenta": 302,
    ///             "Gold": 50, "Cerise": 320]
    ///     let colorNames = Array(namedHues.keys)
    ///     cacheImagesWithNames(colorNames)
    /// 
    ///     print(colorNames)
    ///     // Prints "["Gold", "Cerise", "Magenta", "Vermillion"]"
    ///
    /// - Parameter s: The sequence of elements to turn into an array.
    public init<S : Sequence where S.Iterator.Element == Element>(_ s: S)

    /// Creates a new array containing the specified number of a single, repeated
    /// value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Element, count: Int)

    /// The number of elements in the array.
    public var count: Int { get }

    /// The total number of elements that the array can contain using its current
    /// storage.
    ///
    /// If the array grows larger than its capacity, it discards its current
    /// storage and allocates a larger one.
    ///
    /// The following example creates an array of integers from an array literal,
    /// then appends the elements of another collection. Before appending, the
    /// array allocates new storage that is large enough store the resulting
    /// elements.
    ///
    ///     var numbers = [10, 20, 30, 40, 50]
    ///     print("Count: \(numbers.count), capacity: \(numbers.capacity)")
    ///     // Prints "Count: 5, capacity: 5"
    ///
    ///     numbers.append(contentsOf: stride(from: 60, through: 100, by: 10))
    ///     print("Count: \(numbers.count), capacity: \(numbers.capacity)")
    ///     // Prints "Count: 10, capacity: 12"
    public var capacity: Int { get }

    /// Reserves enough space to store the specified number of elements.
    ///
    /// If you are adding a known number of elements to an array, use this method
    /// to avoid multiple reallocations. This method ensures that the array has
    /// unique, mutable, contiguous storage, with space allocated for at least
    /// the requested number of elements.
    ///
    /// For performance reasons, the newly allocated storage may be larger than
    /// the requested capacity. Use the array's `capacity` property to determine
    /// the size of the new storage.
    ///
    /// - Parameter minimumCapacity: The requested number of elements to store.
    ///
    /// - Complexity: O(*n*), where *n* is the count of the array.
    public mutating func reserveCapacity(_ minimumCapacity: Int)

    /// Adds a new element at the end of the array.
    ///
    /// - Parameter newElement: The element to append to the array.
    ///
    /// - Complexity: Appending an element to the array averages to O(1) over
    ///   many additions. When the array needs to reallocate storage before
    ///   appending or its storage is shared with another copy, appending an
    ///   element is O(*n*), where *n* is the length of the array. If the array
    ///   uses a bridged `NSArray` instance as its storage, the efficiency is
    ///   unspecified.
    public mutating func append(_ newElement: Element)

    /// Adds the elements of a sequence to the end of the array.
    ///
    /// Use this method to append the elements of a sequence to the end of a
    /// collection. This example appends the elements of a `Range<Int>` instance
    /// to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.appendContents(of: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the array.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting array.
    public mutating func append<S : Sequence where S.Iterator.Element == Element>(contentsOf newElements: S)

    /// Adds the elements of a collection to the end of the array.
    ///
    /// Use this method to append the elements of a collection to the end of this
    /// collection. This example appends the elements of a `Range<Int>` instance
    /// to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.appendContents(of: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the array.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting array.
    public mutating func append<C : Collection where C.Iterator.Element == Element>(contentsOf newElements: C)

    /// Removes and returns the last element of the array.
    ///
    /// The array must not be empty.
    ///
    /// - Returns: The element that was removed.
    public mutating func removeLast() -> Element

    /// Inserts a new element at the specified position.
    ///
    /// The new element is inserted before the element currently at the specified
    /// index. If you pass the array's `endIndex` property as the `index`
    /// parameter, the new element is appended to the array.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// - Parameter newElement: The new element to insert into the array.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index of the array or equal to its `endIndex`
    ///   property.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func insert(_ newElement: Element, at i: Int)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved up to
    /// close the gap.
    ///
    ///     var measurements: [Double] = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.1, 1.5, 1.2, 1.5, 1.3, 1.2]"
    ///
    /// - Parameter index: The position of the element to remove. `index` must
    ///   be a valid index of the array.
    /// - Returns: The element at the specified index.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func remove(at index: Int) -> Element

    /// Removes all elements from the array.
    ///
    /// - Parameter keepCapacity: Pass `true` to keep the existing capacity of
    ///   the array after removing its elements. The default value is
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)
}

extension Array : CustomReflectable {

    /// A mirror that reflects the array.
    public var customMirror: Mirror { get }
}

extension Array : CustomStringConvertible, CustomDebugStringConvertible {

    /// A textual representation of the array and its elements.
    public var description: String { get }

    /// A textual representation of the array and its elements, suitable for
    /// debugging.
    public var debugDescription: String { get }
}

extension Array {

    /// Calls a closure with a pointer to the array's contiguous storage.
    ///  If no such storage exists, it is first created.
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows how you can iterate over the contents of the
    /// buffer pointer:
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     let sum = numbers.withUnsafeBufferPointer { buffer -> Int in
    ///         var result = 0
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {
    ///             result += buffer[i]
    ///         }
    ///         return result
    ///     }
    ///     // 'sum' == 9
    ///
    /// - Parameter body: A closure with an `UnsafeBufferPointer` parameter that
    ///   points to the contiguous storage for the array. If `body` has a return
    ///   value, it is used as the return value for the
    ///   `withUnsafeBufferPointer(_:)` method. The pointer argument is valid
    ///   only for the duration of the closure's execution.
    /// - Returns: The return value of the `body` closure parameter, if any.
    ///
    /// - SeeAlso: `withUnsafeMutableBufferPointer`, `UnsafeBufferPointer`
    public func withUnsafeBufferPointer<R>(_ body: @noescape (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R

    /// Calls the given closure with a pointer to the array's mutable contiguous
    /// storage. If no such storage exists, it is first created.
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows modifying the contents of the
    /// `UnsafeMutableBufferPointer` argument to `body` alters the contents of
    /// the array:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.withUnsafeMutableBufferPointer { buffer in
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {
    ///             swap(&buffer[i], &buffer[i + 1])
    ///         }
    ///     }
    ///     print(numbers)
    ///     // Prints "[2, 1, 4, 3, 5]"
    ///
    /// - Warning: Do not rely on anything about `self` (the array that is the
    ///   target of this method) during the execution of the `body` closure: It
    ///   may not appear to have its correct value.  Instead, use only the
    ///   `UnsafeMutableBufferPointer` argument to `body`.
    ///
    /// - Parameter body: A closure with an `UnsafeMutableBufferPointer`
    ///   parameter that points to the contiguous storage for the array. If
    ///   `body` has a return value, it is used as the return value for the
    ///   `withUnsafeMutableBufferPointer(_:)` method. The pointer argument is
    ///   valid only for the duration of the closure's execution.
    /// - Returns: The return value of the `body` closure parameter, if any.
    ///
    /// - SeeAlso: `withUnsafeBufferPointer`, `UnsafeMutableBufferPointer`
    public mutating func withUnsafeMutableBufferPointer<R>(_ body: @noescape (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R
}

extension Array {

    /// Replaces a range of elements with the elements in the specified
    /// collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the array and inserting the new elements at the same location. The
    /// number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the array to replace. The start and end of
    ///     a subrange must be valid indices of the array.
    ///   - newElements: The new elements to add to the array.
    ///
    /// - Complexity: O(`subrange.count`) if you are replacing a suffix of the
    ///   array with an empty collection; otherwise, O(*n*), where *n* is the
    ///   length of the array.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == _Buffer.Element>(_ subrange: Range<Int>, with newElements: C)
}

extension Array {

    /// Removes and returns the last element of the array.
    ///
    /// - Returns: The last element of the array if the array is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(*n*) if the array is bridged, where *n* is the length
    ///   of the array; otherwise, O(1).
    /// - SeeAlso: `removeLast()`
    public mutating func popLast() -> Element?
}

/// A type that can be initialized using an array literal.
///
/// An array literal is a simple way of expressing a list of values. Simply
/// surround a comma-separated list of values, instances, or literals with
/// square brackets to create an array literal. You can use an array literal
/// anywhere an instance of an `ArrayLiteralConvertible` type is expected: as
/// a value assigned to a variable or constant, as a parameter to a method or
/// initializer, or even as the subject of a nonmutating operation like
/// `map(_:)` or `filter(_:)`.
///
/// Arrays, sets, and option sets all conform to `ArrayLiteralConvertible`, and
/// your own custom types can as well. Here's an example of creating a set and
/// an array using array literals:
///
///     let employeesSet: Set<String> = ["Amir", "Jihye", "Dave", "Alessia", "Dave"]
///     print(employeesSet)
///     // Prints "["Amir", "Dave", "Jihye", "Alessia"]"
///
///     let employeesArray: [String] = ["Amir", "Jihye", "Dave", "Alessia", "Dave"]
///     print(employeesArray)
///     // Prints "["Amir", "Jihye", "Dave", "Alessia", "Dave"]"
///
/// The `Set` and `Array` types each handle array literals in their own way to
/// create new instances. In this case, the newly created set drops the
/// duplicate value ("Dave") and doesn't maintain the order of the array
/// literal's elements. The new array, on the other hand, matches the order
/// and number of elements provided.
///
/// - Note: An array literal is not the same as an `Array` instance. You can't
///   initialize a type that conforms to `ArrayLiteralConvertible` simply by
///   assigning an existing array.
///
///         let anotherSet: Set = employeesArray
///         // error: cannot convert value of type '[String]' to specified type 'Set'
///
/// Type Inference of Array Literals
/// ================================
///
/// Whenever possible, Swift's compiler infers the full intended type of your
/// array literal. Because `Array` is the default type for an array literal,
/// without writing any other code, you can declare an array with a particular
/// element type by providing one or more values.
///
/// In this example, the compiler infers the full type of each array literal.
///
///     let integers = [1, 2, 3]
///     // 'integers' has type '[Int]'
///
///     let strings = ["a", "b", "c"]
///     // 'strings' has type '[String]'
///
/// An empty array literal alone doesn't provide enough information for the
/// compiler to infer the intended type of the `Array` instance. When using an
/// empty array literal, specify the type of the variable or constant.
///
///     var emptyArray: [Bool] = []
///     // 'emptyArray' has type '[Bool]'
///
/// Because many functions and initializers fully specify the types of their
/// parameters, you can often use an array literal with or without elements as
/// a parameter. For example, the `sum(_:)` function shown here takes an `Int`
/// array as a parameter:
///
///     func sum(values: [Int]) -> Int {
///         return values.reduce(0, combine: +)
///     }
///
///     let sumOfFour = sum([5, 10, 15, 20])
///     // 'sumOfFour' == 50
///
///     let sumOfNone = sum([])
///     // 'sumOfNone' == 0
///
/// When you call a function that does not fully specify its parameters' types,
/// use the type-cast operator (`as`) to specify the type of an array literal.
/// For example, the `log(name:value:)` function shown here has an
/// unconstrained generic `value` parameter.
///
///     func log<T>(name name: String, value: T) {
///         print("\(name): \(value)")
///     }
///
///     log(name: "Four integers", value: [5, 10, 15, 20])
///     // Prints "Four integers: [5, 10, 15, 20]"
///
///     log(name: "Zero integers", value: [] as [Int])
///     // Prints "Zero integers: []"
///
/// Conforming to ArrayLiteralConvertible
/// =====================================
///
/// Add the capability to be initialized with an array literal to your own
/// custom types by declaring an `init(arrayLiteral:)` initializer. The
/// following example shows the array literal initializer for a hypothetical
/// `OrderedSet` type, which has setlike semantics but maintains the order of
/// its elements.
///
///     struct OrderedSet<Element: Hashable>: Collection, SetAlgebra {
///         // implementation details
///     }
///
///     extension OrderedSet: ArrayLiteralConvertible {
///         init(arrayLiteral: Element...) {
///             self.init()
///             for element in arrayLiteral {
///                 self.append(element)
///             }
///         }
///     }
public protocol ArrayLiteralConvertible {

    /// The type of the elements of an array literal.
    associatedtype Element

    /// Creates an instance initialized with the given elements.
    public init(arrayLiteral elements: Self.Element...)
}

/// A slice of an `Array`, `ContiguousArray`, or `ArraySlice` instance.
///
/// The `ArraySlice` type makes it fast and efficient for you to perform
/// operations on sections of a larger array. Instead of copying over the
/// elements of a slice to new storage, an `ArraySlice` instance presents a
/// view onto the storage of a larger array. And because `ArraySlice`
/// presents the same interface as `Array`, you can generally perform the
/// same operations on a slice as you could on the original array.
///
/// For more information about using arrays, see `Array` and `ContiguousArray`,
/// with which `ArraySlice` shares most properties and methods.
///
/// Slices Are Views onto Arrays
/// ============================
///
/// For example, suppose you have an array holding the number of absences
/// from each class during a session.
///
///     let absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You want to compare the absences in the first half of the session with
/// those in the second half. To do so, start by creating two slices of the
/// `absences` array.
///
///     let midpoint = absences.count / 2
///
///     let firstHalf = absences.prefix(upTo: midpoint)
///     let secondHalf = absences.suffix(from: midpoint)
///
/// Neither the `firstHalf` nor `secondHalf` slices allocate any new storage
/// of their own. Instead, each presents a view onto the storage of the
/// `absences` array.
///
/// You can call any method on the slices that you might have called on the
/// `absences` array. To learn which half had more absences, use the
/// `reduce(_:combine:)` method to calculate each sum.
///
///     let firstHalfSum = firstHalf.reduce(0, combine: +)
///     let secondHalfSum = secondHalf.reduce(0, combine: +)
///
///     if firstHalfSum > secondHalfSum {
///         print("More absences in the first half.")
///     } else {
///         print("More absences in the second half.")
///     }
///     // Prints "More absences in the second half."
///
/// - Important: Long-term storage of `ArraySlice` instances is discouraged. A
///   slice holds a reference to the entire storage of a larger array, not
///   just to the portion it presents, even after the original array's lifetime
///   ends. Long-term storage of a slice may therefore prolong the lifetime of
///   elements that are no longer otherwise accessible, which can appear to be
///   memory and object leakage.
///
/// Slices Maintain Indices
/// =======================
///
/// Unlike `Array` and `ContiguousArray`, the starting index for an
/// `ArraySlice` instance isn't always zero. Slices maintain the same
/// indices of the larger array for the same elements, so the starting
/// index of a slice depends on how it was created, letting you perform
/// index-based operations on either a full array or a slice.
///
/// Sharing indices between collections and their subsequences is an important
/// part of the design of Swift's collection algorithms. Suppose you are
/// tasked with finding the first two days with absences in the session. To
/// find the indices of the two days in question, follow these steps:
///
/// 1) Call `index(where:)` to find the index of the first element in the
///    `absences` array that is greater than zero.
/// 2) Create a slice of the `absences` array starting after the index found in
///    step 1.
/// 3) Call `index(where:)` again, this time on the slice created in step 2.
///    Where in some languages you might pass a starting index into an
///    `indexOf` method to find the second day, in Swift you perform the same
///    operation on a slice of the original array.
/// 4) Print the results using the indices found in steps 1 and 3 on the
///    original `absences` array.
///
/// Here's an implementation of those steps:
///
///     if let i = absences.index(where: { $0 > 0 }) {                      // 1
///         let absencesAfterFirst = absences.suffix(from: i + 1)           // 2
///         if let j = absencesAfterFirst.index(where: { $0 > 0 }) {        // 3
///             print("The first day with absences had \(absences[i]).")    // 4
///             print("The second day with absences had \(absences[j]).")
///         }
///     }
///     // Prints "The first day with absences had 2."
///     // Prints "The second day with absences had 4."
///
/// In particular, note that `j`, the index of the second day with absences,
/// was found in a slice of the original array and then used to access a value
/// in the original `absences` array itself.
///
/// - Note: To safely reference the starting and ending indices of a slice,
///   always use the `startIndex` and `endIndex` properties instead of
///   specific values.
public struct ArraySlice<Element> : RandomAccessCollection, MutableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Int

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying a `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ArraySlice<Element>>

    /// The position of the first element in a nonempty array.
    ///
    /// If the array is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The array's "past the end" position---that is, the position one greater
    /// than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of an array, use the
    /// half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let i = numbers.index(of: 30) {
    ///         print(numbers[i ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the array is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Int) -> Int

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Int)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1)
    public func index(_ i: Int, offsetBy n: Int) -> Int

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position. The
    /// operation doesn't require going beyond the limiting `numbers.endIndex`
    /// value, so it succeeds.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex,
    ///                           offsetBy: 4,
    ///                           limitedBy: numbers.endIndex)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// The next example attempts to retrieve an index ten positions from
    /// `numbers.startIndex`, but fails, because that distance is beyond the
    /// index passed as `limit`.
    ///
    ///     let j = numbers.index(numbers.startIndex,
    ///                           offsetBy: 10,
    ///                           limitedBy: numbers.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Complexity: O(1)
    public func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -> Int?

    /// Returns the distance between two indices.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`.
    public func distance(from start: Int, to end: Int) -> Int

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = CountableRange<Int>

    /// Accesses the element at the specified position.
    ///
    /// For example:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// - Parameter index: The position of the element to access. `index` must be
    ///   greater than or equal to `startIndex` and less than `endIndex`.
    ///
    /// - Complexity: Reading an element from an array is O(1). Writing is O(1)
    ///   unless the array's storage is shared with another array, in which case
    ///   writing is O(*n*), where *n* is the length of the array.
    public subscript(index: Int) -> Element

    /// Accesses a contiguous subrange of the array's elements.
    ///
    /// The returned `ArraySlice` instance uses the same indices for the same
    /// elements as the original array. In particular, that slice, unlike an
    /// array, may have a nonzero `startIndex` and an `endIndex` that is not
    /// equal to `count`. Always use the slice's `startIndex` and `endIndex`
    /// properties instead of assuming that its indices start or end at a
    /// particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let i = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[i!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of integers. The bounds of the range must be
    ///   valid indices of the array.
    public subscript(bounds: Range<Int>) -> ArraySlice<Element>
}

extension ArraySlice : ArrayLiteralConvertible {

    /// Creates an array from the given array literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use an array literal. Instead, create a new array by using an array
    /// literal as its value. To do this, enclose a comma-separated list of
    /// values in square brackets.
    ///
    /// Here, an array of strings is created from an array literal holding only
    /// strings:
    ///
    ///     let ingredients: ArraySlice =
    ///           ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///
    /// - Parameter elements: A variadic list of elements of the new array.
    public init(arrayLiteral elements: Element...)
}

extension ArraySlice : RangeReplaceableCollection {

    /// Creates a new, empty array.
    ///
    /// This is equivalent to initializing with an empty array literal.
    /// For example:
    ///
    ///     var emptyArray = Array<Int>()
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    ///
    ///     emptyArray = []
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    public init()

    /// Creates an array containing the elements of a sequence.
    ///
    /// You can use this initializer to create an array from any other type that
    /// conforms to the `Sequence` protocol. For example, you might want to
    /// create an array with the integers from 1 through 7. Use this initializer
    /// around a range instead of typing all those numbers in an array literal.
    ///
    ///     let numbers = Array(1...7)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7]"
    ///
    /// You can also use this initializer to convert a complex sequence or
    /// collection type back to an array. For example, the `keys` property of
    /// a dictionary isn't an array with its own storage, it's a collection
    /// that maps its elements from the dictionary only when they're
    /// accessed, saving the time and space needed to allocate an array. If
    /// you need to pass those keys to a method that takes an array, however,
    /// use this initializer to convert that list from its type of
    /// `LazyMapCollection<Dictionary<String, Int>, Int>` to a simple
    /// `[String]`.
    ///
    ///     func cacheImagesWithNames(names: [String]) {
    ///         // custom image loading and caching
    ///      }
    /// 
    ///     let namedHues: [String: Int] = ["Vermillion": 18, "Magenta": 302,
    ///             "Gold": 50, "Cerise": 320]
    ///     let colorNames = Array(namedHues.keys)
    ///     cacheImagesWithNames(colorNames)
    /// 
    ///     print(colorNames)
    ///     // Prints "["Gold", "Cerise", "Magenta", "Vermillion"]"
    ///
    /// - Parameter s: The sequence of elements to turn into an array.
    public init<S : Sequence where S.Iterator.Element == Element>(_ s: S)

    /// Creates a new array containing the specified number of a single, repeated
    /// value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Element, count: Int)

    /// The number of elements in the array.
    public var count: Int { get }

    /// The total number of elements that the array can contain using its current
    /// storage.
    ///
    /// If the array grows larger than its capacity, it discards its current
    /// storage and allocates a larger one.
    ///
    /// The following example creates an array of integers from an array literal,
    /// then appends the elements of another collection. Before appending, the
    /// array allocates new storage that is large enough store the resulting
    /// elements.
    ///
    ///     var numbers = [10, 20, 30, 40, 50]
    ///     print("Count: \(numbers.count), capacity: \(numbers.capacity)")
    ///     // Prints "Count: 5, capacity: 5"
    ///
    ///     numbers.append(contentsOf: stride(from: 60, through: 100, by: 10))
    ///     print("Count: \(numbers.count), capacity: \(numbers.capacity)")
    ///     // Prints "Count: 10, capacity: 12"
    public var capacity: Int { get }

    /// Reserves enough space to store the specified number of elements.
    ///
    /// If you are adding a known number of elements to an array, use this method
    /// to avoid multiple reallocations. This method ensures that the array has
    /// unique, mutable, contiguous storage, with space allocated for at least
    /// the requested number of elements.
    ///
    /// For performance reasons, the newly allocated storage may be larger than
    /// the requested capacity. Use the array's `capacity` property to determine
    /// the size of the new storage.
    ///
    /// - Parameter minimumCapacity: The requested number of elements to store.
    ///
    /// - Complexity: O(*n*), where *n* is the count of the array.
    public mutating func reserveCapacity(_ minimumCapacity: Int)

    /// Adds a new element at the end of the array.
    ///
    /// - Parameter newElement: The element to append to the array.
    ///
    /// - Complexity: Appending an element to the array averages to O(1) over
    ///   many additions. When the array needs to reallocate storage before
    ///   appending or its storage is shared with another copy, appending an
    ///   element is O(*n*), where *n* is the length of the array. If the array
    ///   uses a bridged `NSArray` instance as its storage, the efficiency is
    ///   unspecified.
    public mutating func append(_ newElement: Element)

    /// Adds the elements of a sequence to the end of the array.
    ///
    /// Use this method to append the elements of a sequence to the end of a
    /// collection. This example appends the elements of a `Range<Int>` instance
    /// to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.appendContents(of: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the array.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting array.
    public mutating func append<S : Sequence where S.Iterator.Element == Element>(contentsOf newElements: S)

    /// Adds the elements of a collection to the end of the array.
    ///
    /// Use this method to append the elements of a collection to the end of this
    /// collection. This example appends the elements of a `Range<Int>` instance
    /// to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.appendContents(of: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the array.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting array.
    public mutating func append<C : Collection where C.Iterator.Element == Element>(contentsOf newElements: C)

    /// Removes and returns the last element of the array.
    ///
    /// The array must not be empty.
    ///
    /// - Returns: The element that was removed.
    public mutating func removeLast() -> Element

    /// Inserts a new element at the specified position.
    ///
    /// The new element is inserted before the element currently at the specified
    /// index. If you pass the array's `endIndex` property as the `index`
    /// parameter, the new element is appended to the array.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// - Parameter newElement: The new element to insert into the array.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index of the array or equal to its `endIndex`
    ///   property.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func insert(_ newElement: Element, at i: Int)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved up to
    /// close the gap.
    ///
    ///     var measurements: [Double] = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.1, 1.5, 1.2, 1.5, 1.3, 1.2]"
    ///
    /// - Parameter index: The position of the element to remove. `index` must
    ///   be a valid index of the array.
    /// - Returns: The element at the specified index.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func remove(at index: Int) -> Element

    /// Removes all elements from the array.
    ///
    /// - Parameter keepCapacity: Pass `true` to keep the existing capacity of
    ///   the array after removing its elements. The default value is
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)
}

extension ArraySlice : CustomReflectable {

    /// A mirror that reflects the array.
    public var customMirror: Mirror { get }
}

extension ArraySlice : CustomStringConvertible, CustomDebugStringConvertible {

    /// A textual representation of the array and its elements.
    public var description: String { get }

    /// A textual representation of the array and its elements, suitable for
    /// debugging.
    public var debugDescription: String { get }
}

extension ArraySlice {

    /// Calls a closure with a pointer to the array's contiguous storage.
    /// 
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows how you can iterate over the contents of the
    /// buffer pointer:
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     let sum = numbers.withUnsafeBufferPointer { buffer -> Int in
    ///         var result = 0
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {
    ///             result += buffer[i]
    ///         }
    ///         return result
    ///     }
    ///     // 'sum' == 9
    ///
    /// - Parameter body: A closure with an `UnsafeBufferPointer` parameter that
    ///   points to the contiguous storage for the array. If `body` has a return
    ///   value, it is used as the return value for the
    ///   `withUnsafeBufferPointer(_:)` method. The pointer argument is valid
    ///   only for the duration of the closure's execution.
    /// - Returns: The return value of the `body` closure parameter, if any.
    ///
    /// - SeeAlso: `withUnsafeMutableBufferPointer`, `UnsafeBufferPointer`
    public func withUnsafeBufferPointer<R>(_ body: @noescape (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R

    /// Calls the given closure with a pointer to the array's mutable contiguous
    /// storage.
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows modifying the contents of the
    /// `UnsafeMutableBufferPointer` argument to `body` alters the contents of
    /// the array:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.withUnsafeMutableBufferPointer { buffer in
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {
    ///             swap(&buffer[i], &buffer[i + 1])
    ///         }
    ///     }
    ///     print(numbers)
    ///     // Prints "[2, 1, 4, 3, 5]"
    ///
    /// - Warning: Do not rely on anything about `self` (the array that is the
    ///   target of this method) during the execution of the `body` closure: It
    ///   may not appear to have its correct value.  Instead, use only the
    ///   `UnsafeMutableBufferPointer` argument to `body`.
    ///
    /// - Parameter body: A closure with an `UnsafeMutableBufferPointer`
    ///   parameter that points to the contiguous storage for the array. If
    ///   `body` has a return value, it is used as the return value for the
    ///   `withUnsafeMutableBufferPointer(_:)` method. The pointer argument is
    ///   valid only for the duration of the closure's execution.
    /// - Returns: The return value of the `body` closure parameter, if any.
    ///
    /// - SeeAlso: `withUnsafeBufferPointer`, `UnsafeMutableBufferPointer`
    public mutating func withUnsafeMutableBufferPointer<R>(_ body: @noescape (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R
}

extension ArraySlice {

    /// Replaces a range of elements with the elements in the specified
    /// collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the array and inserting the new elements at the same location. The
    /// number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the array to replace. The start and end of
    ///     a subrange must be valid indices of the array.
    ///   - newElements: The new elements to add to the array.
    ///
    /// - Complexity: O(`subrange.count`) if you are replacing a suffix of the
    ///   array with an empty collection; otherwise, O(*n*), where *n* is the
    ///   length of the array.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == _Buffer.Element>(_ subrange: Range<Int>, with newElements: C)
}

/// A mutable pointer-to-ObjC-pointer argument.
///
/// This type has implicit conversions to allow passing any of the following
/// to a C or ObjC API:
///
/// - `nil`, which gets passed as a null pointer,
/// - an inout argument of the referenced type, which gets passed as a pointer
///   to a writeback temporary with autoreleasing ownership semantics,
/// - an `UnsafeMutablePointer<Pointee>`, which is passed as-is.
///
/// Passing pointers to mutable arrays of ObjC class pointers is not
/// directly supported. Unlike `UnsafeMutablePointer<Pointee>`,
/// `AutoreleasingUnsafeMutablePointer<Pointee>` must reference storage that
/// does not own a reference count to the referenced
/// value. UnsafeMutablePointer's operations, by contrast, assume that
/// the referenced storage owns values loaded from or stored to it.
///
/// This type does not carry an owner pointer unlike the other C*Pointer types
/// because it only needs to reference the results of inout conversions, which
/// already have writeback-scoped lifetime.
public struct AutoreleasingUnsafeMutablePointer<Pointee> : Equatable {

    /// Access the `Pointee` instance referenced by `self`.
    ///
    /// - Precondition: the pointee has been initialized with an instance of type
    ///   `Pointee`.
    public var pointee: Pointee { get nonmutating set }

    /// Access the `i`th element of the raw array pointed to by
    /// `self`.
    ///
    /// - Precondition: `self != nil`.
    public subscript(i: Int) -> Pointee { get }

    /// Explicit construction from an UnsafeMutablePointer.
    ///
    /// This is inherently unsafe; UnsafeMutablePointer assumes the
    /// referenced memory has +1 strong ownership semantics, whereas
    /// AutoreleasingUnsafeMutablePointer implies +0 semantics.
    public init<U>(_ from: UnsafeMutablePointer<U>)

    /// Explicit construction from an UnsafeMutablePointer.
    ///
    /// Returns nil if `from` is nil.
    ///
    /// This is inherently unsafe; UnsafeMutablePointer assumes the
    /// referenced memory has +1 strong ownership semantics, whereas
    /// AutoreleasingUnsafeMutablePointer implies +0 semantics.
    public init?<U>(_ from: UnsafeMutablePointer<U>?)
}

extension AutoreleasingUnsafeMutablePointer : CustomDebugStringConvertible {

    /// A textual representation of `self`, suitable for debugging.
    public var debugDescription: String { get }
}

extension AutoreleasingUnsafeMutablePointer {
}

extension AutoreleasingUnsafeMutablePointer : CVarArg {
}

/// A collection that supports backward as well as forward traversal.
///
/// Bidirectional collections offer traversal backward from any valid index,
/// not including a collection's `startIndex`. Bidirectional collections can
/// therefore offer additional operations, such as a `last` property that
/// provides efficient access to the last element and a `reversed()` method
/// that presents the elements in reverse order. In addition, bidirectional
/// collections have more efficient implementations of some sequence and
/// collection methods, such as `suffix(_:)`.
///
/// Conforming to the BidirectionalCollection Protocol
/// ==================================================
///
/// To add `BidirectionalProtocol` conformance to your custom types, implement
/// the `index(before:)` method in addition to the requirements of the
/// `Collection` protocol.
///
/// Indices that are moved forward and backward in a bidirectional collection
/// move by the same amount in each direction. That is, for any index `i` into
/// a bidirectional collection `c`:
///
/// - If `i >= c.startIndex && i < c.endIndex`,
///   `c.index(before: c.index(after: i)) == i`.
/// - If `i > c.startIndex && i <= c.endIndex`
///   `c.index(after: c.index(before: i)) == i`.
public protocol BidirectionalCollection : BidirectionalIndexable, Collection {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Self.Index) -> Self.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Self.Index)

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    associatedtype SubSequence : BidirectionalIndexable, Collection = BidirectionalSlice<Self>

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    associatedtype Indices : BidirectionalIndexable, Collection = DefaultBidirectionalIndices<Self>

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Self.Iterator.Element? { get }
}

extension BidirectionalCollection where SubSequence == Self {

    /// Removes and returns the last element of the collection.
    ///
    /// - Returns: The last element of the collection if the collection has one
    ///   or more elements; otherwise, `nil`.
    ///
    /// - Complexity: O(1).
    /// - SeeAlso: `removeLast()`
    public mutating func popLast() -> Self.Iterator.Element?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    /// - SeeAlso: `popLast()`
    public mutating func removeLast() -> Self.Iterator.Element

    /// Removes the given number of elements from the end of the collection.
    ///
    /// - Parameter n: The number of elements to remove. `n` must be greater
    ///   than or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public mutating func removeLast(_ n: Int)
}

extension BidirectionalCollection {

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   collection. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `n` elements from the end.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop.
    public func dropLast(_ n: Int) -> Self.SubSequence

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is equal to `maxLength`.
    public func suffix(_ maxLength: Int) -> Self.SubSequence
}

extension BidirectionalCollection {

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    public var last: Self.Iterator.Element? { get }
}

extension BidirectionalCollection where Iterator.Element : BidirectionalCollection {

    /// Returns the elements of this collection of collections, concatenated.
    ///
    /// In this example, an array of three ranges is flattened so that the
    /// elements of each range can be iterated in turn.
    ///
    ///     let ranges = [0..<3, 8..<10, 15..<17]
    ///
    ///     // A for-in loop over 'ranges' accesses each range:
    ///     for range in ranges {
    ///       print(range)
    ///     }
    ///     // Prints "0..<3"
    ///     // Prints "8..<10"
    ///     // Prints "15..<17"
    ///
    ///     // Use 'flatten()' to access each element of each range:
    ///     for index in ranges.flatten() {
    ///         print(index, terminator: " ")
    ///     }
    ///     // Prints: "0 1 2 8 9 15 16"
    ///
    /// - Returns: A flattened view of the elements of this
    ///   collection of collections.
    ///
    /// - SeeAlso: `flatMap(_:)`, `joined(separator:)`
    public func flatten() -> FlattenBidirectionalCollection<Self>
}

extension BidirectionalCollection where Indices == DefaultBidirectionalIndices<Self> {

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: DefaultBidirectionalIndices<Self> { get }
}

/// Augment `self` with lazy methods such as `map`, `filter`, etc.
extension BidirectionalCollection {

    /// A view onto this collection that provides lazy implementations of
    /// normally eager operations, such as `map` and `filter`.
    ///
    /// Use the `lazy` property when chaining operations to prevent
    /// intermediate operations from allocating storage, or when you only
    /// need a part of the final collection to avoid unnecessary computation.
    ///
    /// - See Also: `LazySequenceProtocol`, `LazyCollectionProtocol`.
    public var lazy: LazyBidirectionalCollection<Self> { get }
}

extension BidirectionalCollection where Self : LazyCollectionProtocol {

    /// Identical to `self`.
    public var lazy: Self { get }
}

extension BidirectionalCollection {

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReverseCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.characters.reversed() {
    ///         print(char, terminator="")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.characters.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    public func reversed() -> ReversedCollection<Self>
}

/// A type that provides subscript access to its elements, with bidirectional
/// index traversal.
///
/// In most cases, it's best to ignore this protocol and use the
/// `BidirectionalCollection` protocol instead, because it has a more complete
/// interface.
public protocol BidirectionalIndexable : Indexable {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Self.Index) -> Self.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Self.Index)
}

/// Default implementation for bidirectional collections.
extension BidirectionalIndexable {

    public func formIndex(before i: inout Self.Index)

    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance) -> Self.Index

    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance, limitedBy limit: Self.Index) -> Self.Index?

    public func distance(from start: Self.Index, to end: Self.Index) -> Self.IndexDistance
}

/// Supply the default "slicing" `subscript` for `BidirectionalCollection`
/// models that accept the default associated `SubSequence`,
/// `BidirectionalSlice<Self>`.
extension BidirectionalIndexable where SubSequence == BidirectionalSlice<Self> {

    public subscript(bounds: Range<Self.Index>) -> BidirectionalSlice<Self> { get }
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `BidirectionalSlice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
public struct BidirectionalSlice<Base : BidirectionalIndexable> : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element { get }

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = BidirectionalSlice<Base>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Base.Index>) -> BidirectionalSlice<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position. The
    /// operation doesn't require going beyond the limiting `s.endIndex` value,
    /// so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A radix-2 (binary) floating-point type that follows the IEEE 754 encoding
/// conventions.
public protocol BinaryFloatingPoint : FloatingPoint, FloatLiteralConvertible {

    /// An unsigned integer type that can represent the significand of any value.
    ///
    /// The significand (http://en.wikipedia.org/wiki/Significand) is frequently
    /// also called the "mantissa", but this terminology is slightly incorrect
    /// (see the "Use of 'mantissa'" section on the linked Wikipedia page for
    /// more details).  "Significand" is the preferred terminology in IEEE 754.
    associatedtype RawSignificand : UnsignedInteger

    /// An unsigned integer type that can represent the exponent encoding of any
    /// value.
    associatedtype RawExponent : UnsignedInteger

    /// Combines `sign`, `exponent` and `significand` bit patterns to produce
    /// a floating-point value.
    public init(sign: FloatingPointSign, exponentBitPattern: Self.RawExponent, significandBitPattern: Self.RawSignificand)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: Float)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: Double)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: Float80)

    /// The number of bits used to represent the exponent.
    ///
    /// Following IEEE 754 encoding convention, the exponent bias is:
    ///
    /// ~~~
    /// bias = 2**(exponentBitCount-1) - 1
    /// ~~~
    ///
    /// (where `**` is exponentiation).  The least normal exponent is `1-bias`
    /// and the largest finite exponent is `bias`.  The all-zeros exponent is
    /// reserved for subnormals and zeros, and the all-ones exponent is reserved
    /// for infinities and NaNs.
    public static var exponentBitCount: Int { get }

    /// For fixed-width floating-point types, this is the number of fractional
    /// significand bits.
    ///
    /// For extensible floating-point types, `significandBitCount` should be
    /// the maximum allowed significand width (without counting any leading
    /// integral bit of the significand).  If there is no upper limit, then
    /// `significandBitCount` should be `Int.max`.
    ///
    /// Note that `Float80.significandBitCount` is 63, even though 64 bits
    /// are used to store the significand in the memory representation of a
    /// `Float80` (unlike other floating-point types, `Float80` explicitly
    /// stores the leading integral significand bit, but the
    /// `BinaryFloatingPoint` APIs provide an abstraction so that users don't
    /// need to be aware of this detail).
    public static var significandBitCount: Int { get }

    /// The raw encoding of the exponent field of the floating-point value.
    public var exponentBitPattern: Self.RawExponent { get }

    /// The raw encoding of the significand field of the floating-point value.
    ///
    /// `significandBitPattern` does *not* include the leading integral bit of
    /// the significand, even for types like `Float80` that store it explicitly.
    public var significandBitPattern: Self.RawSignificand { get }

    /// The least-magnitude member of the binade of `self`.
    ///
    /// If `x` is `+/-significand * 2**exponent`, then `x.binade` is
    /// `+/- 2**exponent`; i.e. the floating point number with the same sign
    /// and exponent, but with a significand of 1.0.
    public var binade: Self { get }

    /// The number of bits required to represent significand.
    ///
    /// If `self` is not a finite non-zero number, `significandWidth` is
    /// `-1`.  Otherwise, it is the number of fractional bits required to
    /// represent `self.significand`, which is an integer between zero and
    /// `significandBitCount`.  Some examples:
    ///
    /// - For any representable power of two, `significandWidth` is zero,
    ///   because `significand` is `1.0`.
    /// - If `x` is 10, then `x.significand` is `1.01` in binary, so
    ///   `x.significandWidth` is 2.
    /// - If `x` is Float.pi, `x.significand` is `1.10010010000111111011011`,
    ///   and `x.significandWidth` is 23.
    public var significandWidth: Int { get }
}

extension BinaryFloatingPoint {

    public static var radix: Int { get }

    public convenience init(signOf: Self, magnitudeOf: Self)

    public func isTotallyOrdered(below other: Self) -> Bool
}

/// A type that supports standard bitwise arithmetic operators.
///
/// Types that conform to the `BitwiseOperations` protocol implement operators
/// for bitwise arithmetic. The integer types in the standard library all
/// conform to `BitwiseOperations` by default. When you use bitwise operators
/// with an integer, you perform operations on the raw data bits that store
/// the integer's value.
///
/// In the following examples, the binary representation of any values are
/// shown in a comment to the right, like this:
///
///     let x: UInt8 = 5        // 0b00000101
///
/// Here are the required operators for the `BitwiseOperations` protocol:
///
/// - The bitwise OR operator (`|`) returns a value that has each bit set to
///   `1` where *one or both* of its arguments had that bit set to `1`. This
///   is equivalent to the union of two sets. For example:
///
///         let x: UInt8 = 5        // 0b00000101
///         let y: UInt8 = 14       // 0b00001110
///         let z = x | y           // 0b00001111
///
///   Performing a bitwise OR operation with a value and `allZeros` always
/// returns the same value.
///
///         print(x | .allZeros)    // 0b00000101
///         // Prints "5"
///
/// - The bitwise AND operator (`&`) returns a value that has each bit set to
///   `1` where *both* of its arguments had that bit set to `1`. This is
///   equivalent to the intersection of two sets. For example:
///
///         let x: UInt8 = 5        // 0b00000101
///         let y: UInt8 = 14       // 0b00001110
///         let z = x & y           // 0b00000100
///
///   Performing a bitwise AND operation with a value and `allZeros` always
/// returns `allZeros`.
///
///         print(x & .allZeros)    // 0b00000000
///         // Prints "0"
///
/// - The bitwise XOR operator (`^`), or exclusive OR operator, returns a value
///   that has each bit set to `1` where *one or the other but not both* of
///   its operators has that bit set to `1`. This is equivalent to the
///   symmetric difference of two sets. For example:
///
///         let x: UInt8 = 5        // 0b00000101
///         let y: UInt8 = 14       // 0b00001110
///         let z = x ^ y           // 0b00001011
///
///   Performing a bitwise XOR operation with a value and `allZeros` always
/// returns the same value.
///
///         print(x ^ .allZeros)    // 0b00000101
///         // Prints "5"
///
/// - The bitwise NOT operator (`~`) is a prefix operator that returns a value
///   where all the bits of its argument are flipped: Bits that are `1` in the
///   argument are `0` in the result, and bits that are `0` in the argument
///   are `1` in the result. This is equivalent to the inverse of a set. For
///   example:
///
///         let x: UInt8 = 5        // 0b00000101
///         let notX = ~x           // 0b11111010
///
///   Performing a bitwise NOT operation on `allZeros` returns a value with
///   every bit set to `1`.
///
///         let allOnes = ~UInt8.allZeros   // 0b11111111
///
/// The `OptionSet` protocol uses a raw value that conforms to
/// `BitwiseOperations` to provide mathematical set operations like
/// `union(_:)`, `intersection(_:)` and `contains(_:)` with O(1) performance.
///
/// Conforming to the BitwiseOperations Protocol
/// ============================================
///
/// To make your custom type conform to `BitwiseOperations`, add a static
/// `allZeros` property and declare the four required operator functions. Any
/// type that conforms to `BitwiseOperations`, where `x` is an instance of the
/// conforming type, must satisfy the following conditions:
///
/// - `x | Self.allZeros == x`
/// - `x ^ Self.allZeros == x`
/// - `x & Self.allZeros == .allZeros`
/// - `x & ~Self.allZeros == x`
/// - `~x == x ^ ~Self.allZeros`
///
/// - SeeAlso: `OptionSet`
public protocol BitwiseOperations {

    /// Returns the intersection of bits set in the two arguments.
    ///
    /// The bitwise AND operator (`&`) returns a value that has each bit set to
    /// `1` where *both* of its arguments had that bit set to `1`. This is
    /// equivalent to the intersection of two sets. For example:
    ///
    ///     let x: UInt8 = 5        // 0b00000101
    ///     let y: UInt8 = 14       // 0b00001110
    ///     let z = x & y           // 0b00000100
    ///
    /// Performing a bitwise AND operation with a value and `allZeros` always
    /// returns `allZeros`.
    ///
    ///     print(x & .allZeros)    // 0b00000000
    ///     // Prints "0"
    ///
    /// - Complexity: O(1).
    public func &(lhs: Self, rhs: Self) -> Self

    /// Returns the union of bits set in the two arguments.
    ///
    /// The bitwise OR operator (`|`) returns a value that has each bit set to
    /// `1` where *one or both* of its arguments had that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5        // 0b00000101
    ///     let y: UInt8 = 14       // 0b00001110
    ///     let z = x | y           // 0b00001111
    ///
    /// Performing a bitwise OR operation with a value and `allZeros` always
    /// returns the same value.
    ///
    ///     print(x | .allZeros)    // 0b00000101
    ///     // Prints "5"
    ///
    /// - Complexity: O(1).
    public func |(lhs: Self, rhs: Self) -> Self

    /// Returns the bits that are set in exactly one of the two arguments.
    ///
    /// The bitwise XOR operator (`^`), or exclusive OR operator, returns a value
    /// that has each bit set to `1` where *one or the other but not both* of
    /// its operators has that bit set to `1`. This is equivalent to the
    /// symmetric difference of two sets. For example:
    ///
    ///     let x: UInt8 = 5        // 0b00000101
    ///     let y: UInt8 = 14       // 0b00001110
    ///     let z = x ^ y           // 0b00001011
    ///
    /// Performing a bitwise XOR with a value and `allZeros` always returns the
    /// same value:
    ///
    ///     print(x ^ .allZeros)    // 0b00000101
    ///     // Prints "5"
    ///
    /// - Complexity: O(1).
    public func ^(lhs: Self, rhs: Self) -> Self

    /// Returns the inverse of the bits set in the argument.
    ///
    /// The bitwise NOT operator (`~`) is a prefix operator that returns a value
    /// in which all the bits of its argument are flipped: Bits that are `1` in the
    /// argument are `0` in the result, and bits that are `0` in the argument
    /// are `1` in the result. This is equivalent to the inverse of a set. For
    /// example:
    ///
    ///     let x: UInt8 = 5        // 0b00000101
    ///     let notX = ~x           // 0b11111010
    ///
    /// Performing a bitwise NOT operation on `allZeros` returns a value with
    /// every bit set to `1`.
    ///
    ///     let allOnes = ~UInt8.allZeros   // 0b11111111
    ///
    /// - Complexity: O(1).
    prefix public func ~(x: Self) -> Self

    /// The empty bitset.
    ///
    /// The `allZeros` static property is the [identity element][] for bitwise OR
    /// and XOR operations and the [fixed point][] for bitwise AND operations.
    /// For example:
    ///
    ///     let x: UInt8 = 5        // 0b00000101
    ///
    ///     // Identity
    ///     x | .allZeros           // 0b00000101
    ///     x ^ .allZeros           // 0b00000101
    ///
    ///     // Fixed point
    ///     x & .allZeros           // 0b00000000
    ///
    /// [identity element]:http://en.wikipedia.org/wiki/Identity_element
    /// [fixed point]:http://en.wikipedia.org/wiki/Fixed_point_(mathematics)
    public static var allZeros: Self { get }
}

/// A value type whose instances are either `true` or `false`.
///
/// `Bool` is the default type for Boolean values in Swift. Create instances of
/// `Bool` by using one of the Boolean literals `true` and `false` or by
/// assigning the result of a Boolean method or operation to a variable or
/// constant.
///
///     var godotHasArrived = false
///
///     let numbers = 1...5
///     let containsTen = numbers.contains(10)
///     print(containsTen)
///     // Prints "false"
///
///     let (a, b) == (100, 101)
///     let aFirst = a < b
///     print(aFirst)
///     // Prints "true"
///
/// Swift uses only simple Boolean values in conditional contexts to help avoid
/// accidental programming errors and to help maintain the clarity of each
/// control statement. Unlike other programming languages, in Swift integers
/// and strings cannot be used where a Boolean value is expected.
///
/// For example, the following code sample does not compile, because it
/// attempts to use the integer `i` in a logical context:
///
///     var i = 5
///     while i {
///         print(i)
///         i -= 1
///     }
///
/// The correct approach in Swift is to compare the `i` value with zero in the
/// `while` statement.
///
///     while i != 0 {
///         print(i)
///         i -= 1
///     }
public struct Bool {

    /// Creates an instance initialized to `false`.
    ///
    /// Don't call this initializer directly. Instead, use the Boolean literal
    /// `false` to create a new `Bool` instance.
    public init()
}

extension Bool : BooleanLiteralConvertible {

    public init(_builtinBooleanLiteral value: Builtin.Int1)

    /// Creates an instance initialized to the specified Boolean literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use a Boolean literal. Instead, create a new `Bool` instance by
    /// using one of the Boolean literals `true` and `false`.
    ///
    ///     var printedMessage = false
    ///
    ///     if !printedMessage {
    ///         print("You look nice today!")
    ///         printedMessage = true
    ///     }
    ///     // Prints "You look nice today!"
    ///
    /// In this example, both assignments to the `printedMessage` variable call
    /// this Boolean literal initializer behind the scenes.
    ///
    /// - Parameter value: The value of the new instance.
    public init(booleanLiteral value: Bool)
}

extension Bool : Boolean {

    /// This value expressed as a `Bool` instance; its value is identical to that
    /// of the current instance.
    public var boolValue: Bool { get }

    /// Creates an instance representing the given logical value.
    ///
    /// - Parameter value: The logical value for the new instance.
    public init<T : Boolean>(_ value: T)
}

extension Bool : CustomStringConvertible {

    /// A textual representation of the Boolean value.
    public var description: String { get }
}

extension Bool : Equatable, Hashable {

    /// The hash value for the Boolean value.
    ///
    /// Two values that are equal always have equal hash values.
    ///
    /// - Note: The hash value is not guaranteed to be stable across different
    ///   invocations of the same program. Do not persist the hash value across
    ///   program runs.
    /// - SeeAlso: `Hashable`
    public var hashValue: Int { get }
}

extension Bool : CustomReflectable {

    /// A mirror that reflects the `Bool` instance.
    public var customMirror: Mirror { get }
}

extension Bool : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

/// A type that represents a Boolean value.
///
/// Types that conform to the `Boolean` protocol can be used as the condition
/// in control statements, such as `if` and `while`, and in other contexts
/// that require a logical value, such as the `where` clause of a `case`
/// statement.
///
/// Swift uses only simple Boolean values in conditional contexts to help avoid
/// accidental programming errors and to help maintain the clarity of each
/// control statement. Unlike other programming languages, integers or strings
/// cannot be used where a Boolean value is expected.
///
/// For example, the following code sample will not compile, because it
/// attempts to use the integer `i` in a logical context:
///
///     var i = 5
///     while i {
///         print(i)
///         i -= 1
///     }
///
/// The correct approach in Swift is to compare the `i` value with zero in the
/// `while` statement.
///
///     while i != 0 {
///         print(i)
///         i -= 1
///     }
///
/// Conforming to the Boolean Protocol
/// ==================================
///
/// Only three types provided by Swift---`Bool`, `DarwinBoolean`, and
/// `ObjCBool`---conform to the `Boolean` protocol. Expanding this set to
/// include types that represent more than simple Boolean values is
/// discouraged.
///
/// To add `Boolean` conformance to your custom type, implement a `boolValue`
/// property that represents your type as an instance of `Bool`, the default
/// concrete type for the `Boolean` protocol.
public protocol Boolean {

    /// This value expressed as a `Bool` instance.
    public var boolValue: Bool { get }
}

/// A type that can be initialized with the Boolean literals `true` and
/// `false`.
///
/// Only three types provided by Swift---`Bool`, `DarwinBoolean`, and
/// `ObjCBool`---are treated as Boolean values. Expanding this set to include
/// types that represent more than simple Boolean values is discouraged.
///
/// To add `BooleanLiteralConvertible` conformance to your custom type,
/// implement the `init(booleanLiteral:)` initializer that creates an instance
/// of your type with the given Boolean value.
public protocol BooleanLiteralConvertible {

    /// A type that can represent a Boolean literal, such as `Bool`.
    associatedtype BooleanLiteralType

    /// Creates an instance initialized to the given Boolean value.
    ///
    /// Do not call this initializer directly. Instead, initialize a variable or
    /// constant using one of the Boolean literals `true` and `false`. For
    /// example:
    ///
    ///     let twasBrillig = true
    ///
    /// In this example, the assignments to the `twasBrillig` constant calls this
    /// Boolean literal initializer behind the scenes.
    ///
    /// - Parameter value: The value of the new instance.
    public init(booleanLiteral value: Self.BooleanLiteralType)
}

/// The default type for an otherwise-unconstrained Boolean literal.
///
/// When you create a constant or variable using one of the Boolean literals
/// `true` or `false`, the resulting type is determined by the
/// `BooleanLiteralType` alias. For example:
///
///     let isBool = true
///     print("isBool is a '\(isBool.dynamicType)'")
///     // Prints "isBool is a 'Bool'"
///
/// The type aliased by `BooleanLiteralType` must conform to the
/// `BooleanLiteralConvertible` protocol.
public typealias BooleanLiteralType = Bool

/// The C '_Bool' and C++ 'bool' type.
public typealias CBool = Bool

/// The C 'char' type.
///
/// This will be the same as either `CSignedChar` (in the common
/// case) or `CUnsignedChar`, depending on the platform.
public typealias CChar = Int8

/// The C++11 'char16_t' type, which has UTF-16 encoding.
public typealias CChar16 = UInt16

/// The C++11 'char32_t' type, which has UTF-32 encoding.
public typealias CChar32 = UnicodeScalar

/// The C 'double' type.
public typealias CDouble = Double

/// The C 'float' type.
public typealias CFloat = Float

/// The C 'int' type.
public typealias CInt = Int32

/// The C 'long' type.
public typealias CLong = Int

/// The C 'long long' type.
public typealias CLongLong = Int64

/// The C 'short' type.
public typealias CShort = Int16

/// The C 'signed char' type.
public typealias CSignedChar = Int8

/// The C 'unsigned char' type.
public typealias CUnsignedChar = UInt8

/// The C 'unsigned int' type.
public typealias CUnsignedInt = UInt32

/// The C 'unsigned long' type.
public typealias CUnsignedLong = UInt

/// The C 'unsigned long long' type.
public typealias CUnsignedLongLong = UInt64

/// The C 'unsigned short' type.
public typealias CUnsignedShort = UInt16

/// The corresponding Swift type to `va_list` in imported C APIs.
public struct CVaListPointer {

    public init(_fromUnsafeMutablePointer from: UnsafeMutablePointer<Swift.Void>)
}

extension CVaListPointer : CustomDebugStringConvertible {

    /// A textual representation of `self`, suitable for debugging.
    public var debugDescription: String { get }
}

/// Instances of conforming types can be encoded, and appropriately
/// passed, as elements of a C `va_list`.
///
/// This protocol is useful in presenting C "varargs" APIs natively in
/// Swift.  It only works for APIs that have a `va_list` variant, so
/// for example, it isn't much use if all you have is:
///
/// ~~~ c
/// int c_api(int n, ...)
/// ~~~
///
/// Given a version like this, though,
///
/// ~~~ c
/// int c_api(int, va_list arguments)
/// ~~~
///
/// you can write:
///
///     func swiftAPI(_ x: Int, arguments: CVarArg...) -> Int {
///       return withVaList(arguments) { c_api(x, $0) }
///     }
public protocol CVarArg {
}

/// The C++ 'wchar_t' type.
public typealias CWideChar = UnicodeScalar

/// A single extended grapheme cluster, which approximates a user-perceived
/// character.
///
/// The `Character` type represents a character made up of one or more Unicode
/// scalar values, grouped by a Unicode boundary algorithm. Generally, a
/// `Character` instance matches what the reader of a string will perceive as
/// a single character. The number of visible characters is generally the most
/// natural way to count the length of a string.
///
///     let greeting = "Hello! "
///     print("Character count: \(greeting.characters.count)")
///     // Prints "Character count: 8"
///
/// Because each character in a string can be made up of one or more Unicode
/// code points, the number of characters in a string may not match the length
/// of the Unicode code point representation or the length of the string in a
/// particular binary representation.
///
///     print("Unicode code point count: \(greeting.unicodeScalars.count)")
///     // Prints "Unicode code point count: 15"
///
///     print("UTF-8 representation count: \(greeting.utf8.count)")
///     // Prints "UTF-8 representation count: 18"
///
/// Every `Character` instance is composed of one or more Unicode code points
/// that are grouped together as an *extended grapheme cluster*. The way these
/// code points are grouped is defined by a canonical, localized, or otherwise
/// tailored Unicode segmentation algorithm.
///
/// For example, a country's Unicode flag character is made up of two regional
/// indicator code points that correspond to that country's ISO 3166-1 alpha-2
/// code. The alpha-2 code for The United States is "US", so its flag
/// character is made up of the Unicode code points `"\u{1F1FA}"` (REGIONAL
/// INDICATOR SYMBOL LETTER U) and `"\u{1F1F8}"` (REGIONAL INDICATOR SYMBOL
/// LETTER S). When placed next to each other in a Swift string literal, these
/// two code points are combined into a single grapheme cluster, represented
/// by a `Character` instance in Swift.
///
///     let usFlag: Character = "\u{1F1FA}\u{1F1F8}"
///     print(usFlag)
///     // Prints ""
///
/// For more information about the Unicode terms used in this discussion, see
/// the [Unicode.org glossary][glossary]. In particular, this discussion
/// mentions [extended grapheme clusters][clusters] and [Unicode scalar
/// values][scalars].
///
/// [glossary]: http://www.unicode.org/glossary/
/// [clusters]: http://www.unicode.org/glossary/#extended_grapheme_cluster
/// [scalars]: http://www.unicode.org/glossary/#unicode_scalar_value
public struct Character : ExtendedGraphemeClusterLiteralConvertible, Equatable, Hashable, Comparable {

    /// Creates a character containing the given Unicode scalar value.
    ///
    /// - Parameter scalar: The Unicode scalar value to convert into a character.
    public init(_ scalar: UnicodeScalar)

    public init(_builtinUnicodeScalarLiteral value: Builtin.Int32)

    /// Creates a character with the specified value.
    ///
    /// Don't call this initializer directly. It is used by the compiler when you
    /// use a string literal to initialize a `Character` instance. For example:
    ///
    ///     let snowflake: Character = ""
    ///     print(snowflake)
    ///     // Prints ""
    ///
    /// The assignment to the `snowflake` constant calls this initializer behind
    /// the scenes.
    public init(unicodeScalarLiteral value: Character)

    public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1)

    /// Creates a character with the specified value.
    ///
    /// Don't call this initializer directly. It is used by the compiler when you
    /// use a string literal to initialize a `Character` instance. For example:
    ///
    ///     let oBreve: Character = "o\u{306}"
    ///     print(oBreve)
    ///     // Prints "o"
    ///
    /// The assignment to the `oBreve` constant calls this initializer behind the
    /// scenes.
    public init(extendedGraphemeClusterLiteral value: Character)

    /// Creates a character from a single-character string.
    ///
    /// The following example creates a new character from the uppercase version
    /// of a string that only holds one character.
    ///
    ///     let a = "a"
    ///     let capitalA = Character(a.uppercased())
    ///
    /// - Parameter s: The single-character string to convert to a `Character`
    ///   instance. `s` must contain exactly one extended grapheme cluster.
    public init(_ s: String)

    /// The character's hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }
}

extension Character : CustomDebugStringConvertible {

    /// A textual representation of the character, suitable for debugging.
    public var debugDescription: String { get }
}

extension Character : CustomReflectable {

    /// A mirror that reflects the `Character` instance.
    public var customMirror: Mirror { get }
}

extension Character : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Character : Streamable {

    /// Writes the character into the given output stream.
    ///
    /// - Parameter target: An output stream.
    public func write<Target : OutputStream>(to target: inout Target)
}

/// An interval over a comparable type, from a lower bound up to, and
/// including, an upper bound.
///
/// You create instances of `ClosedRange` by using the closed range operator
/// (`...`).
///
///     let lowercase = "a"..."z"
///
/// You can use a `ClosedRange` instance to quickly check if a value is
/// contained in a particular range of values. For example:
///
///     print(lowercase.contains("c"))      // Prints "true"
///     print(lowercase.contains("5"))      // Prints "false"
///     print(lowercase.contains("z"))      // Prints "true"
///
/// Unlike `Range`, instances of `ClosedRange` cannot represent an empty
/// interval.
///
///     let lowercaseA = "a"..."a"
///     print(lowercaseA.isEmpty)
///     // Prints "false"
///
/// - SeeAlso: `CountableRange`, `Range`, `CountableClosedRange`
public struct ClosedRange<Bound : Comparable> {

    /// Creates an instance with the given bounds.
    ///
    /// Because this initializer does not perform any checks, it should be used
    /// as an optimization only when you are absolutely certain that `lower` is
    /// less than or equal to `upper`. Using the closed range operator (`...`)
    /// to form `ClosedRange` instances is preferred.
    ///
    /// - Parameter bounds: A tuple of the lower and upper bounds of the range.
    public init(uncheckedBounds bounds: (lower: Bound, upper: Bound))

    /// The range's lower bound.
    public let lowerBound: Bound

    /// The range's upper bound.
    public let upperBound: Bound

    /// Returns a Boolean value indicating whether the given element is contained
    /// within the range.
    ///
    /// A `ClosedRange` instance contains both its lower and upper bound.
    /// `element` is contained in the range if it is between the two bounds or
    /// equal to either bound.
    ///
    /// - Parameter element: The element to check for containment.
    /// - Returns: `true` if `element` is contained in the range; otherwise,
    ///   `false`.
    public func contains(_ element: Bound) -> Bool

    /// A Boolean value indicating whether the range contains no elements.
    ///
    /// Because a closed range cannot represent an empty range, this property is
    /// always `false`.
    public var isEmpty: Bool { get }
}

extension ClosedRange {
}

extension ClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// An equivalent range must be representable as an instance of `ClosedRange`.
    /// For example, passing an empty range as `other` triggers a runtime error,
    /// because an empty range cannot be represented by a `ClosedRange` instance.
    ///
    /// - Parameter other: A range to convert to a `ClosedRange` instance.
    public init(_ other: Range<Bound>)
}

extension ClosedRange {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: ClosedRange = 0...20
    ///     print(x.overlaps(10..<1000 as Range))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: Range<Bound>) -> Bool
}

extension ClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// An equivalent range must be representable as an instance of `ClosedRange`.
    /// For example, passing an empty range as `other` triggers a runtime error,
    /// because an empty range cannot be represented by a `ClosedRange` instance.
    ///
    /// - Parameter other: A range to convert to a `ClosedRange` instance.
    public init(_ other: CountableRange<Bound>)
}

extension ClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: ClosedRange = 0...20
    ///     print(x.overlaps(10..<1000 as CountableRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: CountableRange<Bound>) -> Bool
}

extension ClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// - Parameter other: A range to convert to a `ClosedRange` instance.
    public init(_ other: ClosedRange<Bound>)
}

extension ClosedRange {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: ClosedRange = 0...20
    ///     print(x.overlaps(10...1000 as ClosedRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: ClosedRange<Bound>) -> Bool
}

extension ClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// - Parameter other: A range to convert to a `ClosedRange` instance.
    public init(_ other: CountableClosedRange<Bound>)
}

extension ClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: ClosedRange = 0...20
    ///     print(x.overlaps(10...1000 as CountableClosedRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: CountableClosedRange<Bound>) -> Bool
}

extension ClosedRange {

    /// Returns a copy of this range clamped to the given limiting range.
    ///
    /// The bounds of the result are always limited to the bounds of `limits`.
    /// For example:
    ///
    ///     let x: ClosedRange = 0...20
    ///     print(x.clamped(to: 10...1000))
    ///     // Prints "10...20"
    ///
    /// If the two ranges do not overlap, the result is a single-element range at
    /// the upper or lower bound of `limits`.
    ///
    ///     let y: ClosedRange = 0...5
    ///     print(y.clamped(to: 10...1000))
    ///     // Prints "10...10"
    ///
    /// - Parameter limits: The range to clamp the bounds of this range.
    /// - Returns: A new range clamped to the bounds of `limits`.
    public func clamped(to limits: ClosedRange<Bound>) -> ClosedRange<Bound>
}

extension ClosedRange : CustomStringConvertible {

    /// A textual representation of the range.
    public var description: String { get }
}

extension ClosedRange : CustomDebugStringConvertible {

    /// A textual representation of the range, suitable for debugging.
    public var debugDescription: String { get }
}

extension ClosedRange : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension ClosedRange : Equatable {
}

/// Ranges whose `Bound` is `Strideable` with `Integer` `Stride` have all
/// the capabilities of `RandomAccessCollection`s, just like
/// `CountableRange` and `CountableClosedRange`.
///
/// Unfortunately, we can't forward the full collection API, so we are
/// forwarding a few select APIs.
extension ClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// The number of values contained in the range.
    public var count: Bound.Stride { get }
}

/// A position in a `CountableClosedRange` instance.
public struct ClosedRangeIndex<Bound : Comparable where Bound : _Strideable, Bound.Stride : Integer> : Comparable {
}

/// An iterator over the elements of a `CountableClosedRange` instance.
public struct ClosedRangeIterator<Bound : protocol<Comparable, _Strideable> where Bound.Stride : SignedInteger> : IteratorProtocol, Sequence {

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> ClosedRangeIterator<Bound>

    /// Advances and returns the next element of the underlying sequence, or
    /// `nil` if no next element exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. After the sequence has run out of elements, the
    /// `next()` method returns `nil`.
    ///
    /// You must not call this method if it has previously returned `nil` or if
    /// any other copy of this iterator has been advanced with a call to its
    /// `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> Bound?
}

/// A sequence whose elements can be traversed multiple times,
/// nondestructively, and accessed by indexed subscript.
///
/// Collections are used extensively throughout the standard library. When
/// you use arrays, dictionaries, views of a string's contents and other
/// types, you benefit from the operations that the `Collection` protocol
/// declares and implements.
///
/// In addition to the methods that collections inherit from the `Sequence`
/// protocol, you gain access to methods that depend on accessing an element
/// at a specific position when using a collection.
///
/// For example, if you want to print only the first word in a string,
/// search for the index of the first space, and then create a subsequence up
/// to that position.
///
///     let text = "Buffalo buffalo buffalo buffalo."
///     if let firstSpace = text.characters.index(of: " ") {
///         print(String(text.characters.prefix(upTo: firstSpace)))
///     }
///     // Prints "Buffalo"
///
/// The `firstSpace` constant is an index into the `text.characters`
/// collection. `firstSpace` is the position of the first space in the
/// collection. You can store indices in variables, and pass them to
/// collection algorithms or use them later to access the corresponding
/// element. In the example above, `firstSpace` is used to extract the prefix
/// that contains elements up to that index.
///
/// You can pass only valid indices to collection operations. You can find a
/// complete set of a collection's valid indices by starting with the
/// collection's `startIndex` property and finding every successor up to, and
/// including, the `endIndex` property. All other values of the `Index` type,
/// such as the `startIndex` property of a different collection, are invalid
/// indices for this collection.
///
/// Saved indices may become invalid as a result of mutating operations; for
/// more information about index invalidation in mutable collections, see the
/// reference for the `MutableCollection` and `RangeReplaceableCollection`
/// protocols, as well as for the specific type you're using.
///
/// Accessing Individual Elements
/// =============================
///
/// You can access an element of a collection through its subscript with any
/// valid index except the collection's `endIndex` property, a "past the end"
/// index that does not correspond with any element of the collection.
///
/// Here's an example of accessing the first character in a string through its
/// subscript:
///
///     let firstChar = text.characters[text.characters.startIndex]
///     print(firstChar)
///     // Prints "B"
///
/// The `Collection` protocol declares and provides default implementations
/// for many operations that depend on elements being accessible by their
/// subscript. For example, you can also access the first character of
/// `text` using the `first` property, which has the value of the first
/// element of the collection, or `nil` if the collection is empty.
///
///     print(text.characters.first)
///     // Prints "Optional("B")"
///
/// Traversing a Collection 
/// =======================
///
/// While a sequence may be consumed as it is traversed, a collection is
/// guaranteed to be multi-pass: Any element may be repeatedly accessed by
/// saving its index. Moreover, a collection's indices form a finite range
/// of the positions of the collection's elements. This guarantees the
/// safety of operations that depend on a sequence being finite, such as
/// checking to see whether a collection contains an element.
///
/// Iterating over the elements of a collection by their positions yields the
/// same elements in the same order as iterating over that collection using
/// its iterator. This example demonstrates that the `characters` view of a
/// string returns the same characters in the same order whether the view's
/// indices or the view itself is being iterated.
///
///     let word = "Swift"
///     for character in word.characters {
///         print(character)
///     }
///     // Prints "S"
///     // Prints "w"
///     // Prints "i"
///     // Prints "f"
///     // Prints "t"
/// 
///     for i in word.characters.indices {
///         print(word.characters[i])
///     }
///     // Prints "S"
///     // Prints "w"
///     // Prints "i"
///     // Prints "f"
///     // Prints "t"
///
/// Conforming to the Collection Protocol 
/// =====================================
///
/// If you create a custom sequence that can provide repeated access to its
/// elements, conformance to the `Collection` protocol gives your custom type
/// a more useful and more efficient interface for sequence and collection
/// operations. To add `Collection` conformance to your type, declare
/// `startIndex` and `endIndex` properties, a subscript that provides at least
/// read-only access to your type's elements, and the `index(after:)` method
/// for advancing your collection's indices.
///
/// Expected Performance
/// ====================
///
/// Types that conform to `Collection` are expected to provide the
/// `startIndex` and `endIndex` properties and subscript access to elements
/// as O(1) operations. Types that are not able to guarantee that expected
/// performance must document the departure, because many collection operations
/// depend on O(1) subscripting performance for their own performance
/// guarantees.
///
/// The performance of some collection operations depends on the type of index
/// that the collection provides. For example, a random-access collection,
/// which can measure the distance between two indices in O(1) time, will be
/// able to calculate its `count` property in O(1) time. Conversely, because a
/// forward or bidirectional collection must traverse the entire collection to
/// count the number of contained elements, accessing its `count` property is
/// an O(N) operation.
public protocol Collection : Indexable, Sequence {

    /// A type that can represent the number of steps between a pair of
    /// indices.
    associatedtype IndexDistance : SignedInteger = Int

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying a `IndexingIterator` as its associated `Iterator`
    /// type.
    associatedtype Iterator : IteratorProtocol = IndexingIterator<Self>

    /// Returns an iterator over the elements of the collection.
    public func makeIterator() -> Self.Iterator

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    associatedtype SubSequence : IndexableBase, Sequence = Slice<Self>

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(position: Self.Index) -> Self.Iterator.Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Self.Index>) -> Self.SubSequence { get }

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    associatedtype Indices : IndexableBase, Sequence = DefaultIndices<Self>

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Self.Indices { get }

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the
    /// position `end`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.index(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    /// - SeeAlso: `prefix(through:)`
    public func prefix(upTo end: Self.Index) -> Self.SubSequence

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.index(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Precondition: `start >= self.startIndex && start <= self.endIndex`
    /// - Complexity: O(1)
    public func suffix(from start: Self.Index) -> Self.SubSequence

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position `end`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.index(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter end: The index of the last element to include in the
    ///   resulting subsequence. `end` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the `end` position.
    ///
    /// - Complexity: O(1)
    /// - SeeAlso: `prefix(upTo:)`
    public func prefix(through position: Self.Index) -> Self.SubSequence

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.characters.isEmpty {
    ///         print("I've been through the desert on a horse with no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    public var isEmpty: Bool { get }

    /// The number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Self.IndexDistance { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Self.Iterator.Element? { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance) -> Self.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance, limitedBy limit: Self.Index) -> Self.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Self.Index, to end: Self.Index) -> Self.IndexDistance
}

/// Supply the default `makeIterator()` method for `Collection` models
/// that accept the default associated `Iterator`,
/// `IndexingIterator<Self>`.
extension Collection where Iterator == IndexingIterator<Self> {

    /// Returns an iterator over the elements of the collection.
    public func makeIterator() -> IndexingIterator<Self>
}

/// Supply the default "slicing" `subscript` for `Collection` models
/// that accept the default associated `SubSequence`, `Slice<Self>`.
extension Collection where SubSequence == Slice<Self> {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Self.Index>) -> Slice<Self> { get }
}

extension Collection where SubSequence == Self {

    /// Removes and returns the first element of the collection.
    ///
    /// - Returns: The first element of the collection if the collection is
    ///   not empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    public mutating func popFirst() -> Self.Iterator.Element?
}

/// Default implementations of core requirements
extension Collection {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.characters.isEmpty {
    ///         print("I've been through the desert on a horse with no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Self.Iterator.Element? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Self.IndexDistance { get }
}

extension Collection {

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercaseString }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.characters.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: @noescape (Self.Iterator.Element) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the collection. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the collection.
    public func dropFirst(_ n: Int) -> Self.SubSequence

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   collection. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off the specified number of elements
    ///   at the end.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func dropLast(_ n: Int) -> Self.SubSequence

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> Self.SubSequence

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func suffix(_ maxLength: Int) -> Self.SubSequence

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the
    /// position `end`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.index(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Precondition: `end >= self.startIndex && end <= self.endIndex`
    /// - Complexity: O(1)
    /// - SeeAlso: `prefix(through:)`
    public func prefix(upTo end: Self.Index) -> Self.SubSequence

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.index(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// - Parameter start: The index at which to start the resulting
    ///   subsequence. `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Precondition: `start >= self.startIndex && start <= self.endIndex`
    /// - Complexity: O(1)
    public func suffix(from start: Self.Index) -> Self.SubSequence

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position
    /// `end`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.index(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter end: The index of the last element to include in the
    ///   resulting subsequence. `end` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the `end` position.
    ///
    /// - Complexity: O(1)
    /// - SeeAlso: `prefix(upTo:)`
    public func prefix(through position: Self.Index) -> Self.SubSequence

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate. Elements that are
    /// used to split the sequence are not returned as part of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.characters.split(isSeparator: { $0 == " " })
    ///                          .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don't", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.characters.split(maxSplits: 1, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.characters.split(omittingEmptySubsequences: false, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the sequence should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, isSeparator: @noescape (Self.Iterator.Element) throws -> Bool) rethrows -> [Self.SubSequence]
}

extension Collection where Iterator.Element : Equatable {

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate. Elements that are
    /// used to split the sequence are not returned as part of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.characters.split(isSeparator: { $0 == " " })
    ///                          .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don't", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.characters.split(maxSplits: 1, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.characters.split(omittingEmptySubsequences: false, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the sequence should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(separator: Self.Iterator.Element, maxSplits: Int = default, omittingEmptySubsequences: Bool = default) -> [Self.SubSequence]
}

extension Collection where SubSequence == Self {

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// - Returns: The first element of the collection.
    ///
    /// - Complexity: O(1)
    /// - SeeAlso: `popFirst()`
    public mutating func removeFirst() -> Self.Iterator.Element

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    /// - Parameter n: The number of elements to remove. `n` must be greater than
    ///   or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*).
    public mutating func removeFirst(_ n: Int)
}

extension Collection where Iterator.Element : Equatable {

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `index(of:)` to find the position of a particular element in
    /// a collection, you can use it to access the element by subscripting. This
    /// example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.index(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    ///
    /// - SeeAlso: `index(where:)`
    public func index(of element: Self.Iterator.Element) -> Self.Index?
}

extension Collection {

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.index(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    ///
    /// - SeeAlso: `index(of:)`
    public func index(where predicate: @noescape (Self.Iterator.Element) throws -> Bool) rethrows -> Self.Index?
}

extension Collection where Iterator.Element : Collection {

    /// Returns the elements of this collection of collections, concatenated.
    ///
    /// In this example, an array of three ranges is flattened so that the
    /// elements of each range can be iterated in turn.
    ///
    ///     let ranges = [0..<3, 8..<10, 15..<17]
    ///
    ///     // A for-in loop over 'ranges' accesses each range:
    ///     for range in ranges {
    ///       print(range)
    ///     }
    ///     // Prints "0..<3"
    ///     // Prints "8..<10"
    ///     // Prints "15..<17"
    ///
    ///     // Use 'flatten()' to access each element of each range:
    ///     for index in ranges.flatten() {
    ///         print(index, terminator: " ")
    ///     }
    ///     // Prints: "0 1 2 8 9 15 16"
    ///
    /// - Returns: A flattened view of the elements of this
    ///   collection of collections.
    ///
    /// - SeeAlso: `flatMap(_:)`, `joined(separator:)`
    public func flatten() -> FlattenCollection<Self>
}

extension Collection where Indices == DefaultIndices<Self> {

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: DefaultIndices<Self> { get }
}

/// Augment `self` with lazy methods such as `map`, `filter`, etc.
extension Collection {

    /// A view onto this collection that provides lazy implementations of
    /// normally eager operations, such as `map` and `filter`.
    ///
    /// Use the `lazy` property when chaining operations to prevent
    /// intermediate operations from allocating storage, or when you only
    /// need a part of the final collection to avoid unnecessary computation.
    ///
    /// - See Also: `LazySequenceProtocol`, `LazyCollectionProtocol`.
    public var lazy: LazyCollection<Self> { get }
}

extension Collection where Self : LazyCollectionProtocol {

    /// Identical to `self`.
    public var lazy: Self { get }
}

/// A collection containing a single element of type `Element`.
public struct CollectionOfOne<Element> : MutableCollection, RandomAccessCollection {

    /// Construct an instance containing just `element`.
    public init(_ element: Element)

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Int

    /// The position of the first element.
    public var startIndex: Int { get }

    /// The "past the end" position---that is, the position one greater than the
    /// last valid subscript argument.
    ///
    /// In a `CollectionOfOne` instance, `endIndex` is always identical to
    /// `index(after: startIndex)`.
    public var endIndex: Int { get }

    /// Always returns `endIndex`.
    public func index(after i: Int) -> Int

    /// Always returns `startIndex`.
    public func index(before i: Int) -> Int

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = CountableRange<Int>

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> IteratorOverOne<Element>

    /// Access the element at `position`.
    ///
    /// - Precondition: `position == 0`.
    public subscript(position: Int) -> Element

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Int>) -> MutableRandomAccessSlice<CollectionOfOne<Element>>

    /// The number of elements (always one).
    public var count: Int { get }
}

extension CollectionOfOne : CustomDebugStringConvertible {

    /// A textual representation of `self`, suitable for debugging.
    public var debugDescription: String { get }
}

extension CollectionOfOne : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// A type that can be compared using the relational operators `<`, `<=`, `>=`,
/// and `>`.
///
/// The `Comparable` protocol is used for types that have an inherent order,
/// such as numbers and strings. Many types in the standard library already
/// conform to the `Comparable` protocol. Add `Comparable` conformance to your
/// own custom types when you want to be able to compare instances using
/// relational operators or use standard library methods that are designed for
/// `Comparable` types.
///
/// The most familiar use of relational operators is to compare numbers, as in
/// the following example:
///
///     let currentTemp = 73
///
///     if currentTemp >= 90 {
///         print("It's a scorcher!")
///     } else if currentTemp < 65 {
///         print("Might need a sweater today.")
///     } else {
///         print("Seems like picnic weather!")
///     }
///     // Prints "Seems like picnic weather!"
///
/// You can use special versions of some sequence and collection operations
/// when working with a `Comparable` type. For example, if your array's
/// elements conform to `Comparable`, you can call the `sort()` method without
/// using arguments to sort the elements of your array in ascending order.
///
///     var measurements = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]
///     measurements.sort()
///     print(measurements)
///     // Prints "[1.1, 1.2, 1.2, 1.3, 1.5, 1.5, 2.9]"
///
/// Conforming to the Comparable Protocol
/// =====================================
///
/// Types with Comparable conformance implement the less-than operator (`<`)
/// and the is-equal-to operator (`==`). These two operations impose a strict
/// total order on the values of a type, in which exactly one of the following
/// must be true for any two values `a` and `b`:
///
/// - `a == b`
/// - `a < b`
/// - `b < a`
///
/// In addition, the following conditions must hold:
///
/// - `a < a` is always `false` (Irreflexivity)
/// - `a < b` implies `!(b < a)` (Asymmetry)
/// - `a < b` and `b < c` implies `a < c` (Transitivity)
///
/// To add `Comparable` conformance to your custom types, define the `<` and
/// `==` operators. The `==` operator is a requirement of the `Equatable`
/// protocol, which `Comparable` extends---see that protocol's documentation
/// for more information about equality in Swift. Because default
/// implementations of the remainder of the relational operators are provided
/// by the standard library, you'll be able to use `!=`, `>`, `<=`, and `>=`
/// with instances of your type without any further code.
///
/// As an example, here's an implementation of a `Date` structure that stores
/// the year, month, and day of a date:
///
///     struct Date {
///         let year: Int
///         let month: Int
///         let day: Int
///     }
///
/// To add `Comparable` conformance to `Date`, first declare conformance to
/// `Comparable` and implement the `<` operator function.
///
///     extension Date: Comparable { }
///
///     func <(lhs: Date, rhs: Date) -> Bool {
///         if lhs.year != rhs.year {
///             return lhs.year < rhs.year
///         } else if lhs.month != rhs.month {
///             return lhs.month < rhs.month
///         } else {
///             return lhs.day < rhs.day
///         }
///     }
///
/// This function uses the least specific nonmatching property of the date to
/// determine the result of the comparison. For example, if the two `year`
/// properties are equal but the two `month` properties are not, the date with
/// the lesser value for `month` is the lesser of the two dates.
///
/// Next, implement the `==` operator function, the requirement inherited from
/// the `Equatable` protocol.
///
///     func ==(lhs: Date, rhs: Date) -> Bool {
///         return lhs.year == rhs.year && lhs.month == rhs.month
///             && lhs.day == rhs.day
///     }
///
/// Two `Date` instances are equal if each of their corresponding properties is
/// equal.
///
/// Now that `Date` conforms to `Comparable`, you can compare instances of the
/// type with any of the relational operators. The following example compares
/// the date of the first moon landing with the release of David Bowie's song
/// "Space Oddity":
///
///     let spaceOddity = Date(year: 1969, month: 7, day: 11)   // July 11, 1969
///     let moonLanding = Date(year: 1969, month: 7, day: 20)   // July 20, 1969
///     if moonLanding > spaceOddity {
///         print("Major Tom stepped through the door first.")
///     } else {
///         print("David Bowie was following in Neil Armstrong's footsteps.")
///     }
///     // Prints "Major Tom stepped through the door first."
///
/// Note that the `>` operator provided by the standard library is used in this
/// example, not the `<` operator implemented above.
///
/// - Note: A conforming type may contain a subset of values which are treated
///   as exceptional---that is, values that are outside the domain of
///   meaningful arguments for the purposes of the `Comparable` protocol. For
///   example, the special not-a-number (`FloatingPoint.nan`) value for
///   floating-point types compares as neither less than, greater than, nor
///   equal to any normal floating-point value. Exceptional values need not
///   take part in the strict total order.
public protocol Comparable : Equatable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public func <(lhs: Self, rhs: Self) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public func <=(lhs: Self, rhs: Self) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public func >=(lhs: Self, rhs: Self) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public func >(lhs: Self, rhs: Self) -> Bool
}

/// A contiguously stored array.
///
/// The `ContiguousArray` type is a specialized array that always stores its
/// elements in a contiguous region of memory. This contrasts with `Array`,
/// which can store its elements in either a contiguous region of memory or an
/// `NSArray` instance if its `Element` type is a class or `@objc` protocol.
///
/// If your array's `Element` type is a class or `@objc` protocol and you do
/// not need to bridge the array to `NSArray` or pass the array to Objective-C
/// APIs, using `ContiguousArray` may be more efficient and have more
/// predictable performance than `Array`. If the array's `Element` type is a
/// struct or enumeration, `Array` and `ContiguousArray` should have similar
/// efficiency.
///
/// For more information about using arrays, see `Array` and `ArraySlice`, with
/// which `ContiguousArray` shares most properties and methods.
public struct ContiguousArray<Element> : RandomAccessCollection, MutableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Int

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying a `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<ContiguousArray<Element>>

    /// The position of the first element in a nonempty array.
    ///
    /// For an instance of `ContiguousArray`, `startIndex` is always zero. If the array
    /// is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The array's "past the end" position---that is, the position one greater
    /// than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of an array, use the
    /// half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let i = numbers.index(of: 30) {
    ///         print(numbers[i ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the array is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Int) -> Int

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Int)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1)
    public func index(_ i: Int, offsetBy n: Int) -> Int

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position. The
    /// operation doesn't require going beyond the limiting `numbers.endIndex`
    /// value, so it succeeds.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex,
    ///                           offsetBy: 4,
    ///                           limitedBy: numbers.endIndex)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// The next example attempts to retrieve an index ten positions from
    /// `numbers.startIndex`, but fails, because that distance is beyond the
    /// index passed as `limit`.
    ///
    ///     let j = numbers.index(numbers.startIndex,
    ///                           offsetBy: 10,
    ///                           limitedBy: numbers.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Complexity: O(1)
    public func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -> Int?

    /// Returns the distance between two indices.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`.
    public func distance(from start: Int, to end: Int) -> Int

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = CountableRange<Int>

    /// Accesses the element at the specified position.
    ///
    /// For example:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// - Parameter index: The position of the element to access. `index` must be
    ///   greater than or equal to `startIndex` and less than `endIndex`.
    ///
    /// - Complexity: Reading an element from an array is O(1). Writing is O(1)
    ///   unless the array's storage is shared with another array, in which case
    ///   writing is O(*n*), where *n* is the length of the array.
    public subscript(index: Int) -> Element

    /// Accesses a contiguous subrange of the array's elements.
    ///
    /// The returned `ArraySlice` instance uses the same indices for the same
    /// elements as the original array. In particular, that slice, unlike an
    /// array, may have a nonzero `startIndex` and an `endIndex` that is not
    /// equal to `count`. Always use the slice's `startIndex` and `endIndex`
    /// properties instead of assuming that its indices start or end at a
    /// particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let i = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[i!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of integers. The bounds of the range must be
    ///   valid indices of the array.
    ///
    /// - SeeAlso: `ArraySlice`
    public subscript(bounds: Range<Int>) -> ArraySlice<Element>
}

extension ContiguousArray : ArrayLiteralConvertible {

    /// Creates an array from the given array literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use an array literal. Instead, create a new array by using an array
    /// literal as its value. To do this, enclose a comma-separated list of
    /// values in square brackets.
    ///
    /// Here, an array of strings is created from an array literal holding only
    /// strings:
    ///
    ///     let ingredients: ContiguousArray =
    ///           ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///
    /// - Parameter elements: A variadic list of elements of the new array.
    public init(arrayLiteral elements: Element...)
}

extension ContiguousArray : RangeReplaceableCollection {

    /// Creates a new, empty array.
    ///
    /// This is equivalent to initializing with an empty array literal.
    /// For example:
    ///
    ///     var emptyArray = Array<Int>()
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    ///
    ///     emptyArray = []
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    public init()

    /// Creates an array containing the elements of a sequence.
    ///
    /// You can use this initializer to create an array from any other type that
    /// conforms to the `Sequence` protocol. For example, you might want to
    /// create an array with the integers from 1 through 7. Use this initializer
    /// around a range instead of typing all those numbers in an array literal.
    ///
    ///     let numbers = Array(1...7)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7]"
    ///
    /// You can also use this initializer to convert a complex sequence or
    /// collection type back to an array. For example, the `keys` property of
    /// a dictionary isn't an array with its own storage, it's a collection
    /// that maps its elements from the dictionary only when they're
    /// accessed, saving the time and space needed to allocate an array. If
    /// you need to pass those keys to a method that takes an array, however,
    /// use this initializer to convert that list from its type of
    /// `LazyMapCollection<Dictionary<String, Int>, Int>` to a simple
    /// `[String]`.
    ///
    ///     func cacheImagesWithNames(names: [String]) {
    ///         // custom image loading and caching
    ///      }
    /// 
    ///     let namedHues: [String: Int] = ["Vermillion": 18, "Magenta": 302,
    ///             "Gold": 50, "Cerise": 320]
    ///     let colorNames = Array(namedHues.keys)
    ///     cacheImagesWithNames(colorNames)
    /// 
    ///     print(colorNames)
    ///     // Prints "["Gold", "Cerise", "Magenta", "Vermillion"]"
    ///
    /// - Parameter s: The sequence of elements to turn into an array.
    public init<S : Sequence where S.Iterator.Element == Element>(_ s: S)

    /// Creates a new array containing the specified number of a single, repeated
    /// value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Element, count: Int)

    /// The number of elements in the array.
    public var count: Int { get }

    /// The total number of elements that the array can contain using its current
    /// storage.
    ///
    /// If the array grows larger than its capacity, it discards its current
    /// storage and allocates a larger one.
    ///
    /// The following example creates an array of integers from an array literal,
    /// then appends the elements of another collection. Before appending, the
    /// array allocates new storage that is large enough store the resulting
    /// elements.
    ///
    ///     var numbers = [10, 20, 30, 40, 50]
    ///     print("Count: \(numbers.count), capacity: \(numbers.capacity)")
    ///     // Prints "Count: 5, capacity: 5"
    ///
    ///     numbers.append(contentsOf: stride(from: 60, through: 100, by: 10))
    ///     print("Count: \(numbers.count), capacity: \(numbers.capacity)")
    ///     // Prints "Count: 10, capacity: 12"
    public var capacity: Int { get }

    /// Reserves enough space to store the specified number of elements.
    ///
    /// If you are adding a known number of elements to an array, use this method
    /// to avoid multiple reallocations. This method ensures that the array has
    /// unique, mutable, contiguous storage, with space allocated for at least
    /// the requested number of elements.
    ///
    /// For performance reasons, the newly allocated storage may be larger than
    /// the requested capacity. Use the array's `capacity` property to determine
    /// the size of the new storage.
    ///
    /// - Parameter minimumCapacity: The requested number of elements to store.
    ///
    /// - Complexity: O(*n*), where *n* is the count of the array.
    public mutating func reserveCapacity(_ minimumCapacity: Int)

    /// Adds a new element at the end of the array.
    ///
    /// - Parameter newElement: The element to append to the array.
    ///
    /// - Complexity: Appending an element to the array averages to O(1) over
    ///   many additions. When the array needs to reallocate storage before
    ///   appending or its storage is shared with another copy, appending an
    ///   element is O(*n*), where *n* is the length of the array. If the array
    ///   uses a bridged `NSArray` instance as its storage, the efficiency is
    ///   unspecified.
    public mutating func append(_ newElement: Element)

    /// Adds the elements of a sequence to the end of the array.
    ///
    /// Use this method to append the elements of a sequence to the end of a
    /// collection. This example appends the elements of a `Range<Int>` instance
    /// to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.appendContents(of: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the array.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting array.
    public mutating func append<S : Sequence where S.Iterator.Element == Element>(contentsOf newElements: S)

    /// Adds the elements of a collection to the end of the array.
    ///
    /// Use this method to append the elements of a collection to the end of this
    /// collection. This example appends the elements of a `Range<Int>` instance
    /// to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.appendContents(of: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the array.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting array.
    public mutating func append<C : Collection where C.Iterator.Element == Element>(contentsOf newElements: C)

    /// Removes and returns the last element of the array.
    ///
    /// The array must not be empty.
    ///
    /// - Returns: The element that was removed.
    public mutating func removeLast() -> Element

    /// Inserts a new element at the specified position.
    ///
    /// The new element is inserted before the element currently at the specified
    /// index. If you pass the array's `endIndex` property as the `index`
    /// parameter, the new element is appended to the array.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// - Parameter newElement: The new element to insert into the array.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index of the array or equal to its `endIndex`
    ///   property.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func insert(_ newElement: Element, at i: Int)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved up to
    /// close the gap.
    ///
    ///     var measurements: [Double] = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.1, 1.5, 1.2, 1.5, 1.3, 1.2]"
    ///
    /// - Parameter index: The position of the element to remove. `index` must
    ///   be a valid index of the array.
    /// - Returns: The element at the specified index.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func remove(at index: Int) -> Element

    /// Removes all elements from the array.
    ///
    /// - Parameter keepCapacity: Pass `true` to keep the existing capacity of
    ///   the array after removing its elements. The default value is
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)
}

extension ContiguousArray : CustomReflectable {

    /// A mirror that reflects the array.
    public var customMirror: Mirror { get }
}

extension ContiguousArray : CustomStringConvertible, CustomDebugStringConvertible {

    /// A textual representation of the array and its elements.
    public var description: String { get }

    /// A textual representation of the array and its elements, suitable for
    /// debugging.
    public var debugDescription: String { get }
}

extension ContiguousArray {

    /// Calls a closure with a pointer to the array's contiguous storage.
    /// 
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows how you can iterate over the contents of the
    /// buffer pointer:
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     let sum = numbers.withUnsafeBufferPointer { buffer -> Int in
    ///         var result = 0
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {
    ///             result += buffer[i]
    ///         }
    ///         return result
    ///     }
    ///     // 'sum' == 9
    ///
    /// - Parameter body: A closure with an `UnsafeBufferPointer` parameter that
    ///   points to the contiguous storage for the array. If `body` has a return
    ///   value, it is used as the return value for the
    ///   `withUnsafeBufferPointer(_:)` method. The pointer argument is valid
    ///   only for the duration of the closure's execution.
    /// - Returns: The return value of the `body` closure parameter, if any.
    ///
    /// - SeeAlso: `withUnsafeMutableBufferPointer`, `UnsafeBufferPointer`
    public func withUnsafeBufferPointer<R>(_ body: @noescape (UnsafeBufferPointer<Element>) throws -> R) rethrows -> R

    /// Calls the given closure with a pointer to the array's mutable contiguous
    /// storage.
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows modifying the contents of the
    /// `UnsafeMutableBufferPointer` argument to `body` alters the contents of
    /// the array:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.withUnsafeMutableBufferPointer { buffer in
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {
    ///             swap(&buffer[i], &buffer[i + 1])
    ///         }
    ///     }
    ///     print(numbers)
    ///     // Prints "[2, 1, 4, 3, 5]"
    ///
    /// - Warning: Do not rely on anything about `self` (the array that is the
    ///   target of this method) during the execution of the `body` closure: It
    ///   may not appear to have its correct value.  Instead, use only the
    ///   `UnsafeMutableBufferPointer` argument to `body`.
    ///
    /// - Parameter body: A closure with an `UnsafeMutableBufferPointer`
    ///   parameter that points to the contiguous storage for the array. If
    ///   `body` has a return value, it is used as the return value for the
    ///   `withUnsafeMutableBufferPointer(_:)` method. The pointer argument is
    ///   valid only for the duration of the closure's execution.
    /// - Returns: The return value of the `body` closure parameter, if any.
    ///
    /// - SeeAlso: `withUnsafeBufferPointer`, `UnsafeMutableBufferPointer`
    public mutating func withUnsafeMutableBufferPointer<R>(_ body: @noescape (inout UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R
}

extension ContiguousArray {

    /// Replaces a range of elements with the elements in the specified
    /// collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the array and inserting the new elements at the same location. The
    /// number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the array to replace. The start and end of
    ///     a subrange must be valid indices of the array.
    ///   - newElements: The new elements to add to the array.
    ///
    /// - Complexity: O(`subrange.count`) if you are replacing a suffix of the
    ///   array with an empty collection; otherwise, O(*n*), where *n* is the
    ///   length of the array.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == _Buffer.Element>(_ subrange: Range<Int>, with newElements: C)
}

extension ContiguousArray {

    /// Removes and returns the last element of the array.
    ///
    /// - Returns: The last element of the array if the array is not empty;
    ///   otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    /// - SeeAlso: `removeLast()`
    public mutating func popLast() -> Element?
}

/// A closed range that forms a collection of consecutive values.
///
/// You create a `CountableClosedRange` instance by using the closed range
/// operator (`...`).
///
///     let throughFive = 0...5
///
/// A `CountableClosedRange` instance contains both its lower bound and its
/// upper bound.
///
///     print(throughFive.contains(3))      // Prints "true"
///     print(throughFive.contains(10))     // Prints "false"
///     print(throughFive.contains(5))      // Prints "true"
///
/// Because a closed range includes its upper bound, a closed range whose lower
/// bound is equal to the upper bound contains one element. Therefore, a
/// `CountableClosedRange` instance cannot represent an empty range.
///
///     let zeroInclusive = 0...0
///     print(zeroInclusive.isEmpty)
///     // Prints "false"
///     print(zeroInclusive.count)
///     // Prints "1"
///
/// You can use a `for`-`in` loop or any sequence or collection method with a
/// countable range. The elements of the range are the consecutive values from
/// its lower bound up to, and including, its upper bound.
///
///     for n in throughFive.suffix(3) {
///         print(n)
///     }
///     // Prints "3"
///     // Prints "4"
///     // Prints "5"
///
/// You can create a countable range over any type that conforms to the
/// `Strideable` protocol and uses an integer as its associated `Stride` type.
/// By default, Swift's integer and pointer types are usable as the bounds of
/// a countable range.
///
/// Because floating-point types such as `Float` and `Double` are their own
/// `Stride` types, they cannot be used as the bounds of a countable range. If
/// you need to test whether values are contained within a closed interval
/// bound by floating-point values, see the `ClosedRange` type. If you need to
/// iterate over consecutive floating-point values, see the
/// `stride(from:through:by:)` function.
///
/// - SeeAlso: `CountableRange`, `ClosedRange`, `Range`
public struct CountableClosedRange<Bound : protocol<Comparable, _Strideable> where Bound.Stride : SignedInteger> : RandomAccessCollection {

    /// The range's lower bound.
    public let lowerBound: Bound

    /// The range's upper bound.
    ///
    /// `upperBound` is always reachable from `lowerBound` by zero or
    /// more applications of `index(after:)`.
    public let upperBound: Bound

    /// The element type of the range; the same type as the range's bounds.
    public typealias Element = Bound

    /// A type that represents a position in the range.
    public typealias Index = ClosedRangeIndex<Bound>

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Bound.Stride

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying a `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = ClosedRangeIterator<Bound>

    /// Returns an iterator over the elements of the collection.
    public func makeIterator() -> ClosedRangeIterator<Bound>

    /// The position of the first element in the range.
    public var startIndex: ClosedRangeIndex<Bound> { get }

    /// The range's "past the end" position---that is, the position one greater
    /// than the last valid subscript argument.
    public var endIndex: ClosedRangeIndex<Bound> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: ClosedRangeIndex<Bound>) -> ClosedRangeIndex<Bound>

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: ClosedRangeIndex<Bound>) -> ClosedRangeIndex<Bound>

    /// Accesses the element at specified position.
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the range, and must not equal the range's end
    ///   index.
    public subscript(position: ClosedRangeIndex<Bound>) -> Bound { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<ClosedRangeIndex<Bound>>) -> RandomAccessSlice<CountableClosedRange<Bound>> { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: DefaultRandomAccessIndices<CountableClosedRange<Bound>> { get }

    /// Creates an instance with the given bounds.
    ///
    /// Because this initializer does not perform any checks, it should be used
    /// as an optimization only when you are absolutely certain that `lower` is
    /// less than or equal to `upper`. Using the closed range operator (`...`)
    /// to form `CountableClosedRange` instances is preferred.
    ///
    /// - Parameter bounds: A tuple of the lower and upper bounds of the range.
    public init(uncheckedBounds bounds: (lower: Bound, upper: Bound))

    /// A Boolean value indicating whether the range contains no elements.
    ///
    /// Because a closed range cannot represent an empty range, this property is
    /// always `false`.
    public var isEmpty: Bool { get }
}

extension CountableClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// An equivalent range must be representable as an instance of `CountableClosedRange`.
    /// For example, passing an empty range as `other` triggers a runtime error,
    /// because an empty range cannot be represented by a `CountableClosedRange` instance.
    ///
    /// - Parameter other: A range to convert to a `CountableClosedRange` instance.
    public init(_ other: Range<Bound>)
}

extension CountableClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: CountableClosedRange = 0...20
    ///     print(x.overlaps(10..<1000 as Range))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: Range<Bound>) -> Bool
}

extension CountableClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// An equivalent range must be representable as an instance of `CountableClosedRange`.
    /// For example, passing an empty range as `other` triggers a runtime error,
    /// because an empty range cannot be represented by a `CountableClosedRange` instance.
    ///
    /// - Parameter other: A range to convert to a `CountableClosedRange` instance.
    public init(_ other: CountableRange<Bound>)
}

extension CountableClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: CountableClosedRange = 0...20
    ///     print(x.overlaps(10..<1000 as CountableRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: CountableRange<Bound>) -> Bool
}

extension CountableClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// - Parameter other: A range to convert to a `CountableClosedRange` instance.
    public init(_ other: ClosedRange<Bound>)
}

extension CountableClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: CountableClosedRange = 0...20
    ///     print(x.overlaps(10...1000 as ClosedRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: ClosedRange<Bound>) -> Bool
}

extension CountableClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// - Parameter other: A range to convert to a `CountableClosedRange` instance.
    public init(_ other: CountableClosedRange<Bound>)
}

extension CountableClosedRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: CountableClosedRange = 0...20
    ///     print(x.overlaps(10...1000 as CountableClosedRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: CountableClosedRange<Bound>) -> Bool
}

extension CountableClosedRange {

    /// Returns a copy of this range clamped to the given limiting range.
    ///
    /// The bounds of the result are always limited to the bounds of `limits`.
    /// For example:
    ///
    ///     let x: CountableClosedRange = 0...20
    ///     print(x.clamped(to: 10...1000))
    ///     // Prints "10...20"
    ///
    /// If the two ranges do not overlap, the result is a single-element range at
    /// the upper or lower bound of `limits`.
    ///
    ///     let y: CountableClosedRange = 0...5
    ///     print(y.clamped(to: 10...1000))
    ///     // Prints "10...10"
    ///
    /// - Parameter limits: The range to clamp the bounds of this range.
    /// - Returns: A new range clamped to the bounds of `limits`.
    public func clamped(to limits: CountableClosedRange<Bound>) -> CountableClosedRange<Bound>
}

extension CountableClosedRange : CustomStringConvertible {

    /// A textual representation of the range.
    public var description: String { get }
}

extension CountableClosedRange : CustomDebugStringConvertible {

    /// A textual representation of the range, suitable for debugging.
    public var debugDescription: String { get }
}

extension CountableClosedRange : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension CountableClosedRange : Equatable {
}

/// A half-open range that forms a collection of consecutive values.
///
/// You create a `CountableRange` instance by using the half-open range
/// operator (`..<`).
///
///     let upToFive = 0..<5
///
/// The associated `Bound` type is both the element and index type of
/// `CountableRange`. Each element of the range is its own corresponding
/// index. The lower bound of a `CountableRange` instance is its start index,
/// and the upper bound is its end index.
///
///     print(upToFive.contains(3))         // Prints "true"
///     print(upToFive.contains(10))        // Prints "false"
///     print(upToFive.contains(5))         // Prints "false"
///
/// If the `Bound` type has a maximal value, it can serve as an upper bound but
/// can never be contained in a `CountableRange<Bound>` instance. For example,
/// a `CountableRange<Int8>` instance can use `Int8.max` as its upper bound,
/// but it can't represent a range that includes `Int8.max`.
///
///     let maximumRange = Int8.min..<Int8.max
///     print(maximumRange.contains(Int8.max))
///     // Prints "false"
///
/// If you need to create a range that includes the maximal value of its
/// `Bound` type, see the `CountableClosedRange` type.
///
/// You can create a countable range over any type that conforms to the
/// `Strideable` protocol and uses an integer as its associated `Stride` type.
/// By default, Swift's integer and pointer types are usable as the bounds of
/// a countable range.
///
/// Because floating-point types such as `Float` and `Double` are their own
/// `Stride` types, they cannot be used as the bounds of a countable range. If
/// you need to test whether values are contained within an interval bound by
/// floating-point values, see the `Range` type. If you need to iterate over
/// consecutive floating-point values, see the `stride(from:to:by:)` function.
///
/// Integer Index Ambiguity
/// -----------------------
///
/// Because each element of a `CountableRange` instance is its own index, for
/// the range `(-99..<100)` the element at index `0` is `0`. This is an
/// unexpected result for those accustomed to zero-based collection indices,
/// who might expect the result to be `-99`. To prevent this confusion, in a
/// context where `Bound` is known to be an integer type, subscripting
/// directly is a compile-time error:
///
///     // error: ambiguous use of 'subscript'
///     print((-99..<100)[0])
///
/// However, subscripting that range still works in a generic context:
///
///     func brackets<T>(_ x: CountableRange<T>, _ i: T) -> T {
///         return x[i] // Just forward to subscript
///     }
///     print(brackets(-99..<100, 0))
///     // Prints "0"
///
/// - SeeAlso: `CountableClosedRange`, `Range`, `ClosedRange`
public struct CountableRange<Bound : protocol<Comparable, _Strideable> where Bound.Stride : SignedInteger> : RandomAccessCollection {

    /// The range's lower bound.
    ///
    /// In an empty range, `lowerBound` is equal to `upperBound`.
    public let lowerBound: Bound

    /// The range's upper bound.
    ///
    /// `upperBound` is not a valid subscript argument and is always
    /// reachable from `lowerBound` by zero or more applications of
    /// `index(after:)`.
    ///
    /// In an empty range, `upperBound` is equal to `lowerBound`.
    public let upperBound: Bound

    /// The bound type of the range.
    public typealias Element = Bound

    /// A type that represents a position in the range.
    public typealias Index = Bound

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Bound.Stride

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Bound { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Bound { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Bound) -> Bound

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Bound) -> Bound

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Bound, offsetBy n: Bound.Stride) -> Bound

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Bound, to end: Bound) -> Bound.Stride

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = CountableRange<Bound>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the range's indices. The upper and lower
    ///   bounds of the `bounds` range must be valid indices of the collection.
    public subscript(bounds: Range<Bound>) -> CountableRange<Bound> { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the range's indices. The upper and lower
    ///   bounds of the `bounds` range must be valid indices of the collection.
    public subscript(bounds: CountableRange<Bound>) -> CountableRange<Bound> { get }

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = CountableRange<Bound>

    /// The indices that are valid for subscripting the range, in ascending
    /// order.
    public var indices: CountableRange<Bound> { get }

    /// Creates an instance with the given bounds.
    ///
    /// Because this initializer does not perform any checks, it should be used
    /// as an optimization only when you are absolutely certain that `lower` is
    /// less than or equal to `upper`. Using the half-open range operator
    /// (`..<`) to form `CountableRange` instances is preferred.
    ///
    /// - Parameter bounds: A tuple of the lower and upper bounds of the range.
    public init(uncheckedBounds bounds: (lower: Bound, upper: Bound))

    /// A Boolean value indicating whether the range contains no elements.
    ///
    /// An empty range has equal lower and upper bounds.
    ///
    ///     let empty = 10..<10
    ///     print(empty.isEmpty)
    ///     // Prints "true"
    public var isEmpty: Bool { get }
}

extension CountableRange {

    /// Accesses the element at specified position.
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the range, and must not equal the range's end
    ///   index.
    public subscript(position: Bound) -> Bound { get }
}

extension CountableRange where Bound._DisabledRangeIndex : Strideable, Bound._DisabledRangeIndex.Stride : SignedInteger {

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection and `bounds.upperBound` must be less than the collection's
    ///   end index.
    public subscript(bounds: ClosedRange<Bound>) -> CountableRange<Bound> { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection and `bounds.upperBound` must be less than the collection's
    ///   end index.
    public subscript(bounds: CountableClosedRange<Bound>) -> CountableRange<Bound> { get }
}

extension CountableRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// - Parameter other: A range to convert to a `CountableRange` instance.
    public init(_ other: Range<Bound>)
}

extension CountableRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: CountableRange = 0..<20
    ///     print(x.overlaps(10..<1000 as Range))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: Range<Bound>) -> Bool
}

extension CountableRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// - Parameter other: A range to convert to a `CountableRange` instance.
    public init(_ other: CountableRange<Bound>)
}

extension CountableRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: CountableRange = 0..<20
    ///     print(x.overlaps(10..<1000 as CountableRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: CountableRange<Bound>) -> Bool
}

extension CountableRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// An equivalent range must be representable as an instance of `CountableRange`.
    /// For example, passing a closed range with an upper bound of `Int.max`
    /// triggers a runtime error, because the resulting half-open range would
    /// require an upper bound of `Int.max + 1`, which is not representable as
    /// an `Int`.
    ///
    /// - Parameter other: A range to convert to a `CountableRange` instance.
    public init(_ other: ClosedRange<Bound>)
}

extension CountableRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: CountableRange = 0..<20
    ///     print(x.overlaps(10...1000 as ClosedRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: ClosedRange<Bound>) -> Bool
}

extension CountableRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// An equivalent range must be representable as an instance of `CountableRange`.
    /// For example, passing a closed range with an upper bound of `Int.max`
    /// triggers a runtime error, because the resulting half-open range would
    /// require an upper bound of `Int.max + 1`, which is not representable as
    /// an `Int`.
    ///
    /// - Parameter other: A range to convert to a `CountableRange` instance.
    public init(_ other: CountableClosedRange<Bound>)
}

extension CountableRange where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: CountableRange = 0..<20
    ///     print(x.overlaps(10...1000 as CountableClosedRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: CountableClosedRange<Bound>) -> Bool
}

extension CountableRange {

    /// Returns a copy of this range clamped to the given limiting range.
    ///
    /// The bounds of the result are always limited to the bounds of `limits`.
    /// For example:
    ///
    ///     let x: CountableRange = 0..<20
    ///     print(x.clamped(to: 10..<1000))
    ///     // Prints "10..<20"
    ///
    /// If the two ranges do not overlap, the result is an empty range within the
    /// bounds of `limits`.
    ///
    ///     let y: CountableRange = 0..<5
    ///     print(y.clamped(to: 10..<1000))
    ///     // Prints "10..<10"
    ///
    /// - Parameter limits: The range to clamp the bounds of this range.
    /// - Returns: A new range clamped to the bounds of `limits`.
    public func clamped(to limits: CountableRange<Bound>) -> CountableRange<Bound>
}

extension CountableRange : CustomStringConvertible {

    /// A textual representation of the range.
    public var description: String { get }
}

extension CountableRange : CustomDebugStringConvertible {

    /// A textual representation of the range, suitable for debugging.
    public var debugDescription: String { get }
}

extension CountableRange : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension CountableRange : Equatable {
}

/// A type with a customized textual representation suitable for debugging
/// purposes.
///
/// Swift provides a default debugging textual representation for any type.
/// That default representation is used by the `String(reflecting:)`
/// initializer and the `debugPrint(_:)` function for types that don't provide
/// their own. To customize that representation, make your type conform to the
/// `CustomDebugStringConvertible` protocol.
///
/// Because the `String(reflecting:)` initializer works for instances of *any*
/// type, returning an instance's `debugDescription` if the value passed
/// conforms to `CustomDebugStringConvertible`, accessing a type's
/// `debugDescription` property directly or using
/// `CustomDebugStringConvertible` as a generic constraint is discouraged.
///
/// Conforming to the CustomDebugStringConvertible Protocol
/// =======================================================
///
/// Add `CustomDebugStringConvertible` conformance to your custom types by
/// defining a `debugDescription` property.
///
/// For example, this custom `Point` struct uses the default representation
/// supplied by the standard library:
///
///     struct Point {
///         let x: Int, y: Int
///     }
///
///     let p = Point(x: 21, y: 30)
///     print(String(reflecting: p))
///     // Prints "p: Point = {
///     //           x = 21
///     //           y = 30
///     //         }"
///
/// After adding `CustomDebugStringConvertible` conformance by implementing the
/// `debugDescription` property, `Point` provides its own custom debugging
/// representation.
///
///     extension Point: CustomDebugStringConvertible {
///         var debugDescription: String {
///             return "Point(x: \(x), y: \(y))"
///         }
///     }
///
///     print(String(reflecting: p))
///     // Prints "Point(x: 21, y: 30)"
///
/// - SeeAlso: `String.init<T>(reflecting: T)`, `CustomStringConvertible`
public protocol CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    public var debugDescription: String { get }
}

/// A type that explicitly supplies its own mirror, but whose
/// descendant classes are not represented in the mirror unless they
/// also override `customMirror`.
public protocol CustomLeafReflectable : CustomReflectable {
}

/// A type that explicitly supplies its own PlaygroundQuickLook.
///
/// Instances of any type can be `PlaygroundQuickLook(reflect:)`'ed
/// upon, but if you are not satisfied with the `PlaygroundQuickLook`
/// supplied for your type by default, you can make it conform to
/// `CustomPlaygroundQuickLookable` and return a custom
/// `PlaygroundQuickLook`.
public protocol CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

/// A type that explicitly supplies its own mirror.
///
/// You can create a mirror for any type using the `Mirror(reflect:)`
/// initializer, but if you are not satisfied with the mirror supplied for
/// your type by default, you can make it conform to `CustomReflectable` and
/// return a custom `Mirror` instance.
public protocol CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// A type with a customized textual representation.
///
/// Types that conform to the `CustomStringConvertible` protocol can provide
/// their own representation to be used when converting an instance to a
/// string. The `String(_:)` initializer is the preferred way to convert an
/// instance of *any* type to a string. If the passed instance conforms to
/// `CustomStringConvertible`, the `String(_:)` initializer and the
/// `print(_:)` function use the instance's custom `description` property.
///
/// Accessing a type's `description` property directly or using
/// `CustomStringConvertible` as a generic constraint is discouraged.
///
/// Conforming to the CustomStringConvertible Protocol
/// ==================================================
///
/// Add `CustomStringConvertible` conformance to your custom types by defining
/// a `description` property.
///
/// For example, this custom `Point` struct uses the default representation
/// supplied by the standard library:
///
///     struct Point {
///         let x: Int, y: Int
///     }
///
///     let p = Point(x: 21, y: 30)
///     print(p)
///     // Prints "Point(x: 21, y: 30)"
///
/// After implementing the `description` property and declaring
/// `CustomStringConvertible` conformance, the `Point` type provides its own
/// custom representation.
///
///     extension Point: CustomStringConvertible {
///         var description: String {
///             return "(\(x), \(y))"
///         }
///     }
///
///     print(p)
///     // Prints "(21, 30)"
///
/// - SeeAlso: `String.init<T>(T)`, `CustomDebugStringConvertible`
public protocol CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Instead of accessing this property directly, convert an instance of any
    /// type to a string by using the `String(_:)` initializer. For example:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

/// A collection of indices for an arbitrary bidirectional collection.
public struct DefaultBidirectionalIndices<Elements : BidirectionalIndexable> : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Elements.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Elements.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Elements.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(i: Elements.Index) -> Elements.Index { get }

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = DefaultBidirectionalIndices<Elements>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Elements.Index>) -> DefaultBidirectionalIndices<Elements> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Elements.Index) -> Elements.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Elements.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Elements.Index) -> Elements.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Elements.Index)

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultBidirectionalIndices<Elements>

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: DefaultBidirectionalIndices<Elements> { get }
}

/// A collection of indices for an arbitrary collection.
public struct DefaultIndices<Elements : Indexable> : Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Elements.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Elements.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Elements.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(i: Elements.Index) -> Elements.Index { get }

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = DefaultIndices<Elements>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Elements.Index>) -> DefaultIndices<Elements> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Elements.Index) -> Elements.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Elements.Index)

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultIndices<Elements>

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: DefaultIndices<Elements> { get }
}

/// A collection of indices for an arbitrary random-access collection.
public struct DefaultRandomAccessIndices<Elements : RandomAccessIndexable> : RandomAccessCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Elements.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Elements.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Elements.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(i: Elements.Index) -> Elements.Index { get }

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = DefaultRandomAccessIndices<Elements>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Elements.Index>) -> DefaultRandomAccessIndices<Elements> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Elements.Index) -> Elements.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Elements.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Elements.Index) -> Elements.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Elements.Index)

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultRandomAccessIndices<Elements>

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: DefaultRandomAccessIndices<Elements> { get }
}

/// A collection whose elements are key-value pairs.
///
/// A dictionary is a type of hash table, providing fast access to the entries
/// it contains. Each entry in the table is identified using its key, which is
/// a hashable type such as a string or number. You use that key to retrieve
/// the corresponding value, which can be any object. In other languages,
/// similar data types are known as hashes or associated arrays.
///
/// Create a new dictionary by using a dictionary literal. A dictionary literal
/// is a comma-separated list of key-value pairs, in which a colon separates
/// each key from its associated value, surrounded by square brackets. You can
/// assign a dictionary literal to a variable or constant or pass it to a
/// function that expects a dictionary.
///
/// Here's how you would create a dictionary of HTTP response codes and their
/// related messages:
///
///     var responseMessages = [200: "OK",
///                             403: "Access forbidden",
///                             404: "File not found",
///                             500: "Internal server error"]
///
/// The `responseMessages` variable is inferred to have type `[Int: String]`.
/// The `Key` type of the dictionary is `Int`, and the `Value` type of the
/// dictionary is `String`.
///
/// To create a dictionary with no key-value pairs, use an empty dictionary
/// literal (`[:]`).
///
///     var emptyDict: [String: String] = [:]
///
/// Any type that conforms to the `Hashable` protocol can be used as a
/// dictionary's `Key` type, including all of Swift's basic types. You can use
/// your own custom types as dictionary keys by making them conform to the
/// `Hashable` protocol.
///
/// Getting and Setting Dictionary Values
/// =====================================
///
/// The most common way to access values in a dictionary is to use a key as a
/// subscript. Subscripting with a key takes the following form:
///
///     print(responseMessages[200])
///     // Prints "Optional("OK")"
///
/// Subscripting a dictionary with a key returns an optional value, because a
/// dictionary might not hold a value for the key that you use in the
/// subscript.
///
/// The next example uses key-based subscripting of the `responseMessages`
/// dictionary with two keys that exist in the dictionary and one that does
/// not.
///
///     let httpResponseCodes = [200, 403, 301]
///     for code in httpResponseCodes {
///         if let message = responseMessages[code] {
///             print("Response \(code): \(message)")
///         } else {
///             print("Unknown response \(code)")
///         }
///     }
///     // Prints "Response 200: OK"
///     // Prints "Response 403: Access Forbidden"
///     // Prints "Unknown response 301"
///
/// You can also update, modify, or remove keys and values from a dictionary
/// using the key-based subscript. To add a new key-value pair, assign a value
/// to a key that isn't yet a part of the dictionary.
///
///     responseMessages[301] = "Moved permanently"
///     print(responseMessages[301])
///     // Prints "Optional("Moved permanently")"
///
/// Update an existing value by assigning a new value to a key that already
/// exists in the dictionary. If you assign `nil` to an existing key, the key
/// and its associated value are removed. The following example updates the
/// value for the `404` code to be simply "Not found" and removes the
/// key-value pair for the `500` code entirely.
///
///     responseMessages[404] = "Not found"
///     responseMessages[500] = nil
///     print(responseMessages)
///     // Prints "[301: "Moved permanently", 200: "OK", 403: "Access forbidden", 404: "Not found"]"
///
/// In a mutable `Dictionary` instance, you can modify in place a value that
/// you've accessed through a keyed subscript. The code sample below declares a
/// dictionary called `interestingNumbers` with string keys and values that
/// are integer arrays, then sorts each array in-place in descending order.
///
///     var interestingNumbers = ["primes": [2, 3, 5, 7, 11, 13, 15],
///                               "triangular": [1, 3, 6, 10, 15, 21, 28],
///                               "hexagonal": [1, 6, 15, 28, 45, 66, 91]]
///     for key in interestingNumbers.keys {
///         interestingNumbers[key]?.sort(isOrderedBefore: >)
///     }
///
///     print(interestingNumbers["primes"]!)
///     // Prints "[15, 13, 11, 7, 5, 3, 2]"
///
/// Iterating Over the Contents of a Dictionary
/// ===========================================
///
/// Every dictionary is an unordered collection of key-value pairs. You can
/// iterate over a dictionary using a `for`-`in` loop, decomposing each
/// key-value pair into the elements of a tuple.
///
///     let imagePaths = ["star": "/glyphs/star.png",
///                       "portrait": "/images/content/portrait.jpg",
///                       "spacer": "/images/shared/spacer.gif"]
///
///     for (name, path) in imagePaths {
///         print("The path to '\(name)' is '\(path)'.")
///     }
///     // Prints "The path to 'star' is '/glyphs/star.png'."
///     // Prints "The path to 'portrait' is '/images/content/portrait.jpg'."
///     // Prints "The path to 'spacer' is '/images/shared/spacer.gif'."
///
/// The order of key-value pairs in a dictionary is stable between mutations
/// but is otherwise unpredictable. If you need an ordered collection of
/// key-value pairs and don't need the fast key lookup that `Dictionary`
/// provides, see the `DictionaryLiteral` type for an alternative.
///
/// You can search a dictionary's contents for a particular value using the
/// `contains(where:)` or `index(where:)` methods supplied by default
/// implementation. The following example checks to see if `imagePaths` contains
/// any paths in the `"/glyphs"` directory:
///
///     let glyphIndex = imagePaths.index { $0.value.hasPrefix("/glyphs") }
///     if let index = glyphIndex {
///         print("The '\(imagesPaths[index].key)' image is a glyph.")
///     } else {
///         print("No glyphs found!")
///     }
///     // Prints "The 'star' image is a glyph.")
///
/// Note that in this example, `imagePaths` is subscripted using a dictionary
/// index. Unlike the key-based subscript, the index-based subscript returns
/// the corresponding key-value pair as a non-optional tuple.
///
///     print(imagePaths[glyphIndex!])
///     // Prints "("star", "/glyphs/star.png")"
///
/// A dictionary's indices stay valid across additions to the dictionary as
/// long as the dictionary has enough capacity to store the added values
/// without allocating more storage. When a dictionary outgrows its storage,
/// existing indices may be invalidated without any notification.
///
/// When you know how many new values you're adding to a dictionary, use the
/// `init(minimumCapacity:)` initializer to allocate the correct amount of
/// storage.
///
/// Bridging Between Dictionary and NSDictionary
/// ============================================
///
/// You can bridge between `Dictionary` and `NSDictionary` using the `as`
/// operator. For bridging to be possible, the `Key` and `Value` types of a
/// dictionary must be classes, `@objc` protocols, or types that bridge to
/// Foundation types.
///
/// Bridging from `Dictionary` to `NSDictionary` always takes O(1) time and
/// space. When the dictionary's `Key` and `Value` types are neither classes
/// nor `@objc` protocols, any required bridging of elements occurs at the
/// first access of each element. For this reason, the first operation that
/// uses the contents of the dictionary may take O(*n*).
///
/// Bridging from `NSDictionary` to `Dictionary` first calls the `copy(with:)`
/// method (`- copyWithZone:` in Objective-C) on the dictionary to get an
/// immutable copy and then performs additional Swift bookkeeping work that
/// takes O(1) time. For instances of `NSDictionary` that are already
/// immutable, `copy(with:)` usually returns the same dictionary in O(1) time;
/// otherwise, the copying performance is unspecified. The instances of
/// `NSDictionary` and `Dictionary` share storage using the same copy-on-write
/// optimization that is used when two instances of `Dictionary` share
/// storage.
///
/// - SeeAlso: `Hashable`
public struct Dictionary<Key : Hashable, Value> : Collection, DictionaryLiteralConvertible {

    /// The element type of a dictionary: a tuple containing an individual
    /// key-value pair.
    public typealias Element = (key: Key, value: Value)

    /// The index type of a dictionary.
    public typealias Index = DictionaryIndex<Key, Value>

    /// Creates an empty dictionary.
    public init()

    /// Creates a dictionary with at least the given number of elements worth of
    /// storage.
    ///
    /// Use this initializer to avoid intermediate reallocations when you know
    /// how many key-value pairs you are adding to a dictionary. The actual
    /// capacity of the created dictionary is the smallest power of 2 that
    /// is greater than or equal to `minimumCapacity`.
    ///
    /// - Parameter minimumCapacity: The minimum number of key-value pairs to
    ///   allocate storage for in the new dictionary.
    public init(minimumCapacity: Int)

    /// The position of the first element in a nonempty dictionary.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    ///
    /// - Complexity: Amortized O(1) if the dictionary does not wrap a bridged
    ///   `NSDictionary`. If the dictionary wraps a bridged `NSDictionary`, the
    ///   performance is unspecified.
    public var startIndex: DictionaryIndex<Key, Value> { get }

    /// The dictionary's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    ///
    /// - Complexity: Amortized O(1) if the dictionary does not wrap a bridged
    ///   `NSDictionary`; otherwise, the performance is unspecified.
    public var endIndex: DictionaryIndex<Key, Value> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: DictionaryIndex<Key, Value>) -> DictionaryIndex<Key, Value>

    /// Returns the index for the given key.
    ///
    /// If the given key is found in the dictionary, this method returns an index
    /// into the dictionary that corresponds with the key-value pair.
    ///
    ///     let countryCodes = ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"]
    ///     let index = countryCodes.index(forKey: "JP")
    ///
    ///     print("Country code for \(countryCodes[index!].value): '\(countryCodes[index!].key)'.")
    ///     // Prints "Country code for Japan: 'JP'."
    ///
    /// - Parameter key: The key to find in the dictionary.
    /// - Returns: The index for `key` and its associated value if `key` is in
    ///   the dictionary; otherwise, `nil`.
    public func index(forKey key: Key) -> DictionaryIndex<Key, Value>?

    /// Accesses the key-value pair at the specified position.
    ///
    /// This subscript takes an index into the dictionary, instead of a key, and
    /// returns the corresponding key-value pair as a tuple. When performing
    /// collection-based operations that return an index into a dictionary, use
    /// this subscript with the resulting value.
    ///
    /// For example, to find the key for a particular value in a dictionary, use
    /// the `index(where:)` method.
    ///
    ///     let countryCodes = ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"]
    ///     if let index = countryCodes.index(where: { $0.value == "Japan" }) {
    ///         print(countryCodes[index])
    ///         print("Japan's country code is '\(countryCodes[index].key)'.")
    ///     } else {
    ///         print("Didn't find 'Japan' as a value in the dictionary.")
    ///     }
    ///     // Prints "("JP", "Japan")"
    ///     // Prints "Japan's country code is 'JP'."
    ///
    /// - Parameter position: The position of the key-value pair to access.
    ///   `position` must be a valid index of the dictionary and not equal to
    ///   `endIndex`.
    /// - Returns: A two-element tuple with the key and value corresponding to
    ///   `position`.
    public subscript(position: DictionaryIndex<Key, Value>) -> (key: Key, value: Value) { get }

    /// Accesses the value associated with the given key for reading and writing.
    ///
    /// This *key-based* subscript returns the value for the given key if the key
    /// is found in the dictionary, or `nil` if the key is not found.
    ///
    /// The following example creates a new dictionary and prints the value of a
    /// key found in the dictionary (`"Coral"`) and a key not found in the
    /// dictionary (`"Cerise"`).
    ///
    ///     var hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     print(hues["Coral"])
    ///     // Prints "Optional(16)"
    ///     print(hues["Cerise"])
    ///     // Prints "nil"
    ///
    /// When you assign a value for a key and that key already exists, the
    /// dictionary overwrites the existing value. If the dictionary doesn't
    /// contain the key, the key and value are added as a new key-value pair.
    ///
    /// Here, the value for the key `"Coral"` is updated from `16` to `18` and a
    /// new key-value pair is added for the key `"Cerise"`.
    ///
    ///     hues["Coral"] = 18
    ///     print(hues["Coral"])
    ///     // Prints "Optional(18)"
    ///
    ///     hues["Cerise"] = 330
    ///     print(hues["Cerise"])
    ///     // Prints "Optional(330)"
    ///
    /// If you assign `nil` as the value for the given key, the dictionary
    /// removes that key and its associated value.
    ///
    /// In the following example, the key-value pair for the key `"Aquamarine"`
    /// is removed from the dictionary by assigning `nil` to the key-based
    /// subscript.
    ///
    ///     hues["Aquamarine"] = nil
    ///     print(hues)
    ///     // Prints "["Coral": 18, "Heliotrope": 296, "Cerise": 330]"
    ///
    /// - Parameter key: The key to find in the dictionary.
    /// - Returns: The value associated with `key` if `key` is in the dictionary;
    ///   otherwise, `nil`.
    public subscript(key: Key) -> Value?

    /// Updates the value stored in the dictionary for the given key, or adds a
    /// new key-value pair if the key does not exist.
    ///
    /// Use this method instead of key-based subscripting when you need to know
    /// whether the new value supplants the value of an existing key. If the
    /// value of an existing key is updated, `updateValue(_:forKey:)` returns
    /// the original value.
    ///
    ///     var hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///
    ///     if let oldValue = hues.updateValue(18, forKey: "Coral") {
    ///         print("The old value of \(oldValue) was replaced with a new one.")
    ///     }
    ///     // Prints "The old value of 16 was replaced with a new one."
    ///
    /// If the given key is not present in the dictionary, this method adds the
    /// key-value pair and returns `nil`.
    ///
    ///     if let oldValue = hues.updateValue(330, forKey: "Cerise") {
    ///         print("The old value of \(oldValue) was replaced with a new one.")
    ///     } else {
    ///         print("No value was found in the dictionary for that key.")
    ///     }
    ///     // Prints "No value was found in the dictionary for that key."
    ///
    /// - Parameters:
    ///   - value: The new value to add to the dictionary.
    ///   - key: The key to associate with `value`. If `key` already exists in
    ///     the dictionary, `value` replaces the existing associated value. If
    ///     `key` isn't already a key of the dictionary, the `(key, value)` pair
    ///     is added.
    /// - Returns: The value that was replaced, or `nil` if a new key-value pair
    ///   was added.
    public mutating func updateValue(_ value: Value, forKey key: Key) -> Value?

    /// Removes and returns the key-value pair at the specified index.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// dictionary.
    ///
    /// - Parameter index: The position of the key-value pair to remove. `index`
    ///   must be a valid index of the dictionary, and must not equal the
    ///   dictionary's end index.
    /// - Returns: The key-value pair that correspond to `index`.
    ///
    /// - Complexity: O(*n*), where *n* is the number of key-value pairs in the
    ///   dictionary.
    public mutating func remove(at index: DictionaryIndex<Key, Value>) -> (key: Key, value: Value)

    /// Removes the given key and its associated value from the dictionary.
    ///
    /// If the key is found in the dictionary, this method returns the key's
    /// associated value. On removal, this method invalidates all indices with
    /// respect to the dictionary.
    ///
    ///     var hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     if let value = hues.removeValue(forKey: "Coral") {
    ///         print("The value \(value) was removed.")
    ///     }
    ///     // Prints "The value 16 was removed."
    ///
    /// If the key isn't found in the dictionary, `removeValue(forKey:)` returns
    /// `nil`.
    ///
    ///     if let value = hues.removeValueForKey("Cerise") {
    ///         print("The value \(value) was removed.")
    ///     } else {
    ///         print("No value found for that key.")
    ///     }
    ///     // Prints "No value found for that key.""
    ///
    /// - Parameter key: The key to remove along with its associated value.
    /// - Returns: The value that was removed, or `nil` if the key was not
    ///   present in the dictionary.
    ///
    /// - Complexity: O(*n*), where *n* is the number of key-value pairs in the
    ///   dictionary.
    public mutating func removeValue(forKey key: Key) -> Value?

    /// Removes all key-value pairs from the dictionary.
    ///
    /// Calling this method invalidates all indices with respect to the
    /// dictionary.
    ///
    /// - Parameter keepCapacity: Whether the dictionary should keep its
    ///   underlying storage. If you pass `true`, the operation preserves the
    ///   storage capacity that the collection has, otherwise the underlying
    ///   storage is released.  The default is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the number of key-value pairs in the
    ///   dictionary.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)

    /// The number of key-value pairs in the dictionary.
    ///
    /// - Complexity: O(1).
    public var count: Int { get }

    /// Returns an iterator over the dictionary's key-value pairs.
    ///
    /// Iterating over a dictionary yields the key-value pairs as two-element
    /// tuples. You can decompose the tuple in a `for`-`in` loop, which calls
    /// `makeIterator()` behind the scenes, or when calling the iterator's
    /// `next()` method directly.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     for (name, hueValue) in hues {
    ///         print("The hue of \(name) is \(hueValue).")
    ///     }
    ///     // Prints "The hue of Heliotrope is 296."
    ///     // Prints "The hue of Coral is 16."
    ///     // Prints "The hue of Aquamarine is 156."
    ///
    /// - Returns: An iterator over the dictionary with elements of type
    ///   `(key: Key, value: Value)`.
    public func makeIterator() -> DictionaryIterator<Key, Value>

    /// Creates a dictionary initialized with a dictionary literal.
    ///
    /// Do not call this initializer directly. It is called by the compiler to
    /// handle dictionary literals. To use a dictionary literal as the initial
    /// value of a dictionary, enclose a comma-separated list of key-value pairs
    /// in square brackets.
    ///
    /// For example, the code sample below creates a dictionary with string keys
    /// and values.
    ///
    ///     let countryCodes = ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"]
    ///     print(countryCodes)
    ///     // Prints "["BR": "Brazil", "JP": "Japan", "GH": "Ghana"]"
    ///
    /// - Parameter elements: The key-value pairs that will make up the new
    ///   dictionary. Each key in `elements` must be unique.
    ///
    /// - SeeAlso: `DictionaryLiteralConvertible`
    public init(dictionaryLiteral elements: (Key, Value)...)

    /// A collection containing just the keys of the dictionary.
    ///
    /// When iterated over, keys appear in this collection in the same order as they
    /// occur in the dictionary's key-value pairs. Each key in the keys
    /// collection has a unique value.
    ///
    ///     let countryCodes = ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"]
    ///     for k in countryCodes.keys {
    ///         print(k)
    ///     }
    ///     // Prints "BR"
    ///     // Prints "JP"
    ///     // Prints "GH"
    public var keys: LazyMapCollection<[Key : Value], Key> { get }

    /// A collection containing just the values of the dictionary.
    ///
    /// When iterated over, values appear in this collection in the same order as they
    /// occur in the dictionary's key-value pairs.
    ///
    ///     let countryCodes = ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"]
    ///     print(countryCodes)
    ///     // Prints "["BR": "Brazil", "JP": "Japan", "GH": "Ghana"]"
    ///     for v in countryCodes.values {
    ///         print(v)
    ///     }
    ///     // Prints "Brazil"
    ///     // Prints "Japan"
    ///     // Prints "Ghana"
    public var values: LazyMapCollection<[Key : Value], Value> { get }

    /// A Boolean value that indicates whether the dictionary is empty. (read
    /// only)
    ///
    /// Dictionaries are empty when created with an initializer or an empty
    /// dictionary literal.
    ///
    ///     var frequencies: [String: Int] = [:]
    ///     print(frequencies.isEmpty)
    ///     // Prints "true"
    public var isEmpty: Bool { get }
}

extension Dictionary : CustomStringConvertible, CustomDebugStringConvertible {

    /// A string that represents the contents of the dictionary.
    public var description: String { get }

    /// A string that represents the contents of the dictionary, suitable for
    /// debugging.
    public var debugDescription: String { get }
}

extension Dictionary : CustomReflectable {

    /// A mirror that reflects the dictionary.
    public var customMirror: Mirror { get }
}

extension Dictionary {

    /// Removes and returns the first key-value pair of the dictionary if the
    /// dictionary isn't empty.
    ///
    /// The first element of the dictionary is not necessarily the first element
    /// added. Don't expect any particular ordering of key-value pairs.
    ///
    /// - Returns: The first key-value pair of the dictionary if the dictionary
    ///   is not empty; otherwise, `nil`.
    ///
    /// - Complexity: Averages to O(1) over many calls to `popFirst()`.
    public mutating func popFirst() -> (key: Key, value: Value)?
}

/// Used to access the key-value pairs in an instance of
/// `Dictionary<Key, Value>`.
///
/// Dictionary has two subscripting interfaces:
///
/// 1. Subscripting with a key, yielding an optional value:
///
///        v = d[k]!
///
/// 2. Subscripting with an index, yielding a key-value pair:
///
///        (k, v) = d[i]
public struct DictionaryIndex<Key : Hashable, Value> : Comparable {
}

/// An iterator over the members of a `Dictionary<Key, Value>`.
public struct DictionaryIterator<Key : Hashable, Value> : IteratorProtocol {

    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    ///
    /// - Precondition: No preceding call to `self.next()` has returned `nil`.
    public mutating func next() -> (key: Key, value: Value)?
}

extension DictionaryIterator : CustomReflectable {

    /// A mirror that reflects the iterator.
    public var customMirror: Mirror { get }
}

/// A lightweight collection of key-value pairs.
///
/// Use a `DictionaryLiteral` instance when you need an ordered collection of
/// key-value pairs and don't require the fast key lookup that the
/// `Dictionary` type provides. Unlike key-value pairs in a true dictionary,
/// neither the key nor the value of a `DictionaryLiteral` instance must
/// conform to the `Hashable` protocol.
///
/// You initialize a `DictionaryLiteral` instance using a Swift dictionary
/// literal. Besides maintaining the order of the original dictionary literal,
/// `DictionaryLiteral` also allows duplicates keys. For example:
///
///     let recordTimes: DictionaryLiteral = ["Florence Griffith-Joyner": 10.49,
///                                           "Evelyn Ashford": 10.76,
///                                           "Evelyn Ashford": 10.79,
///                                           "Marlies Gohr": 10.81]
///     print(recordTimes.first!)
///     // Prints "("Florence Griffith-Joyner", 10.49)"
///
/// Some operations that are efficient on a dictionary are slower when using
/// `DictionaryLiteral`. In particular, to find the value matching a key, you
/// must search through every element of the collection. The call to
/// `index(where:)` in the following example must traverse the whole
/// collection to make sure that no element matches the given predicate:
///
///     let runner = "Marlies Gohr"
///     if let index = recordTimes.index(where: { $0.0 == runner }) {
///         let time = recordTimes[index].1
///         print("\(runner) set a 100m record of \(time) seconds.")
///     } else {
///         print("\(runner) couldn't be found in the records.")
///     }
///     // Prints "Marlies Gohr set a 100m record of 10.81 seconds."
///
/// Dictionary Literals as Function Parameters
/// ------------------------------------------
///
/// When calling a function with a `DictionaryLiteral` parameter, you can pass
/// a Swift dictionary literal without causing a `Dictionary` to be created.
/// This capability can be especially important when the order of elements in
/// the literal is significant.
///
/// For example, you could create an `IntPairs` structure that holds a list of
/// two-integer tuples and use an initializer that accepts a
/// `DictionaryLiteral` instance.
///
///     struct IntPairs {
///         var elements: [(Int, Int)]
///
///         init(_ elements: DictionaryLiteral<Int, Int>) {
///             self.elements = Array(elements)
///         }
///     }
///
/// When you're ready to create a new `IntPairs` instance, use a dictionary
/// literal as the parameter to the `IntPairs` initializer. The
/// `DictionaryLiteral` instance preserves the order of the elements as
/// passed.
///
///     let pairs = IntPairs([1: 2, 1: 1, 3: 4, 2: 1])
///     print(pairs.elements)
///     // Prints "[(1, 2), (1, 1), (3, 4), (2, 1)]"
public struct DictionaryLiteral<Key, Value> : DictionaryLiteralConvertible {

    /// Creates a new `DictionaryLiteral` instance from the given dictionary
    /// literal.
    ///
    /// The order of the key-value pairs is kept intact in the resulting
    /// `DictionaryLiteral` instance.
    public init(dictionaryLiteral elements: (Key, Value)...)
}

/// `Collection` conformance that allows `DictionaryLiteral` to
/// interoperate with the rest of the standard library.
extension DictionaryLiteral : RandomAccessCollection {

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = CountableRange<Int>

    /// The position of the first element in a nonempty collection.
    ///
    /// If the `DictionaryLiteral` instance is empty, `startIndex` is equal to
    /// `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// If the `DictionaryLiteral` instance is empty, `endIndex` is equal to
    /// `startIndex`.
    public var endIndex: Int { get }

    /// The element type of a `DictionaryLiteral`: a tuple containing an
    /// individual key-value pair.
    public typealias Element = (key: Key, value: Value)

    /// Accesses the element at the specified position.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    /// - Returns: The key-value pair at position `position`.
    public subscript(position: Int) -> (key: Key, value: Value) { get }
}

/// A type that can be initialized using a dictionary literal.
///
/// A dictionary literal is a simple way of writing a list of key-value pairs.
/// You write each key-value pair with a colon (`:`) separating the key and
/// the value. The dictionary literal is made up of one or more key-value
/// pairs, separated by commas and surrounded with square brackets.
///
/// To declare a dictionary, assign a dictionary literal to a variable or
/// constant:
///
///     let countryCodes = ["BR": "Brazil", "GH": "Ghana",
///                         "JP": "Japan", "US": "United States"]
///     // 'countryCodes' has type [String: String]
///
///     print(countryCodes["BR"]!)
///     // Prints "Brazil"
///
/// When the context provides enough type information, you can use a special
/// form of the dictionary literal, square brackets surrounding a single
/// colon, to initialize an empty dictionary.
///
///     var frequencies: [String: Int] = [:]
///     print(frequencies.count)
///     // Prints "0"
///
/// - Note: A dictionary literal is *not* the same as an instance of
///   `Dictionary` or the similarly named `DictionaryLiteral` type. You can't
///   initialize a type that conforms to `DictionaryLiteralConvertible` simply
///   by assigning an instance of one of these types.
///
/// Conforming to the DictionaryLiteralConvertible Protocol
/// =======================================================
///
/// To add the capability to be initialized with a dictionary literal to your
/// own custom types, declare an `init(dictionaryLiteral:)` initializer. The
/// following example shows the dictionary literal initializer for a
/// hypothetical `CountedSet` type, which uses setlike semantics while keeping
/// track of the count for duplicate elements:
///
///     struct CountedSet<Element: Hashable>: Collection, SetAlgebra {
///         // implementation details
///
///         /// Updates the count stored in the set for the given element,
///         /// adding the element if necessary.
///         ///
///         /// - Parameter n: The new count for `element`. `n` must be greater
///         ///   than or equal to zero.
///         /// - Parameter element: The element to set the new count on.
///         mutating func updateCount(_ n: Int, for element: Element)
///     }
///
///     extension CountedSet: DictionaryLiteralConvertible {
///         init(dictionaryLiteral elements: (Element, Int)...) {
///             self.init()
///             for (element, count) in elements {
///                 self.updateCount(count, for: element)
///             }
///         }
///     }
public protocol DictionaryLiteralConvertible {

    /// The key type of a dictionary literal.
    associatedtype Key

    /// The value type of a dictionary literal.
    associatedtype Value

    /// Create an instance initialized with `elements`.
    public init(dictionaryLiteral elements: (Self.Key, Self.Value)...)
}

/// A double-precision floating-point value type.
public struct Double {

    /// Create an instance initialized to zero.
    public init()

    public init(_bits v: Builtin.FPIEEE64)

    /// Create an instance initialized to `value`.
    public init(_ value: Double)
}

extension Double {

    /// Construct from an ASCII representation.
    ///
    /// Returns the result of calling the POSIX function
    /// `strtod_l` using the "C" locale, unless
    /// `text` contains non-ASCII text or whitespace, or is not
    /// completely consumed by the call. Otherwise, returns `nil`.
    ///
    /// See the `strtod (3)` man page for details of
    /// the exact format accepted.
    public init?(_ text: String)
}

extension Double : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension Double : CustomDebugStringConvertible {

    /// A textual representation of `self`.
    public var debugDescription: String { get }
}

extension Double : BinaryFloatingPoint {

    /// An integer type that can represent any written exponent.
    public typealias Exponent = Int

    /// An unsigned integer type that can represent the significand of any value.
    ///
    /// The significand (http://en.wikipedia.org/wiki/Significand) is frequently
    /// also called the "mantissa", but this terminology is slightly incorrect
    /// (see the "Use of 'mantissa'" section on the linked Wikipedia page for
    /// more details).  "Significand" is the preferred terminology in IEEE 754.
    public typealias RawSignificand = UInt64

    /// The number of bits used to represent the exponent.
    ///
    /// Following IEEE 754 encoding convention, the exponent bias is:
    ///
    /// ~~~
    /// bias = 2**(exponentBitCount-1) - 1
    /// ~~~
    ///
    /// (where `**` is exponentiation).  The least normal exponent is `1-bias`
    /// and the largest finite exponent is `bias`.  The all-zeros exponent is
    /// reserved for subnormals and zeros, and the all-ones exponent is reserved
    /// for infinities and NaNs.
    public static var exponentBitCount: Int { get }

    /// For fixed-width floating-point types, this is the number of fractional
    /// significand bits.
    ///
    /// For extensible floating-point types, `significandBitCount` should be
    /// the maximum allowed significand width (without counting any leading
    /// integral bit of the significand).  If there is no upper limit, then
    /// `significandBitCount` should be `Int.max`.
    ///
    /// Note that `Float80.significandBitCount` is 63, even though 64 bits
    /// are used to store the significand in the memory representation of a
    /// `Float80` (unlike other floating-point types, `Float80` explicitly
    /// stores the leading integral significand bit, but the
    /// `BinaryFloatingPoint` APIs provide an abstraction so that users don't
    /// need to be aware of this detail).
    public static var significandBitCount: Int { get }

    public var bitPattern: UInt64 { get }

    public init(bitPattern: UInt64)

    /// `minus` if the signbit of `self` is set, and `plus` otherwise.
    /// Implements the IEEE 754 `signbit` operation.
    ///
    /// Note that the property `x.sign == .minus` is not the same as `x < 0`.
    /// In particular, `x < 0` while `x.sign == .minus` if `x` is -0, and while
    /// `x < 0` is always false if `x` is NaN, `x.sign` could be either `.plus`
    /// or `.minus`.
    public var sign: FloatingPointSign { get }

    /// The raw encoding of the exponent field of the floating-point value.
    public var exponentBitPattern: UInt { get }

    /// The raw encoding of the significand field of the floating-point value.
    ///
    /// `significandBitPattern` does *not* include the leading integral bit of
    /// the significand, even for types like `Float80` that store it explicitly.
    public var significandBitPattern: UInt64 { get }

    /// Combines `sign`, `exponent` and `significand` bit patterns to produce
    /// a floating-point value.
    public init(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)

    /// True if and only if `self` is canonical.
    ///
    /// Every floating-point value of type Float or Double is canonical, but
    /// non-canonical values of type Float80 exist, and non-canonical values
    /// may exist for other types that conform to FloatingPoint.
    ///
    /// The non-canonical Float80 values are known as "pseudo-denormal",
    /// "unnormal", "pseudo-infinity", and "pseudo-NaN".
    /// (https://en.wikipedia.org/wiki/Extended_precision#x86_Extended_Precision_Format)
    public var isCanonical: Bool { get }

    /// Positive infinity.  Compares greater than all finite numbers.
    public static var infinity: Double { get }

    /// A quiet NaN (not-a-number).  Compares not equal to every value,
    /// including itself.
    public static var nan: Double { get }

    /// A signaling NaN (not-a-number).
    ///
    /// The default IEEE 754 behavior of operations involving a signaling NaN
    /// is to raise the Invalid flag in the floating-point environment and
    /// return a quiet NaN.  Operations on types conforming to FloatingPoint
    /// should support this behavior, but they might also support other options;
    /// for example, it would be reasonable to implement alternative operations
    /// in which operating on a signaling NaN is a `fatalError()` or results in
    /// a diagnostic for debugging purposes.
    public static var signalingNaN: Double { get }

    /// The greatest finite number.
    ///
    /// Compares greater than or equal to all finite numbers, but less than
    /// infinity.  Corresponds to the C macros `FLT_MAX`, `DBL_MAX`, etc.
    /// The naming of those macros is slightly misleading, because infinity
    /// is greater than this value.
    public static var greatestFiniteMagnitude: Double { get }

    /// The mathematical constant pi = 3.14159...
    ///
    /// Extensible floating-point types might provide additional APIs to obtain
    /// this value to caller-specified precision.
    public static var pi: Double { get }

    /// The unit in the last place of `self`.
    ///
    /// This is the unit of the least significant digit in the significand of
    /// `self`.  For most numbers `x`, this is the difference between `x` and
    /// the next greater (in magnitude) representable number.  There are some
    /// edge cases to be aware of:
    ///
    /// - `greatestFiniteMagnitude.ulp` is a finite number, even though
    ///   the next greater representable value is `infinity`.
    /// - `x.ulp` is `NaN` if `x` is not a finite number.
    /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal
    ///   number.  On targets that do not support subnormals, `x.ulp` may be
    ///   flushed to zero.
    ///
    /// This quantity, or a related quantity is sometimes called "epsilon" or
    /// "machine epsilon".  We avoid that name because it has different meanings
    /// in different languages, which can lead to confusion, and because it
    /// suggests that it is a good tolerance to use for comparisons,
    /// which is almost never is.
    ///
    /// (See https://en.wikipedia.org/wiki/Machine_epsilon for more detail)
    public var ulp: Double { get }

    /// The least positive normal number.
    ///
    /// Compares less than or equal to all positive normal numbers.  There may
    /// be smaller positive numbers, but they are "subnormal", meaning that
    /// they are represented with less precision than normal numbers.
    /// Corresponds to the C macros `FLT_MIN`, `DBL_MIN`, etc.  The naming of
    /// those macros is slightly misleading, because subnormals, zeros, and
    /// negative numbers are smaller than this value.
    public static var leastNormalMagnitude: Double { get }

    /// The least positive number.
    ///
    /// Compares less than or equal to all positive numbers, but greater than
    /// zero.  If the target supports subnormal values, this is smaller than
    /// `leastNormalMagnitude`; otherwise they are equal.
    public static var leastNonzeroMagnitude: Double { get }

    /// The integer part of the base-r logarithm of the magnitude of `self`,
    /// where r is the radix (2 for binary, 10 for decimal).  Implements the
    /// IEEE 754 `logB` operation.
    ///
    /// Edge cases:
    ///
    /// - If `x` is zero, then `x.exponent` is `Int.min`.
    /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`
    public var exponent: Int { get }

    /// The significand satisfies:
    ///
    /// ~~~
    /// self = (sign == .minus ? -1 : 1) * significand * radix**exponent
    /// ~~~
    ///
    /// (where `**` is exponentiation).  If radix is 2, then for finite non-zero
    /// numbers `1 <= significand` and `significand < 2`.  For other values of
    /// `x`, `x.significand` is defined as follows:
    ///
    /// - If `x` is zero, then `x.significand` is 0.0.
    /// - If `x` is infinity, then `x.significand` is 1.0.
    /// - If `x` is NaN, then `x.significand` is NaN.
    ///
    /// For all floating-point `x`, if we define y by:
    ///
    /// ~~~
    /// let y = Self(sign: x.sign, exponent: x.exponent,
    ///              significand: x.significand)
    /// ~~~
    ///
    /// then `y` is equivalent to `x`, meaning that `y` is `x` canonicalized.
    public var significand: Double { get }

    /// Initialize from sign, exponent, and significand.
    ///
    /// The result is:
    ///
    /// ~~~
    /// (sign == .minus ? -1 : 1) * significand * radix**exponent
    /// ~~~
    ///
    /// (where `**` is exponentiation) computed as if by a single correctly-
    /// rounded floating-point operation.  If this value is outside the
    /// representable range of the type, overflow or underflow occurs, and zero,
    /// a subnormal value, or infinity may result, as with any basic operation.
    /// Other edge cases:
    ///
    /// - If `significand` is zero or infinite, the result is zero or infinite,
    ///   regardless of the value of `exponent`.
    ///
    /// - If `significand` is NaN, the result is NaN.
    ///
    /// Note that for any floating-point `x` the result of
    ///
    ///   `Self(sign: x.sign,
    ///         exponent: x.exponent,
    ///         significand: x.significand)`
    ///
    /// is "the same" as `x`; it is `x` canonicalized.
    ///
    /// This initializer implements the IEEE 754 `scaleB` operation.
    public init(sign: FloatingPointSign, exponent: Int, significand: Double)

    /// NaN with specified `payload`.
    ///
    /// Compares not equal to every value, including itself.  Most operations
    /// with a NaN operand will produce a NaN result.
    public init(nan payload: RawSignificand, signaling: Bool)

    /// The least representable value that compares greater than `self`.
    ///
    /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestMagnitude`.
    /// - If `x` is `-leastNonzeroMagnitude`, then `x.nextUp` is `-0.0`.
    /// - If `x` is zero, then `x.nextUp` is `leastNonzeroMagnitude`.
    /// - If `x` is `greatestMagnitude`, then `x.nextUp` is `infinity`.
    /// - If `x` is `infinity` or `NaN`, then `x.nextUp` is `x`.
    public var nextUp: Double { get }

    /// The greatest representable value that compares less than `self`.
    ///
    /// `x.nextDown` is equivalent to `-(-x).nextUp`
    public var nextDown: Double { get }

    /// Replace `self` with its additive inverse.
    public mutating func negate()

    /// Replace `self` with the sum of `self` and `other` rounded to a
    /// representable value.
    public mutating func add(_ other: Double)

    /// Replace `self` with the sum of `self` and the additive inverse of `other`
    /// rounded to a representable value.
    public mutating func subtract(_ other: Double)

    /// Replace `self` with the product of `self` and `other` rounded to a
    /// representable value.
    public mutating func multiply(by other: Double)

    /// Replace `self` with the quotient of `self` and `other` rounded to a
    /// representable value.
    public mutating func divide(by other: Double)

    /// Mutating form of `truncatingRemainder`.
    public mutating func formTruncatingRemainder(dividingBy other: Double)

    /// IEEE 754 equality predicate.
    ///
    /// -0 compares equal to +0, and NaN compares not equal to anything,
    /// including itself.
    public func isEqual(to other: Double) -> Bool

    /// IEEE 754 less-than predicate.
    ///
    /// NaN compares not less than anything.  -infinity compares less than
    /// all values except for itself and NaN.  Everything except for NaN and
    /// +infinity compares less than +infinity.
    public func isLess(than other: Double) -> Bool

    /// IEEE 754 less-than-or-equal predicate.
    ///
    /// NaN compares not less than or equal to anything, including itself.
    /// -infinity compares less than or equal to everything except NaN.
    /// Everything except NaN compares less than or equal to +infinity.
    ///
    /// Because of the existence of NaN in FloatingPoint types, trichotomy does
    /// not hold, which means that `x < y` and `!(y <= x)` are not equivalent.
    /// This is why `isLessThanOrEqualTo(_:)` is a separate implementation hook
    /// in the protocol.
    ///
    /// Note that this predicate does not impose a total order.  The
    /// `isTotallyOrdered` predicate refines this relation so that all values
    /// are totally ordered.
    public func isLessThanOrEqualTo(_ other: Double) -> Bool

    /// True if and only if `self` is normal.
    ///
    /// A normal number uses the full precision available in the format.  Zero
    /// is not a normal number.
    public var isNormal: Bool { get }

    /// True if and only if `self` is finite.
    ///
    /// If `x.isFinite` is `true`, then one of `x.isZero`, `x.isSubnormal`, or
    /// `x.isNormal` is also `true`, and `x.isInfinite` and `x.isNaN` are
    /// `false`.
    public var isFinite: Bool { get }

    /// True iff `self` is zero.  Equivalent to `self == 0`.
    public var isZero: Bool { get }

    /// True if and only if `self` is subnormal.
    ///
    /// A subnormal number does not use the full precision available to normal
    /// numbers of the same format.  Zero is not a subnormal number.
    ///
    /// Subnormal numbers are often called "denormal" or "denormalized".  These
    /// are simply different names for the same concept.  IEEE 754 prefers the
    /// name "subnormal", and we follow that usage.
    public var isSubnormal: Bool { get }

    /// True if and only if `self` is infinite.
    ///
    /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because
    /// they are not total.  If `x` is `NaN`, then both properties are `false`.
    public var isInfinite: Bool { get }

    /// True if and only if `self` is NaN ("not a number"); this property is
    /// true for both quiet and signaling NaNs.
    public var isNaN: Bool { get }

    /// True if and only if `self` is a signaling NaN.
    public var isSignalingNaN: Bool { get }

    /// The least-magnitude member of the binade of `self`.
    ///
    /// If `x` is `+/-significand * 2**exponent`, then `x.binade` is
    /// `+/- 2**exponent`; i.e. the floating point number with the same sign
    /// and exponent, but with a significand of 1.0.
    public var binade: Double { get }

    /// The number of bits required to represent significand.
    ///
    /// If `self` is not a finite non-zero number, `significandWidth` is
    /// `-1`.  Otherwise, it is the number of fractional bits required to
    /// represent `self.significand`, which is an integer between zero and
    /// `significandBitCount`.  Some examples:
    ///
    /// - For any representable power of two, `significandWidth` is zero,
    ///   because `significand` is `1.0`.
    /// - If `x` is 10, then `x.significand` is `1.01` in binary, so
    ///   `x.significandWidth` is 2.
    /// - If `x` is Float.pi, `x.significand` is `1.10010010000111111011011`,
    ///   and `x.significandWidth` is 23.
    public var significandWidth: Int { get }

    /// Create an instance initialized to `value`.
    public init(floatLiteral value: Double)
}

extension Double : IntegerLiteralConvertible {

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: Int64)
}

extension Double {

    public init(_builtinFloatLiteral value: Builtin.FPIEEE80)
}

extension Double : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension Double : AbsoluteValuable {

    /// Returns the absolute value of `x`.
    public static func abs(_ x: Double) -> Double
}

extension Double {

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt8)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int8)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt16)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int16)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt32)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int32)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt64)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int64)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int)
}

extension Double {

    /// Construct an instance that approximates `other`.
    public init(_ other: Float)

    /// Construct an instance that approximates `other`.
    public init(_ other: Float80)
}

extension Double : Strideable {

    /// Returns a stride `x` such that `self.advanced(by: x)` approximates
    /// `other`.
    ///
    /// - Complexity: O(1).
    public func distance(to other: Double) -> Double

    /// Returns a `Self` `x` such that `self.distance(to: x)` approximates
    /// `n`.
    ///
    /// - Complexity: O(1).
    public func advanced(by amount: Double) -> Double
}

extension Double : CustomReflectable {

    /// A mirror that reflects the `Double` instance.
    public var customMirror: Mirror { get }
}

extension Double : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Double {
}

/// A collection whose element type is `Element` but that is always empty.
public struct EmptyCollection<Element> : RandomAccessCollection, MutableCollection, Equatable {

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = Int

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Int

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = EmptyCollection<Element>

    /// Construct an instance.
    public init()

    /// Always zero, just like `endIndex`.
    public var startIndex: Index { get }

    /// Always zero, just like `startIndex`.
    public var endIndex: Index { get }

    /// Always traps.
    ///
    /// EmptyCollection does not have any element indices, so it is not
    /// possible to advance indices.
    public func index(after i: Index) -> Index

    /// Always traps.
    ///
    /// EmptyCollection does not have any element indices, so it is not
    /// possible to advance indices.
    public func index(before i: Index) -> Index

    /// Returns an empty iterator.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> EmptyIterator<Element>

    /// Access the element at `position`.
    ///
    /// Should never be called, since this collection is always empty.
    public subscript(position: Index) -> Element

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Index>) -> EmptyCollection<Element>

    /// The number of elements (always zero).
    public var count: Int { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Index, offsetBy n: IndexDistance) -> Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Index, offsetBy n: IndexDistance, limitedBy limit: Index) -> Index?

    /// The distance between two indexes (always zero).
    public func distance(from start: Index, to end: Index) -> IndexDistance

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = CountableRange<Int>
}

/// An iterator that never produces an element.
///
/// - SeeAlso: `EmptyCollection<Element>`.
public struct EmptyIterator<Element> : IteratorProtocol, Sequence {

    /// Construct an instance.
    public init()

    /// Returns `nil`, indicating that there are no more elements.
    public mutating func next() -> Element?
}

/// The iterator for `EnumeratedSequence`.  `EnumeratedIterator`
/// wraps a `Base` iterator and yields successive `Int` values,
/// starting at zero, along with the elements of the underlying
/// `Base`:
///
///     var iterator = ["foo", "bar"].enumerated().makeIterator()
///     iterator.next() // (0, "foo")
///     iterator.next() // (1, "bar")
///     iterator.next() // nil
///
/// - Note: Idiomatic usage is to call `enumerate` instead of
///   constructing an `EnumerateIterator` directly.
public struct EnumeratedIterator<Base : IteratorProtocol> : IteratorProtocol, Sequence {

    /// The type of element returned by `next()`.
    public typealias Element = (offset: Int, element: Base.Element)

    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    ///
    /// - Requires: No preceding call to `self.next()` has returned `nil`.
    public mutating func next() -> (offset: Int, element: Base.Element)?
}

/// The type of the `enumerated()` property.
///
/// `EnumeratedSequence` is a sequence of pairs (*n*, *x*), where *n*s
/// are consecutive `Int`s starting at zero, and *x*s are the elements
/// of a `Base` `Sequence`:
///
///     var s = ["foo", "bar"].enumerated()
///     Array(s) // [(0, "foo"), (1, "bar")]
public struct EnumeratedSequence<Base : Sequence> : Sequence {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> EnumeratedIterator<Base.Iterator>
}

/// A type that can be compared for value equality.
///
/// Types that conform to the `Equatable` protocol can be compared for equality
/// using the is-equal-to operator (`==`) or inequality using the
/// is-not-equal-to operator (`!=`). Most basic types in the Swift standard
/// library conform to `Equatable`.
///
/// Some sequence and collection operations can be used more simply when the
/// elements conform to `Equatable`. For example, to check whether an array
/// contains a particular value, you can pass the value itself to the
/// `contains(_:)` method when the array's element conforms to `Equatable`
/// instead of providing a closure that determines equivalence. The following
/// example shows how the `contains(_:)` method can be used with an array of
/// strings.
///
///     let students = ["Nora", "Fern", "Ryan", "Rainer"]
///
///     let nameToCheck = "Ryan"
///     if students.contains(nameToCheck) {
///         print("\(nameToCheck) is signed up!")
///     } else {
///         print("No record of \(nameToCheck).")
///     }
///     // Prints "Ryan is signed up!"
///
/// Conforming to the Equatable Protocol
/// ====================================
///
/// Adding `Equatable` conformance to your custom types means that you can use
/// more convenient APIs when searching for particular instances in a
/// collection. `Equatable` is also the base protocol for the `Hashable` and
/// `Comparable` protocols, which allow more uses of your custom type, such as
/// constructing sets or sorting the elements of a collection.
///
/// To adopt the `Equatable` protocol, implement the "is equal to" operator
/// (`==`). The standard library provides an implementation for the "is not
/// equal to" operator (`!=`) for any `Equatable` type, which calls the custom
/// `==` function and negates its result.
///
/// As an example, consider a `StreetAddress` structure that holds the parts of
/// a street address: a house or building number, the street name, and an
/// optional unit number. Here's the initial declaration of the
/// `StreetAddress` type:
///
///     struct StreetAddress {
///         let number: String
///         let street: String
///         let unit: String?
///
///         init(_ number: String, _ street: String, unit: String? = nil) {
///             self.number = number
///             self.street = street
///             self.unit = unit
///         }
///     }
///
/// Now suppose you have an array of addresses that you need to check for a
/// particular address. To use the `contains(_:)` method without including a
/// closure in each call, extend the `StreetAddress` type to conform to
/// `Equatable`.
///
///     extension StreetAddress: Equatable { }
///     func ==(lhs: StreetAddress, rhs: StreetAddress) -> Bool {
///         return
///             lhs.number == rhs.number &&
///             lhs.street == rhs.street &&
///             lhs.unit == rhs.unit
///     }
///
/// The `StreetAddress` type now conforms to `Equatable`. You can use `==` to
/// check for equality between any two instances or call the
/// `Equatable`-constrained `contains(_:)` method.
///
///     let addresses = [StreetAddress("1490", "Grove Street"),
///                      StreetAddress("2119", "Maple Avenue"),
///                      StreetAddress("1400", "16th Street")]
///     let home = StreetAddress("1400", "16th Street")
///
///     print(addresses[0] == home)
///     // Prints "false"
///     print(addresses.contains(home))
///     // Prints "true"
///
/// Equality implies substitutability---any two instances that compare equally
/// can be used interchangeably in any code that depends on their values. To
/// maintain substitutability, the `==` operator should take into account all
/// visible aspects of an `Equatable` type. Exposing nonvalue aspects of
/// `Equatable` types other than class identity is discouraged, and any that
/// *are* exposed should be explicitly pointed out in documentation.
///
/// Since equality between instances of `Equatable` types is an equivalence
/// relation, any of your custom types that conform to `Equatable` must
/// satisfy three conditions, for any values `a`, `b`, and `c`:
///
/// - `a == a` is always `true` (Reflexivity)
/// - `a == b` implies `b == a` (Symmetry)
/// - `a == b` and `b == c` implies `a == c` (Transitivity)
///
/// Moreover, inequality is the inverse of equality, so any custom
/// implementation of the `!=` operator must guarantee that `a != b` implies
/// `!(a == b)`. The default implementation of the `!=` operator function
/// satisfies this requirement.
///
/// Equality is Separate From Identity
/// ----------------------------------
///
/// The identity of a class instance is not part of an instance's value.
/// Consider a class called `IntegerRef` that wraps an integer value. Here's
/// the definition for `IntegerRef` and the `==` function that makes it
/// conform to `Equatable`:
///
///     class IntegerRef: Equatable {
///         let value: Int
///         init(_ value: Int) {
///             self.value = value
///         }
///     }
///
///     func ==(lhs: IntegerRef, rhs: IntegerRef) -> Bool {
///         return lhs.value == rhs.value
///     }
///
/// The implementation of the `==` function returns the same value whether
/// its two arguments are the same instance or are two different instances
/// with the same integer stored in their `value` properties. For example:
///
///     let a = IntegerRef(100)
///     let b = IntegerRef(100)
///
///     print(a == a, a == b, separator: ", ")
///     // Prints "true, true"
///
/// Class instance identity, on the other hand, is compared using the
/// triple-equals "is identical to" operator (`===`). For example:
///
///     let c = a
///     print(a === c, b === c, separator: ", ")
///     // Prints "true, false"
public protocol Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public func ==(lhs: Self, rhs: Self) -> Bool
}

/// A type representing an error value that can be thrown.
///
/// Any type that declares conformance to `ErrorProtocol` can be used to
/// represent an error in Swift's error handling system. Because
/// `ErrorProtocol` has no requirements of its own, you can declare
/// conformance on any custom type you create.
///
/// Using Enumerations as Errors
/// ============================
///
/// Swift's enumerations are well suited to represent simple errors. Create an
/// enumeration that conforms to `ErrorProtocol` with a case for each possible
/// error. If there are additional details about the error that could be
/// helpful for recovery, use associated values to include that information.
///
/// The following example shows an `IntParsingError` enumeration that captures
/// two different kinds of errors that can occur when parsing an integer from
/// a string: overflow, where the value represented by the string is too large
/// for the integer data type, and invalid input, where nonnumeric characters
/// are found within the input.
///
///     enum IntParsingError: ErrorProtocol {
///         case overflow
///         case invalidInput(String)
///     }
///
/// The `invalidInput` case includes the invalid character as an associated
/// value.
///
/// The next code sample shows a possible extension to the `Int` type that
/// parses the integer value of a `String` instance, throwing an error when
/// there is a problem during parsing.
///
///     extension Int {
///         init(validating input: String) throws {
///             // ...
///             if !_isValid(s) {
///                 throw IntParsingError.invalidInput(s)
///             }
///             // ...
///         }
///     }
///
/// When calling the new `Int` initializer within a `do` statement, you can use
/// pattern matching to match specific cases of your custom error type and
/// access their associated values, as in the example below.
///
///     do {
///         let price = try Int(validating: "$100")
///     } catch IntParsingError.invalidInput(let invalid) {
///         print("Invalid character: '\(invalid)'")
///     } catch IntParsingError.overflow {
///         print("Overflow error")
///     } catch {
///         print("Other error")
///     }
///     // Prints "Invalid character: '$'"
///
/// Including More Data in Errors
/// =============================
///
/// Sometimes you may want different error states to include the same common
/// data, such as the position in a file or some of your application's state.
/// When you do, use a structure to represent errors. The following example
/// uses a structure to represent an error when parsing an XML document,
/// including the line and column numbers where the error occurred:
///
///     struct XMLParsingError: ErrorProtocol {
///         enum ErrorKind {
///             case invalidCharacter
///             case mismatchedTag
///             case internalError
///         }
///
///         let line: Int
///         let column: Int
///         let kind: ErrorKind
///     }
///
///     func parse(_ source: String) throws -> XMLDoc {
///         // ...
///         throw XMLParsingError(line: 19, column: 5, kind: .mismatchedTag)
///         // ...
///     }
///
/// Once again, use pattern matching to conditionally catch errors. Here's how
/// you can catch any `XMLParsingError` errors thrown by the `parse(_:)`
/// function:
///
///     do {
///         let xmlDoc = try parse(myXMLData)
///     } catch let e as XMLParsingError {
///         print("Parsing error: \(e.kind) [\(e.line):\(e.column)]")
///     } catch {
///         print("Other error: \(error)")
///     }
///     // Prints "Parsing error: mismatchedTag [19:5]"
public protocol ErrorProtocol {
}

extension ErrorProtocol {
}

/// A type that can be initialized with a string literal containing a single
/// extended grapheme cluster.
///
/// An *extended grapheme cluster* is a group of one or more Unicode code
/// points that approximates a single user-perceived character.  Many
/// individual characters, such as "", "", and "", can be made up of
/// multiple Unicode code points. These code points are combined by Unicode's
/// boundary algorithms into extended grapheme clusters.
///
/// The `String`, `StaticString`, and `Character` types conform to the
/// `ExtendedGraphemeClusterLiteralConvertible` protocol. You can initialize a
/// variable or constant of any of these types using a string literal that
/// holds a single character.
///
///     let snowflake: Character = ""
///     print(snowflake)
///     // Prints ""
///
/// Conforming to ExtendedGraphemeClusterLiteralConvertible
/// =======================================================
///
/// To add `ExtendedGraphemeClusterLiteralConvertible` conformance to your
/// custom type, implement the required initializer.
public protocol ExtendedGraphemeClusterLiteralConvertible : UnicodeScalarLiteralConvertible {

    /// A type that can represent an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    associatedtype ExtendedGraphemeClusterLiteralType

    /// Creates an instance initialized to the given value.
    public init(extendedGraphemeClusterLiteral value: Self.ExtendedGraphemeClusterLiteralType)
}

/// The default type for an otherwise-unconstrained Unicode extended
/// grapheme cluster literal.
public typealias ExtendedGraphemeClusterType = String

/// A flattened view of a base collection of collections.
///
/// The elements of this view are a concatenation of the elements of
/// each collection in the base.
///
/// The `flatten` property is always lazy, but does not implicitly
/// confer laziness on algorithms applied to its result.  In other
/// words, for ordinary collections `c`:
///
/// * `c.flatten()` does not create new storage
/// * `c.flatten().map(f)` maps eagerly and returns a new array
/// * `c.lazy.flatten().map(f)` maps lazily and returns a `LazyMapCollection`
///
/// - Note: The performance of accessing `startIndex`, `first`, any methods
///   that depend on `startIndex`, or of advancing a `FlattenBidirectionalCollectionIndex`
///   depends on how many empty subcollections are found in the base
///   collection, and may not offer the usual performance given by
///   `Collection` or `BidirectionalIndex`. Be aware, therefore, that
///   general operations on `FlattenBidirectionalCollection` instances may not have the
///   documented complexity.
///
/// - See also: `FlattenSequence`
public struct FlattenBidirectionalCollection<Base : BidirectionalCollection where Base.Iterator.Element : BidirectionalCollection> : BidirectionalCollection {

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = FlattenBidirectionalCollectionIndex<Base>

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Base.IndexDistance

    /// Creates a flattened view of `base`.
    public init(_ base: Base)

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> FlattenIterator<Base.Iterator>

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: FlattenBidirectionalCollectionIndex<Base> { get }

    /// The collection's "past the end" position.
    ///
    /// `endIndex` is not a valid argument to `subscript`, and is always
    /// reachable from `startIndex` by zero or more applications of
    /// `index(after:)`.
    public var endIndex: FlattenBidirectionalCollectionIndex<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: FlattenBidirectionalCollectionIndex<Base>) -> FlattenBidirectionalCollectionIndex<Base>

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: FlattenBidirectionalCollectionIndex<Base>) -> FlattenBidirectionalCollectionIndex<Base>

    /// Access the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: FlattenBidirectionalCollectionIndex<Base>) -> Base.Iterator.Element.Iterator.Element { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<FlattenBidirectionalCollectionIndex<Base>>) -> BidirectionalSlice<FlattenBidirectionalCollection<Base>> { get }

    /// A value less than or equal to the number of elements in
    /// the sequence, calculated nondestructively.
    ///
    /// - Complexity: O(1)
    public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: @noescape (Base.Iterator.Element.Iterator.Element) throws -> Swift.Void) rethrows
}

/// A position in a `FlattenBidirectionalCollection`.
public struct FlattenBidirectionalCollectionIndex<BaseElements : BidirectionalCollection where BaseElements.Iterator.Element : BidirectionalCollection> : Comparable {
}

/// A flattened view of a base collection of collections.
///
/// The elements of this view are a concatenation of the elements of
/// each collection in the base.
///
/// The `flatten` property is always lazy, but does not implicitly
/// confer laziness on algorithms applied to its result.  In other
/// words, for ordinary collections `c`:
///
/// * `c.flatten()` does not create new storage
/// * `c.flatten().map(f)` maps eagerly and returns a new array
/// * `c.lazy.flatten().map(f)` maps lazily and returns a `LazyMapCollection`
///
/// - Note: The performance of accessing `startIndex`, `first`, any methods
///   that depend on `startIndex`, or of advancing a `FlattenCollectionIndex`
///   depends on how many empty subcollections are found in the base
///   collection, and may not offer the usual performance given by
///   `Collection` or `ForwardIndex`. Be aware, therefore, that
///   general operations on `FlattenCollection` instances may not have the
///   documented complexity.
///
/// - See also: `FlattenSequence`
public struct FlattenCollection<Base : Collection where Base.Iterator.Element : Collection> : Collection {

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = FlattenCollectionIndex<Base>

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// Creates a flattened view of `base`.
    public init(_ base: Base)

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> FlattenIterator<Base.Iterator>

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: FlattenCollectionIndex<Base> { get }

    /// The collection's "past the end" position.
    ///
    /// `endIndex` is not a valid argument to `subscript`, and is always
    /// reachable from `startIndex` by zero or more applications of
    /// `index(after:)`.
    public var endIndex: FlattenCollectionIndex<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: FlattenCollectionIndex<Base>) -> FlattenCollectionIndex<Base>

    /// Access the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: FlattenCollectionIndex<Base>) -> Base.Iterator.Element.Iterator.Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<FlattenCollectionIndex<Base>>) -> Slice<FlattenCollection<Base>> { get }

    /// A value less than or equal to the number of elements in
    /// the sequence, calculated nondestructively.
    ///
    /// - Complexity: O(1)
    public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: @noescape (Base.Iterator.Element.Iterator.Element) throws -> Swift.Void) rethrows
}

/// A position in a `FlattenCollection`.
public struct FlattenCollectionIndex<BaseElements : Collection where BaseElements.Iterator.Element : Collection> : Comparable {
}

/// An iterator that produces the elements contained in each segment
/// produced by some `Base` Iterator.
///
/// The elements traversed are the concatenation of those in each
/// segment produced by the base iterator.
///
/// - Note: This is the `IteratorProtocol` used by `FlattenSequence`,
///   `FlattenCollection`, and `BidirectionalFlattenCollection`.
public struct FlattenIterator<Base : IteratorProtocol where Base.Element : Sequence> : IteratorProtocol, Sequence {

    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    ///
    /// - Precondition: `next()` has not been applied to a copy of `self`
    ///   since the copy was made, and no preceding call to `self.next()`
    ///   has returned `nil`.
    public mutating func next() -> Base.Element.Iterator.Element?
}

/// A sequence consisting of all the elements contained in each segment
/// contained in some `Base` sequence.
///
/// The elements of this view are a concatenation of the elements of
/// each sequence in the base.
///
/// The `flatten` property is always lazy, but does not implicitly
/// confer laziness on algorithms applied to its result.  In other
/// words, for ordinary sequences `s`:
///
/// * `s.flatten()` does not create new storage
/// * `s.flatten().map(f)` maps eagerly and returns a new array
/// * `s.lazy.flatten().map(f)` maps lazily and returns a `LazyMapSequence`
///
/// - See also: `FlattenCollection`
public struct FlattenSequence<Base : Sequence where Base.Iterator.Element : Sequence> : Sequence {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> FlattenIterator<Base.Iterator>
}

/// A single-precision floating-point value type.
public struct Float {

    /// Create an instance initialized to zero.
    public init()

    public init(_bits v: Builtin.FPIEEE32)

    /// Create an instance initialized to `value`.
    public init(_ value: Float)
}

extension Float {

    /// Construct from an ASCII representation.
    ///
    /// Returns the result of calling the POSIX function
    /// `strtof_l` using the "C" locale, unless
    /// `text` contains non-ASCII text or whitespace, or is not
    /// completely consumed by the call. Otherwise, returns `nil`.
    ///
    /// See the `strtof (3)` man page for details of
    /// the exact format accepted.
    public init?(_ text: String)
}

extension Float : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension Float : CustomDebugStringConvertible {

    /// A textual representation of `self`.
    public var debugDescription: String { get }
}

extension Float : BinaryFloatingPoint {

    /// An integer type that can represent any written exponent.
    public typealias Exponent = Int

    /// An unsigned integer type that can represent the significand of any value.
    ///
    /// The significand (http://en.wikipedia.org/wiki/Significand) is frequently
    /// also called the "mantissa", but this terminology is slightly incorrect
    /// (see the "Use of 'mantissa'" section on the linked Wikipedia page for
    /// more details).  "Significand" is the preferred terminology in IEEE 754.
    public typealias RawSignificand = UInt32

    /// The number of bits used to represent the exponent.
    ///
    /// Following IEEE 754 encoding convention, the exponent bias is:
    ///
    /// ~~~
    /// bias = 2**(exponentBitCount-1) - 1
    /// ~~~
    ///
    /// (where `**` is exponentiation).  The least normal exponent is `1-bias`
    /// and the largest finite exponent is `bias`.  The all-zeros exponent is
    /// reserved for subnormals and zeros, and the all-ones exponent is reserved
    /// for infinities and NaNs.
    public static var exponentBitCount: Int { get }

    /// For fixed-width floating-point types, this is the number of fractional
    /// significand bits.
    ///
    /// For extensible floating-point types, `significandBitCount` should be
    /// the maximum allowed significand width (without counting any leading
    /// integral bit of the significand).  If there is no upper limit, then
    /// `significandBitCount` should be `Int.max`.
    ///
    /// Note that `Float80.significandBitCount` is 63, even though 64 bits
    /// are used to store the significand in the memory representation of a
    /// `Float80` (unlike other floating-point types, `Float80` explicitly
    /// stores the leading integral significand bit, but the
    /// `BinaryFloatingPoint` APIs provide an abstraction so that users don't
    /// need to be aware of this detail).
    public static var significandBitCount: Int { get }

    public var bitPattern: UInt32 { get }

    public init(bitPattern: UInt32)

    /// `minus` if the signbit of `self` is set, and `plus` otherwise.
    /// Implements the IEEE 754 `signbit` operation.
    ///
    /// Note that the property `x.sign == .minus` is not the same as `x < 0`.
    /// In particular, `x < 0` while `x.sign == .minus` if `x` is -0, and while
    /// `x < 0` is always false if `x` is NaN, `x.sign` could be either `.plus`
    /// or `.minus`.
    public var sign: FloatingPointSign { get }

    /// The raw encoding of the exponent field of the floating-point value.
    public var exponentBitPattern: UInt { get }

    /// The raw encoding of the significand field of the floating-point value.
    ///
    /// `significandBitPattern` does *not* include the leading integral bit of
    /// the significand, even for types like `Float80` that store it explicitly.
    public var significandBitPattern: UInt32 { get }

    /// Combines `sign`, `exponent` and `significand` bit patterns to produce
    /// a floating-point value.
    public init(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt32)

    /// True if and only if `self` is canonical.
    ///
    /// Every floating-point value of type Float or Double is canonical, but
    /// non-canonical values of type Float80 exist, and non-canonical values
    /// may exist for other types that conform to FloatingPoint.
    ///
    /// The non-canonical Float80 values are known as "pseudo-denormal",
    /// "unnormal", "pseudo-infinity", and "pseudo-NaN".
    /// (https://en.wikipedia.org/wiki/Extended_precision#x86_Extended_Precision_Format)
    public var isCanonical: Bool { get }

    /// Positive infinity.  Compares greater than all finite numbers.
    public static var infinity: Float { get }

    /// A quiet NaN (not-a-number).  Compares not equal to every value,
    /// including itself.
    public static var nan: Float { get }

    /// A signaling NaN (not-a-number).
    ///
    /// The default IEEE 754 behavior of operations involving a signaling NaN
    /// is to raise the Invalid flag in the floating-point environment and
    /// return a quiet NaN.  Operations on types conforming to FloatingPoint
    /// should support this behavior, but they might also support other options;
    /// for example, it would be reasonable to implement alternative operations
    /// in which operating on a signaling NaN is a `fatalError()` or results in
    /// a diagnostic for debugging purposes.
    public static var signalingNaN: Float { get }

    /// The greatest finite number.
    ///
    /// Compares greater than or equal to all finite numbers, but less than
    /// infinity.  Corresponds to the C macros `FLT_MAX`, `DBL_MAX`, etc.
    /// The naming of those macros is slightly misleading, because infinity
    /// is greater than this value.
    public static var greatestFiniteMagnitude: Float { get }

    /// The mathematical constant pi = 3.14159...
    ///
    /// Extensible floating-point types might provide additional APIs to obtain
    /// this value to caller-specified precision.
    public static var pi: Float { get }

    /// The unit in the last place of `self`.
    ///
    /// This is the unit of the least significant digit in the significand of
    /// `self`.  For most numbers `x`, this is the difference between `x` and
    /// the next greater (in magnitude) representable number.  There are some
    /// edge cases to be aware of:
    ///
    /// - `greatestFiniteMagnitude.ulp` is a finite number, even though
    ///   the next greater representable value is `infinity`.
    /// - `x.ulp` is `NaN` if `x` is not a finite number.
    /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal
    ///   number.  On targets that do not support subnormals, `x.ulp` may be
    ///   flushed to zero.
    ///
    /// This quantity, or a related quantity is sometimes called "epsilon" or
    /// "machine epsilon".  We avoid that name because it has different meanings
    /// in different languages, which can lead to confusion, and because it
    /// suggests that it is a good tolerance to use for comparisons,
    /// which is almost never is.
    ///
    /// (See https://en.wikipedia.org/wiki/Machine_epsilon for more detail)
    public var ulp: Float { get }

    /// The least positive normal number.
    ///
    /// Compares less than or equal to all positive normal numbers.  There may
    /// be smaller positive numbers, but they are "subnormal", meaning that
    /// they are represented with less precision than normal numbers.
    /// Corresponds to the C macros `FLT_MIN`, `DBL_MIN`, etc.  The naming of
    /// those macros is slightly misleading, because subnormals, zeros, and
    /// negative numbers are smaller than this value.
    public static var leastNormalMagnitude: Float { get }

    /// The least positive number.
    ///
    /// Compares less than or equal to all positive numbers, but greater than
    /// zero.  If the target supports subnormal values, this is smaller than
    /// `leastNormalMagnitude`; otherwise they are equal.
    public static var leastNonzeroMagnitude: Float { get }

    /// The integer part of the base-r logarithm of the magnitude of `self`,
    /// where r is the radix (2 for binary, 10 for decimal).  Implements the
    /// IEEE 754 `logB` operation.
    ///
    /// Edge cases:
    ///
    /// - If `x` is zero, then `x.exponent` is `Int.min`.
    /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`
    public var exponent: Int { get }

    /// The significand satisfies:
    ///
    /// ~~~
    /// self = (sign == .minus ? -1 : 1) * significand * radix**exponent
    /// ~~~
    ///
    /// (where `**` is exponentiation).  If radix is 2, then for finite non-zero
    /// numbers `1 <= significand` and `significand < 2`.  For other values of
    /// `x`, `x.significand` is defined as follows:
    ///
    /// - If `x` is zero, then `x.significand` is 0.0.
    /// - If `x` is infinity, then `x.significand` is 1.0.
    /// - If `x` is NaN, then `x.significand` is NaN.
    ///
    /// For all floating-point `x`, if we define y by:
    ///
    /// ~~~
    /// let y = Self(sign: x.sign, exponent: x.exponent,
    ///              significand: x.significand)
    /// ~~~
    ///
    /// then `y` is equivalent to `x`, meaning that `y` is `x` canonicalized.
    public var significand: Float { get }

    /// Initialize from sign, exponent, and significand.
    ///
    /// The result is:
    ///
    /// ~~~
    /// (sign == .minus ? -1 : 1) * significand * radix**exponent
    /// ~~~
    ///
    /// (where `**` is exponentiation) computed as if by a single correctly-
    /// rounded floating-point operation.  If this value is outside the
    /// representable range of the type, overflow or underflow occurs, and zero,
    /// a subnormal value, or infinity may result, as with any basic operation.
    /// Other edge cases:
    ///
    /// - If `significand` is zero or infinite, the result is zero or infinite,
    ///   regardless of the value of `exponent`.
    ///
    /// - If `significand` is NaN, the result is NaN.
    ///
    /// Note that for any floating-point `x` the result of
    ///
    ///   `Self(sign: x.sign,
    ///         exponent: x.exponent,
    ///         significand: x.significand)`
    ///
    /// is "the same" as `x`; it is `x` canonicalized.
    ///
    /// This initializer implements the IEEE 754 `scaleB` operation.
    public init(sign: FloatingPointSign, exponent: Int, significand: Float)

    /// NaN with specified `payload`.
    ///
    /// Compares not equal to every value, including itself.  Most operations
    /// with a NaN operand will produce a NaN result.
    public init(nan payload: RawSignificand, signaling: Bool)

    /// The least representable value that compares greater than `self`.
    ///
    /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestMagnitude`.
    /// - If `x` is `-leastNonzeroMagnitude`, then `x.nextUp` is `-0.0`.
    /// - If `x` is zero, then `x.nextUp` is `leastNonzeroMagnitude`.
    /// - If `x` is `greatestMagnitude`, then `x.nextUp` is `infinity`.
    /// - If `x` is `infinity` or `NaN`, then `x.nextUp` is `x`.
    public var nextUp: Float { get }

    /// The greatest representable value that compares less than `self`.
    ///
    /// `x.nextDown` is equivalent to `-(-x).nextUp`
    public var nextDown: Float { get }

    /// Replace `self` with its additive inverse.
    public mutating func negate()

    /// Replace `self` with the sum of `self` and `other` rounded to a
    /// representable value.
    public mutating func add(_ other: Float)

    /// Replace `self` with the sum of `self` and the additive inverse of `other`
    /// rounded to a representable value.
    public mutating func subtract(_ other: Float)

    /// Replace `self` with the product of `self` and `other` rounded to a
    /// representable value.
    public mutating func multiply(by other: Float)

    /// Replace `self` with the quotient of `self` and `other` rounded to a
    /// representable value.
    public mutating func divide(by other: Float)

    /// Mutating form of `truncatingRemainder`.
    public mutating func formTruncatingRemainder(dividingBy other: Float)

    /// IEEE 754 equality predicate.
    ///
    /// -0 compares equal to +0, and NaN compares not equal to anything,
    /// including itself.
    public func isEqual(to other: Float) -> Bool

    /// IEEE 754 less-than predicate.
    ///
    /// NaN compares not less than anything.  -infinity compares less than
    /// all values except for itself and NaN.  Everything except for NaN and
    /// +infinity compares less than +infinity.
    public func isLess(than other: Float) -> Bool

    /// IEEE 754 less-than-or-equal predicate.
    ///
    /// NaN compares not less than or equal to anything, including itself.
    /// -infinity compares less than or equal to everything except NaN.
    /// Everything except NaN compares less than or equal to +infinity.
    ///
    /// Because of the existence of NaN in FloatingPoint types, trichotomy does
    /// not hold, which means that `x < y` and `!(y <= x)` are not equivalent.
    /// This is why `isLessThanOrEqualTo(_:)` is a separate implementation hook
    /// in the protocol.
    ///
    /// Note that this predicate does not impose a total order.  The
    /// `isTotallyOrdered` predicate refines this relation so that all values
    /// are totally ordered.
    public func isLessThanOrEqualTo(_ other: Float) -> Bool

    /// True if and only if `self` is normal.
    ///
    /// A normal number uses the full precision available in the format.  Zero
    /// is not a normal number.
    public var isNormal: Bool { get }

    /// True if and only if `self` is finite.
    ///
    /// If `x.isFinite` is `true`, then one of `x.isZero`, `x.isSubnormal`, or
    /// `x.isNormal` is also `true`, and `x.isInfinite` and `x.isNaN` are
    /// `false`.
    public var isFinite: Bool { get }

    /// True iff `self` is zero.  Equivalent to `self == 0`.
    public var isZero: Bool { get }

    /// True if and only if `self` is subnormal.
    ///
    /// A subnormal number does not use the full precision available to normal
    /// numbers of the same format.  Zero is not a subnormal number.
    ///
    /// Subnormal numbers are often called "denormal" or "denormalized".  These
    /// are simply different names for the same concept.  IEEE 754 prefers the
    /// name "subnormal", and we follow that usage.
    public var isSubnormal: Bool { get }

    /// True if and only if `self` is infinite.
    ///
    /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because
    /// they are not total.  If `x` is `NaN`, then both properties are `false`.
    public var isInfinite: Bool { get }

    /// True if and only if `self` is NaN ("not a number"); this property is
    /// true for both quiet and signaling NaNs.
    public var isNaN: Bool { get }

    /// True if and only if `self` is a signaling NaN.
    public var isSignalingNaN: Bool { get }

    /// The least-magnitude member of the binade of `self`.
    ///
    /// If `x` is `+/-significand * 2**exponent`, then `x.binade` is
    /// `+/- 2**exponent`; i.e. the floating point number with the same sign
    /// and exponent, but with a significand of 1.0.
    public var binade: Float { get }

    /// The number of bits required to represent significand.
    ///
    /// If `self` is not a finite non-zero number, `significandWidth` is
    /// `-1`.  Otherwise, it is the number of fractional bits required to
    /// represent `self.significand`, which is an integer between zero and
    /// `significandBitCount`.  Some examples:
    ///
    /// - For any representable power of two, `significandWidth` is zero,
    ///   because `significand` is `1.0`.
    /// - If `x` is 10, then `x.significand` is `1.01` in binary, so
    ///   `x.significandWidth` is 2.
    /// - If `x` is Float.pi, `x.significand` is `1.10010010000111111011011`,
    ///   and `x.significandWidth` is 23.
    public var significandWidth: Int { get }

    /// Create an instance initialized to `value`.
    public init(floatLiteral value: Float)
}

extension Float : IntegerLiteralConvertible {

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: Int64)
}

extension Float {

    public init(_builtinFloatLiteral value: Builtin.FPIEEE80)
}

extension Float : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension Float : AbsoluteValuable {

    /// Returns the absolute value of `x`.
    public static func abs(_ x: Float) -> Float
}

extension Float {

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt8)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int8)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt16)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int16)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt32)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int32)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt64)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int64)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int)
}

extension Float {

    /// Construct an instance that approximates `other`.
    public init(_ other: Double)

    /// Construct an instance that approximates `other`.
    public init(_ other: Float80)
}

extension Float : Strideable {

    /// Returns a stride `x` such that `self.advanced(by: x)` approximates
    /// `other`.
    ///
    /// - Complexity: O(1).
    public func distance(to other: Float) -> Float

    /// Returns a `Self` `x` such that `self.distance(to: x)` approximates
    /// `n`.
    ///
    /// - Complexity: O(1).
    public func advanced(by amount: Float) -> Float
}

extension Float : CustomReflectable {

    /// A mirror that reflects the `Float` instance.
    public var customMirror: Mirror { get }
}

extension Float : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Float {
}

/// A 32-bit floating point type.
public typealias Float32 = Float

/// A 64-bit floating point type.
public typealias Float64 = Double

/// An extended-precision floating-point value type.
public struct Float80 {

    /// Create an instance initialized to zero.
    public init()

    public init(_bits v: Builtin.FPIEEE80)

    /// Create an instance initialized to `value`.
    public init(_ value: Float80)
}

extension Float80 {

    /// Construct from an ASCII representation.
    ///
    /// Returns the result of calling the POSIX function
    /// `strtold_l` using the "C" locale, unless
    /// `text` contains non-ASCII text or whitespace, or is not
    /// completely consumed by the call. Otherwise, returns `nil`.
    ///
    /// See the `strtold (3)` man page for details of
    /// the exact format accepted.
    public init?(_ text: String)
}

extension Float80 : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension Float80 : CustomDebugStringConvertible {

    /// A textual representation of `self`.
    public var debugDescription: String { get }
}

extension Float80 : BinaryFloatingPoint {

    /// An integer type that can represent any written exponent.
    public typealias Exponent = Int

    /// An unsigned integer type that can represent the significand of any value.
    ///
    /// The significand (http://en.wikipedia.org/wiki/Significand) is frequently
    /// also called the "mantissa", but this terminology is slightly incorrect
    /// (see the "Use of 'mantissa'" section on the linked Wikipedia page for
    /// more details).  "Significand" is the preferred terminology in IEEE 754.
    public typealias RawSignificand = UInt64

    /// The number of bits used to represent the exponent.
    ///
    /// Following IEEE 754 encoding convention, the exponent bias is:
    ///
    /// ~~~
    /// bias = 2**(exponentBitCount-1) - 1
    /// ~~~
    ///
    /// (where `**` is exponentiation).  The least normal exponent is `1-bias`
    /// and the largest finite exponent is `bias`.  The all-zeros exponent is
    /// reserved for subnormals and zeros, and the all-ones exponent is reserved
    /// for infinities and NaNs.
    public static var exponentBitCount: Int { get }

    /// For fixed-width floating-point types, this is the number of fractional
    /// significand bits.
    ///
    /// For extensible floating-point types, `significandBitCount` should be
    /// the maximum allowed significand width (without counting any leading
    /// integral bit of the significand).  If there is no upper limit, then
    /// `significandBitCount` should be `Int.max`.
    ///
    /// Note that `Float80.significandBitCount` is 63, even though 64 bits
    /// are used to store the significand in the memory representation of a
    /// `Float80` (unlike other floating-point types, `Float80` explicitly
    /// stores the leading integral significand bit, but the
    /// `BinaryFloatingPoint` APIs provide an abstraction so that users don't
    /// need to be aware of this detail).
    public static var significandBitCount: Int { get }

    /// `minus` if the signbit of `self` is set, and `plus` otherwise.
    /// Implements the IEEE 754 `signbit` operation.
    ///
    /// Note that the property `x.sign == .minus` is not the same as `x < 0`.
    /// In particular, `x < 0` while `x.sign == .minus` if `x` is -0, and while
    /// `x < 0` is always false if `x` is NaN, `x.sign` could be either `.plus`
    /// or `.minus`.
    public var sign: FloatingPointSign { get }

    /// The raw encoding of the exponent field of the floating-point value.
    public var exponentBitPattern: UInt { get }

    /// The raw encoding of the significand field of the floating-point value.
    ///
    /// `significandBitPattern` does *not* include the leading integral bit of
    /// the significand, even for types like `Float80` that store it explicitly.
    public var significandBitPattern: UInt64 { get }

    /// Combines `sign`, `exponent` and `significand` bit patterns to produce
    /// a floating-point value.
    public init(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)

    /// True if and only if `self` is canonical.
    ///
    /// Every floating-point value of type Float or Double is canonical, but
    /// non-canonical values of type Float80 exist, and non-canonical values
    /// may exist for other types that conform to FloatingPoint.
    ///
    /// The non-canonical Float80 values are known as "pseudo-denormal",
    /// "unnormal", "pseudo-infinity", and "pseudo-NaN".
    /// (https://en.wikipedia.org/wiki/Extended_precision#x86_Extended_Precision_Format)
    public var isCanonical: Bool { get }

    /// Positive infinity.  Compares greater than all finite numbers.
    public static var infinity: Float80 { get }

    /// A quiet NaN (not-a-number).  Compares not equal to every value,
    /// including itself.
    public static var nan: Float80 { get }

    /// A signaling NaN (not-a-number).
    ///
    /// The default IEEE 754 behavior of operations involving a signaling NaN
    /// is to raise the Invalid flag in the floating-point environment and
    /// return a quiet NaN.  Operations on types conforming to FloatingPoint
    /// should support this behavior, but they might also support other options;
    /// for example, it would be reasonable to implement alternative operations
    /// in which operating on a signaling NaN is a `fatalError()` or results in
    /// a diagnostic for debugging purposes.
    public static var signalingNaN: Float80 { get }

    /// The greatest finite number.
    ///
    /// Compares greater than or equal to all finite numbers, but less than
    /// infinity.  Corresponds to the C macros `FLT_MAX`, `DBL_MAX`, etc.
    /// The naming of those macros is slightly misleading, because infinity
    /// is greater than this value.
    public static var greatestFiniteMagnitude: Float80 { get }

    /// The mathematical constant pi = 3.14159...
    ///
    /// Extensible floating-point types might provide additional APIs to obtain
    /// this value to caller-specified precision.
    public static var pi: Float80 { get }

    /// The unit in the last place of `self`.
    ///
    /// This is the unit of the least significant digit in the significand of
    /// `self`.  For most numbers `x`, this is the difference between `x` and
    /// the next greater (in magnitude) representable number.  There are some
    /// edge cases to be aware of:
    ///
    /// - `greatestFiniteMagnitude.ulp` is a finite number, even though
    ///   the next greater representable value is `infinity`.
    /// - `x.ulp` is `NaN` if `x` is not a finite number.
    /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal
    ///   number.  On targets that do not support subnormals, `x.ulp` may be
    ///   flushed to zero.
    ///
    /// This quantity, or a related quantity is sometimes called "epsilon" or
    /// "machine epsilon".  We avoid that name because it has different meanings
    /// in different languages, which can lead to confusion, and because it
    /// suggests that it is a good tolerance to use for comparisons,
    /// which is almost never is.
    ///
    /// (See https://en.wikipedia.org/wiki/Machine_epsilon for more detail)
    public var ulp: Float80 { get }

    /// The least positive normal number.
    ///
    /// Compares less than or equal to all positive normal numbers.  There may
    /// be smaller positive numbers, but they are "subnormal", meaning that
    /// they are represented with less precision than normal numbers.
    /// Corresponds to the C macros `FLT_MIN`, `DBL_MIN`, etc.  The naming of
    /// those macros is slightly misleading, because subnormals, zeros, and
    /// negative numbers are smaller than this value.
    public static var leastNormalMagnitude: Float80 { get }

    /// The least positive number.
    ///
    /// Compares less than or equal to all positive numbers, but greater than
    /// zero.  If the target supports subnormal values, this is smaller than
    /// `leastNormalMagnitude`; otherwise they are equal.
    public static var leastNonzeroMagnitude: Float80 { get }

    /// The integer part of the base-r logarithm of the magnitude of `self`,
    /// where r is the radix (2 for binary, 10 for decimal).  Implements the
    /// IEEE 754 `logB` operation.
    ///
    /// Edge cases:
    ///
    /// - If `x` is zero, then `x.exponent` is `Int.min`.
    /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`
    public var exponent: Int { get }

    /// The significand satisfies:
    ///
    /// ~~~
    /// self = (sign == .minus ? -1 : 1) * significand * radix**exponent
    /// ~~~
    ///
    /// (where `**` is exponentiation).  If radix is 2, then for finite non-zero
    /// numbers `1 <= significand` and `significand < 2`.  For other values of
    /// `x`, `x.significand` is defined as follows:
    ///
    /// - If `x` is zero, then `x.significand` is 0.0.
    /// - If `x` is infinity, then `x.significand` is 1.0.
    /// - If `x` is NaN, then `x.significand` is NaN.
    ///
    /// For all floating-point `x`, if we define y by:
    ///
    /// ~~~
    /// let y = Self(sign: x.sign, exponent: x.exponent,
    ///              significand: x.significand)
    /// ~~~
    ///
    /// then `y` is equivalent to `x`, meaning that `y` is `x` canonicalized.
    public var significand: Float80 { get }

    /// Initialize from sign, exponent, and significand.
    ///
    /// The result is:
    ///
    /// ~~~
    /// (sign == .minus ? -1 : 1) * significand * radix**exponent
    /// ~~~
    ///
    /// (where `**` is exponentiation) computed as if by a single correctly-
    /// rounded floating-point operation.  If this value is outside the
    /// representable range of the type, overflow or underflow occurs, and zero,
    /// a subnormal value, or infinity may result, as with any basic operation.
    /// Other edge cases:
    ///
    /// - If `significand` is zero or infinite, the result is zero or infinite,
    ///   regardless of the value of `exponent`.
    ///
    /// - If `significand` is NaN, the result is NaN.
    ///
    /// Note that for any floating-point `x` the result of
    ///
    ///   `Self(sign: x.sign,
    ///         exponent: x.exponent,
    ///         significand: x.significand)`
    ///
    /// is "the same" as `x`; it is `x` canonicalized.
    ///
    /// This initializer implements the IEEE 754 `scaleB` operation.
    public init(sign: FloatingPointSign, exponent: Int, significand: Float80)

    /// NaN with specified `payload`.
    ///
    /// Compares not equal to every value, including itself.  Most operations
    /// with a NaN operand will produce a NaN result.
    public init(nan payload: RawSignificand, signaling: Bool)

    /// The least representable value that compares greater than `self`.
    ///
    /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestMagnitude`.
    /// - If `x` is `-leastNonzeroMagnitude`, then `x.nextUp` is `-0.0`.
    /// - If `x` is zero, then `x.nextUp` is `leastNonzeroMagnitude`.
    /// - If `x` is `greatestMagnitude`, then `x.nextUp` is `infinity`.
    /// - If `x` is `infinity` or `NaN`, then `x.nextUp` is `x`.
    public var nextUp: Float80 { get }

    /// The greatest representable value that compares less than `self`.
    ///
    /// `x.nextDown` is equivalent to `-(-x).nextUp`
    public var nextDown: Float80 { get }

    /// Replace `self` with its additive inverse.
    public mutating func negate()

    /// Replace `self` with the sum of `self` and `other` rounded to a
    /// representable value.
    public mutating func add(_ other: Float80)

    /// Replace `self` with the sum of `self` and the additive inverse of `other`
    /// rounded to a representable value.
    public mutating func subtract(_ other: Float80)

    /// Replace `self` with the product of `self` and `other` rounded to a
    /// representable value.
    public mutating func multiply(by other: Float80)

    /// Replace `self` with the quotient of `self` and `other` rounded to a
    /// representable value.
    public mutating func divide(by other: Float80)

    /// Mutating form of `truncatingRemainder`.
    public mutating func formTruncatingRemainder(dividingBy other: Float80)

    /// IEEE 754 equality predicate.
    ///
    /// -0 compares equal to +0, and NaN compares not equal to anything,
    /// including itself.
    public func isEqual(to other: Float80) -> Bool

    /// IEEE 754 less-than predicate.
    ///
    /// NaN compares not less than anything.  -infinity compares less than
    /// all values except for itself and NaN.  Everything except for NaN and
    /// +infinity compares less than +infinity.
    public func isLess(than other: Float80) -> Bool

    /// IEEE 754 less-than-or-equal predicate.
    ///
    /// NaN compares not less than or equal to anything, including itself.
    /// -infinity compares less than or equal to everything except NaN.
    /// Everything except NaN compares less than or equal to +infinity.
    ///
    /// Because of the existence of NaN in FloatingPoint types, trichotomy does
    /// not hold, which means that `x < y` and `!(y <= x)` are not equivalent.
    /// This is why `isLessThanOrEqualTo(_:)` is a separate implementation hook
    /// in the protocol.
    ///
    /// Note that this predicate does not impose a total order.  The
    /// `isTotallyOrdered` predicate refines this relation so that all values
    /// are totally ordered.
    public func isLessThanOrEqualTo(_ other: Float80) -> Bool

    /// True if and only if `self` is normal.
    ///
    /// A normal number uses the full precision available in the format.  Zero
    /// is not a normal number.
    public var isNormal: Bool { get }

    /// True if and only if `self` is finite.
    ///
    /// If `x.isFinite` is `true`, then one of `x.isZero`, `x.isSubnormal`, or
    /// `x.isNormal` is also `true`, and `x.isInfinite` and `x.isNaN` are
    /// `false`.
    public var isFinite: Bool { get }

    /// True iff `self` is zero.  Equivalent to `self == 0`.
    public var isZero: Bool { get }

    /// True if and only if `self` is subnormal.
    ///
    /// A subnormal number does not use the full precision available to normal
    /// numbers of the same format.  Zero is not a subnormal number.
    ///
    /// Subnormal numbers are often called "denormal" or "denormalized".  These
    /// are simply different names for the same concept.  IEEE 754 prefers the
    /// name "subnormal", and we follow that usage.
    public var isSubnormal: Bool { get }

    /// True if and only if `self` is infinite.
    ///
    /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because
    /// they are not total.  If `x` is `NaN`, then both properties are `false`.
    public var isInfinite: Bool { get }

    /// True if and only if `self` is NaN ("not a number"); this property is
    /// true for both quiet and signaling NaNs.
    public var isNaN: Bool { get }

    /// True if and only if `self` is a signaling NaN.
    public var isSignalingNaN: Bool { get }

    /// The least-magnitude member of the binade of `self`.
    ///
    /// If `x` is `+/-significand * 2**exponent`, then `x.binade` is
    /// `+/- 2**exponent`; i.e. the floating point number with the same sign
    /// and exponent, but with a significand of 1.0.
    public var binade: Float80 { get }

    /// The number of bits required to represent significand.
    ///
    /// If `self` is not a finite non-zero number, `significandWidth` is
    /// `-1`.  Otherwise, it is the number of fractional bits required to
    /// represent `self.significand`, which is an integer between zero and
    /// `significandBitCount`.  Some examples:
    ///
    /// - For any representable power of two, `significandWidth` is zero,
    ///   because `significand` is `1.0`.
    /// - If `x` is 10, then `x.significand` is `1.01` in binary, so
    ///   `x.significandWidth` is 2.
    /// - If `x` is Float.pi, `x.significand` is `1.10010010000111111011011`,
    ///   and `x.significandWidth` is 23.
    public var significandWidth: Int { get }

    /// Create an instance initialized to `value`.
    public init(floatLiteral value: Float80)
}

extension Float80 : IntegerLiteralConvertible {

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: Int64)
}

extension Float80 {

    public init(_builtinFloatLiteral value: Builtin.FPIEEE80)
}

extension Float80 : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension Float80 : AbsoluteValuable {

    /// Returns the absolute value of `x`.
    public static func abs(_ x: Float80) -> Float80
}

extension Float80 {

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt8)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int8)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt16)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int16)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt32)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int32)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt64)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int64)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: UInt)

    /// `value` rounded to the closest representable `Self`.
    public init(_ v: Int)
}

extension Float80 {

    /// Construct an instance that approximates `other`.
    public init(_ other: Float)

    /// Construct an instance that approximates `other`.
    public init(_ other: Double)
}

extension Float80 : Strideable {

    /// Returns a stride `x` such that `self.advanced(by: x)` approximates
    /// `other`.
    ///
    /// - Complexity: O(1).
    public func distance(to other: Float80) -> Float80

    /// Returns a `Self` `x` such that `self.distance(to: x)` approximates
    /// `n`.
    ///
    /// - Complexity: O(1).
    public func advanced(by amount: Float80) -> Float80
}

/// Conforming types can be initialized with floating point literals.
public protocol FloatLiteralConvertible {

    associatedtype FloatLiteralType

    /// Create an instance initialized to `value`.
    public init(floatLiteral value: Self.FloatLiteralType)
}

/// The default type for an otherwise-unconstrained floating point literal.
public typealias FloatLiteralType = Double

/// A floating-point type that provides most of the IEEE 754 basic (clause 5)
/// operations.  The base, precision, and exponent range are not fixed in
/// any way by this protocol, but it enforces the basic requirements of
/// any IEEE 754 floating-point type.
///
/// The BinaryFloatingPoint protocol refines these requirements, adds some
/// additional operations that only make sense for a fixed radix, and also
/// provides default implementations of some of the FloatingPoint APIs.
public protocol FloatingPoint : Comparable, IntegerLiteralConvertible, SignedNumber, AbsoluteValuable, Strideable {

    /// An integer type that can represent any written exponent.
    associatedtype Exponent : SignedInteger

    /// Initialize to zero
    public init()

    /// Initialize from sign, exponent, and significand.
    ///
    /// The result is:
    ///
    /// ~~~
    /// (sign == .minus ? -1 : 1) * significand * radix**exponent
    /// ~~~
    ///
    /// (where `**` is exponentiation) computed as if by a single correctly-
    /// rounded floating-point operation.  If this value is outside the
    /// representable range of the type, overflow or underflow occurs, and zero,
    /// a subnormal value, or infinity may result, as with any basic operation.
    /// Other edge cases:
    ///
    /// - If `significand` is zero or infinite, the result is zero or infinite,
    ///   regardless of the value of `exponent`.
    ///
    /// - If `significand` is NaN, the result is NaN.
    ///
    /// Note that for any floating-point `x` the result of
    ///
    ///   `Self(sign: x.sign,
    ///         exponent: x.exponent,
    ///         significand: x.significand)`
    ///
    /// is "the same" as `x`; it is `x` canonicalized.
    ///
    /// This initializer implements the IEEE 754 `scaleB` operation.
    public init(sign: FloatingPointSign, exponent: Self.Exponent, significand: Self)

    /// A floating point value whose exponent and significand are taken from
    /// `magnitude` and whose sign is taken from `signOf`.  Implements the
    /// IEEE 754 `copysign` operation.
    public init(signOf: Self, magnitudeOf: Self)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: UInt8)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: Int8)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: UInt16)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: Int16)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: UInt32)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: Int32)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: UInt64)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: Int64)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: UInt)

    /// `value` rounded to the closest representable `Self`.
    public init(_ value: Int)

    /// 2 for binary floating-point types, 10 for decimal.
    ///
    /// A conforming type may use any integer radix, but values other than
    /// 2 or 10 are extraordinarily rare in practice.
    public static var radix: Int { get }

    /// A quiet NaN (not-a-number).  Compares not equal to every value,
    /// including itself.
    public static var nan: Self { get }

    /// A signaling NaN (not-a-number).
    ///
    /// The default IEEE 754 behavior of operations involving a signaling NaN
    /// is to raise the Invalid flag in the floating-point environment and
    /// return a quiet NaN.  Operations on types conforming to FloatingPoint
    /// should support this behavior, but they might also support other options;
    /// for example, it would be reasonable to implement alternative operations
    /// in which operating on a signaling NaN is a `fatalError()` or results in
    /// a diagnostic for debugging purposes.
    public static var signalingNaN: Self { get }

    /// Positive infinity.  Compares greater than all finite numbers.
    public static var infinity: Self { get }

    /// The greatest finite number.
    ///
    /// Compares greater than or equal to all finite numbers, but less than
    /// infinity.  Corresponds to the C macros `FLT_MAX`, `DBL_MAX`, etc.
    /// The naming of those macros is slightly misleading, because infinity
    /// is greater than this value.
    public static var greatestFiniteMagnitude: Self { get }

    /// The mathematical constant pi = 3.14159...
    ///
    /// Extensible floating-point types might provide additional APIs to obtain
    /// this value to caller-specified precision.
    public static var pi: Self { get }

    /// The unit in the last place of `self`.
    ///
    /// This is the unit of the least significant digit in the significand of
    /// `self`.  For most numbers `x`, this is the difference between `x` and
    /// the next greater (in magnitude) representable number.  There are some
    /// edge cases to be aware of:
    ///
    /// - `greatestFiniteMagnitude.ulp` is a finite number, even though
    ///   the next greater representable value is `infinity`.
    /// - `x.ulp` is `NaN` if `x` is not a finite number.
    /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal
    ///   number.  On targets that do not support subnormals, `x.ulp` may be
    ///   flushed to zero.
    ///
    /// This quantity, or a related quantity is sometimes called "epsilon" or
    /// "machine epsilon".  We avoid that name because it has different meanings
    /// in different languages, which can lead to confusion, and because it
    /// suggests that it is a good tolerance to use for comparisons,
    /// which is almost never is.
    ///
    /// (See https://en.wikipedia.org/wiki/Machine_epsilon for more detail)
    public var ulp: Self { get }

    /// The unit in the last place of 1.0.
    ///
    /// The positive difference between 1.0 and the next greater representable
    /// number.  Corresponds to the C macros `FLT_EPSILON`, `DBL_EPSILON`, etc.
    public static var ulpOfOne: Self { get }

    /// The least positive normal number.
    ///
    /// Compares less than or equal to all positive normal numbers.  There may
    /// be smaller positive numbers, but they are "subnormal", meaning that
    /// they are represented with less precision than normal numbers.
    /// Corresponds to the C macros `FLT_MIN`, `DBL_MIN`, etc.  The naming of
    /// those macros is slightly misleading, because subnormals, zeros, and
    /// negative numbers are smaller than this value.
    public static var leastNormalMagnitude: Self { get }

    /// The least positive number.
    ///
    /// Compares less than or equal to all positive numbers, but greater than
    /// zero.  If the target supports subnormal values, this is smaller than
    /// `leastNormalMagnitude`; otherwise they are equal.
    public static var leastNonzeroMagnitude: Self { get }

    /// `minus` if the signbit of `self` is set, and `plus` otherwise.
    /// Implements the IEEE 754 `signbit` operation.
    ///
    /// Note that the property `x.sign == .minus` is not the same as `x < 0`.
    /// In particular, `x < 0` while `x.sign == .minus` if `x` is -0, and while
    /// `x < 0` is always false if `x` is NaN, `x.sign` could be either `.plus`
    /// or `.minus`.
    public var sign: FloatingPointSign { get }

    /// The integer part of the base-r logarithm of the magnitude of `self`,
    /// where r is the radix (2 for binary, 10 for decimal).  Implements the
    /// IEEE 754 `logB` operation.
    ///
    /// Edge cases:
    ///
    /// - If `x` is zero, then `x.exponent` is `Int.min`.
    /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`
    public var exponent: Self.Exponent { get }

    /// The significand satisfies:
    ///
    /// ~~~
    /// self = (sign == .minus ? -1 : 1) * significand * radix**exponent
    /// ~~~
    ///
    /// (where `**` is exponentiation).  If radix is 2, then for finite non-zero
    /// numbers `1 <= significand` and `significand < 2`.  For other values of
    /// `x`, `x.significand` is defined as follows:
    ///
    /// - If `x` is zero, then `x.significand` is 0.0.
    /// - If `x` is infinity, then `x.significand` is 1.0.
    /// - If `x` is NaN, then `x.significand` is NaN.
    ///
    /// For all floating-point `x`, if we define y by:
    ///
    /// ~~~
    /// let y = Self(sign: x.sign, exponent: x.exponent,
    ///              significand: x.significand)
    /// ~~~
    ///
    /// then `y` is equivalent to `x`, meaning that `y` is `x` canonicalized.
    public var significand: Self { get }

    /// Sum of `self` and `other` rounded to a representable value.  The IEEE
    /// 754 addition operation.
    ///
    /// A default implementation is provided in terms of `add()`.
    public func adding(_ other: Self) -> Self

    /// Replace `self` with the sum of `self` and `other` rounded to a
    /// representable value.
    public mutating func add(_ other: Self)

    /// Additive inverse of `self`.  Always exact.
    public func negated() -> Self

    /// Replace `self` with its additive inverse.
    public mutating func negate()

    /// Sum of `self` and the additive inverse of `other` rounded to a
    /// representable value.  The IEEE 754 subtraction operation.
    ///
    /// A default implementation is provided in terms of `subtract()`.
    public func subtracting(_ other: Self) -> Self

    /// Replace `self` with the sum of `self` and the additive inverse of `other`
    /// rounded to a representable value.
    public mutating func subtract(_ other: Self)

    /// Product of `self` and `other` rounded to a representable value.  The
    /// IEEE 754 multiply operation.
    ///
    /// A default implementation is provided in terms of `multiply(by:)`.
    public func multiplied(by other: Self) -> Self

    /// Replace `self` with the product of `self` and `other` rounded to a
    /// representable value.
    public mutating func multiply(by other: Self)

    /// Quotient of `self` and `other` rounded to a representable value.  The
    /// IEEE 754 divide operation.
    ///
    /// A default implementation is provided in terms of `divide(by:)`.
    public func divided(by other: Self) -> Self

    /// Replace `self` with the quotient of `self` and `other` rounded to a
    /// representable value.
    public mutating func divide(by other: Self)

    /// Remainder of `self` divided by `other` using truncating division.
    /// Equivalent to the C standard library function `fmod`.
    ///
    /// If `self` and `other` are finite numbers, the truncating remainder
    /// `r` has the same sign as `other` and is strictly smaller in magnitude.
    /// It satisfies `r = self - other*n`, where `n` is the integral part
    /// of `self/other`.
    ///
    /// `truncatingRemainder` is always exact.
    public func truncatingRemainder(dividingBy other: Self) -> Self

    /// Mutating form of `truncatingRemainder`.
    public mutating func formTruncatingRemainder(dividingBy other: Self)

    /// The minimum of `x` and `y`.  Implements the IEEE 754 `minNum` operation.
    ///
    /// Returns `x` if `x <= y`, `y` if `y < x`, and whichever of `x` or `y`
    /// is a number if the other is NaN.  The result is NaN only if both
    /// arguments are NaN.
    ///
    /// This function is an implementation hook to be used by the free function
    /// min(Self, Self) -> Self so that we get the IEEE 754 behavior with regard
    /// to NaNs.
    public static func minimum(_ x: Self, _ y: Self) -> Self

    /// The maximum of `x` and `y`.  Implements the IEEE 754 `maxNum` operation.
    ///
    /// Returns `x` if `x >= y`, `y` if `y > x`, and whichever of `x` or `y`
    /// is a number if the other is NaN.  The result is NaN only if both
    /// arguments are NaN.
    ///
    /// This function is an implementation hook to be used by the free function
    /// max(Self, Self) -> Self so that we get the IEEE 754 behavior with regard
    /// to NaNs.
    public static func maximum(_ x: Self, _ y: Self) -> Self

    /// Whichever of `x` or `y` has lesser magnitude.  Implements the IEEE 754
    /// `minNumMag` operation.
    ///
    /// Returns `x` if abs(x) <= abs(y), `y` if abs(y) < abs(x), and whichever of
    /// `x` or `y` is a number if the other is NaN.  The result is NaN
    /// only if both arguments are NaN.
    public static func minimumMagnitude(_ x: Self, _ y: Self) -> Self

    /// Whichever of `x` or `y` has greater magnitude.  Implements the IEEE 754
    /// `maxNumMag` operation.
    ///
    /// Returns `x` if abs(x) >= abs(y), `y` if abs(y) > abs(x), and whichever of
    /// `x` or `y` is a number if the other is NaN.  The result is NaN
    /// only if both arguments are NaN.
    public static func maximumMagnitude(_ x: Self, _ y: Self) -> Self

    /// The least representable value that compares greater than `self`.
    ///
    /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestMagnitude`.
    /// - If `x` is `-leastNonzeroMagnitude`, then `x.nextUp` is `-0.0`.
    /// - If `x` is zero, then `x.nextUp` is `leastNonzeroMagnitude`.
    /// - If `x` is `greatestMagnitude`, then `x.nextUp` is `infinity`.
    /// - If `x` is `infinity` or `NaN`, then `x.nextUp` is `x`.
    public var nextUp: Self { get }

    /// The greatest representable value that compares less than `self`.
    ///
    /// `x.nextDown` is equivalent to `-(-x).nextUp`
    public var nextDown: Self { get }

    /// IEEE 754 equality predicate.
    ///
    /// -0 compares equal to +0, and NaN compares not equal to anything,
    /// including itself.
    public func isEqual(to other: Self) -> Bool

    /// IEEE 754 less-than predicate.
    ///
    /// NaN compares not less than anything.  -infinity compares less than
    /// all values except for itself and NaN.  Everything except for NaN and
    /// +infinity compares less than +infinity.
    public func isLess(than other: Self) -> Bool

    /// IEEE 754 less-than-or-equal predicate.
    ///
    /// NaN compares not less than or equal to anything, including itself.
    /// -infinity compares less than or equal to everything except NaN.
    /// Everything except NaN compares less than or equal to +infinity.
    ///
    /// Because of the existence of NaN in FloatingPoint types, trichotomy does
    /// not hold, which means that `x < y` and `!(y <= x)` are not equivalent.
    /// This is why `isLessThanOrEqualTo(_:)` is a separate implementation hook
    /// in the protocol.
    ///
    /// Note that this predicate does not impose a total order.  The
    /// `isTotallyOrdered` predicate refines this relation so that all values
    /// are totally ordered.
    public func isLessThanOrEqualTo(_ other: Self) -> Bool

    /// True if and only if `self` precedes `other` in the IEEE 754 total order
    /// relation.
    ///
    /// This relation is a refinement of `<=` that provides a total order on all
    /// values of type `Self`, including non-canonical encodings, signed zeros,
    /// and NaNs.  Because it is used much less frequently than the usual
    /// comparisons, there is no operator form of this relation.
    public func isTotallyOrdered(below other: Self) -> Bool

    /// True if and only if `self` is normal.
    ///
    /// A normal number uses the full precision available in the format.  Zero
    /// is not a normal number.
    public var isNormal: Bool { get }

    /// True if and only if `self` is finite.
    ///
    /// If `x.isFinite` is `true`, then one of `x.isZero`, `x.isSubnormal`, or
    /// `x.isNormal` is also `true`, and `x.isInfinite` and `x.isNaN` are
    /// `false`.
    public var isFinite: Bool { get }

    /// True iff `self` is zero.  Equivalent to `self == 0`.
    public var isZero: Bool { get }

    /// True if and only if `self` is subnormal.
    ///
    /// A subnormal number does not use the full precision available to normal
    /// numbers of the same format.  Zero is not a subnormal number.
    ///
    /// Subnormal numbers are often called "denormal" or "denormalized".  These
    /// are simply different names for the same concept.  IEEE 754 prefers the
    /// name "subnormal", and we follow that usage.
    public var isSubnormal: Bool { get }

    /// True if and only if `self` is infinite.
    ///
    /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because
    /// they are not total.  If `x` is `NaN`, then both properties are `false`.
    public var isInfinite: Bool { get }

    /// True if and only if `self` is NaN ("not a number"); this property is
    /// true for both quiet and signaling NaNs.
    public var isNaN: Bool { get }

    /// True if and only if `self` is a signaling NaN.
    public var isSignalingNaN: Bool { get }

    /// The IEEE 754 "class" of this type.
    public var floatingPointClass: FloatingPointClassification { get }

    /// True if and only if `self` is canonical.
    ///
    /// Every floating-point value of type Float or Double is canonical, but
    /// non-canonical values of type Float80 exist, and non-canonical values
    /// may exist for other types that conform to FloatingPoint.
    ///
    /// The non-canonical Float80 values are known as "pseudo-denormal",
    /// "unnormal", "pseudo-infinity", and "pseudo-NaN".
    /// (https://en.wikipedia.org/wiki/Extended_precision#x86_Extended_Precision_Format)
    public var isCanonical: Bool { get }
}

extension FloatingPoint {

    public static var ulpOfOne: Self { get }

    public func truncatingRemainder(dividingBy rhs: Self) -> Self

    public static func minimum(_ left: Self, _ right: Self) -> Self

    public static func maximum(_ left: Self, _ right: Self) -> Self

    public static func minimumMagnitude(_ left: Self, _ right: Self) -> Self

    public static func maximumMagnitude(_ left: Self, _ right: Self) -> Self

    public var floatingPointClass: FloatingPointClassification { get }

    public func adding(_ other: Self) -> Self

    public func subtracting(_ other: Self) -> Self

    public func multiplied(by other: Self) -> Self

    public func divided(by other: Self) -> Self

    public func negated() -> Self
}

/// The IEEE 754 floating-point classes.
public enum FloatingPointClassification {

    case signalingNaN

    case quietNaN

    case negativeInfinity

    case negativeNormal

    case negativeSubnormal

    case negativeZero

    case positiveZero

    case positiveSubnormal

    case positiveNormal

    case positiveInfinity
}

/// The sign of a floating-point value.
public enum FloatingPointSign : Int {

    case plus

    case minus
}

/// A type that provides an integer hash value.
///
/// You can use any type that conforms to the `Hashable` protocol in a set or
/// as a dictionary key. Many types in the standard library conform to
/// `Hashable`: strings, integers, floating-point and Boolean values, and even
/// sets provide a hash value by default. Your own custom types can be
/// hashable as well. When you define an enumeration without associated
/// values, it gains `Hashable` conformance automatically, and you can add
/// `Hashable` conformance to your other custom types by adding a single
/// `hashValue` property.
///
/// A hash value, provided by a type's `hashValue` property, is an integer that
/// is the same for any two instances that compare equally. That is, for two
/// instances `a` and `b` of the same type, if `a == b` then
/// `a.hashValue == b.hashValue`. The reverse is not true: Two instances with
/// equal hash values are not necessarily equal to each other.
///
/// - Important: Hash values are not guaranteed to be equal across different
///   executions of your program. Do not save hash values to use during a
///   future execution.
///
/// Conforming to the Hashable Protocol
/// ===================================
///
/// To use your own custom type in a set or as the key type of a dictionary,
/// add `Hashable` conformance to your type by providing a `hashValue`
/// property. The `Hashable` protocol inherits from the `Equatable` protocol,
/// so you must also add an is-equal-to operator (`==`) function for your
/// custom type.
///
/// As an example, consider a `GridPoint` type that describes a location in a
/// grid of buttons. Here's the initial declaration of the `GridPoint` type:
///
///     /// A point in an x-y coordinate system.
///     struct GridPoint {
///         var x: Int
///         var y: Int
///     }
///
/// You'd like to create a set of the grid points where a user has already
/// tapped. Because the `GridPoint` type is not hashable yet, it can't be used
/// as the `Element` type for a set. To add `Hashable` conformance, provide an
/// `==` operator function and a `hashValue` property.
///
///     func ==(lhs: GridPoint, rhs: GridPoint) -> Bool {
///         return lhs.x == rhs.x && lhs.y == rhs.y
///     }
///
///     extension GridPoint: Hashable {
///         var hashValue: Int {
///             return x.hashValue ^ y.hashValue
///         }
///     }
///
/// The `hashValue` property in this example combines the hash values of a grid
/// point's `x` and `y` values using the bitwise XOR operator (`^`). The `^`
/// operator is one way to combine two integer values into a single value.
///
/// - Note: Set and dictionary performance depends on hash values that minimize
///   collisions for their associated element and key types, respectively.
///
/// Now that `GridPoint` conforms to the `Hashable` protocol, you can create a
/// set of previously tapped grid points.
///
///     var tappedPoints: Set = [GridPoint(x: 2, y: 3), GridPoint(x: 4, y: 1)]
///     let nextTap = GridPoint(x: 0, y: 1)
///     if tappedPoints.contains(nextTap) {
///         print("Already tapped at (\(nextTap.x), \(nextTap.y)).")
///     } else {
///         tappedPoints.insert(nextTap)
///         print("New tap detected at (\(nextTap.x), \(nextTap.y)).")
///     }
///     // Prints "New tap detected at (0, 1).")
public protocol Hashable : Equatable {

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }
}

/// An optional type that allows implicit member access.
///
/// *Deprecated.*
public enum ImplicitlyUnwrappedOptional<Wrapped> : NilLiteralConvertible {

    /// The absence of a value. Typically written using the nil literal, `nil`.
    case none

    /// The presence of a value, stored as `Wrapped`.
    case some(Wrapped)

    /// Creates an instance that stores the given value.
    public init(_ some: Wrapped)

    /// Creates an instance initialized with `nil`.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you initialize an `Optional` instance with a `nil` literal. For example:
    ///
    ///     let i: Index! = nil
    public init(nilLiteral: ())
}

extension ImplicitlyUnwrappedOptional : CustomStringConvertible {

    /// A textual representation of the value, or `nil`.
    public var description: String { get }
}

/// Directly conform to CustomDebugStringConvertible to support
/// optional printing. Implementation of that feature relies on
/// _isOptional thus cannot distinguish ImplicitlyUnwrappedOptional
/// from Optional. When conditional conformance is available, this
/// outright conformance can be removed.
extension ImplicitlyUnwrappedOptional : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    public var debugDescription: String { get }
}

extension ImplicitlyUnwrappedOptional {
}

/// A type that provides subscript access to its elements, with forward index
/// traversal.
///
/// In most cases, it's best to ignore this protocol and use the `Collection`
/// protocol instead, because it has a more complete interface.
public protocol Indexable : IndexableBase {

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    associatedtype IndexDistance : SignedInteger = Int

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance) -> Self.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position. The
    /// operation doesn't require going beyond the limiting `s.endIndex` value,
    /// so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance, limitedBy limit: Self.Index) -> Self.Index?

    /// Offsets the given index by the specified distance.
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout Self.Index, offsetBy n: Self.IndexDistance)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: `true` if `i` has been offset by exactly `n` steps without
    ///   going beyond `limit`; otherwise, `false`. When the return value is
    ///   `false`, the value of `i` is equal to `limit`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout Self.Index, offsetBy n: Self.IndexDistance, limitedBy limit: Self.Index) -> Bool

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Self.Index, to end: Self.Index) -> Self.IndexDistance
}

/// Default implementation for forward collections.
extension Indexable {

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Self.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance) -> Self.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance, limitedBy limit: Self.Index) -> Self.Index?

    /// Offsets the given index by the specified distance.
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout Self.Index, offsetBy n: Self.IndexDistance)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: `true` if `i` has been offset by exactly `n` steps without
    ///   going beyond `limit`; otherwise, `false`. When the return value is
    ///   `false`, the value of `i` is equal to `limit`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout Self.Index, offsetBy n: Self.IndexDistance, limitedBy limit: Self.Index) -> Bool

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Self.Index, to end: Self.Index) -> Self.IndexDistance
}

extension Indexable {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: ClosedRange<Self.Index>) -> Self.SubSequence { get }
}

extension Indexable where Index : Strideable, Index.Stride : SignedInteger {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: CountableRange<Self.Index>) -> Self.SubSequence { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: CountableClosedRange<Self.Index>) -> Self.SubSequence { get }
}

/// A type that provides subscript access to its elements, with forward
/// index traversal.
///
/// In most cases, it's best to ignore this protocol and use the `Collection`
/// protocol instead, because it has a more complete interface.
public protocol IndexableBase {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    associatedtype Index : Comparable

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Self.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Self.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(position: Self.Index) -> Self._Element { get }

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    associatedtype SubSequence

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Self.Index>) -> Self.SubSequence { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Self.Index) -> Self.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Self.Index)
}

/// A type that iterates over a collection using its indices.
///
/// The `IndexingIterator` type is the default iterator for any collection that
/// doesn't declare its own. It acts as an iterator by using a collection's
/// indices to step over each value in the collection. Most collections in the
/// standard library use `IndexingIterator` as their iterator.
///
/// By default, any custom collection type you create will inherit a
/// `makeIterator()` method that returns an `IndexingIterator` instance,
/// making it unnecessary to declare your own. When creating a custom
/// collection type, add the minimal requirements of the `Collection`
/// protocol: starting and ending indices and a subscript for accessing
/// elements. With those elements defined, the inherited `makeIterator()`
/// method satisfies the requirements of the `Sequence` protocol.
///
/// Here's an example of a type that declares the minimal requirements for a
/// collection. The `CollectionOfTwo` structure is a fixed-size collection
/// that always holds two elements of a specific type.
///
///     struct CollectionOfTwo<Element>: Collection {
///         let elements: (Element, Element)
///
///         init(_ first: Element, _ second: Element) {
///             self.elements = (first, second)
///         }
///
///         var startIndex: Int { return 0 }
///         var endIndex: Int   { return 2 }
///
///         subscript(index: Int) -> Element {
///             switch index {
///             case 0: return elements.0
///             case 1: return elements.1
///             default: fatalError("Index out of bounds.")
///             }
///         }
///         
///         func index(after i: Int) -> Int {
///             precondition(i < endIndex, "Can't advance beyond endIndex")
///             return i + 1
///         }
///     }
///
/// The `CollectionOfTwo` type uses the default iterator type,
/// `IndexingIterator`, because it doesn't define its own `makeIterator()`
/// method or `Iterator` associated type. This example shows how a
/// `CollectionOfTwo` instance can be created holding the values of a point,
/// and then iterated over using a `for`-`in` loop.
///
///     let point = CollectionOfTwo(15.0, 20.0)
///     for element in point {
///         print(element)
///     }
///     // Prints "15.0"
///     // Prints "20.0"
public struct IndexingIterator<Elements : IndexableBase> : IteratorProtocol, Sequence {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns all the elements of the underlying
    /// sequence in order. As soon as the sequence has run out of elements, the
    /// `next()` method returns `nil`.
    ///
    /// You must not call this method if it has previously returned `nil`.
    ///
    /// This example shows how an iterator can be used explicitly to emulate a
    /// `for`-`in` loop. First, retrieve a sequence's iterator, and then call
    /// the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> Elements._Element?
}

/// A 64-bit signed integer value
/// type.
public struct Int : SignedInteger, Comparable, Equatable {

    /// Create an instance initialized to zero.
    public init()

    public init(_ v: Builtin.Word)

    /// Create an instance initialized to `value`.
    public init(_ value: Int)

    /// Creates an integer from its big-endian representation, changing the
    /// byte order if necessary.
    public init(bigEndian value: Int)

    /// Creates an integer from its little-endian representation, changing the
    /// byte order if necessary.
    public init(littleEndian value: Int)

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: Int)

    /// Returns the big-endian representation of the integer, changing the
    /// byte order if necessary.
    public var bigEndian: Int { get }

    /// Returns the little-endian representation of the integer, changing the
    /// byte order if necessary.
    public var littleEndian: Int { get }

    /// Returns the current integer with the byte order swapped.
    public var byteSwapped: Int { get }

    public static var max: Int { get }

    public static var min: Int { get }
}

extension Int {

    public init(bitPattern pointer: OpaquePointer?)
}

extension Int : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension Int : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension Int {

    /// Add `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func addWithOverflow(_ lhs: Int, _ rhs: Int) -> (Int, overflow: Bool)

    /// Subtract `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func subtractWithOverflow(_ lhs: Int, _ rhs: Int) -> (Int, overflow: Bool)

    /// Multiply `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func multiplyWithOverflow(_ lhs: Int, _ rhs: Int) -> (Int, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// a result and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func divideWithOverflow(_ lhs: Int, _ rhs: Int) -> (Int, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// the remainder and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func remainderWithOverflow(_ lhs: Int, _ rhs: Int) -> (Int, overflow: Bool)

    /// Represent this number using Swift's widest native signed
    /// integer type.
    public func toIntMax() -> IntMax
}

extension Int : SignedNumber {
}

extension Int {

    public init(_ v: UInt8)

    public init(_ v: Int8)

    public init(_ v: UInt16)

    public init(_ v: Int16)

    public init(_ v: UInt32)

    public init(_ v: Int32)

    public init(_ v: UInt64)

    /// Construct a `Int` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt64)

    /// Convert from Swift's widest signed integer type, trapping on
    /// overflow.
    public init(_ v: Int64)

    /// Construct a `Int` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int64)

    public init(_ v: UInt)

    /// Construct a `Int` having the same memory representation as
    /// the `UInt` `bitPattern`.  No range or overflow checking
    /// occurs, and the resulting `Int` may not have the same numeric
    /// value as `bitPattern`--it is only guaranteed to use the same
    /// pattern of bits.
    public init(bitPattern: UInt)
}

extension Int : BitwiseOperations {

    /// The empty bitset of type `Int`.
    public static var allZeros: Int { get }
}

extension Int {

    /// Creates a Int whose value is `other` rounded towards zero.
    public init(_ other: Float)

    /// Creates a Int whose value is `other` rounded towards zero.
    public init(_ other: Double)

    /// Creates a Int whose value is `other` rounded towards zero.
    public init(_ other: Float80)
}

extension Int {

    /// Construct from an ASCII representation in the given `radix`.
    ///
    /// If `text` does not match the regular expression
    /// "[+-]?[0-9a-zA-Z]+", or the value it denotes in the given `radix`
    /// is not representable, the result is `nil`.
    public init?(_ text: String, radix: Int = default)
}

extension Int : CustomReflectable {

    /// A mirror that reflects the `Int` instance.
    public var customMirror: Mirror { get }
}

extension Int : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Int {

    /// Create an `Int` that captures the full value of `objectID`.
    public init(_ objectID: ObjectIdentifier)
}

extension Int {

    public init<U>(bitPattern: UnsafeMutablePointer<U>?)
}

extension Int {

    public init<U>(bitPattern: UnsafePointer<U>?)
}

extension Int : MirrorPath {
}

extension Int : CVarArg {
}

/// A 16-bit signed integer value
/// type.
public struct Int16 : SignedInteger, Comparable, Equatable {

    /// Create an instance initialized to zero.
    public init()

    /// Create an instance initialized to `value`.
    public init(_ value: Int16)

    /// Creates an integer from its big-endian representation, changing the
    /// byte order if necessary.
    public init(bigEndian value: Int16)

    /// Creates an integer from its little-endian representation, changing the
    /// byte order if necessary.
    public init(littleEndian value: Int16)

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: Int16)

    /// Returns the big-endian representation of the integer, changing the
    /// byte order if necessary.
    public var bigEndian: Int16 { get }

    /// Returns the little-endian representation of the integer, changing the
    /// byte order if necessary.
    public var littleEndian: Int16 { get }

    /// Returns the current integer with the byte order swapped.
    public var byteSwapped: Int16 { get }

    public static var max: Int16 { get }

    public static var min: Int16 { get }
}

extension Int16 : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension Int16 : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension Int16 {

    /// Add `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func addWithOverflow(_ lhs: Int16, _ rhs: Int16) -> (Int16, overflow: Bool)

    /// Subtract `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func subtractWithOverflow(_ lhs: Int16, _ rhs: Int16) -> (Int16, overflow: Bool)

    /// Multiply `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func multiplyWithOverflow(_ lhs: Int16, _ rhs: Int16) -> (Int16, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// a result and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func divideWithOverflow(_ lhs: Int16, _ rhs: Int16) -> (Int16, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// the remainder and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func remainderWithOverflow(_ lhs: Int16, _ rhs: Int16) -> (Int16, overflow: Bool)

    /// Represent this number using Swift's widest native signed
    /// integer type.
    public func toIntMax() -> IntMax
}

extension Int16 : SignedNumber {
}

extension Int16 {

    public init(_ v: UInt8)

    public init(_ v: Int8)

    public init(_ v: UInt16)

    public init(_ v: UInt32)

    /// Construct a `Int16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt32)

    public init(_ v: Int32)

    /// Construct a `Int16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int32)

    public init(_ v: UInt64)

    /// Construct a `Int16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt64)

    /// Convert from Swift's widest signed integer type, trapping on
    /// overflow.
    public init(_ v: Int64)

    /// Construct a `Int16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int64)

    public init(_ v: UInt)

    /// Construct a `Int16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt)

    public init(_ v: Int)

    /// Construct a `Int16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int)

    /// Construct a `Int16` having the same memory representation as
    /// the `UInt16` `bitPattern`.  No range or overflow checking
    /// occurs, and the resulting `Int16` may not have the same numeric
    /// value as `bitPattern`--it is only guaranteed to use the same
    /// pattern of bits.
    public init(bitPattern: UInt16)
}

extension Int16 : BitwiseOperations {

    /// The empty bitset of type `Int16`.
    public static var allZeros: Int16 { get }
}

extension Int16 {

    /// Creates a Int16 whose value is `other` rounded towards zero.
    public init(_ other: Float)

    /// Creates a Int16 whose value is `other` rounded towards zero.
    public init(_ other: Double)

    /// Creates a Int16 whose value is `other` rounded towards zero.
    public init(_ other: Float80)
}

extension Int16 {

    /// Construct from an ASCII representation in the given `radix`.
    ///
    /// If `text` does not match the regular expression
    /// "[+-]?[0-9a-zA-Z]+", or the value it denotes in the given `radix`
    /// is not representable, the result is `nil`.
    public init?(_ text: String, radix: Int = default)
}

extension Int16 : CustomReflectable {

    /// A mirror that reflects the `Int16` instance.
    public var customMirror: Mirror { get }
}

extension Int16 : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Int16 : CVarArg {
}

/// A 32-bit signed integer value
/// type.
public struct Int32 : SignedInteger, Comparable, Equatable {

    /// Create an instance initialized to zero.
    public init()

    /// Create an instance initialized to `value`.
    public init(_ value: Int32)

    /// Creates an integer from its big-endian representation, changing the
    /// byte order if necessary.
    public init(bigEndian value: Int32)

    /// Creates an integer from its little-endian representation, changing the
    /// byte order if necessary.
    public init(littleEndian value: Int32)

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: Int32)

    /// Returns the big-endian representation of the integer, changing the
    /// byte order if necessary.
    public var bigEndian: Int32 { get }

    /// Returns the little-endian representation of the integer, changing the
    /// byte order if necessary.
    public var littleEndian: Int32 { get }

    /// Returns the current integer with the byte order swapped.
    public var byteSwapped: Int32 { get }

    public static var max: Int32 { get }

    public static var min: Int32 { get }
}

extension Int32 : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension Int32 : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension Int32 {

    /// Add `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func addWithOverflow(_ lhs: Int32, _ rhs: Int32) -> (Int32, overflow: Bool)

    /// Subtract `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func subtractWithOverflow(_ lhs: Int32, _ rhs: Int32) -> (Int32, overflow: Bool)

    /// Multiply `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func multiplyWithOverflow(_ lhs: Int32, _ rhs: Int32) -> (Int32, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// a result and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func divideWithOverflow(_ lhs: Int32, _ rhs: Int32) -> (Int32, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// the remainder and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func remainderWithOverflow(_ lhs: Int32, _ rhs: Int32) -> (Int32, overflow: Bool)

    /// Represent this number using Swift's widest native signed
    /// integer type.
    public func toIntMax() -> IntMax
}

extension Int32 : SignedNumber {
}

extension Int32 {

    public init(_ v: UInt8)

    public init(_ v: Int8)

    public init(_ v: UInt16)

    public init(_ v: Int16)

    public init(_ v: UInt32)

    public init(_ v: UInt64)

    /// Construct a `Int32` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt64)

    /// Convert from Swift's widest signed integer type, trapping on
    /// overflow.
    public init(_ v: Int64)

    /// Construct a `Int32` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int64)

    public init(_ v: UInt)

    /// Construct a `Int32` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt)

    public init(_ v: Int)

    /// Construct a `Int32` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int)

    /// Construct a `Int32` having the same memory representation as
    /// the `UInt32` `bitPattern`.  No range or overflow checking
    /// occurs, and the resulting `Int32` may not have the same numeric
    /// value as `bitPattern`--it is only guaranteed to use the same
    /// pattern of bits.
    public init(bitPattern: UInt32)
}

extension Int32 : BitwiseOperations {

    /// The empty bitset of type `Int32`.
    public static var allZeros: Int32 { get }
}

extension Int32 {

    /// Creates a Int32 whose value is `other` rounded towards zero.
    public init(_ other: Float)

    /// Creates a Int32 whose value is `other` rounded towards zero.
    public init(_ other: Double)

    /// Creates a Int32 whose value is `other` rounded towards zero.
    public init(_ other: Float80)
}

extension Int32 {

    /// Construct from an ASCII representation in the given `radix`.
    ///
    /// If `text` does not match the regular expression
    /// "[+-]?[0-9a-zA-Z]+", or the value it denotes in the given `radix`
    /// is not representable, the result is `nil`.
    public init?(_ text: String, radix: Int = default)
}

extension Int32 : CustomReflectable {

    /// A mirror that reflects the `Int32` instance.
    public var customMirror: Mirror { get }
}

extension Int32 : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Int32 : CVarArg {
}

/// A 64-bit signed integer value
/// type.
public struct Int64 : SignedInteger, Comparable, Equatable {

    /// Create an instance initialized to zero.
    public init()

    /// Create an instance initialized to `value`.
    public init(_ value: Int64)

    /// Creates an integer from its big-endian representation, changing the
    /// byte order if necessary.
    public init(bigEndian value: Int64)

    /// Creates an integer from its little-endian representation, changing the
    /// byte order if necessary.
    public init(littleEndian value: Int64)

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: Int64)

    /// Returns the big-endian representation of the integer, changing the
    /// byte order if necessary.
    public var bigEndian: Int64 { get }

    /// Returns the little-endian representation of the integer, changing the
    /// byte order if necessary.
    public var littleEndian: Int64 { get }

    /// Returns the current integer with the byte order swapped.
    public var byteSwapped: Int64 { get }

    public static var max: Int64 { get }

    public static var min: Int64 { get }
}

extension Int64 : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension Int64 : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension Int64 {

    /// Add `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func addWithOverflow(_ lhs: Int64, _ rhs: Int64) -> (Int64, overflow: Bool)

    /// Subtract `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func subtractWithOverflow(_ lhs: Int64, _ rhs: Int64) -> (Int64, overflow: Bool)

    /// Multiply `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func multiplyWithOverflow(_ lhs: Int64, _ rhs: Int64) -> (Int64, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// a result and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func divideWithOverflow(_ lhs: Int64, _ rhs: Int64) -> (Int64, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// the remainder and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func remainderWithOverflow(_ lhs: Int64, _ rhs: Int64) -> (Int64, overflow: Bool)

    /// Represent this number using Swift's widest native signed
    /// integer type.
    public func toIntMax() -> IntMax
}

extension Int64 : SignedNumber {
}

extension Int64 {

    public init(_ v: UInt8)

    public init(_ v: Int8)

    public init(_ v: UInt16)

    public init(_ v: Int16)

    public init(_ v: UInt32)

    public init(_ v: Int32)

    public init(_ v: UInt64)

    public init(_ v: UInt)

    public init(_ v: Int)

    /// Construct a `Int64` having the same memory representation as
    /// the `UInt64` `bitPattern`.  No range or overflow checking
    /// occurs, and the resulting `Int64` may not have the same numeric
    /// value as `bitPattern`--it is only guaranteed to use the same
    /// pattern of bits.
    public init(bitPattern: UInt64)
}

extension Int64 : BitwiseOperations {

    /// The empty bitset of type `Int64`.
    public static var allZeros: Int64 { get }
}

extension Int64 {

    /// Creates a Int64 whose value is `other` rounded towards zero.
    public init(_ other: Float)

    /// Creates a Int64 whose value is `other` rounded towards zero.
    public init(_ other: Double)

    /// Creates a Int64 whose value is `other` rounded towards zero.
    public init(_ other: Float80)
}

extension Int64 {

    /// Construct from an ASCII representation in the given `radix`.
    ///
    /// If `text` does not match the regular expression
    /// "[+-]?[0-9a-zA-Z]+", or the value it denotes in the given `radix`
    /// is not representable, the result is `nil`.
    public init?(_ text: String, radix: Int = default)
}

extension Int64 : CustomReflectable {

    /// A mirror that reflects the `Int64` instance.
    public var customMirror: Mirror { get }
}

extension Int64 : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension IntMax : MirrorPath {
}

extension Int64 : CVarArg {
}

/// An 8-bit signed integer value
/// type.
public struct Int8 : SignedInteger, Comparable, Equatable {

    /// Create an instance initialized to zero.
    public init()

    /// Create an instance initialized to `value`.
    public init(_ value: Int8)

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: Int8)

    public static var max: Int8 { get }

    public static var min: Int8 { get }
}

extension Int8 : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension Int8 : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension Int8 {

    /// Add `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func addWithOverflow(_ lhs: Int8, _ rhs: Int8) -> (Int8, overflow: Bool)

    /// Subtract `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func subtractWithOverflow(_ lhs: Int8, _ rhs: Int8) -> (Int8, overflow: Bool)

    /// Multiply `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func multiplyWithOverflow(_ lhs: Int8, _ rhs: Int8) -> (Int8, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// a result and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func divideWithOverflow(_ lhs: Int8, _ rhs: Int8) -> (Int8, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// the remainder and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func remainderWithOverflow(_ lhs: Int8, _ rhs: Int8) -> (Int8, overflow: Bool)

    /// Represent this number using Swift's widest native signed
    /// integer type.
    public func toIntMax() -> IntMax
}

extension Int8 : SignedNumber {
}

extension Int8 {

    public init(_ v: UInt8)

    public init(_ v: UInt16)

    /// Construct a `Int8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt16)

    public init(_ v: Int16)

    /// Construct a `Int8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int16)

    public init(_ v: UInt32)

    /// Construct a `Int8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt32)

    public init(_ v: Int32)

    /// Construct a `Int8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int32)

    public init(_ v: UInt64)

    /// Construct a `Int8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt64)

    /// Convert from Swift's widest signed integer type, trapping on
    /// overflow.
    public init(_ v: Int64)

    /// Construct a `Int8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int64)

    public init(_ v: UInt)

    /// Construct a `Int8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt)

    public init(_ v: Int)

    /// Construct a `Int8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int)

    /// Construct a `Int8` having the same memory representation as
    /// the `UInt8` `bitPattern`.  No range or overflow checking
    /// occurs, and the resulting `Int8` may not have the same numeric
    /// value as `bitPattern`--it is only guaranteed to use the same
    /// pattern of bits.
    public init(bitPattern: UInt8)
}

extension Int8 : BitwiseOperations {

    /// The empty bitset of type `Int8`.
    public static var allZeros: Int8 { get }
}

extension Int8 {

    /// Creates a Int8 whose value is `other` rounded towards zero.
    public init(_ other: Float)

    /// Creates a Int8 whose value is `other` rounded towards zero.
    public init(_ other: Double)

    /// Creates a Int8 whose value is `other` rounded towards zero.
    public init(_ other: Float80)
}

extension Int8 {

    /// Construct from an ASCII representation in the given `radix`.
    ///
    /// If `text` does not match the regular expression
    /// "[+-]?[0-9a-zA-Z]+", or the value it denotes in the given `radix`
    /// is not representable, the result is `nil`.
    public init?(_ text: String, radix: Int = default)
}

extension Int8 : CustomReflectable {

    /// A mirror that reflects the `Int8` instance.
    public var customMirror: Mirror { get }
}

extension Int8 : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Int8 : CVarArg {
}

/// The largest native signed integer type.
public typealias IntMax = Int64

/// A set of common requirements for Swift's integer types.
public protocol Integer : _Integer, Strideable {
}

/// The common requirements for types that support integer arithmetic.
public protocol IntegerArithmetic : _IntegerArithmetic, Comparable {

    /// Adds `lhs` and `rhs`, returning the result and trapping in case of
    /// arithmetic overflow (except in -Ounchecked builds).
    public func +(lhs: Self, rhs: Self) -> Self

    /// Subtracts `lhs` and `rhs`, returning the result and trapping in case of
    /// arithmetic overflow (except in -Ounchecked builds).
    public func -(lhs: Self, rhs: Self) -> Self

    /// Multiplies `lhs` and `rhs`, returning the result and trapping in case of
    /// arithmetic overflow (except in -Ounchecked builds).
    public func *(lhs: Self, rhs: Self) -> Self

    /// Divides `lhs` and `rhs`, returning the result and trapping in case of
    /// arithmetic overflow (except in -Ounchecked builds).
    public func /(lhs: Self, rhs: Self) -> Self

    /// Divides `lhs` and `rhs`, returning the remainder and trapping in case of
    /// arithmetic overflow (except in -Ounchecked builds).
    public func %(lhs: Self, rhs: Self) -> Self

    /// Explicitly convert to `IntMax`, trapping on overflow (except in
    /// -Ounchecked builds).
    public func toIntMax() -> IntMax
}

/// Conforming types can be initialized with integer literals.
public protocol IntegerLiteralConvertible {

    associatedtype IntegerLiteralType

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: Self.IntegerLiteralType)
}

/// The default type for an otherwise-unconstrained integer literal.
public typealias IntegerLiteralType = Int

/// An iterator that produces one or fewer instances of `Element`.
public struct IteratorOverOne<Element> : IteratorProtocol, Sequence {

    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    ///
    /// - Precondition: `next()` has not been applied to a copy of `self`
    ///   since the copy was made, and no preceding call to `self.next()`
    ///   has returned `nil`.
    public mutating func next() -> Element?
}

/// A type that supplies the values of a sequence one at a time.
///
/// The `IteratorProtocol` protocol is tightly linked with the `Sequence`
/// protocol. Sequences provide access to their elements by creating an
/// iterator, which keeps track of its iteration process and returns one
/// element at a time as it advances through the sequence.
///
/// Whenever you use a `for`-`in` loop with an array, set, or any other
/// collection or sequence, you're using that type's iterator. Swift uses a
/// sequence's or collection's iterator internally to enable the `for`-`in`
/// loop language construct.
///
/// Using a sequence's iterator directly gives you access to the same elements
/// in the same order as iterating over that sequence using a `for`-`in` loop.
/// For example, you might typically use a `for`-`in` loop to print each of
/// the elements in an array.
///
///     let animals = ["Antelope", "Butterfly", "Camel", "Dolphin"]
///     for animal in animals {
///         print(animal)
///     }
///     // Prints "Antelope"
///     // Prints "Butterfly"
///     // Prints "Camel"
///     // Prints "Dolphin"
///
/// Behind the scenes, Swift uses the `animals` array's iterator to loop over
/// the contents of the array.
///
///     var animalIterator = animals.makeIterator()
///     while let animal = animalIterator.next() {
///         print(animal)
///     }
///     // Prints "Antelope"
///     // Prints "Butterfly"
///     // Prints "Camel"
///     // Prints "Dolphin"
///
/// The call to `animals.makeIterator()` returns an instance of the array's
/// iterator. Next, the `while` loop calls the iterator's `next()` method
/// repeatedly, binding each element that is returned to `animal` and exiting
/// when the `next()` method returns `nil`.
///
/// Using Iterators Directly
/// ========================
///
/// You rarely need to use iterators directly, because a `for`-`in` loop is the
/// more idiomatic approach to traversing a sequence in Swift. Some
/// algorithms, however, may call for direct iterator use.
///
/// One example is the `reduce1(_:)` method. Similar to the
/// `reduce(_:combine:)` method defined in the standard library, which takes
/// an initial value and a combining closure, `reduce1(_:)` uses the first
/// element of the sequence as the initial value.
///
/// Here's an implementation of the `reduce1(_:)` method. The sequence's
/// iterator is used directly to retrieve the initial value before looping
/// over the rest of the sequence.
///
///     extension Sequence {
///         func reduce1(
///           combine: (Iterator.Element, Iterator.Element) -> Iterator.Element
///         ) -> Iterator.Element?
///         {
///             var i = makeIterator()
///             guard var accumulated = i.next() else {
///                 return nil
///             }
///
///             while let element = i.next() {
///                 accumulated = combine(accumulated, element)
///             }
///             return accumulated
///         }
///     }
///
/// The `reduce1(_:)` method makes certain kinds of sequence operations
/// simpler. Here's how to find the longest string in a sequence, using the
/// `animals` array introduced earlier as an example:
///
///     let longestAnimal = animals.reduce1 { current, element in
///         if current.characters.count > element.characters.count {
///             return current
///         } else {
///             return element
///         }
///     }
///     print(longestAnimal)
///     // Prints "Butterfly"
///
/// Using Multiple Iterators
/// ========================
///
/// Whenever you use multiple iterators (or `for`-`in` loops) over a single
/// sequence, be sure you know that the specific sequence supports repeated
/// iteration, either because you know its concrete type or because the
/// sequence is also constrained to the `Collection` protocol.
///
/// Obtain each separate iterator from separate calls to the sequence's
/// `makeIterator()` method rather than by copying. Copying an iterator is
/// safe, but advancing one copy of an iterator by calling its `next()` method
/// may invalidate other copies of that iterator. `for`-`in` loops are safe in
/// this regard.
///
/// Adding IteratorProtocol Conformance to Your Type
/// ================================================
///
/// Implementing an iterator that conforms to `IteratorProtocol` is simple.
/// Declare a `next()` method that advances one step in the related sequence
/// and returns the current element. When the sequence has been exhausted, the
/// `next()` method returns `nil`.
///
/// For example, consider a custom `Countdown` sequence. You can initialize the
/// `Countdown` sequence with a starting integer and then iterate over the
/// count down to zero. The `Countdown` structure's definition is short: It
/// contains only the starting count and the `makeIterator()` method required
/// by the `Sequence` protocol.
///
///     struct Countdown: Sequence {
///         let start: Int
///
///         func makeIterator() -> CountdownIterator {
///             return CountdownIterator(self)
///         }
///     }
///
/// The `makeIterator()` method returns another custom type, an iterator named
/// `CountdownIterator`. The `CountdownIterator` type keeps track of both the
/// `Countdown` sequence that it's iterating and the number of times it has
/// returned a value.
///
///     struct CountdownIterator: IteratorProtocol {
///         let countdown: Countdown
///         var times = 0
///
///         init(_ countdown: Countdown) {
///             self.countdown = countdown
///         }
///
///         mutating func next() -> Int? {
///             let nextNumber = countdown.start - times
///             guard nextNumber > 0
///                 else { return nil }
///
///             times += 1
///             return nextNumber
///         }
///     }
///
/// Each time the `next()` method is called on a `CountdownIterator` instance,
/// it calculates the new next value, checks to see whether it has reached
/// zero, and then returns either the number, or `nil` if the iterator is
/// finished returning elements of the sequence.
///
/// Creating and iterating over a `Countdown` sequence uses a
/// `CountdownGenerator` to handle the iteration.
///
///     let threeTwoOne = Countdown(start: 3)
///     for count in threeTwoOne {
///         print("\(count)...")
///     }
///     // Prints "3..."
///     // Prints "2..."
///     // Prints "1..."
public protocol IteratorProtocol {

    /// The type of element traversed by the iterator.
    associatedtype Element

    /// Advances and returns the next element of the underlying sequence, or
    /// `nil` if no next element exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. After the sequence has run out of elements, the
    /// `next()` method returns `nil`.
    ///
    /// You must not call this method if it has previously returned `nil` or if
    /// any other copy of this iterator has been advanced with a call to its
    /// `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> Self.Element?
}

/// A sequence built around an iterator of type `Base`.
///
/// Useful mostly to recover the ability to use `for`...`in`,
/// given just an iterator `i`:
///
///     for x in IteratorSequence(i) { ... }
public struct IteratorSequence<Base : IteratorProtocol> : IteratorProtocol, Sequence {

    /// Construct an instance whose iterator is a copy of `base`.
    public init(_ base: Base)

    /// Advances to the next element and returns it, or `nil` if no next
    /// element exists.
    ///
    /// - Precondition: `next()` has not been applied to a copy of `self`
    ///   since the copy was made, and no preceding call to `self.next()`
    ///   has returned `nil`.
    public mutating func next() -> Base.Element?
}

/// An iterator that presents the elements of the sequences traversed
/// by `Base`, concatenated using a given separator.
public struct JoinedIterator<Base : IteratorProtocol where Base.Element : Sequence> : IteratorProtocol {

    /// Creates an iterator that presents the elements of the sequences
    /// traversed by `base`, concatenated using `separator`.
    ///
    /// - Complexity: O(`separator.count`).
    public init<Separator : Sequence where Separator.Iterator.Element == Base.Element.Iterator.Element>(base: Base, separator: Separator)

    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    public mutating func next() -> Base.Element.Iterator.Element?
}

/// A sequence that presents the elements of the `Base` sequences
/// concatenated using a given separator.
public struct JoinedSequence<Base : Sequence where Base.Iterator.Element : Sequence> : Sequence {

    /// Creates a sequence that presents the elements of `base` sequences
    /// concatenated using `separator`.
    ///
    /// - Complexity: O(`separator.count`).
    public init<Separator : Sequence where Separator.Iterator.Element == Base.Iterator.Element.Iterator.Element>(base: Base, separator: Separator)

    /// Return an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> JoinedIterator<Base.Iterator>
}

/// A collection containing the same elements as a `Base` collection,
/// but on which some operations such as `map` and `filter` are
/// implemented lazily.
///
/// - See also: `LazySequenceProtocol`, `LazyCollection`
public struct LazyBidirectionalCollection<Base : BidirectionalCollection> : LazyCollectionProtocol {

    /// The type of the underlying collection
    public typealias Elements = Base

    /// The underlying collection
    public var elements: Base { get }

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = Base.Index
}

/// Forward implementations to the base collection, to pick up any
/// optimizations it might implement.
extension LazyBidirectionalCollection : Sequence {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> Base.Iterator

    /// Returns a value less than or equal to the number of elements in
    /// `self`, **nondestructively**.
    ///
    /// - Complexity: O(N).
    public var underestimatedCount: Int { get }
}

extension LazyBidirectionalCollection : BidirectionalCollection {

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: Base.Index { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Base.Indices { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Access the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: Base.Index) -> Base.Iterator.Element { get }

    /// Returns a collection representing a contiguous sub-range of
    /// `self`'s elements.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<Base.Index>) -> LazyBidirectionalCollection<BidirectionalSlice<Base>> { get }

    /// Returns `true` iff `self` is empty.
    public var isEmpty: Bool { get }

    /// Returns the number of elements.
    ///
    /// - Complexity: O(1) if `Self` conforms to `RandomAccessCollection`;
    ///   O(N) otherwise.
    public var count: Base.IndexDistance { get }

    /// Returns the first element of `self`, or `nil` if `self` is empty.
    public var first: Base.Iterator.Element? { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Base.Iterator.Element? { get }
}

/// A collection containing the same elements as a `Base` collection,
/// but on which some operations such as `map` and `filter` are
/// implemented lazily.
///
/// - See also: `LazySequenceProtocol`, `LazyCollection`
public struct LazyCollection<Base : Collection> : LazyCollectionProtocol {

    /// The type of the underlying collection
    public typealias Elements = Base

    /// The underlying collection
    public var elements: Base { get }

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = Base.Index
}

/// Forward implementations to the base collection, to pick up any
/// optimizations it might implement.
extension LazyCollection : Sequence {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> Base.Iterator

    /// Returns a value less than or equal to the number of elements in
    /// `self`, **nondestructively**.
    ///
    /// - Complexity: O(N).
    public var underestimatedCount: Int { get }
}

extension LazyCollection : Collection {

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: Base.Index { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Base.Indices { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Access the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: Base.Index) -> Base.Iterator.Element { get }

    /// Returns a collection representing a contiguous sub-range of
    /// `self`'s elements.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<Base.Index>) -> LazyCollection<Slice<Base>> { get }

    /// Returns `true` iff `self` is empty.
    public var isEmpty: Bool { get }

    /// Returns the number of elements.
    ///
    /// - Complexity: O(1) if `Self` conforms to `RandomAccessCollection`;
    ///   O(N) otherwise.
    public var count: Base.IndexDistance { get }

    /// Returns the first element of `self`, or `nil` if `self` is empty.
    public var first: Base.Iterator.Element? { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance
}

/// A collection on which normally-eager operations such as `map` and
/// `filter` are implemented lazily.
///
/// Please see `LazySequenceProtocol` for background; `LazyCollectionProtocol`
/// is an analogous component, but for collections.
///
/// To add new lazy collection operations, extend this protocol with
/// methods that return lazy wrappers that are themselves
/// `LazyCollectionProtocol`s.
///
/// - See Also: `LazySequenceProtocol`, `LazyCollection`
public protocol LazyCollectionProtocol : Collection, LazySequenceProtocol {

    /// A `Collection` that can contain the same elements as this one,
    /// possibly with a simpler type.
    ///
    /// - See also: `elements`
    associatedtype Elements : Collection = Self
}

extension LazyCollectionProtocol where Self : Collection, Elements : Collection {

    /// Returns the elements of `self` that satisfy `predicate`.
    ///
    /// - Note: The elements of the result are computed on-demand, as
    ///   the result is used. No buffering storage is allocated and each
    ///   traversal step invokes `predicate` on one or more underlying
    ///   elements.
    public func filter(_ predicate: (Self.Elements.Iterator.Element) -> Bool) -> LazyFilterCollection<Self.Elements>
}

extension LazyCollectionProtocol where Self : BidirectionalCollection, Elements : BidirectionalCollection {

    /// Returns the elements of `self` that satisfy `predicate`.
    ///
    /// - Note: The elements of the result are computed on-demand, as
    ///   the result is used. No buffering storage is allocated and each
    ///   traversal step invokes `predicate` on one or more underlying
    ///   elements.
    public func filter(_ predicate: (Self.Elements.Iterator.Element) -> Bool) -> LazyFilterBidirectionalCollection<Self.Elements>
}

extension LazyCollectionProtocol {

    /// Returns the concatenated results of mapping `transform` over
    /// `self`.  Equivalent to 
    ///
    ///     self.map(transform).flatten()
    ///
    /// - Complexity: O(1)
    public func flatMap<SegmentOfResult : Collection>(_ transform: (Self.Elements.Iterator.Element) -> SegmentOfResult) -> LazyCollection<FlattenCollection<LazyMapCollection<Self.Elements, SegmentOfResult>>>

    /// Returns a `LazyMapCollection` containing the concatenated non-nil
    /// results of mapping transform over this collection.
    ///
    /// Use this method to receive only nonoptional values when your
    /// transformation produces an optional value.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    /// collection as its argument and returns an optional value.
    public func flatMap<ElementOfResult>(_ transform: (Self.Elements.Iterator.Element) -> ElementOfResult?) -> LazyMapCollection<LazyFilterCollection<LazyMapCollection<Self.Elements, ElementOfResult?>>, ElementOfResult>
}

extension LazyCollectionProtocol where Self : BidirectionalCollection, Elements : BidirectionalCollection {

    /// Returns the concatenated results of mapping `transform` over
    /// `self`.  Equivalent to 
    ///
    ///     self.map(transform).flatten()
    ///
    /// - Complexity: O(1)
    public func flatMap<SegmentOfResult : Collection where SegmentOfResult : BidirectionalCollection>(_ transform: (Self.Elements.Iterator.Element) -> SegmentOfResult) -> LazyCollection<FlattenBidirectionalCollection<LazyMapBidirectionalCollection<Self.Elements, SegmentOfResult>>>

    /// Returns a `LazyMapBidirectionalCollection` containing the concatenated non-nil
    /// results of mapping transform over this collection.
    ///
    /// Use this method to receive only nonoptional values when your
    /// transformation produces an optional value.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    /// collection as its argument and returns an optional value.
    public func flatMap<ElementOfResult>(_ transform: (Self.Elements.Iterator.Element) -> ElementOfResult?) -> LazyMapBidirectionalCollection<LazyFilterBidirectionalCollection<LazyMapBidirectionalCollection<Self.Elements, ElementOfResult?>>, ElementOfResult>
}

extension LazyCollectionProtocol where Self : Collection, Elements : Collection, Iterator.Element : Collection, Elements.Iterator.Element : Collection, Iterator.Element == Elements.Iterator.Element {

    /// A concatenation of the elements of `self`.
    public func flatten() -> LazyCollection<FlattenCollection<Self.Elements>>
}

extension LazyCollectionProtocol where Self : BidirectionalCollection, Elements : BidirectionalCollection, Iterator.Element : BidirectionalCollection, Elements.Iterator.Element : BidirectionalCollection, Iterator.Element == Elements.Iterator.Element {

    /// A concatenation of the elements of `self`.
    public func flatten() -> LazyCollection<FlattenBidirectionalCollection<Self.Elements>>
}

/// When there's no special associated `Elements` type, the `elements`
/// property is provided.
extension LazyCollectionProtocol where Elements == Self {

    /// Identical to `self`.
    public var elements: Self { get }
}

extension LazyCollectionProtocol where Self : Collection, Elements : Collection {

    /// Returns a `LazyMapCollection` over this `Collection`.  The elements of
    /// the result are computed lazily, each time they are read, by
    /// calling `transform` function on a base element.
    public func map<U>(_ transform: (Self.Elements.Iterator.Element) -> U) -> LazyMapCollection<Self.Elements, U>
}

extension LazyCollectionProtocol where Self : BidirectionalCollection, Elements : BidirectionalCollection {

    /// Returns a `LazyMapCollection` over this `Collection`.  The elements of
    /// the result are computed lazily, each time they are read, by
    /// calling `transform` function on a base element.
    public func map<U>(_ transform: (Self.Elements.Iterator.Element) -> U) -> LazyMapBidirectionalCollection<Self.Elements, U>
}

extension LazyCollectionProtocol where Self : RandomAccessCollection, Elements : RandomAccessCollection {

    /// Returns a `LazyMapCollection` over this `Collection`.  The elements of
    /// the result are computed lazily, each time they are read, by
    /// calling `transform` function on a base element.
    public func map<U>(_ transform: (Self.Elements.Iterator.Element) -> U) -> LazyMapRandomAccessCollection<Self.Elements, U>
}

extension LazyCollectionProtocol where Self : BidirectionalCollection, Elements : BidirectionalCollection {

    /// Returns the elements of `self` in reverse order.
    ///
    /// - Complexity: O(1)
    public func reversed() -> LazyBidirectionalCollection<ReversedCollection<Self.Elements>>
}

extension LazyCollectionProtocol where Self : RandomAccessCollection, Elements : RandomAccessCollection {

    /// Returns the elements of `self` in reverse order.
    ///
    /// - Complexity: O(1)
    public func reversed() -> LazyRandomAccessCollection<ReversedRandomAccessCollection<Self.Elements>>
}

/// A lazy `Collection` wrapper that includes the elements of an
/// underlying collection that satisfy a predicate.
///
/// - Note: The performance of accessing `startIndex`, `first`, any methods
///   that depend on `startIndex`, or of advancing a `LazyFilterIndex` depends
///   on how sparsely the filtering predicate is satisfied, and may not offer
///   the usual performance given by `Collection`. Be aware, therefore, that 
///   general operations on `LazyFilterCollection` instances may not have the
///   documented complexity.
public struct LazyFilterBidirectionalCollection<Base : BidirectionalCollection> : LazyCollectionProtocol, BidirectionalCollection {

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = LazyFilterIndex<Base>

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    ///
    /// - Complexity: O(N), where N is the ratio between unfiltered and
    ///   filtered collection counts.
    public var startIndex: LazyFilterIndex<Base> { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: LazyFilterIndex<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: LazyFilterIndex<Base>) -> LazyFilterIndex<Base>

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout LazyFilterIndex<Base>)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: LazyFilterIndex<Base>) -> LazyFilterIndex<Base>

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout LazyFilterIndex<Base>)

    /// Access the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    /// `position != endIndex`.
    public subscript(position: LazyFilterIndex<Base>) -> Base.Iterator.Element { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<LazyFilterIndex<Base>>) -> BidirectionalSlice<LazyFilterBidirectionalCollection<Base>> { get }

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyFilterIterator<Base.Iterator>
}

/// A lazy `Collection` wrapper that includes the elements of an
/// underlying collection that satisfy a predicate.
///
/// - Note: The performance of accessing `startIndex`, `first`, any methods
///   that depend on `startIndex`, or of advancing a `LazyFilterIndex` depends
///   on how sparsely the filtering predicate is satisfied, and may not offer
///   the usual performance given by `Collection`. Be aware, therefore, that 
///   general operations on `LazyFilterCollection` instances may not have the
///   documented complexity.
public struct LazyFilterCollection<Base : Collection> : LazyCollectionProtocol, Collection {

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = LazyFilterIndex<Base>

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    ///
    /// - Complexity: O(N), where N is the ratio between unfiltered and
    ///   filtered collection counts.
    public var startIndex: LazyFilterIndex<Base> { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: LazyFilterIndex<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: LazyFilterIndex<Base>) -> LazyFilterIndex<Base>

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout LazyFilterIndex<Base>)

    /// Access the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    /// `position != endIndex`.
    public subscript(position: LazyFilterIndex<Base>) -> Base.Iterator.Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<LazyFilterIndex<Base>>) -> Slice<LazyFilterCollection<Base>> { get }

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyFilterIterator<Base.Iterator>
}

/// The `Index` used for subscripting a `LazyFilterCollection`.
///
/// The positions of a `LazyFilterIndex` correspond to those positions
/// `p` in its underlying collection `c` such that `c[p]`
/// satisfies the predicate with which the `LazyFilterIndex` was
/// initialized.
/// 
/// - Note: The performance of advancing a `LazyFilterIndex`
///   depends on how sparsely the filtering predicate is satisfied,
///   and may not offer the usual performance given by models of
///   `Collection`.
public struct LazyFilterIndex<Base : Collection> : Comparable {

    /// The position corresponding to `self` in the underlying collection.
    public let base: Base.Index
}

/// An iterator over the elements traversed by some base iterator that also
/// satisfy a given predicate.
///
/// - Note: This is the associated `Iterator` of `LazyFilterSequence`
/// and `LazyFilterCollection`.
public struct LazyFilterIterator<Base : IteratorProtocol> : IteratorProtocol, Sequence {

    /// Advances to the next element and returns it, or `nil` if no next
    /// element exists.
    ///
    /// - Precondition: `next()` has not been applied to a copy of `self`
    ///   since the copy was made, and no preceding call to `self.next()`
    ///   has returned `nil`.
    public mutating func next() -> Base.Element?

    /// The underlying iterator whose elements are being filtered.
    public var base: Base { get }
}

/// A sequence whose elements consist of the elements of some base
/// sequence that also satisfy a given predicate.
///
/// - Note: `s.lazy.filter { ... }`, for an arbitrary sequence `s`,
///   is a `LazyFilterSequence`.
public struct LazyFilterSequence<Base : Sequence> : LazySequenceProtocol {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyFilterIterator<Base.Iterator>

    /// Creates an instance consisting of the elements `x` of `base` for
    /// which `predicate(x) == true`.
    public init(_base base: Base, whereElementsSatisfy predicate: (Base.Iterator.Element) -> Bool)

    /// The underlying sequence whose elements are being filtered
    public let base: Base
}

/// A `Collection` whose elements consist of those in a `Base`
/// `Collection` passed through a transform function returning `Element`.
/// These elements are computed lazily, each time they're read, by
/// calling the transform function on a base element.
public struct LazyMapBidirectionalCollection<Base : BidirectionalCollection, Element> : LazyCollectionProtocol, BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Base.Index)

    /// Access the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: Base.Index) -> Element { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Base.Index>) -> BidirectionalSlice<LazyMapBidirectionalCollection<Base, Element>> { get }

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Base.IndexDistance

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Base.Indices

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Base.Indices { get }

    /// Returns `true` iff `self` is empty.
    public var isEmpty: Bool { get }

    /// Returns the number of elements.
    ///
    /// - Complexity: O(1) if `Index` conforms to `RandomAccessIndex`;
    ///   O(N) otherwise.
    public var count: Base.IndexDistance { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Element? { get }

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Element? { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position. The
    /// operation doesn't require going beyond the limiting `s.endIndex` value,
    /// so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyMapIterator<Base.Iterator, Element>

    /// A value less than or equal to the number of elements in
    /// the sequence, calculated nondestructively.
    ///
    /// - Complexity: O(1)
    public var underestimatedCount: Int { get }
}

/// A `Collection` whose elements consist of those in a `Base`
/// `Collection` passed through a transform function returning `Element`.
/// These elements are computed lazily, each time they're read, by
/// calling the transform function on a base element.
public struct LazyMapCollection<Base : Collection, Element> : LazyCollectionProtocol, Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Access the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: Base.Index) -> Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Base.Index>) -> Slice<LazyMapCollection<Base, Element>> { get }

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Base.Indices

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Base.Indices { get }

    /// Returns `true` iff `self` is empty.
    public var isEmpty: Bool { get }

    /// Returns the number of elements.
    ///
    /// - Complexity: O(1) if `Index` conforms to `RandomAccessIndex`;
    ///   O(N) otherwise.
    public var count: Base.IndexDistance { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Element? { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyMapIterator<Base.Iterator, Element>

    /// A value less than or equal to the number of elements in
    /// the sequence, calculated nondestructively.
    ///
    /// - Complexity: O(1)
    public var underestimatedCount: Int { get }
}

/// The `IteratorProtocol` used by `MapSequence` and `MapCollection`.
/// Produces each element by passing the output of the `Base`
/// `IteratorProtocol` through a transform function returning `Element`.
public struct LazyMapIterator<Base : IteratorProtocol, Element> : IteratorProtocol, Sequence {

    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    ///
    /// - Precondition: `next()` has not been applied to a copy of `self`
    ///   since the copy was made, and no preceding call to `self.next()`
    ///   has returned `nil`.
    public mutating func next() -> Element?

    public var base: Base { get }
}

/// A `Collection` whose elements consist of those in a `Base`
/// `Collection` passed through a transform function returning `Element`.
/// These elements are computed lazily, each time they're read, by
/// calling the transform function on a base element.
public struct LazyMapRandomAccessCollection<Base : RandomAccessCollection, Element> : LazyCollectionProtocol, RandomAccessCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Base.Index)

    /// Access the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: Base.Index) -> Element { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Base.Index>) -> RandomAccessSlice<LazyMapRandomAccessCollection<Base, Element>> { get }

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Base.IndexDistance

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Base.Indices

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Base.Indices { get }

    /// Returns `true` iff `self` is empty.
    public var isEmpty: Bool { get }

    /// Returns the number of elements.
    ///
    /// - Complexity: O(1) if `Index` conforms to `RandomAccessIndex`;
    ///   O(N) otherwise.
    public var count: Base.IndexDistance { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Element? { get }

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Element? { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position. The
    /// operation doesn't require going beyond the limiting `s.endIndex` value,
    /// so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyMapIterator<Base.Iterator, Element>

    /// A value less than or equal to the number of elements in
    /// the sequence, calculated nondestructively.
    ///
    /// - Complexity: O(1)
    public var underestimatedCount: Int { get }
}

/// A `Sequence` whose elements consist of those in a `Base`
/// `Sequence` passed through a transform function returning `Element`.
/// These elements are computed lazily, each time they're read, by
/// calling the transform function on a base element.
public struct LazyMapSequence<Base : Sequence, Element> : LazySequenceProtocol {

    /// A `Sequence` that can contain the same elements as this one,
    /// possibly with a simpler type.
    ///
    /// - See also: `elements`
    public typealias Elements = LazyMapSequence<Base, Element>

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyMapIterator<Base.Iterator, Element>

    /// Returns a value less than or equal to the number of elements in
    /// `self`, **nondestructively**.
    ///
    /// - Complexity: O(N).
    public var underestimatedCount: Int { get }
}

/// A collection containing the same elements as a `Base` collection,
/// but on which some operations such as `map` and `filter` are
/// implemented lazily.
///
/// - See also: `LazySequenceProtocol`, `LazyCollection`
public struct LazyRandomAccessCollection<Base : RandomAccessCollection> : LazyCollectionProtocol {

    /// The type of the underlying collection
    public typealias Elements = Base

    /// The underlying collection
    public var elements: Base { get }

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = Base.Index
}

/// Forward implementations to the base collection, to pick up any
/// optimizations it might implement.
extension LazyRandomAccessCollection : Sequence {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> Base.Iterator

    /// Returns a value less than or equal to the number of elements in
    /// `self`, **nondestructively**.
    ///
    /// - Complexity: O(N).
    public var underestimatedCount: Int { get }
}

extension LazyRandomAccessCollection : RandomAccessCollection {

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: Base.Index { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Base.Indices { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Access the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: Base.Index) -> Base.Iterator.Element { get }

    /// Returns a collection representing a contiguous sub-range of
    /// `self`'s elements.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<Base.Index>) -> LazyRandomAccessCollection<RandomAccessSlice<Base>> { get }

    /// Returns `true` iff `self` is empty.
    public var isEmpty: Bool { get }

    /// Returns the number of elements.
    ///
    /// - Complexity: O(1) if `Self` conforms to `RandomAccessCollection`;
    ///   O(N) otherwise.
    public var count: Base.IndexDistance { get }

    /// Returns the first element of `self`, or `nil` if `self` is empty.
    public var first: Base.Iterator.Element? { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Base.Iterator.Element? { get }
}

/// A sequence containing the same elements as a `Base` sequence, but
/// on which some operations such as `map` and `filter` are
/// implemented lazily.
///
/// - See also: `LazySequenceProtocol`
public struct LazySequence<Base : Sequence> : LazySequenceProtocol, _SequenceWrapper {

    /// The `Base` (presumably non-lazy) sequence from which `self` was created.
    public var elements: Base { get }
}

/// A sequence on which normally-eager operations such as `map` and
/// `filter` are implemented lazily.
///
/// Lazy sequences can be used to avoid needless storage allocation
/// and computation, because they use an underlying sequence for
/// storage and compute their elements on demand.  For example,
///
///     [1, 2, 3].lazy.map { $0 * 2 }
///
/// is a sequence containing { `2`, `4`, `6` }.  Each time an element
/// of the lazy sequence is accessed, an element of the underlying
/// array is accessed and transformed by the closure.
///
/// Sequence operations taking closure arguments, such as `map` and
/// `filter`, are normally eager: they use the closure immediately and
/// return a new array.  Using the `lazy` property gives the standard
/// library explicit permission to store the closure and the sequence
/// in the result, and defer computation until it is needed.
///
/// To add new lazy sequence operations, extend this protocol with
/// methods that return lazy wrappers that are themselves
/// `LazySequenceProtocol`s.  For example, given an eager `scan`
/// method defined as follows
///
///     extension Sequence {
///       /// Returns an array containing the results of
///       ///
///       ///   p.reduce(initial, combine: combine)
///       ///
///       /// for each prefix `p` of `self`, in order from shortest to
///       /// longest.  For example:
///       ///
///       ///     (1..<6).scan(0, combine: +) // [0, 1, 3, 6, 10, 15]
///       ///
///       /// - Complexity: O(N)
///       func scan<ResultElement>(
///         _ initial: ResultElement,
///         combine: @noescape (ResultElement, Iterator.Element) -> ResultElement
///       ) -> [ResultElement] {
///         var result = [initial]
///         for x in self {
///           result.append(combine(result.last!, x))
///         }
///         return result
///       }
///     }
///
/// we can build a sequence that lazily computes the elements in the
/// result of `scan`:
///
///     struct LazyScanIterator<Base : IteratorProtocol, ResultElement>
///       : IteratorProtocol {
///       mutating func next() -> ResultElement? {
///         return nextElement.map { result in
///           nextElement = base.next().map { combine(result, $0) }
///           return result
///         }
///       }
///       private var nextElement: ResultElement? // The next result of next().
///       private var base: Base                  // The underlying iterator.
///       private let combine: (ResultElement, Base.Element) -> ResultElement
///     }
///     
///     struct LazyScanSequence<Base: Sequence, ResultElement>
///       : LazySequenceProtocol // Chained operations on self are lazy, too
///     {
///       func makeIterator() -> LazyScanIterator<Base.Iterator, ResultElement> {
///         return LazyScanIterator(
///           nextElement: initial, base: base.makeIterator(), combine: combine)
///       }
///       private let initial: ResultElement
///       private let base: Base
///       private let combine:
///         (ResultElement, Base.Iterator.Element) -> ResultElement
///     }
///
/// and finally, we can give all lazy sequences a lazy `scan` method:
///     
///     extension LazySequenceProtocol {
///       /// Returns a sequence containing the results of
///       ///
///       ///   p.reduce(initial, combine: combine)
///       ///
///       /// for each prefix `p` of `self`, in order from shortest to
///       /// longest.  For example:
///       ///
///       ///     Array((1..<6).lazy.scan(0, combine: +)) // [0, 1, 3, 6, 10, 15]
///       ///
///       /// - Complexity: O(1)
///       func scan<ResultElement>(
///         _ initial: ResultElement,
///         combine: (ResultElement, Iterator.Element) -> ResultElement
///       ) -> LazyScanSequence<Self, ResultElement> {
///         return LazyScanSequence(
///           initial: initial, base: self, combine: combine)
///       }
///     }
///
/// - See also: `LazySequence`, `LazyCollectionProtocol`, `LazyCollection`
///
/// - Note: The explicit permission to implement further operations
///   lazily applies only in contexts where the sequence is statically
///   known to conform to `LazySequenceProtocol`.  Thus, side-effects such
///   as the accumulation of `result` below are never unexpectedly
///   dropped or deferred:
///
///       extension Sequence where Iterator.Element == Int {
///         func sum() -> Int {
///           var result = 0
///           _ = self.map { result += $0 }
///           return result
///         }
///       }
///
///   [We don't recommend that you use `map` this way, because it
///   creates and discards an array. `sum` would be better implemented
///   using `reduce`].
public protocol LazySequenceProtocol : Sequence {

    /// A `Sequence` that can contain the same elements as this one,
    /// possibly with a simpler type.
    ///
    /// - See also: `elements`
    associatedtype Elements : Sequence = Self

    /// A sequence containing the same elements as this one, possibly with
    /// a simpler type.
    ///
    /// When implementing lazy operations, wrapping `elements` instead
    /// of `self` can prevent result types from growing an extra
    /// `LazySequence` layer.  For example,
    ///
    /// _prext_ example needed
    ///
    /// Note: this property need not be implemented by conforming types,
    /// it has a default implementation in a protocol extension that
    /// just returns `self`.
    public var elements: Self.Elements { get }
}

extension LazySequenceProtocol {

    /// Returns the elements of `self` that satisfy `predicate`.
    ///
    /// - Note: The elements of the result are computed on-demand, as
    ///   the result is used. No buffering storage is allocated and each
    ///   traversal step invokes `predicate` on one or more underlying
    ///   elements.
    public func filter(_ predicate: (Self.Elements.Iterator.Element) -> Bool) -> LazyFilterSequence<Self.Elements>
}

extension LazySequenceProtocol {

    /// Returns the concatenated results of mapping `transform` over
    /// `self`.  Equivalent to 
    ///
    ///     self.map(transform).flatten()
    ///
    /// - Complexity: O(1)
    public func flatMap<SegmentOfResult : Sequence>(_ transform: (Self.Elements.Iterator.Element) -> SegmentOfResult) -> LazySequence<FlattenSequence<LazyMapSequence<Self.Elements, SegmentOfResult>>>

    /// Returns a `LazyMapSequence` containing the concatenated non-nil
    /// results of mapping transform over this `Sequence`.
    ///
    /// Use this method to receive only nonoptional values when your
    /// transformation produces an optional value.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    /// sequence as its argument and returns an optional value.
    public func flatMap<ElementOfResult>(_ transform: (Self.Elements.Iterator.Element) -> ElementOfResult?) -> LazyMapSequence<LazyFilterSequence<LazyMapSequence<Self.Elements, ElementOfResult?>>, ElementOfResult>
}

extension LazySequenceProtocol where Elements.Iterator.Element == Iterator.Element, Iterator.Element : Sequence {

    /// A concatenation of the elements of `self`.
    public func flatten() -> LazySequence<FlattenSequence<Self.Elements>>
}

/// When there's no special associated `Elements` type, the `elements`
/// property is provided.
extension LazySequenceProtocol where Elements == Self {

    /// Identical to `self`.
    public var elements: Self { get }
}

/// Avoid creating multiple layers of `LazySequence` wrapper.
/// Anything conforming to `LazySequenceProtocol` is already lazy.
extension LazySequenceProtocol {

    /// Identical to `self`.
    public var lazy: Self { get }
}

extension LazySequenceProtocol {
}

extension LazySequenceProtocol {

    /// Returns a `LazyMapSequence` over this `Sequence`.  The elements of
    /// the result are computed lazily, each time they are read, by
    /// calling `transform` function on a base element.
    public func map<U>(_ transform: (Self.Elements.Iterator.Element) -> U) -> LazyMapSequence<Self.Elements, U>
}

/// A class whose instances contain a property of type `Value` and raw
/// storage for an array of `Element`, whose size is determined at
/// instance creation.
///
/// Note that the `Element` array is suitably-aligned **raw memory**.
/// You are expected to construct and---if necessary---destroy objects
/// there yourself, using the APIs on `UnsafeMutablePointer<Element>`.
/// Typical usage stores a count and capacity in `Value` and destroys
/// any live elements in the `deinit` of a subclass.
/// - Note: Subclasses must not have any stored properties; any storage
///   needed should be included in `Value`.
public class ManagedBuffer<Value, Element> : ManagedProtoBuffer<Value, Element> {

    /// Create a new instance of the most-derived class, calling
    /// `initializeValue` on the partially-constructed object to
    /// generate an initial `Value`.
    final public class func create(minimumCapacity: Int, initialValue: (ManagedProtoBuffer<Value, Element>) -> Value) -> ManagedBuffer<Value, Element>

    /// The stored `Value` instance.
    final public var value: Value
}

/// Contains a buffer object, and provides access to an instance of
/// `Value` and contiguous storage for an arbitrary number of
/// `Element` instances stored in that buffer.
///
/// For most purposes, the `ManagedBuffer` class works fine for this
/// purpose, and can simply be used on its own.  However, in cases
/// where objects of various different classes must serve as storage,
/// `ManagedBufferPointer` is needed.
///
/// A valid buffer class is non-`@objc`, with no declared stored
///   properties.  Its `deinit` must destroy its
///   stored `Value` and any constructed `Element`s.
///
/// Example Buffer Class
/// --------------------
///
///      class MyBuffer<Element> { // non-@objc
///        typealias Manager = ManagedBufferPointer<(Int, String), Element>
///        deinit {
///          Manager(unsafeBufferObject: self).withUnsafeMutablePointers {
///            (pointerToValue, pointerToElements) -> Void in
///            pointerToElements.deinitialize(count: self.count)
///            pointerToValue.deinitialize()
///          }
///        }
///
///        // All properties are *computed* based on members of the Value
///        var count: Int {
///          return Manager(unsafeBufferObject: self).value.0
///        }
///        var name: String {
///          return Manager(unsafeBufferObject: self).value.1
///        }
///      }
public struct ManagedBufferPointer<Value, Element> : Equatable {

    /// Create with new storage containing an initial `Value` and space
    /// for at least `minimumCapacity` `element`s.
    ///
    /// - parameter bufferClass: The class of the object used for storage.
    /// - parameter minimumCapacity: The minimum number of `Element`s that
    ///   must be able to be stored in the new buffer.
    /// - parameter initialValue: A function that produces the initial
    ///   `Value` instance stored in the buffer, given the `buffer`
    ///   object and a function that can be called on it to get the actual
    ///   number of allocated elements.
    ///
    /// - Precondition: `minimumCapacity >= 0`, and the type indicated by
    ///   `bufferClass` is a non-`@objc` class with no declared stored
    ///   properties.  The `deinit` of `bufferClass` must destroy its
    ///   stored `Value` and any constructed `Element`s.
    public init(bufferClass: Swift.AnyClass, minimumCapacity: Int, initialValue: (buffer: AnyObject, capacity: (AnyObject) -> Int) -> Value)

    /// Manage the given `buffer`.
    ///
    /// - Precondition: `buffer` is an instance of a non-`@objc` class whose
    ///   `deinit` destroys its stored `Value` and any constructed `Element`s.
    public init(unsafeBufferObject buffer: AnyObject)

    /// The stored `Value` instance.
    public var value: Value

    /// Returns the object instance being used for storage.
    public var buffer: AnyObject { get }

    /// The actual number of elements that can be stored in this object.
    ///
    /// This value may be nontrivial to compute; it is usually a good
    /// idea to store this information in the "value" area when
    /// an instance is created.
    public var capacity: Int { get }

    /// Call `body` with an `UnsafeMutablePointer` to the stored
    /// `Value`.
    ///
    /// - Note: This pointer is only valid
    ///   for the duration of the call to `body`.
    public func withUnsafeMutablePointerToValue<R>(_ body: @noescape (UnsafeMutablePointer<Value>) -> R) -> R

    /// Call `body` with an `UnsafeMutablePointer` to the `Element`
    /// storage.
    ///
    /// - Note: This pointer is only valid for the duration of the
    ///   call to `body`.
    public func withUnsafeMutablePointerToElements<R>(_ body: (UnsafeMutablePointer<Element>) -> R) -> R

    /// Call `body` with `UnsafeMutablePointer`s to the stored `Value`
    /// and raw `Element` storage.
    ///
    /// - Note: These pointers are only valid for the duration of the
    ///   call to `body`.
    public func withUnsafeMutablePointers<R>(_ body: @noescape (UnsafeMutablePointer<Value>, UnsafeMutablePointer<Element>) -> R) -> R

    /// Returns `true` iff `self` holds the only strong reference to its buffer.
    ///
    /// See `isUniquelyReferenced` for details.
    public mutating func holdsUniqueReference() -> Bool

    /// Returns `true` iff either `self` holds the only strong reference
    /// to its buffer or the pinned has been 'pinned'.
    ///
    /// See `isUniquelyReferenced` for details.
    public mutating func holdsUniqueOrPinnedReference() -> Bool
}

extension ManagedBufferPointer {
}

/// A base class of `ManagedBuffer<Value, Element>`, used during
/// instance creation.
///
/// During instance creation, in particular during
/// `ManagedBuffer.create`'s call to initialize, `ManagedBuffer`'s
/// `value` property is as-yet uninitialized, and therefore
/// `ManagedProtoBuffer` does not offer access to the as-yet
/// uninitialized `value` property of `ManagedBuffer`.
public class ManagedProtoBuffer<Value, Element> : NonObjectiveCBase {

    /// The actual number of elements that can be stored in this object.
    ///
    /// This value may be nontrivial to compute; it is usually a good
    /// idea to store this information in the "value" area when
    /// an instance is created.
    final public var capacity: Int { get }

    /// Call `body` with an `UnsafeMutablePointer` to the stored
    /// `Value`.
    ///
    /// - Note: This pointer is only valid for the duration of the
    ///   call to `body`.
    final public func withUnsafeMutablePointerToValue<R>(_ body: (UnsafeMutablePointer<Value>) -> R) -> R

    /// Call `body` with an `UnsafeMutablePointer` to the `Element`
    /// storage.
    ///
    /// - Note: This pointer is only valid for the duration of the
    ///   call to `body`.
    final public func withUnsafeMutablePointerToElements<R>(_ body: (UnsafeMutablePointer<Element>) -> R) -> R

    /// Call `body` with `UnsafeMutablePointer`s to the stored `Value`
    /// and raw `Element` storage.
    ///
    /// - Note: These pointers are only valid for the duration of the
    ///   call to `body`.
    final public func withUnsafeMutablePointers<R>(_ body: (UnsafeMutablePointer<Value>, UnsafeMutablePointer<Element>) -> R) -> R
}

/// Representation of the sub-structure and optional "display style"
/// of any arbitrary subject instance.
///
/// Describes the parts---such as stored properties, collection
/// elements, tuple elements, or the active enumeration case---that
/// make up a particular instance.  May also supply a "display style"
/// property that suggests how this structure might be rendered.
///
/// Mirrors are used by playgrounds and the debugger.
public struct Mirror {

    /// Representation of ancestor classes.
    ///
    /// A `CustomReflectable` class can control how its mirror will
    /// represent ancestor classes by initializing the mirror with a
    /// `AncestorRepresentation`.  This setting has no effect on mirrors
    /// reflecting value type instances.
    public enum AncestorRepresentation {

        /// Generate a default mirror for all ancestor classes.
        ///
        /// This case is the default.
        ///
        /// - Note: This option generates default mirrors even for
        ///   ancestor classes that may implement `CustomReflectable`'s
        ///   `customMirror` requirement.  To avoid dropping an ancestor class
        ///   customization, an override of `customMirror` should pass
        ///   `ancestorRepresentation: .Customized(super.customMirror)` when
        ///   initializing its `Mirror`.
        case generated

        /// Use the nearest ancestor's implementation of `customMirror` to
        /// create a mirror for that ancestor.  Other classes derived from
        /// such an ancestor are given a default mirror.
        ///
        /// The payload for this option should always be
        /// "`{ super.customMirror }`":
        ///
        ///     var customMirror: Mirror {
        ///       return Mirror(
        ///         self,
        ///         children: ["someProperty": self.someProperty],
        ///         ancestorRepresentation: .Customized({ super.customMirror })) // <==
        ///     }
        case customized(() -> Mirror)

        /// Suppress the representation of all ancestor classes.  The
        /// resulting `Mirror`'s `superclassMirror` is `nil`.
        case suppressed
    }

    /// Reflect upon the given `subject`.
    ///
    /// If the dynamic type of `subject` conforms to `CustomReflectable`,
    /// the resulting mirror is determined by its `customMirror` property.
    /// Otherwise, the result is generated by the language.
    ///
    /// - Note: If the dynamic type of `subject` has value semantics,
    ///   subsequent mutations of `subject` will not observable in
    ///   `Mirror`.  In general, though, the observability of such
    /// mutations is unspecified.
    public init(reflecting subject: Swift.Any)

    /// An element of the reflected instance's structure.  The optional
    /// `label` may be used when appropriate, e.g. to represent the name
    /// of a stored property or of an active `enum` case, and will be
    /// used for lookup when `String`s are passed to the `descendant`
    /// method.
    public typealias Child = (label: String?, value: Swift.Any)

    /// The type used to represent sub-structure.
    ///
    /// Depending on your needs, you may find it useful to "upgrade"
    /// instances of this type to `AnyBidirectionalCollection` or
    /// `AnyRandomAccessCollection`.  For example, to display the last
    /// 20 children of a mirror if they can be accessed efficiently, you
    /// might write:
    ///
    ///     if let b = AnyBidirectionalCollection(someMirror.children) {
    ///       var i = xs.index(b.endIndex, offsetBy: -20,
    ///         limitedBy: b.startIndex) ?? b.startIndex
    ///       while i != xs.endIndex {
    ///          print(b[i])
    ///          b.formIndex(after: &i)
    ///       }
    ///     }
    public typealias Children = AnyCollection<Mirror.Type.Child>

    /// A suggestion of how a `Mirror`'s is to be interpreted.
    ///
    /// Playgrounds and the debugger will show a representation similar
    /// to the one used for instances of the kind indicated by the
    /// `DisplayStyle` case name when the `Mirror` is used for display.
    public enum DisplayStyle {

        case `struct`

        case `class`

        case `enum`

        case tuple

        case optional

        case collection

        case dictionary

        case set
    }

    /// Represent `subject` with structure described by `children`,
    /// using an optional `displayStyle`.
    ///
    /// If `subject` is not a class instance, `ancestorRepresentation`
    /// is ignored.  Otherwise, `ancestorRepresentation` determines
    /// whether ancestor classes will be represented and whether their
    /// `customMirror` implementations will be used.  By default, a
    /// representation is automatically generated and any `customMirror`
    /// implementation is bypassed.  To prevent bypassing customized
    /// ancestors, `customMirror` overrides should initialize the
    /// `Mirror` with:
    ///
    ///     ancestorRepresentation: .customized({ super.customMirror })
    ///
    /// - Note: The traversal protocol modeled by `children`'s indices
    ///   (`ForwardIndex`, `BidirectionalIndex`, or
    ///   `RandomAccessIndex`) is captured so that the resulting
    /// `Mirror`'s `children` may be upgraded later.  See the failable
    /// initializers of `AnyBidirectionalCollection` and
    /// `AnyRandomAccessCollection` for details.
    public init<Subject, C : Collection where C.Iterator.Element == Child, C.SubSequence : Collection, C.SubSequence.Iterator.Element == Child, C.SubSequence.Index == C.Index, C.SubSequence.Indices : Collection, C.SubSequence.Indices.Iterator.Element == C.Index, C.SubSequence.Indices.Index == C.Index, C.SubSequence.Indices.SubSequence == C.SubSequence.Indices, C.SubSequence.SubSequence == C.SubSequence, C.Indices : Collection, C.Indices.Iterator.Element == C.Index, C.Indices.Index == C.Index, C.Indices.SubSequence == C.Indices>(_ subject: Subject, children: C, displayStyle: Mirror.DisplayStyle? = default, ancestorRepresentation: Mirror.AncestorRepresentation = default)

    /// Represent `subject` with child values given by
    /// `unlabeledChildren`, using an optional `displayStyle`.  The
    /// result's child labels will all be `nil`.
    ///
    /// This initializer is especially useful for the mirrors of
    /// collections, e.g.:
    ///
    ///     extension MyArray : CustomReflectable {
    ///       var customMirror: Mirror {
    ///         return Mirror(self, unlabeledChildren: self, displayStyle: .collection)
    ///       }
    ///     }
    ///
    /// If `subject` is not a class instance, `ancestorRepresentation`
    /// is ignored.  Otherwise, `ancestorRepresentation` determines
    /// whether ancestor classes will be represented and whether their
    /// `customMirror` implementations will be used.  By default, a
    /// representation is automatically generated and any `customMirror`
    /// implementation is bypassed.  To prevent bypassing customized
    /// ancestors, `customMirror` overrides should initialize the
    /// `Mirror` with:
    ///
    ///     ancestorRepresentation: .Customized({ super.customMirror })
    ///
    /// - Note: The traversal protocol modeled by `children`'s indices
    ///   (`ForwardIndex`, `BidirectionalIndex`, or
    ///   `RandomAccessIndex`) is captured so that the resulting
    /// `Mirror`'s `children` may be upgraded later.  See the failable
    /// initializers of `AnyBidirectionalCollection` and
    /// `AnyRandomAccessCollection` for details.
    public init<Subject, C : Collection where C.SubSequence : Collection, C.SubSequence.SubSequence == C.SubSequence, C.Indices : Collection, C.Indices.Iterator.Element == C.Index, C.Indices.Index == C.Index, C.Indices.SubSequence == C.Indices>(_ subject: Subject, unlabeledChildren: C, displayStyle: Mirror.DisplayStyle? = default, ancestorRepresentation: Mirror.AncestorRepresentation = default)

    /// Represent `subject` with labeled structure described by
    /// `children`, using an optional `displayStyle`.
    ///
    /// Pass a dictionary literal with `String` keys as `children`.  Be
    /// aware that although an *actual* `Dictionary` is
    /// arbitrarily-ordered, the ordering of the `Mirror`'s `children`
    /// will exactly match that of the literal you pass.
    ///
    /// If `subject` is not a class instance, `ancestorRepresentation`
    /// is ignored.  Otherwise, `ancestorRepresentation` determines
    /// whether ancestor classes will be represented and whether their
    /// `customMirror` implementations will be used.  By default, a
    /// representation is automatically generated and any `customMirror`
    /// implementation is bypassed.  To prevent bypassing customized
    /// ancestors, `customMirror` overrides should initialize the
    /// `Mirror` with:
    ///
    ///     ancestorRepresentation: .customized({ super.customMirror })
    ///
    /// - Note: The resulting `Mirror`'s `children` may be upgraded to
    ///   `AnyRandomAccessCollection` later.  See the failable
    ///   initializers of `AnyBidirectionalCollection` and
    /// `AnyRandomAccessCollection` for details.
    public init<Subject>(_ subject: Subject, children: DictionaryLiteral<String, Swift.Any>, displayStyle: Mirror.DisplayStyle? = default, ancestorRepresentation: Mirror.AncestorRepresentation = default)

    /// The static type of the subject being reflected.
    ///
    /// This type may differ from the subject's dynamic type when `self`
    /// is the `superclassMirror` of another mirror.
    public let subjectType: Swift.Any.Type

    /// A collection of `Child` elements describing the structure of the
    /// reflected subject.
    public let children: Children

    /// Suggests a display style for the reflected subject.
    public let displayStyle: Mirror.DisplayStyle?

    public var superclassMirror: Mirror? { get }
}

extension Mirror {

    /// Return a specific descendant of the reflected subject, or `nil`
    /// Returns a specific descendant of the reflected subject, or `nil`
    /// if no such descendant exists.
    ///
    /// A `String` argument selects the first `Child` with a matching label.
    /// An integer argument *n* select the *n*th `Child`.  For example:
    ///
    ///     var d = Mirror(reflecting: x).descendant(1, "two", 3)
    ///
    /// is equivalent to:
    ///
    ///     var d = nil
    ///     let children = Mirror(reflecting: x).children
    ///     if let p0 = children.index(children.startIndex,
    ///       offsetBy: 1, limitedBy: children.endIndex) {
    ///       let grandChildren = Mirror(reflecting: children[p0].value).children
    ///       SeekTwo: for g in grandChildren {
    ///         if g.label == "two" {
    ///           let greatGrandChildren = Mirror(reflecting: g.value).children
    ///           if let p1 = greatGrandChildren.index(
    ///             greatGrandChildren.startIndex,
    ///             offsetBy: 3, limitedBy: greatGrandChildren.endIndex) {
    ///             d = greatGrandChildren[p1].value
    ///           }
    ///           break SeekTwo
    ///         }
    ///       }
    ///     }
    ///
    /// As you can see, complexity for each element of the argument list
    /// depends on the argument type and capabilities of the collection
    /// used to initialize the corresponding subject's parent's mirror.
    /// Each `String` argument results in a linear search.  In short,
    /// this function is suitable for exploring the structure of a
    /// `Mirror` in a REPL or playground, but don't expect it to be
    /// efficient.
    public func descendant(_ first: MirrorPath, _ rest: MirrorPath...) -> Swift.Any?
}

/// Reflection for `Mirror` itself.
extension Mirror : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Instead of accessing this property directly, convert an instance of any
    /// type to a string by using the `String(_:)` initializer. For example:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension Mirror : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// A protocol for legitimate arguments to `Mirror`'s `descendant`
/// method.
///
/// Do not declare new conformances to this protocol; they will not
/// work as expected.
public protocol MirrorPath {
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `MutableBidirectionalSlice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
///
/// - Note: `MutableBidirectionalSlice` requires that the base collection's `subscript(_: Index)`
///   setter does not invalidate indices. If you are writing a collection and
///   mutations need to invalidate indices, don't use `MutableBidirectionalSlice` as its
///   subsequence type. Instead, use the nonmutable `Slice` or define your own
///   subsequence type that takes your index invalidation requirements into
///   account.
public struct MutableBidirectionalSlice<Base : protocol<BidirectionalIndexable, MutableIndexable>> : BidirectionalCollection, MutableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = MutableBidirectionalSlice<Base>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Base.Index>) -> MutableBidirectionalSlice<Base>

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A collection that supports subscript assignment.
///
/// Collections that conform to `MutableCollection` gain the ability to
/// change the value of their elements. This example shows how you can
/// modify one of the names in an array of students.
///
///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
///     if let i = students.index(of: "Maxime") {
///         students[i] = "Max"
///     }
///     print(students)
///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
///
/// In addition to changing the value of an individual element, you can also
/// change the values of a slice of elements in a mutable collection. For
/// example, you can sort *part* of a mutable collection by calling the
/// mutable `sort()` method on a subscripted subsequence. Here's an
/// example that sorts the first half of an array of integers:
///
///     var numbers = [15, 40, 10, 30, 60, 25, 5, 100]
///     numbers[0..<4].sort()
///     print(numbers)
///     // Prints "[10, 15, 30, 40, 60, 25, 5, 100]"
///
/// The `MutableCollection` protocol allows changing the values of a
/// collection's elements but not the length of the collection itself. For
/// operations that require adding or removing elements, see the
/// `RangeReplaceableCollection` protocol instead.
///
/// Conforming to the MutableCollection Protocol
/// ============================================
///
/// To add conformance to the `MutableCollection` protocol to your own
/// custom collection, upgrade your type's subscript to support both read
/// and write access.
/// 
/// A value stored into a subscript of a `MutableCollection` instance must
/// subsequently be accessible at that same position. That is, for a mutable
/// collection instance `a`, index `i`, and value `x`, the two sets of
/// assignments in the following code sample must be equivalent:
///
///     a[i] = x
///     let y = a[i]
///     
///     // Must be equivalent to:
///     a[i] = x
///     let y = x
public protocol MutableCollection : MutableIndexable, Collection {

    /// A collection that represents a contiguous subrange of the collection's
    /// elements.
    associatedtype SubSequence : Collection = MutableSlice<Self>

    /// Accesses the element at the specified position.
    ///
    /// For example, you can replace an element of an array by using its
    /// subscript.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one
    /// past the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(position: Self.Index) -> Self.Iterator.Element { get set }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     streets[index!] = "Eustace"
    ///     print(streets[index!])
    ///     // Prints "Eustace"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Self.Index>) -> Self.SubSequence { get set }
}

extension MutableCollection where Self : RandomAccessCollection {

    /// Reorders the elements in the collection and returns a pivot index, using
    /// the given predicate as the comparison between elements.
    ///
    /// This method is typically one step of a sorting algorithm. A collection is
    /// partitioned around a pivot index when each of the elements before the
    /// pivot is correctly ordered before each of the elements at or after the
    /// pivot. The `partition(isOrderedBefore:)` method reorders the elements of
    /// the collection and returns a pivot index that satisfies this condition,
    /// using the given predicate to determine the relative order of any two
    /// elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `isOrderedBefore(a, a)` is always `false`. (Irreflexivity)
    /// - If `isOrderedBefore(a, b)` and `isOrderedBefore(b, c)` are both `true`,
    ///   then `isOrderedBefore(a, c)` is also `true`. (Transitive
    ///   comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// Here's an example that uses a predicate that orders elements from largest
    /// to smallest:
    ///
    ///     var numbers = [50, 30, 60, 50, 80, 10, 40, 30]
    ///     let pivot = numbers.partition { a, b in a > b }
    ///
    ///     print(pivot)
    ///     // Prints "2"
    ///     print(numbers)
    ///     // Prints "[60, 80, 50, 50, 30, 10, 40, 30]"
    ///
    /// The return value of the call to `numbers.partition()` is the pivot for
    /// the rearranged `numbers` array. `pivot` divides the collection into two
    /// subranges, `numbers[0..<pivot]` and `numbers[pivot..<8]`.
    ///
    ///     print(numbers[0..<pivot])
    ///     // Prints "[60, 80]"
    ///     print(numbers[pivot..<8])
    ///     // Prints "[50, 50, 30, 10, 40, 30]"
    ///
    /// The elements of `numbers` are rearranged so that every element in the
    /// subrange before `pivot` is ordered before every element in the subrange
    /// after. Because the supplied predicate returns `true` when its first
    /// argument is greater than its second argument, larger elements are
    /// ordered before smaller elements.
    ///
    /// - Parameter isOrderedBefore: A predicate that returns `true` if its first
    ///   argument should be ordered before its second argument; otherwise,
    ///   `false`.
    /// - Returns: A pivot index, such that every element before the pivot is
    ///   ordered before every element at or above the pivot, using
    ///   `isOrderedBefore` to determine the relative order of any two elements.
    ///   The returned pivot is equal to the collection's end index only if the
    ///   collection is empty.
    ///
    /// - SeeAlso: `partition()`
    public mutating func partition(isOrderedBefore: @noescape (Self.Iterator.Element, Self.Iterator.Element) -> Bool) -> Self.Index
}

extension MutableCollection where Self : RandomAccessCollection, Iterator.Element : Comparable {

    /// Reorders the elements in the collection and returns a pivot index.
    ///
    /// This method is typically one step of a sorting algorithm. A collection is
    /// partitioned around a pivot index when each of the elements before the
    /// pivot are less than each of the elements at or after the pivot. The
    /// `partition()` method reorders the elements of the collection and returns
    /// a pivot index that satisfies this condition.
    ///
    /// For example:
    ///
    ///     var numbers = [50, 30, 60, 50, 80, 10, 40, 30]
    ///     let pivot = numbers.partition()
    ///
    ///     print(pivot)
    ///     // Prints "4"
    ///     print(numbers)
    ///     // Prints "[10, 30, 30, 40, 50, 80, 50, 60]"
    ///
    /// The return value of the call to `numbers.partition()` is the pivot for
    /// the rearranged `numbers` array. `pivot` divides the collection into two
    /// subranges, `numbers[0..<pivot]` and `numbers[pivot..<8]`.
    ///
    ///     print(numbers[0..<pivot])
    ///     // Prints "[10, 30, 30, 40]"
    ///     print(numbers[pivot..<8])
    ///     // Prints "[50, 80, 50, 60]"
    ///
    /// The elements of `numbers` are rearranged so that every element in the
    /// subrange before `pivot` is less than every element in the subrange
    /// after.
    ///
    /// - Returns: A pivot index, such that every element before the pivot is
    ///   less than every element at or above the pivot. The returned pivot is
    ///   equal to the collection's end index only if the collection is empty.
    ///
    /// - SeeAlso: `partition(isOrderedBefore:)`
    public mutating func partition() -> Self.Index
}

extension MutableCollection where Self.Iterator.Element : Comparable {

    /// Returns the elements of the collection, sorted.
    ///
    /// You can sort any collection of elements that conform to the
    /// `Comparable` protocol by calling this method. Elements are sorted in
    /// ascending order.
    ///
    /// The sorting algorithm is not stable. A nonstable sort may change the
    /// relative order of elements that compare equal.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your collection in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(isOrderedBefore:)` method.
    ///
    ///     let descendingStudents = students.sorted(isOrderedBefore: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// - Returns: A sorted array of the collection's elements.
    ///
    /// - SeeAlso: `sorted(isOrderedBefore:)`
    public func sorted() -> [Self.Iterator.Element]
}

extension MutableCollection {

    /// Returns the elements of the collection, sorted using the given
    /// predicate as the comparison between elements.
    ///
    /// When you want to sort a collection of elements that don't conform to
    /// the `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element passed should be ordered before the
    /// second. The elements of the resulting array are ordered according to the
    /// given predicate.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `isOrderedBefore(a, a)` is always `false`. (Irreflexivity)
    /// - If `isOrderedBefore(a, b)` and `isOrderedBefore(b, c)` are both `true`,
    ///   then `isOrderedBefore(a, c)` is also `true`. (Transitive
    ///   comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not stable. A nonstable sort may change the
    /// relative order of elements for which `isOrderedBefore` does not
    /// establish an order.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your collection
    /// in descending order, pass the greater-than operator (`>`) as the
    /// `isOrderedBefore` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(isOrderedBefore: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(isOrderedBefore: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// - Parameter isOrderedBefore: A predicate that returns `true` if its first
    ///   argument should be ordered before its second argument; otherwise,
    ///   `false`.
    /// - Returns: A sorted array of the collection's elements.
    ///
    /// - SeeAlso: `sorted()`
    public func sorted(isOrderedBefore: @noescape (Self.Iterator.Element, Self.Iterator.Element) -> Bool) -> [Self.Iterator.Element]
}

extension MutableCollection where Self : RandomAccessCollection, Self.Iterator.Element : Comparable {

    /// Sorts the collection in place.
    ///
    /// You can sort any mutable collection of elements that conform to the
    /// `Comparable` protocol by calling this method. Elements are sorted in
    /// ascending order.
    ///
    /// The sorting algorithm is not stable. A nonstable sort may change the
    /// relative order of elements that compare equal.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     var students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     students.sort()
    ///     print(students)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your collection in descending order, pass the
    /// greater-than operator (`>`) to the `sort(isOrderedBefore:)` method.
    ///
    ///     students.sort(isOrderedBefore: >)
    ///     print(students)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    public mutating func sort()
}

extension MutableCollection where Self : RandomAccessCollection {

    /// Sorts the collection in place, using the given predicate as the
    /// comparison between elements.
    ///
    /// When you want to sort a collection of elements that doesn't conform to
    /// the `Comparable` protocol, pass a closure to this method that returns
    /// `true` when the first element passed should be ordered before the
    /// second.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `isOrderedBefore(a, a)` is always `false`. (Irreflexivity)
    /// - If `isOrderedBefore(a, b)` and `isOrderedBefore(b, c)` are both `true`,
    ///   then `isOrderedBefore(a, c)` is also `true`. (Transitive
    ///   comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not stable. A nonstable sort may change the
    /// relative order of elements for which `isOrderedBefore` does not
    /// establish an order.
    ///
    /// In the following example, the closure provides an ordering for an array
    /// of a custom enumeration that describes an HTTP response. The predicate
    /// orders errors before successes and sorts the error responses by their
    /// error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     var responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     responses.sort {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(responses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// Alternatively, use this method to sort a collection of elements that do
    /// conform to `Comparable` when you want the sort to be descending instead
    /// of ascending. Pass the greater-than operator (`>`) operator as the
    /// predicate.
    ///
    ///     var students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     students.sort(isOrderedBefore: >)
    ///     print(students)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// - Parameter isOrderedBefore: A predicate that returns `true` if its first
    ///   argument should be ordered before its second argument; otherwise,
    ///   `false`.
    public mutating func sort(isOrderedBefore: @noescape (Self.Iterator.Element, Self.Iterator.Element) -> Bool)
}

extension MutableCollection {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     streets[index!] = "Eustace"
    ///     print(streets[index!])
    ///     // Prints "Eustace"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Self.Index>) -> MutableSlice<Self>
}

/// A type that provides subscript access to its elements.
///
/// In most cases, it's best to ignore this protocol and use the
/// `MutableCollection` protocol instead, because it has a more complete
/// interface.
public protocol MutableIndexable : Indexable {

    associatedtype Index : Comparable

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Self.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Self.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// For example, you can replace an element of an array by using its
    /// subscript.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one
    /// past the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(position: Self.Index) -> Self._Element { get set }

    /// A collection that represents a contiguous subrange of the collection's
    /// elements.
    associatedtype SubSequence

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     streets[index!] = "Eustace"
    ///     print(streets[index!])
    ///     // Prints "Eustace"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Self.Index>) -> Self.SubSequence { get set }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Self.Index) -> Self.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Self.Index)
}

extension MutableIndexable {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     streets[index!] = "Eustace"
    ///     print(streets[index!])
    ///     // Prints "Eustace"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: ClosedRange<Self.Index>) -> Self.SubSequence
}

extension MutableIndexable where Index : Strideable, Index.Stride : SignedInteger {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     streets[index!] = "Eustace"
    ///     print(streets[index!])
    ///     // Prints "Eustace"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: CountableRange<Self.Index>) -> Self.SubSequence

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     streets[index!] = "Eustace"
    ///     print(streets[index!])
    ///     // Prints "Eustace"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: CountableClosedRange<Self.Index>) -> Self.SubSequence
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `MutableRandomAccessSlice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
///
/// - Note: `MutableRandomAccessSlice` requires that the base collection's `subscript(_: Index)`
///   setter does not invalidate indices. If you are writing a collection and
///   mutations need to invalidate indices, don't use `MutableRandomAccessSlice` as its
///   subsequence type. Instead, use the nonmutable `Slice` or define your own
///   subsequence type that takes your index invalidation requirements into
///   account.
public struct MutableRandomAccessSlice<Base : protocol<MutableIndexable, RandomAccessIndexable>> : RandomAccessCollection, MutableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = MutableRandomAccessSlice<Base>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Base.Index>) -> MutableRandomAccessSlice<Base>

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position. The
    /// operation doesn't require going beyond the limiting `s.endIndex` value,
    /// so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `MutableRangeReplaceableBidirectionalSlice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
///
/// - Note: `MutableRangeReplaceableBidirectionalSlice` requires that the base collection's `subscript(_: Index)`
///   setter does not invalidate indices. If you are writing a collection and
///   mutations need to invalidate indices, don't use `MutableRangeReplaceableBidirectionalSlice` as its
///   subsequence type. Instead, use the nonmutable `Slice` or define your own
///   subsequence type that takes your index invalidation requirements into
///   account.
public struct MutableRangeReplaceableBidirectionalSlice<Base : protocol<BidirectionalIndexable, MutableIndexable, RangeReplaceableIndexable>> : BidirectionalCollection, MutableCollection, RangeReplaceableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = MutableRangeReplaceableBidirectionalSlice<Base>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Base.Index>) -> MutableRangeReplaceableBidirectionalSlice<Base>

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a new, empty collection.
    public init()

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// The following example creates an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Base._Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S : Sequence where S.Iterator.Element == Base._Element>(_ elements: S)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Base._Element>(_ subRange: Range<Base.Index>, with newElements: C)

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Base._Element, at i: Base.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<S : Collection where S.Iterator.Element == Base._Element>(contentsOf newElements: S, at i: Base.Index)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter i: The position of the element to remove. `index` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at i: Base.Index) -> Base._Element

    /// Removes the specified subrange of elements from the collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeSubrange(1...3)
    ///     print(bugs)
    ///     // Prints "["Aphid", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The subrange of the collection to remove. The bounds
    ///   of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: Range<Base.Index>)

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `MutableRangeReplaceableRandomAccessSlice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
///
/// - Note: `MutableRangeReplaceableRandomAccessSlice` requires that the base collection's `subscript(_: Index)`
///   setter does not invalidate indices. If you are writing a collection and
///   mutations need to invalidate indices, don't use `MutableRangeReplaceableRandomAccessSlice` as its
///   subsequence type. Instead, use the nonmutable `Slice` or define your own
///   subsequence type that takes your index invalidation requirements into
///   account.
public struct MutableRangeReplaceableRandomAccessSlice<Base : protocol<MutableIndexable, RandomAccessIndexable, RangeReplaceableIndexable>> : RandomAccessCollection, MutableCollection, RangeReplaceableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = MutableRangeReplaceableRandomAccessSlice<Base>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Base.Index>) -> MutableRangeReplaceableRandomAccessSlice<Base>

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a new, empty collection.
    public init()

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// The following example creates an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Base._Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S : Sequence where S.Iterator.Element == Base._Element>(_ elements: S)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Base._Element>(_ subRange: Range<Base.Index>, with newElements: C)

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Base._Element, at i: Base.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<S : Collection where S.Iterator.Element == Base._Element>(contentsOf newElements: S, at i: Base.Index)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter i: The position of the element to remove. `index` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at i: Base.Index) -> Base._Element

    /// Removes the specified subrange of elements from the collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeSubrange(1...3)
    ///     print(bugs)
    ///     // Prints "["Aphid", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The subrange of the collection to remove. The bounds
    ///   of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: Range<Base.Index>)

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `MutableRangeReplaceableSlice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
///
/// - Note: `MutableRangeReplaceableSlice` requires that the base collection's `subscript(_: Index)`
///   setter does not invalidate indices. If you are writing a collection and
///   mutations need to invalidate indices, don't use `MutableRangeReplaceableSlice` as its
///   subsequence type. Instead, use the nonmutable `Slice` or define your own
///   subsequence type that takes your index invalidation requirements into
///   account.
public struct MutableRangeReplaceableSlice<Base : protocol<MutableIndexable, RangeReplaceableIndexable>> : Collection, MutableCollection, RangeReplaceableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = MutableRangeReplaceableSlice<Base>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Base.Index>) -> MutableRangeReplaceableSlice<Base>

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a new, empty collection.
    public init()

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// The following example creates an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Base._Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S : Sequence where S.Iterator.Element == Base._Element>(_ elements: S)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Base._Element>(_ subRange: Range<Base.Index>, with newElements: C)

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Base._Element, at i: Base.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<S : Collection where S.Iterator.Element == Base._Element>(contentsOf newElements: S, at i: Base.Index)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter i: The position of the element to remove. `index` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at i: Base.Index) -> Base._Element

    /// Removes the specified subrange of elements from the collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeSubrange(1...3)
    ///     print(bugs)
    ///     // Prints "["Aphid", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The subrange of the collection to remove. The bounds
    ///   of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: Range<Base.Index>)

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `MutableSlice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
///
/// - Note: `MutableSlice` requires that the base collection's `subscript(_: Index)`
///   setter does not invalidate indices. If you are writing a collection and
///   mutations need to invalidate indices, don't use `MutableSlice` as its
///   subsequence type. Instead, use the nonmutable `Slice` or define your own
///   subsequence type that takes your index invalidation requirements into
///   account.
public struct MutableSlice<Base : MutableIndexable> : Collection, MutableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = MutableSlice<Base>

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Base.Index>) -> MutableSlice<Base>

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A type that can be initialized using the nil literal, `nil`.
///
/// `nil` has a specific meaning in Swift---the absence of a value. Only the
/// `Optional` type conforms to `NilLiteralConvertible`.
/// `NilLiteralConvertible` conformance for types that use `nil` for other
/// purposes is discouraged.
///
/// - SeeAlso: `Optional`
public protocol NilLiteralConvertible {

    /// Creates an instance initialized with `nil`.
    public init(nilLiteral: ())
}

/// A common base class for classes that need to be non-`@objc`,
/// recognizably in the type system.
///
/// - SeeAlso: `isUniquelyReferenced`
public class NonObjectiveCBase {

    public init()
}

/// A unique identifier for a class instance or metatype.
///
/// In Swift, only class instances and metatypes have unique identities. There
/// is no notion of identity for structs, enums, functions, or tuples.
public struct ObjectIdentifier : Hashable, Comparable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }

    /// Construct an instance that uniquely identifies the class instance `x`.
    public init(_ x: AnyObject)

    /// Construct an instance that uniquely identifies the metatype `x`.
    public init(_ x: Swift.Any.Type)
}

extension ObjectIdentifier {
}

/// A wrapper around an opaque C pointer.
///
/// Opaque pointers are used to represent C pointers to types that
/// cannot be represented in Swift, such as incomplete struct types.
public struct OpaquePointer : Equatable, Hashable {

    /// Construct an `OpaquePointer` from a given address in memory.
    public init?(bitPattern: Int)

    /// Construct an `OpaquePointer` from a given address in memory.
    public init?(bitPattern: UInt)

    /// Convert a typed `UnsafePointer` to an opaque C pointer.
    public init<T>(_ from: UnsafePointer<T>)

    /// Convert a typed `UnsafePointer` to an opaque C pointer.
    ///
    /// Returns nil if `from` is nil.
    public init?<T>(_ from: UnsafePointer<T>?)

    /// Convert a typed `UnsafeMutablePointer` to an opaque C pointer.
    public init<T>(_ from: UnsafeMutablePointer<T>)

    /// Convert a typed `UnsafeMutablePointer` to an opaque C pointer.
    ///
    /// Returns nil if `from` is nil.
    public init?<T>(_ from: UnsafeMutablePointer<T>?)

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension OpaquePointer : CustomDebugStringConvertible {

    /// A textual representation of `self`, suitable for debugging.
    public var debugDescription: String { get }
}

extension OpaquePointer : CVarArg {
}

/// A type that presents a mathematical set interface to a bit mask.
///
/// You use the `OptionSet` protocol to represent bit mask types, where
/// individual bits represent members of the set. Adopting this protocol in
/// your custom types lets you perform set-related operations such as
/// membership tests, unions, and intersections on those types. What's more,
/// when implemented using specific criteria, adoption of this protocol
/// requires no extra work on your part.
///
/// When creating an option set, include a `rawValue` property in your type
/// declaration. The `rawValue` property must be of a type that conforms to
/// the `BitwiseOperations` protocol, such as `Int` or `UInt8`. Next, create
/// unique options as static properties of your custom type using unique
/// powers of two (1, 2, 4, 8, 16, and so forth) for each individual
/// property's raw value so that each property can be represented by a single
/// bit of the type's raw value.
///
/// For example, consider a custom type called `ShippingOptions` that is an
/// option set of the possible ways to ship a customer's purchase.
/// `ShippingOptions` includes a `rawValue` property of type `Int` that stores
/// the bit mask of available shipping options. The static members `NextDay`,
/// `SecondDay`, `Priority`, and `Standard` are unique, individual options.
///
///     struct ShippingOptions: OptionSet {
///         let rawValue: Int
///
///         static let nextDay    = ShippingOptions(rawValue: 1 << 0)
///         static let secondDay  = ShippingOptions(rawValue: 1 << 1)
///         static let priority   = ShippingOptions(rawValue: 1 << 2)
///         static let standard   = ShippingOptions(rawValue: 1 << 3)
///
///         static let express: ShippingOptions = [.nextDay, .secondDay]
///         static let all: ShippingOptions = [.express, .priority, .standard]
///     }
///
/// Declare additional preconfigured option set values as static properties
/// initialized with an array literal containing other option values. In the
/// example, because the `express` static property is assigned an array
/// literal with the `nextDay` and `secondDay` options, it will contain those
/// two elements.
///
/// Using an Option Set Type
/// ========================
///
/// When you need to create an instance of an option set, assign one of the
/// type's static members to your variable or constant. Alternately, to create
/// an option set instance with multiple members, assign an array literal with
/// multiple static members of the option set. To create an empty instance,
/// assign an empty array literal to your variable.
///
///     let singleOption: ShippingOptions = .priority
///     let multipleOptions: ShippingOptions = [.nextDay, .secondDay, .priority]
///     let noOptions: ShippingOptions = []
///
/// Use set-related operations to check for membership and to add or remove
/// members from an instance of your custom option set type. The following
/// example shows how you can determine free shipping options based on a
/// customer's purchase price:
///
///     let purchasePrice = 87.55
///
///     var freeOptions: ShippingOptions = []
///     if purchasePrice > 50 {
///         freeOptions.insert(.priority)
///     }
///
///     if freeOptions.contains(.priority) {
///         print("You've earned free priority shipping!")
///     } else {
///         print("Add more to your cart for free priority shipping!")
///     }
///     // Prints "You've earned free priority shipping!"
///
/// - SeeAlso: `BitwiseOperations`, `SetAlgebra`
public protocol OptionSet : SetAlgebra, RawRepresentable {

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    associatedtype Element = Self

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create.
    /// - Returns: A new option set with the given raw value. Each bit of the raw
    ///   value potentially represents an element of the option set, though raw
    ///   values may include bits that are not defined as distinct values of the
    ///   `OptionSet` type.
    public init(rawValue: Self.RawValue)
}

/// `OptionSet` requirements for which default implementations
/// are supplied.
///
/// - Note: A type conforming to `OptionSet` can implement any of
///  these initializers or methods, and those implementations will be
///  used in lieu of these defaults.
extension OptionSet {

    /// Returns a new option set of the elements contained in this set, in the
    /// given set, or in both.
    ///
    /// This example uses the `union(_:)` method to add two more shipping options
    /// to the default set.
    ///
    ///     let defaultShipping = ShippingOptions.standard
    ///     let memberShipping = defaultShipping.union([.secondDay, .priority])
    ///     print(memberShipping.contains(.priority))
    ///     // Prints "true"
    ///
    /// - Parameter other: An option set.
    /// - Returns: A new option set made up of the elements contained in this
    ///   set, in `other`, or in both.
    public func union(_ other: Self) -> Self

    /// Returns a new option set with only the elements contained in both this
    /// set and the given set.
    ///
    /// This example uses the `intersection(_:)` method to limit the available
    /// shipping options to what can be used with a PO Box destination.
    ///
    ///     // Can only ship standard or priority to PO Boxes
    ///     let poboxShipping: ShippingOptions = [.standard, .priority]
    ///     let memberShipping: ShippingOptions =
    ///             [.standard, .priority, .secondDay]
    ///
    ///     let availableOptions = memberShipping.intersection(poboxShipping)
    ///     print(availableOptions.contains(.priority))
    ///     // Prints "true"
    ///     print(availableOptions.contains(.secondDay))
    ///     // Prints "false"
    ///
    /// - Parameter other: An option set.
    /// - Returns: A new option set with only the elements contained in both this
    ///   set and `other`.
    public func intersection(_ other: Self) -> Self

    /// Returns a new option set with the elements contained in this set or in
    /// the given set, but not in both.
    ///
    /// - Parameter other: An option set.
    /// - Returns: A new option set with only the elements contained in either
    ///   this set or `other`, but not in both.
    public func symmetricDifference(_ other: Self) -> Self
}

/// `OptionSet` requirements for which default implementations are
/// supplied when `Element == Self`, which is the default.
///
/// - Note: A type conforming to `OptionSet` can implement any of
///   these initializers or methods, and those implementations will be
///   used in lieu of these defaults.
extension OptionSet where Element == Self {

    /// Returns a Boolean value that indicates whether a given element is a
    /// member of the option set.
    ///
    /// This example uses the `contains(_:)` method to check whether next-day
    /// shipping is in the `availableOptions` instance.
    ///
    ///     let availableOptions = ShippingOptions.express
    ///     if availableOptions.contains(.nextDay) {
    ///         print("Next day shipping available")
    ///     }
    ///     // Prints "Next day shipping available"
    ///
    /// - Parameter member: The element to look for in the option set.
    /// - Returns: `true` if the option set contains `member`; otherwise,
    ///   `false`.
    public func contains(_ member: Self) -> Bool

    /// Inserts the given element into the option set if it is not already a
    /// member.
    ///
    /// For example:
    ///
    ///     let purchasePrice = 87.55
    ///
    ///     var freeOptions: ShippingOptions = [.standard, .priority]
    ///     if purchasePrice > 50 {
    ///         freeOptions.insert(.secondDay)
    ///     }
    ///     print(freeOptions.contains(.secondDay))
    ///     // Prints "true"
    ///
    /// - Parameter newMember: The element to insert.
    /// - Returns: `(true, newMember)` if `newMember` was not contained in
    ///   `self`. Otherwise, returns `(false, oldMember)`, where `oldMember` is
    ///   the member of the set equal to `newMember`.
    public mutating func insert(_ newMember: Self) -> (inserted: Bool, memberAfterInsert: Self)

    /// Removes the given element and all elements subsumed by the given element.
    ///
    /// For example:
    ///
    ///     var options: ShippingOptions = [.secondDay, .priority]
    ///     let priorityOption = options.remove(.priority)
    ///     print(priorityOption == .priority)
    ///     // Prints "true"
    ///
    ///     print(options.remove(.priority))
    ///     // Prints "nil"
    ///
    /// In the following example, the `.express` element is passed to
    /// `remove(_:)`. Although `.express` is not a member of `options`,
    /// `.express` subsumes the remaining `.secondDay` element of the option
    /// set. Therefore, `options` is emptied and the intersection between
    /// `.express` and `options` is returned.
    ///
    ///     let expressOption = options.remove(.express)
    ///     print(expressOption == .express)
    ///     // Prints "false"
    ///     print(expressOption == .secondDay)
    ///     // Prints "true"
    ///
    /// - Parameter member: The element of the set to remove.
    /// - Returns: The intersection of `[member]` and the set if the intersection
    ///   was nonempty; otherwise, `nil`.
    public mutating func remove(_ member: Self) -> Self?

    /// Inserts the given element into the set.
    ///
    /// If `newMember` is not contained in the set but subsumes current members
    /// of the set, the subsumed members are returned.
    ///
    ///     var options: ShippingOptions = [.secondDay, .priority]
    ///     let replaced = options.update(with: .express)
    ///     print(replaced == .secondDay)
    ///     // Prints "true"
    ///
    /// - Returns: The intersection of `[newMember]` and the set if the
    ///   intersection was nonempty; otherwise, `nil`.
    public mutating func update(with newMember: Self) -> Self?
}

/// `OptionSet` requirements for which default implementations are
/// supplied when `RawValue` conforms to `BitwiseOperations`,
/// which is the usual case.  Each distinct bit of an option set's
/// `.rawValue` corresponds to a disjoint value of the `OptionSet`.
///
/// - `union` is implemented as a bitwise "or" (`|`) of `rawValue`s
/// - `intersection` is implemented as a bitwise "and" (`&`) of
///   `rawValue`s
/// - `symmetricDifference` is implemented as a bitwise "exclusive or"
///    (`^`) of `rawValue`s
///
/// - Note: A type conforming to `OptionSet` can implement any of
///   these initializers or methods, and those implementations will be
///   used in lieu of these defaults.
extension OptionSet where RawValue : BitwiseOperations {

    /// Creates an empty option set.
    ///
    /// This initializer creates an option set with a raw value of zero.
    ///
    /// - Returns: An option set that contains no elements.
    public convenience init()

    /// Inserts the elements of another set into this option set.
    ///
    /// This method is implemented as a `|` (bitwise OR) operation on the
    /// two sets' raw values.
    ///
    /// - Parameter other: An option set.
    public mutating func formUnion(_ other: Self)

    /// Removes all elements of this option set that are not 
    /// also present in the given set.
    ///
    /// This method is implemented as a `&` (bitwise AND) operation on the
    /// two sets' raw values.
    ///
    /// - Parameter other: An option set.
    public mutating func formIntersection(_ other: Self)

    /// Replaces this set with a new set containing all elements 
    /// contained in either this set or the given set, but not in both.
    ///
    /// This method is implemented as a `^` (bitwise XOR) operation on the two
    /// sets' raw values.
    ///
    /// - Parameter other: An option set.
    public mutating func formSymmetricDifference(_ other: Self)
}

/// A type that can represent either a wrapped value or `nil`, the absence of a
/// value.
///
/// You use the `Optional` type whenever you use optional values, even if you
/// never type the word `Optional`. Swift's type system usually shows the
/// wrapped type's name with a trailing question mark (`?`) instead of showing
/// the full type name. For example, if a variable has the type `Int?`, that's
/// just another way of writing `Optional<Int>`. The shortened form is
/// preferred for ease of reading and writing code.
///
/// The types of `shortForm` and `longForm` in the following code sample are
/// the same:
///
///     let shortForm: Int? = Int("42")
///     let longForm: Optional<Int> = Int("42")
///
/// The `Optional` type is an enumeration with two cases. `Optional.none` is
/// equivalent to the `nil` literal. `Optional.some(Wrapped)` stores a wrapped
/// value. For example:
///
///     let number: Int? = Optional.some(42)
///     let noNumber: Int? = Optional.none
///     print(noNumber == nil)
///     // Prints "true"
///
/// You must unwrap the value of an `Optional` instance before you can use it
/// in many contexts. Because Swift provides several ways to safely unwrap
/// optional values, you can choose the one that helps you write clear,
/// concise code.
///
/// The following examples use this dictionary of image names and file paths:
///
///     let imagePaths = ["star": "/glyphs/star.png",
///                       "portrait": "/images/content/portrait.jpg",
///                       "spacer": "/images/shared/spacer.gif"]
///
/// Getting a dictionary's value using a key returns an optional value, so
/// `imagePaths["star"]` has type `Optional<String>` or, written in the
/// preferred manner, `String?`.
///
/// Optional Binding
/// ----------------
///
/// To conditionally bind the wrapped value of an `Optional` instance to a new
/// variable, use one of the optional binding control structures, including
/// `if let`, `guard let`, and `switch`.
///
///     if let starPath = imagePaths["star"] {
///         print("The star image is at '\(starPath)'")
///     } else {
///         print("Couldn't find the star image")
///     }
///     // Prints "The star image is at '/glyphs/star.png'"
///
/// Optional Chaining
/// -----------------
///
/// To safely access the properties and methods of a wrapped instance, use the
/// postfix optional chaining operator (`?`). The following example uses
/// optional chaining to access the `hasSuffix(_:)` method on a `String?`
/// instance.
///
///     if let isPNG = imagePaths["star"]?.hasSuffix(".png") {
///         print("The star image is in PNG format")
///     }
///     // Prints "The star image is in PNG format"
///
/// Using the Nil-Coalescing Operator
/// ---------------------------------
///
/// Use the nil-coalescing operator (`??`) to supply a default value in case
/// the `Optional` instance is `nil`. Here a default path is supplied for an
/// image that is missing from `imagePaths`.
///
///     let defaultImagePath = "/images/default.png"
///     let heartPath = imagePaths["heart"] ?? defaultImagePath
///     print(heartPath)
///     // Prints "/images/default.png"
///
/// The `??` operator also works with another `Optional` instance on the
/// right-hand side. As a result, you can chain multiple `??` operators
/// together.
///
///     let shapePath = imagePaths["cir"] ?? imagePaths["squ"] ?? defaultImagePath
///     print(shapePath)
///     // Prints "/images/default.png"
///
/// Unconditional Unwrapping
/// ------------------------
///
/// When you're certain that an instance of `Optional` contains a value, you
/// can unconditionally unwrap the value by using the forced
/// unwrap operator (postfix `!`). For example, the result of the failable `Int`
/// initializer is unconditionally unwrapped in the example below.
///
///     let number = Int("42")!
///     print(number)
///     // Prints "42"
///
/// You can also perform unconditional optional chaining by using the postfix
/// `!` operator.
///
///     let isPNG = imagePaths["star"]!.hasSuffix(".png")
///     print(isPNG)
///     // Prints "true"
///
/// Unconditionally unwrapping a `nil` instance with `!` triggers a runtime
/// error.
public enum Optional<Wrapped> : NilLiteralConvertible {

    /// The absence of a value.
    ///
    /// In code, the absence of a value is typically written using the `nil`
    /// literal rather than the explicit `.none` enumeration case.
    case none

    /// The presence of a value, stored as `Wrapped`.
    case some(Wrapped)

    /// Creates an instance that stores the given value.
    public init(_ some: Wrapped)

    /// Evaluates the given closure when this `Optional` instance is not `nil`,
    /// passing the unwrapped value as a parameter.
    ///
    /// Use the `map` method with a closure that returns a nonoptional value.
    /// This example performs an arithmetic operation on an
    /// optional integer.
    ///
    ///     let possibleNumber: Int? = Int("42")
    ///     let possibleSquare = possibleNumber.map { $0 * $0 }
    ///     print(possibleSquare)
    ///     // Prints "Optional(1746)"
    ///
    ///     let noNumber: Int? = nil
    ///     let noSquare = noNumber.map { $0 * $0 }
    ///     print(noSquare)
    ///     // Prints "nil"
    ///
    /// - Parameter f: A closure that takes the unwrapped value of the instance.
    /// - Returns: The result of the given closure. If this instance is `nil`,
    ///   returns `nil`.
    public func map<U>(_ f: @noescape (Wrapped) throws -> U) rethrows -> U?

    /// Evaluates the given closure when this `Optional` instance is not `nil`,
    /// passing the unwrapped value as a parameter.
    ///
    /// Use the `flatMap` method with a closure that returns an optional value.
    /// This example performs an arithmetic operation with an optional result on
    /// an optional integer.
    ///
    ///     let possibleNumber: Int? = Int("42")
    ///     let nonOverflowingSquare = possibleNumber.flatMap { x -> Int? in
    ///         let (result, overflowed) = Int.multiplyWithOverflow(x, x)
    ///         return overflowed ? nil : result
    ///     }
    ///     print(nonOverflowingSquare)
    ///     // Prints "Optional(1746)"
    ///
    /// - Parameter f: A closure that takes the unwrapped value of the instance.
    /// - Returns: The result of the given closure. If this instance is `nil`,
    ///   returns `nil`.
    public func flatMap<U>(_ f: @noescape (Wrapped) throws -> U?) rethrows -> U?

    /// Creates an instance initialized with `nil`.
    ///
    /// Do not call this initializer directly. It is used by the compiler when you
    /// initialize an `Optional` instance with a `nil` literal. For example:
    ///
    ///     var i: Index? = nil
    ///
    /// In this example, the assignment to the `i` variable calls this
    /// initializer behind the scenes.
    public init(nilLiteral: ())

    /// The wrapped value of this instance, unwrapped without checking whether
    /// the instance is `nil`.
    ///
    /// The `unsafelyUnwrapped` property provides the same value as the forced
    /// unwrap operator (postfix `!`). However, in optimized builds (`-O`), no
    /// check is performed to ensure that the current instance actually has a
    /// value. Accessing this property in the case of a `nil` value is a serious
    /// programming error and could lead to undefined behavior or a runtime
    /// error.
    ///
    /// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same
    /// behavior as using the postfix `!` operator and triggers a runtime error
    /// if the instance is `nil`.
    ///
    /// The `unsafelyUnwrapped` property is recommended over calling the
    /// `unsafeBitCast(_:)` function because the property is more restrictive
    /// and because accessing the property still performs checking in debug
    /// builds.
    ///
    /// - Warning: This property trades safety for performance.  Use
    ///   `unsafelyUnwrapped` only when you are confident that this instance
    ///   will never be equal to `nil` and only after you've tried using the
    ///   postfix `!` operator.
    public var unsafelyUnwrapped: Wrapped { get }
}

extension Optional : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    public var debugDescription: String { get }
}

extension Optional : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// A type that can be the target of text-streaming operations.
///
/// You can send the output of the standard library's `print(_:to:)` and
/// `dump(_:to:)` functions to an instance of a type that conforms to the
/// `OutputStream` protocol instead of to standard output. Swift's `String`
/// type conforms to `OutputStream` already, so you can capture the output
/// from `print(_:to:)` and `dump(_:to:)` in a string instead of logging it to
/// standard output.
///
///     var s = ""
///     for n in 1 ... 5 {
///         print(n, terminator: "", to: &s)
///     }
///     // s == "12345"
///
/// Conforming to the OutputStream Protocol
/// =======================================
///
/// To make your custom type conform to the `OutputStream` protocol, implement
/// the required `write(_:)` method. Functions that use an `OutputStream`
/// target may call `write(_:)` multiple times per writing operation.
///
/// As an example, here's an implementation of an output stream that converts
/// any input to its plain ASCII representation before sending it to standard
/// output.
///
///     struct ASCIILogger: OutputStream {
///         mutating func write(_ string: String) {
///             let ascii = string.unicodeScalars.lazy.map { scalar in
///                 scalar == "\n"
///                   ? "\n"
///                   : scalar.escaped(asASCII: true)
///             }
///             print(ascii.joined(separator: ""), terminator: "")
///         }
///     }
///
/// The `ASCIILogger` type's `write(_:)` method processes its string input by
/// escaping each Unicode scalar, with the exception of `"\n"` line returns.
/// By sending the output of the `print(_:to:)` function to an instance of
/// `ASCIILogger`, you invoke its `write(_:)` method.
///
///     let s = "Hearts  and Diamonds "
///     print(s)
///     // Prints "Hearts  and Diamonds "
///
///     var asciiLogger = ASCIILogger()
///     print(s, to: &asciiLogger)
///     // Prints "Hearts \u{2661} and Diamonds \u{2662}"
public protocol OutputStream {

    /// Appends the given string to the stream.
    public mutating func write(_ string: String)
}

/// The sum of types that can be used as a quick look representation.
public enum PlaygroundQuickLook {

    /// Plain text.
    case text(String)

    /// An integer numeric value.
    case int(Int64)

    /// An unsigned integer numeric value.
    case uInt(UInt64)

    /// A single precision floating-point numeric value.
    case float(Float32)

    /// A double precision floating-point numeric value.
    case double(Float64)

    /// An image.
    case image(Swift.Any)

    /// A sound.
    case sound(Swift.Any)

    /// A color.
    case color(Swift.Any)

    /// A bezier path.
    case bezierPath(Swift.Any)

    /// An attributed string.
    case attributedString(Swift.Any)

    /// A rectangle.
    case rectangle(Float64, Float64, Float64, Float64)

    /// A point.
    case point(Float64, Float64)

    /// A size.
    case size(Float64, Float64)

    /// A boolean value.
    case bool(Bool)

    /// A range.
    case range(Int64, Int64)

    /// A GUI view.
    case view(Swift.Any)

    /// A graphical sprite.
    case sprite(Swift.Any)

    /// A Uniform Resource Locator.
    case url(String)

    /// Raw data that has already been encoded in a format the IDE understands.
    case _raw([UInt8], String)
}

extension PlaygroundQuickLook {

    /// Initialize for the given `subject`.
    ///
    /// If the dynamic type of `subject` conforms to
    /// `CustomPlaygroundQuickLookable`, returns the result of calling
    /// its `customPlaygroundQuickLook` property.  Otherwise, returns
    /// a `PlaygroundQuickLook` synthesized for `subject` by the
    /// language.  Note that in some cases the result may be
    /// `.Text(String(reflecting: subject))`.
    ///
    /// - Note: If the dynamic type of `subject` has value semantics,
    ///   subsequent mutations of `subject` will not observable in
    ///   `Mirror`.  In general, though, the observability of such
    /// mutations is unspecified.
    public init(reflecting subject: Swift.Any)
}

/// Command-line arguments for the current process.
public enum Process {

    /// Access to the raw argc value from C.
    public static var argc: CInt { get }

    /// Access to the raw argv value from C. Accessing the argument vector
    /// through this pointer is unsafe.
    public static var unsafeArgv: UnsafeMutablePointer<UnsafeMutablePointer<Int8>?> { get }

    /// Access to the swift arguments, also use lazy initialization of static
    /// properties to safely initialize the swift arguments.
    ///
    /// NOTE: we can not use static lazy let initializer as they can be moved
    /// around by the optimizer which will break the data dependence on argc
    /// and argv.
    public static var arguments: [String] { get }
}

/// A collection that supports efficient random-access index traversal.
///
/// Random-access collections can measure move indices any distance and can
/// measure the distance between indices in O(1) time. Therefore, the
/// fundamental difference between random-access and bidirectional collections
/// is that operations that depend on index movement or distance measurement
/// offer significantly improved efficiency. For example, a random-access
/// collection's `count` property is calculated in O(1) instead of requiring
/// iteration of an entire collection.
///
/// Conforming to the RandomAccessCollection Protocol
/// =================================================
///
/// The `RandomAccessCollection` protocol adds further constraints on the
/// associated `Indices` and `SubSequence` types, but otherwise imposes no
/// additional requirements over the `BidirectionalCollection` protocol.
/// However, in order to meet the complexity guarantees of a random-access
/// collection, either the index for your custom type must conform to the
/// `Strideable` protocol or you must implement the `index(_:offsetBy:)` and
/// `distance(from:to:)` methods with O(1) efficiency.
public protocol RandomAccessCollection : RandomAccessIndexable, BidirectionalCollection {

    /// A collection that represents a contiguous subrange of the collection's
    /// elements.
    associatedtype SubSequence : RandomAccessIndexable, BidirectionalCollection = RandomAccessSlice<Self>

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    associatedtype Indices : RandomAccessIndexable, BidirectionalCollection = DefaultRandomAccessIndices<Self>
}

extension RandomAccessCollection where Indices == DefaultRandomAccessIndices<Self> {

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: DefaultRandomAccessIndices<Self> { get }
}

/// Augment `self` with lazy methods such as `map`, `filter`, etc.
extension RandomAccessCollection {

    /// A view onto this collection that provides lazy implementations of
    /// normally eager operations, such as `map` and `filter`.
    ///
    /// Use the `lazy` property when chaining operations to prevent
    /// intermediate operations from allocating storage, or when you only
    /// need a part of the final collection to avoid unnecessary computation.
    ///
    /// - See Also: `LazySequenceProtocol`, `LazyCollectionProtocol`.
    public var lazy: LazyRandomAccessCollection<Self> { get }
}

extension RandomAccessCollection where Self : LazyCollectionProtocol {

    /// Identical to `self`.
    public var lazy: Self { get }
}

/// Supply the default "slicing" `subscript` for `RandomAccessCollection`
/// models that accept the default associated `SubSequence`,
/// `RandomAccessSlice<Self>`.
extension RandomAccessCollection where SubSequence == RandomAccessSlice<Self> {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Self.Index>) -> RandomAccessSlice<Self> { get }
}

extension RandomAccessCollection where Index : Strideable, Index.Stride == IndexDistance, Indices == CountableRange<Index> {

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: CountableRange<Self.Index> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Self.Index) -> Self.Index

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Self.Index) -> Self.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1)
    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance) -> Self.Index

    /// Returns the distance between two indices.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`.
    ///
    /// - Complexity: O(1)
    public func distance(from start: Self.Index, to end: Self.Index) -> Self.IndexDistance
}

extension RandomAccessCollection {

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A
    /// `ReverseRandomAccessCollection` instance wraps an underlying collection
    /// and provides access to its elements in reverse order. This example
    /// prints the elements of an array in reverse order:
    ///
    ///     let numbers = [3, 5, 7]
    ///     for number in numbers.reversed() {
    ///         print(number)
    ///     }
    ///     // Prints "7"
    ///     // Prints "5"
    ///     // Prints "3"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of an array, initialize a new
    /// `Array` instance from the result of this `reversed()` method.
    ///
    ///     let reversedNumbers = Array(numbers.reversed())
    ///     print(reversedNumbers)
    ///     // Prints "[7, 5, 3]"
    ///
    /// - Complexity: O(1)
    public func reversed() -> ReversedRandomAccessCollection<Self>
}

/// A collection that supports efficient random-access index traversal.
///
/// In most cases, it's best to ignore this protocol and use the
/// `RandomAccessCollection` protocol instead, because it has a more complete
/// interface.
public protocol RandomAccessIndexable : BidirectionalIndexable {
}

/// Default implementation for random access collections.
extension RandomAccessIndexable {

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position. The
    /// operation doesn't require going beyond the limiting `numbers.endIndex`
    /// value, so it succeeds.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// The next example attempts to retrieve an index ten positions from
    /// `numbers.startIndex`, but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = numbers.index(numbers.startIndex,
    ///                           offsetBy: 10,
    ///                           limitedBy: numbers.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` should be greater than `i` to have any effect. Likewise, if
    ///     `n < 0`, `limit` should be less than `i` to have any effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1)
    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance, limitedBy limit: Self.Index) -> Self.Index?
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `RandomAccessSlice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
public struct RandomAccessSlice<Base : RandomAccessIndexable> : RandomAccessCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element { get }

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = RandomAccessSlice<Base>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Base.Index>) -> RandomAccessSlice<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position. The
    /// operation doesn't require going beyond the limiting `s.endIndex` value,
    /// so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A half-open interval over a comparable type, from a lower bound up to, but
/// not including, an upper bound.
///
/// You create `Range` instances by using the half-open range operator (`..<`).
///
///     let underFive = 0.0..<5.0
///
/// You can use a `Range` instance to quickly check if a value is contained in
/// a particular range of values. For example:
///
///     print(underFive.contains(3.14))     // Prints "true"
///     print(underFive.contains(6.28))     // Prints "false"
///     print(underFive.contains(5.0))      // Prints "false"
///
/// `Range` instances can represent an empty interval, unlike `ClosedRange`.
///
///     let empty = 0.0..<0.0
///     print(empty.contains(0.0))          // Prints "false"
///     print(empty.isEmpty)                // Prints "true"
///
/// - SeeAlso: `CountableRange`, `ClosedRange`, `CountableClosedRange`
public struct Range<Bound : Comparable> {

    /// Creates an instance with the given bounds.
    ///
    /// Because this initializer does not perform any checks, it should be used
    /// as an optimization only when you are absolutely certain that `lower` is
    /// less than or equal to `upper`. Using the half-open range operator
    /// (`..<`) to form `Range` instances is preferred.
    ///
    /// - Parameter bounds: A tuple of the lower and upper bounds of the range.
    public init(uncheckedBounds bounds: (lower: Bound, upper: Bound))

    /// The range's lower bound.
    ///
    /// In an empty range, `lowerBound` is equal to `upperBound`.
    public let lowerBound: Bound

    /// The range's upper bound.
    ///
    /// In an empty range, `upperBound` is equal to `lowerBound`. A `Range`
    /// instance does not contain its upper bound.
    public let upperBound: Bound

    /// Returns a Boolean value indicating whether the given element is contained
    /// within the range.
    ///
    /// Because `Range` represents a half-open range, a `Range` instance does not
    /// contain its upper bound. `element` is contained in the range if it is
    /// greater than or equal to the lower bound and less than the upper bound.
    ///
    /// - Parameter element: The element to check for containment.
    /// - Returns: `true` if `element` is contained in the range; otherwise,
    ///   `false`.
    public func contains(_ element: Bound) -> Bool

    /// A Boolean value indicating whether the range contains no elements.
    ///
    /// An empty `Range` instance has equal lower and upper bounds.
    ///
    ///     let empty: Range = 10..<10
    ///     print(empty.isEmpty)
    ///     // Prints "true"
    public var isEmpty: Bool { get }
}

extension Range {

    /// Creates an instance equivalent to the given range.
    ///
    /// - Parameter other: A range to convert to a `Range` instance.
    public init(_ other: Range<Bound>)
}

extension Range {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: Range = 0..<20
    ///     print(x.overlaps(10..<1000 as Range))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: Range<Bound>) -> Bool
}

extension Range where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// - Parameter other: A range to convert to a `Range` instance.
    public init(_ other: CountableRange<Bound>)
}

extension Range where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: Range = 0..<20
    ///     print(x.overlaps(10..<1000 as CountableRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: CountableRange<Bound>) -> Bool
}

extension Range where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// An equivalent range must be representable as an instance of `Range`.
    /// For example, passing a closed range with an upper bound of `Int.max`
    /// triggers a runtime error, because the resulting half-open range would
    /// require an upper bound of `Int.max + 1`, which is not representable as
    /// an `Int`.
    ///
    /// - Parameter other: A range to convert to a `Range` instance.
    public init(_ other: ClosedRange<Bound>)
}

extension Range {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: Range = 0..<20
    ///     print(x.overlaps(10...1000 as ClosedRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: ClosedRange<Bound>) -> Bool
}

extension Range where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Creates an instance equivalent to the given range.
    ///
    /// An equivalent range must be representable as an instance of `Range`.
    /// For example, passing a closed range with an upper bound of `Int.max`
    /// triggers a runtime error, because the resulting half-open range would
    /// require an upper bound of `Int.max + 1`, which is not representable as
    /// an `Int`.
    ///
    /// - Parameter other: A range to convert to a `Range` instance.
    public init(_ other: CountableClosedRange<Bound>)
}

extension Range where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// For example:
    ///
    ///     let x: Range = 0..<20
    ///     print(x.overlaps(10...1000 as CountableClosedRange))
    ///     // Prints "true"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: CountableClosedRange<Bound>) -> Bool
}

extension Range {

    /// Returns a copy of this range clamped to the given limiting range.
    ///
    /// The bounds of the result are always limited to the bounds of `limits`.
    /// For example:
    ///
    ///     let x: Range = 0..<20
    ///     print(x.clamped(to: 10..<1000))
    ///     // Prints "10..<20"
    ///
    /// If the two ranges do not overlap, the result is an empty range within the
    /// bounds of `limits`.
    ///
    ///     let y: Range = 0..<5
    ///     print(y.clamped(to: 10..<1000))
    ///     // Prints "10..<10"
    ///
    /// - Parameter limits: The range to clamp the bounds of this range.
    /// - Returns: A new range clamped to the bounds of `limits`.
    public func clamped(to limits: Range<Bound>) -> Range<Bound>
}

extension Range : CustomStringConvertible {

    /// A textual representation of the range.
    public var description: String { get }
}

extension Range : CustomDebugStringConvertible {

    /// A textual representation of the range, suitable for debugging.
    public var debugDescription: String { get }
}

extension Range : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension Range : Equatable {
}

/// Ranges whose `Bound` is `Strideable` with `Integer` `Stride` have all
/// the capabilities of `RandomAccessCollection`s, just like
/// `CountableRange` and `CountableClosedRange`.
///
/// Unfortunately, we can't forward the full collection API, so we are
/// forwarding a few select APIs.
extension Range where Bound : _Strideable, Bound.Stride : SignedInteger {

    /// The number of values contained in the range.
    public var count: Bound.Stride { get }
}

extension Range {
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `RangeReplaceableBidirectionalSlice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
public struct RangeReplaceableBidirectionalSlice<Base : protocol<BidirectionalIndexable, RangeReplaceableIndexable>> : BidirectionalCollection, RangeReplaceableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element { get }

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = RangeReplaceableBidirectionalSlice<Base>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Base.Index>) -> RangeReplaceableBidirectionalSlice<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a new, empty collection.
    public init()

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// The following example creates an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Base._Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S : Sequence where S.Iterator.Element == Base._Element>(_ elements: S)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Base._Element>(_ subRange: Range<Base.Index>, with newElements: C)

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Base._Element, at i: Base.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<S : Collection where S.Iterator.Element == Base._Element>(contentsOf newElements: S, at i: Base.Index)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter i: The position of the element to remove. `index` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at i: Base.Index) -> Base._Element

    /// Removes the specified subrange of elements from the collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeSubrange(1...3)
    ///     print(bugs)
    ///     // Prints "["Aphid", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The subrange of the collection to remove. The bounds
    ///   of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: Range<Base.Index>)

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A collection that supports replacement of an arbitrary subrange of elements
/// with the elements of another collection.
///
/// Range-replaceable collections provide operations that insert and remove
/// elements. For example, you can add elements to an array of strings by
/// calling any of the inserting or appending operations that the
/// `RangeReplaceableCollection` protocol defines.
///
///     var bugs = ["Aphid", "Damselfly"]
///     bugs.append("Earwig")
///     bugs.insert(contentsOf: ["Bumblebee", "Cicada"], at: 1)
///     print(bugs)
///     // Prints "["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]"
///
/// Likewise, `RangeReplaceableCollection` types can remove one or more
/// elements using a single operation.
///
///     bugs.removeLast()
///     bugs.removeSubrange(1...2)
///     print(bugs)
///     // Prints "["Aphid", "Damselfly"]"
///
///     bugs.removeAll()
///     print(bugs)
///     // Prints "[]"
///
/// Lastly, use the eponymous `replaceSubrange(_:with:)` method to replace
/// a subrange of elements with the contents of another collection. Here,
/// three elements in the middle of an array of integers are replaced by the
/// five elements of a `Repeated<Int>` instance.
///
///      var nums = [10, 20, 30, 40, 50]
///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
///      print(nums)
///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
///
/// Conforming to the RangeReplaceableCollection Protocol
/// =====================================================
///
/// To add `RangeReplaceableCollection` conformance to your custom collection,
/// add an empty initializer and the `replaceSubrange(_:with:)` method to your
/// custom type. `RangeReplaceableCollection` provides default implementations
/// of all its other methods using this initializer and method. For example,
/// the `removeSubrange` method is implemented by calling `replaceRange` with
/// an empty collection for the `newElements` parameter. You can override any
/// of the protocol's required methods to provide your own custom
/// implementation.
public protocol RangeReplaceableCollection : RangeReplaceableIndexable, Collection {

    /// Creates a new, empty collection.
    public init()

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Iterator.Element>(_ subrange: Range<Self.Index>, with newElements: C)

    /// Prepares the collection to store the specified number of elements, when
    /// doing so is appropriate for the underlying type.
    ///
    /// If you are adding a known number of elements to a collection, use this
    /// method to avoid multiple reallocations. A type that conforms to
    /// `RangeReplaceableCollection` can choose how to respond when this method
    /// is called. Depending on the type, it may make sense to allocate more or
    /// less storage than requested, or to take no action at all.
    ///
    /// - Parameter n: The requested number of elements to store.
    public mutating func reserveCapacity(_ n: Self.IndexDistance)

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// The following example creates an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Self.Iterator.Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S : Sequence where S.Iterator.Element == Iterator.Element>(_ elements: S)

    /// Adds an element to the end of the collection.
    ///
    /// For example:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(100)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 100]"
    ///
    /// - Parameter newElement: The element to append to the collection.
    ///
    /// - Complexity: O(1) on average, over many additions to the same
    ///   collection.
    public mutating func append(_ newElement: Self.Iterator.Element)

    /// Adds the elements of a sequence to the end of the collection.
    ///
    /// Use this method to append the elements of a sequence to the end of a
    /// collection. This example appends the elements of a `Range<Int>` instance
    /// to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting collection.
    public mutating func append<S : Sequence where S.Iterator.Element == Iterator.Element>(contentsOf newElements: S)

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Self.Iterator.Element, at i: Self.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<S : Collection where S.Iterator.Element == Iterator.Element>(contentsOf newElements: S, at i: Self.Index)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter i: The position of the element to remove. `index` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at i: Self.Index) -> Self.Iterator.Element

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    /// 
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst()
    ///     print(bugs)
    ///     // Prints "["Bumblebee", "Cicada", "Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeFirst() -> Self.Iterator.Element

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst(3)
    ///     print(bugs)
    ///     // Prints "["Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter n: The number of elements to remove from the collection.
    ///   `n` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeFirst(_ n: Int)

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool)
}

extension RangeReplaceableCollection {

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public convenience init(repeating repeatedValue: Self.Iterator.Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    public convenience init<S : Sequence where S.Iterator.Element == Iterator.Element>(_ elements: S)

    /// Adds an element to the end of the collection.
    ///
    /// For example:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(100)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 100]"
    ///
    /// - Parameter newElement: The element to append to the collection.
    ///
    /// - Complexity: O(1) on average, over many additions to the same
    ///   collection.
    public mutating func append(_ newElement: Self.Iterator.Element)

    /// Adds the elements of a sequence to the end of the collection.
    ///
    /// Use this method to append the elements of a sequence to the end of a
    /// collection. This example appends the elements of a `Range<Int>` instance
    /// to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting collection.
    public mutating func append<S : Sequence where S.Iterator.Element == Iterator.Element>(contentsOf newElements: S)

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Self.Iterator.Element, at i: Self.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<C : Collection where C.Iterator.Element == Iterator.Element>(contentsOf newElements: C, at i: Self.Index)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter position: The position of the element to remove. `position` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at position: Self.Index) -> Self.Iterator.Element

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes two elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<3)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: Range<Self.Index>)

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst(3)
    ///     print(bugs)
    ///     // Prints "["Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter n: The number of elements to remove from the collection.
    ///   `n` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeFirst(_ n: Int)

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst()
    ///     print(bugs)
    ///     // Prints "["Bumblebee", "Cicada", "Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeFirst() -> Self.Iterator.Element

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)

    /// Prepares the collection to store the specified number of elements, when
    /// doing so is appropriate for the underlying type.
    ///
    /// If you will be adding a known number of elements to a collection, use
    /// this method to avoid multiple reallocations. A type that conforms to
    /// `RangeReplaceableCollection` can choose how to respond when this method
    /// is called. Depending on the type, it may make sense to allocate more or
    /// less storage than requested or to take no action at all.
    ///
    /// - Parameter n: The requested number of elements to store.
    public mutating func reserveCapacity(_ n: Self.IndexDistance)
}

extension RangeReplaceableCollection where SubSequence == Self {

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Don't rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The first element of the collection.
    ///
    /// - Complexity: O(1)
    /// - Precondition: `!self.isEmpty`.
    public mutating func removeFirst() -> Self.Iterator.Element

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Don't rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter n: The number of elements to remove from the collection.
    ///   `n` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(1)
    public mutating func removeFirst(_ n: Int)
}

extension RangeReplaceableCollection where Index : Strideable, Index.Stride : SignedInteger {

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Iterator.Element>(_ subrange: CountableRange<Self.Index>, with newElements: C)

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes two elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<3)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: CountableRange<Self.Index>)
}

extension RangeReplaceableCollection {

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Iterator.Element>(_ subrange: ClosedRange<Self.Index>, with newElements: C)

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes two elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<3)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: ClosedRange<Self.Index>)
}

extension RangeReplaceableCollection where Index : Strideable, Index.Stride : SignedInteger {

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Iterator.Element>(_ subrange: CountableClosedRange<Self.Index>, with newElements: C)

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes two elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<3)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: CountableClosedRange<Self.Index>)
}

extension RangeReplaceableCollection where Self : BidirectionalCollection {

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Don't rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    public mutating func removeLast() -> Self.Iterator.Element

    /// Removes the specified number of elements from the end of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Don't rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter n: The number of elements to remove from the collection.
    ///   `n` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the specified number of elements.
    public mutating func removeLast(_ n: Int)
}

/// Ambiguity breakers.
extension RangeReplaceableCollection where Self : BidirectionalCollection, SubSequence == Self {

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Don't rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    public mutating func removeLast() -> Self.Iterator.Element

    /// Removes the specified number of elements from the end of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Don't rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter n: The number of elements to remove from the collection.
    ///   `n` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the specified number of elements.
    public mutating func removeLast(_ n: Int)
}

/// A type that supports replacement of an arbitrary subrange of elements with
/// the elements of another collection.
///
/// In most cases, it's best to ignore this protocol and use the
/// `RangeReplaceableCollection` protocol instead, because it has a more
/// complete interface.
public protocol RangeReplaceableIndexable : Indexable {

    /// Creates an empty instance.
    public init()

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Self._Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S : Sequence where S.Iterator.Element == _Element>(_ elements: S)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == _Element>(_ subrange: Range<Self.Index>, with newElements: C)

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Self._Element, at i: Self.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<S : Collection where S.Iterator.Element == _Element>(contentsOf newElements: S, at i: Self.Index)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter i: The position of the element to remove. `index` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at i: Self.Index) -> Self._Element

    /// Removes the specified subrange of elements from the collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeSubrange(1...3)
    ///     print(bugs)
    ///     // Prints "["Aphid", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The subrange of the collection to remove. The bounds
    ///   of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: Range<Self.Index>)
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `RangeReplaceableRandomAccessSlice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
public struct RangeReplaceableRandomAccessSlice<Base : protocol<RandomAccessIndexable, RangeReplaceableIndexable>> : RandomAccessCollection, RangeReplaceableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element { get }

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = RangeReplaceableRandomAccessSlice<Base>

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Base.Index>) -> RangeReplaceableRandomAccessSlice<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Base.Index) -> Base.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a new, empty collection.
    public init()

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// The following example creates an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Base._Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S : Sequence where S.Iterator.Element == Base._Element>(_ elements: S)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Base._Element>(_ subRange: Range<Base.Index>, with newElements: C)

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Base._Element, at i: Base.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<S : Collection where S.Iterator.Element == Base._Element>(contentsOf newElements: S, at i: Base.Index)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter i: The position of the element to remove. `index` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at i: Base.Index) -> Base._Element

    /// Removes the specified subrange of elements from the collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeSubrange(1...3)
    ///     print(bugs)
    ///     // Prints "["Aphid", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The subrange of the collection to remove. The bounds
    ///   of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: Range<Base.Index>)

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `RangeReplaceableSlice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
public struct RangeReplaceableSlice<Base : RangeReplaceableIndexable> : Collection, RangeReplaceableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element { get }

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = RangeReplaceableSlice<Base>

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Base.Index>) -> RangeReplaceableSlice<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a new, empty collection.
    public init()

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// The following example creates an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Base._Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S : Sequence where S.Iterator.Element == Base._Element>(_ elements: S)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Base._Element>(_ subRange: Range<Base.Index>, with newElements: C)

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Base._Element, at i: Base.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<S : Collection where S.Iterator.Element == Base._Element>(contentsOf newElements: S, at i: Base.Index)

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter i: The position of the element to remove. `index` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at i: Base.Index) -> Base._Element

    /// Removes the specified subrange of elements from the collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeSubrange(1...3)
    ///     print(bugs)
    ///     // Prints "["Aphid", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The subrange of the collection to remove. The bounds
    ///   of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: Range<Base.Index>)

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A type that can be converted to and from an associated raw value.
///
/// With a `RawRepresentable` type, you can switch back and forth between a
/// custom type and an associated `RawValue` type without losing the value of
/// the original `RawRepresentable` type. Using the raw value of a conforming
/// type streamlines interoperation with Objective-C and legacy APIs and
/// simplifies conformance to other protocols, such as `Equatable`,
/// `Comparable`, and `Hashable`.
///
/// The `RawRepresentable` protocol is seen mainly in two categories of types:
/// enumerations with raw value types and option sets.
///
/// Enumerations with Raw Values
/// ============================
///
/// For any enumeration with a string, integer, or floating-point raw type, the
/// Swift compiler automatically adds `RawRepresentable` conformance. When
/// defining your own custom enumeration, you give it a raw type by specifying
/// the raw type as the first item in the enumeration's type inheritance list.
/// You can also use literals to specify values for one or more cases.
///
/// For example, the `Counter` enumeration defined here has an `Int` raw value
/// type and gives the first case a raw value of `1`:
///
///     enum Counter: Int {
///         case one = 1, two, three, four, five
///     }
///
/// You can create a `Counter` instance from an integer value between 1 and 5
/// by using the `init?(rawValue:)` initializer declared in the
/// `RawRepresentable` protocol. This initializer is failable because although
/// every case of the `Counter` type has a corresponding `Int` value, there
/// are many `Int` values that *don't* correspond to a case of `Counter`.
///
///     for i in 3...6 {
///         print(Counter(rawValue: i))
///     }
///     // Prints "Optional(Counter.three)"
///     // Prints "Optional(Counter.four)"
///     // Prints "Optional(Counter.five)"
///     // Prints "nil"
///
/// Option Sets
/// ===========
///
/// Option sets all conform to `RawRepresentable` by inheritance using the
/// `OptionSet` protocol. Whether using an option set or creating your own,
/// you use the raw value of an option set instance to store the instance's
/// bitfield. The raw value must therefore be of a type that conforms to the
/// `BitwiseOperations` protocol, such as `UInt8` or `Int`. For example, the
/// `Direction` type defines an option set for the four directions you can
/// move in a game.
///
///     struct Directions: OptionSet {
///         let rawValue: UInt8
///
///         static let up    = Directions(rawValue: 1 << 0)
///         static let down  = Directions(rawValue: 1 << 1)
///         static let left  = Directions(rawValue: 1 << 2)
///         static let right = Directions(rawValue: 1 << 3)
///     }
///
/// Unlike enumerations, option sets provide a nonfailable `init(rawValue:)`
/// initializer to convert from a raw value, because option sets don't have an
/// enumerated list of all possible cases. Option set values have
/// a one-to-one correspondence with their associated raw values.
///
/// In the case of the `Directions` option set, an instance can contain zero,
/// one, or more of the four defined directions. This example declares a
/// constant with three currently allowed moves. The raw value of the
/// `allowedMoves` instance is the result of the bitwise OR of its three
/// members' raw values:
///
///     let allowedMoves: Directions = [.up, .down, .left]
///     print(allowedMoves.rawValue)
///     // Prints "7"
///
/// Option sets use bitwise operations on their associated raw values to
/// implement their mathematical set operations. For example, the `contains()`
/// method on `allowedMoves` performs a bitwise AND operation to check whether
/// the option set contains an element.
///
///     print(allowedMoves.contains(.right))
///     // Prints "false"
///     print(allowedMoves.rawValue & Directions.right.rawValue)
///     // Prints "0"
///
/// - SeeAlso: `OptionSet`, `BitwiseOperations`
public protocol RawRepresentable {

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    associatedtype RawValue

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: Self.RawValue)

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public var rawValue: Self.RawValue { get }
}

/// A collection whose elements are all identical `Element`s.
public struct Repeated<Element> : RandomAccessCollection {

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = CountableRange<Int>

    /// A type that represents a valid position in the collection.
    /// 
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = Int

    /// Always zero, which is the index of the first element in a
    /// non-empty instance.
    public var startIndex: Index { get }

    /// Always equal to `count`, which is one greater than the index of
    /// the last element in a non-empty instance.
    public var endIndex: Index { get }

    /// Access the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: Int) -> Element { get }

    /// The number of elements in this collection.
    public let count: Int

    /// The value of every element in this collection.
    public let repeatedValue: Element
}

/// A Collection that presents the elements of its `Base` collection
/// in reverse order.
///
/// - Note: This type is the result of `x.reversed()` where `x` is a
///   collection having bidirectional indices.
///
/// The `reversed()` method is always lazy when applied to a collection
/// with bidirectional indices, but does not implicitly confer
/// laziness on algorithms applied to its result.  In other words, for
/// ordinary collections `c` having bidirectional indices:
///
/// * `c.reversed()` does not create new storage
/// * `c.reversed().map(f)` maps eagerly and returns a new array
/// * `c.lazy.reversed().map(f)` maps lazily and returns a `LazyMapCollection`
///
/// - See also: `ReversedRandomAccessCollection`
public struct ReversedCollection<Base : BidirectionalCollection> : BidirectionalCollection {

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = ReversedIndex<Base>

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Base.IndexDistance

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = IndexingIterator<ReversedCollection<Base>>

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: ReversedIndex<Base> { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: ReversedIndex<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: ReversedIndex<Base>) -> ReversedIndex<Base>

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: ReversedIndex<Base>) -> ReversedIndex<Base>

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: ReversedIndex<Base>, offsetBy n: Base.IndexDistance) -> ReversedIndex<Base>

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position. The
    /// operation doesn't require going beyond the limiting `s.endIndex` value,
    /// so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: ReversedIndex<Base>, offsetBy n: Base.IndexDistance, limitedBy limit: ReversedIndex<Base>) -> ReversedIndex<Base>?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: ReversedIndex<Base>, to end: ReversedIndex<Base>) -> Base.IndexDistance

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(position: ReversedIndex<Base>) -> Base.Iterator.Element { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<ReversedIndex<Base>>) -> BidirectionalSlice<ReversedCollection<Base>> { get }
}

/// An index that traverses the same positions as an underlying index,
/// with inverted traversal direction.
public struct ReversedIndex<Base : Collection> : Comparable {

    public init(_ base: Base.Index)

    /// The position corresponding to `self` in the underlying collection.
    public let base: Base.Index
}

/// A Collection that presents the elements of its `Base` collection
/// in reverse order.
///
/// - Note: This type is the result of `x.reversed()` where `x` is a
///   collection having random access indices.
/// - See also: `ReversedCollection`
public struct ReversedRandomAccessCollection<Base : RandomAccessCollection> : RandomAccessCollection {

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = ReversedRandomAccessIndex<Base>

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Base.IndexDistance

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = IndexingIterator<ReversedRandomAccessCollection<Base>>

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: ReversedRandomAccessIndex<Base> { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: ReversedRandomAccessIndex<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: ReversedRandomAccessIndex<Base>) -> ReversedRandomAccessIndex<Base>

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: ReversedRandomAccessIndex<Base>) -> ReversedRandomAccessIndex<Base>

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: ReversedRandomAccessIndex<Base>, offsetBy n: Base.IndexDistance) -> ReversedRandomAccessIndex<Base>

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position. The
    /// operation doesn't require going beyond the limiting `s.endIndex` value,
    /// so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: ReversedRandomAccessIndex<Base>, offsetBy n: Base.IndexDistance, limitedBy limit: ReversedRandomAccessIndex<Base>) -> ReversedRandomAccessIndex<Base>?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: ReversedRandomAccessIndex<Base>, to end: ReversedRandomAccessIndex<Base>) -> Base.IndexDistance

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(position: ReversedRandomAccessIndex<Base>) -> Base.Iterator.Element { get }
}

/// An index that traverses the same positions as an underlying index,
/// with inverted traversal direction.
public struct ReversedRandomAccessIndex<Base : RandomAccessCollection> : Comparable {

    public init(_ base: Base.Index)

    /// The position corresponding to `self` in the underlying collection.
    public let base: Base.Index
}

/// A type that provides sequential, iterated access to its elements.
///
/// Sequences are lists of values that let you step over their values
/// one at a time. The most common way to iterate over the elements of a
/// sequence is to use a `for`-`in` loop:
///
///     let oneTwoThree = 1...3
///     for number in oneTwoThree {
///         print(number)
///     }
///     // Prints "1"
///     // Prints "2"
///     // Prints "3"
///
/// While seemingly simple, this capability gives you access to a large number
/// of operations that you can perform on any sequence. As an example, to
/// check whether a sequence includes a particular value, you can test each
/// value sequentially until you've found a match or reached the end of the
/// sequence. This example checks to see whether a particular insect is in an
/// array.
///
///     let bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
///     var hasMosquito = false
///     for bug in bugs {
///         if bug == "Mosquito" {
///             hasMosquito = true
///             break
///         }
///     }
///     print("'bugs' has a mosquito: \(hasMosquito)")
///     // Prints "'bugs' has a mosquito: false"
///
/// The `Sequence` protocol provides default implementations for many common
/// operations that depend on sequential access to a sequence's values. For
/// clearer, more concise code, the example above could use the array's
/// `contains(_:)` method, which every sequence inherits from `Sequence`,
/// instead of iterating manually:
///
///     if bugs.contains("Mosquito") {
///         print("Break out the bug spray.")
///     } else {
///         print("Whew, no mosquitos!")
///     }
///     // Prints "Whew, no mosquitos!"
///
/// Repeated Access 
/// ===============
///
/// The `Sequence` protocol makes no requirement on conforming types regarding
/// whether they will be destructively "consumed" by iteration. As a
/// consequence, don't assume that multiple `for`-`in` loops on a sequence
/// will either "resume" iteration or restart from the beginning:
///
///     for element in sequence {
///         if ... some condition { break }
///     }
/// 
///     for element in sequence {
///         // No defined behavior
///     }
///
/// In this case, you cannot assume that a sequence will either be
/// "consumable" and will resume iteration, or that a sequence is a
/// collection and will restart iteration from the first element. A
/// conforming sequence that is not a collection is allowed to produce an
/// arbitrary sequence of elements in the second `for`-`in` loop.
///
/// To establish that a type you've created supports nondestructive
/// iteration, add conformance to the `Collection` protocol.
///
/// Conforming to the Sequence Protocol 
/// ===================================
///
/// Making your own custom types conform to `Sequence` enables many useful
/// operations, like `for`-`in` looping and the `contains` method, without
/// much effort. To add `Sequence` conformance to your own custom type, add
/// a `makeIterator()` method that returns an iterator.
///
/// Alternatively, if your type can act as its own iterator, implementing the
/// requirements of the `IteratorProtocol` protocol and declaring conformance
/// to both `Sequence` and `IteratorProtocol` are sufficient.
///
/// Here's a definition of a `Countdown` sequence that serves as its own
/// iterator. The `makeIterator()` method is provided as a default
/// implementation.
///
///     struct Countdown: Sequence, IteratorProtocol {
///         var count: Int
/// 
///         mutating func next() -> Int? {
///             if count == 0 {
///                 return nil
///             } else {
///                 defer { count -= 1 }
///                 return count
///             }
///         }
///     }
/// 
///     let threeToGo = Countdown(count: 3)
///     for i in threeToGo {
///         print(i)
///     }
///     // Prints "3"
///     // Prints "2"
///     // Prints "1"
///
/// Expected Performance 
/// ====================
///
/// A sequence should provide its iterator in O(1). The `Sequence` protocol
/// makes no other requirements about element access, so routines that
/// traverse a sequence should be considered O(*n*) unless documented
/// otherwise.
///
/// - SeeAlso: `IteratorProtocol`, `Collection`
public protocol Sequence {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    associatedtype Iterator : IteratorProtocol

    /// A type that represents a subsequence of some of the sequence's elements.
    associatedtype SubSequence

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> Self.Iterator

    /// A value less than or equal to the number of elements in
    /// the sequence, calculated nondestructively.
    ///
    /// - Complexity: O(1)
    public var underestimatedCount: Int { get }

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercaseString }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.characters.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: @noescape (Self.Iterator.Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.characters.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter includeElement: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `includeElement` allowed.
    public func filter(_ includeElement: @noescape (Self.Iterator.Element) throws -> Bool) rethrows -> [Self.Iterator.Element]

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: @noescape (Self.Iterator.Element) throws -> Swift.Void) rethrows

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the sequence.
    public func dropFirst(_ n: Int) -> Self.SubSequence

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> Self.SubSequence

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> Self.SubSequence

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number
    /// of elements in the sequence, the result contains all the elements in
    /// the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of this sequence with
    ///   at most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> Self.SubSequence

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate. Elements that are
    /// used to split the sequence are not returned as part of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.characters.split(isSeparator: { $0 == " " })
    ///                          .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don't", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.characters.split(maxSplits: 1, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.characters.split(omittingEmptySubsequences: false, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int, omittingEmptySubsequences: Bool, isSeparator: @noescape (Self.Iterator.Element) throws -> Bool) rethrows -> [Self.SubSequence]

    /// Returns the first element of the sequence that satisfies the given
    /// predicate or nil if no such element is found.
    ///
    /// - Parameter where: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element is a match.
    /// - Returns: The first match or `nil` if there was no match.
    public func first(where: @noescape (Self.Iterator.Element) throws -> Bool) rethrows -> Self.Iterator.Element?
}

extension Sequence where Self.Iterator.Element : Comparable {

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the
    /// `Comparable` protocol by calling this method. Elements are sorted in
    /// ascending order.
    ///
    /// The sorting algorithm is not stable. A nonstable sort may change the
    /// relative order of elements that compare equal.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(isOrderedBefore:)` method.
    ///
    ///     let descendingStudents = students.sorted(isOrderedBefore: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - SeeAlso: `sorted(isOrderedBefore:)`
    public func sorted() -> [Self.Iterator.Element]
}

extension Sequence {

    /// Returns the elements of the sequence, sorted using the given
    /// predicate as the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to
    /// the `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element passed should be ordered before the
    /// second. The elements of the resulting array are ordered according to the
    /// given predicate.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `isOrderedBefore(a, a)` is always `false`. (Irreflexivity)
    /// - If `isOrderedBefore(a, b)` and `isOrderedBefore(b, c)` are both `true`,
    ///   then `isOrderedBefore(a, c)` is also `true`. (Transitive
    ///   comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not stable. A nonstable sort may change the
    /// relative order of elements for which `isOrderedBefore` does not
    /// establish an order.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence
    /// in descending order, pass the greater-than operator (`>`) as the
    /// `isOrderedBefore` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(isOrderedBefore: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(isOrderedBefore: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// - Parameter isOrderedBefore: A predicate that returns `true` if its first
    ///   argument should be ordered before its second argument; otherwise,
    ///   `false`.
    /// - Returns: A sorted array of the sequence's elements.
    ///
    /// - SeeAlso: `sorted()`
    public func sorted(isOrderedBefore: @noescape (Self.Iterator.Element, Self.Iterator.Element) -> Bool) -> [Self.Iterator.Element]
}

extension Sequence where Iterator.Element : Sequence {

    /// Returns the elements of this sequence of sequences, concatenated.
    ///
    /// In this example, an array of three ranges is flattened so that the
    /// elements of each range can be iterated in turn.
    ///
    ///     let ranges = [0..<3, 8..<10, 15..<17]
    ///
    ///     // A for-in loop over 'ranges' accesses each range:
    ///     for range in ranges {
    ///       print(range)
    ///     }
    ///     // Prints "0..<3"
    ///     // Prints "8..<10"
    ///     // Prints "15..<17"
    ///
    ///     // Use 'flatten()' to access each element of each range:
    ///     for index in ranges.flatten() {
    ///         print(index, terminator: " ")
    ///     }
    ///     // Prints: "0 1 2 8 9 15 16"
    ///
    /// - Returns: A flattened view of the elements of this
    ///   sequence of sequences.
    ///
    /// - SeeAlso: `flatMap(_:)`, `joined(separator:)`
    public func flatten() -> FlattenSequence<Self>
}

extension Sequence where Iterator.Element : Sequence {

    /// Returns the concatenated elements of this sequence of sequences,
    /// inserting the given separator between each element.
    ///
    /// This example shows how an array of `[Int]` instances can be joined, using
    /// another `[Int]` instance as the separator:
    ///
    ///     let nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    ///     let joined = nestedNumbers.join(separator: [-1, -2])
    ///     print(Array(joined))
    ///     // Prints "[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]"
    ///
    /// - Parameter separator: A sequence to insert between each of this
    ///   sequence's elements.
    /// - Returns: The joined sequence of elements.
    ///
    /// - SeeAlso: `flatten()`
    public func joined<Separator : Sequence where Separator.Iterator.Element == Iterator.Element.Iterator.Element>(separator: Separator) -> JoinedSequence<Self>
}

extension Sequence {

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    ///
    /// - SeeAlso: `LazySequenceProtocol`, `LazySequence`
    public var lazy: LazySequence<Self> { get }
}

/// A default makeIterator() function for `IteratorProtocol` instances that
/// are declared to conform to `Sequence`
extension Sequence where Self.Iterator == Self, Self : IteratorProtocol {

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> Self
}

extension Sequence {

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercaseString }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.characters.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: @noescape (Self.Iterator.Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.characters.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter includeElement: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `includeElement` allowed.
    public func filter(_ includeElement: @noescape (Self.Iterator.Element) throws -> Bool) rethrows -> [Self.Iterator.Element]

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number of
    /// elements in the sequence, the result contains all the elements in the
    /// sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> AnySequence<Self.Iterator.Element>

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate. Elements that are
    /// used to split the sequence are not returned as part of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.characters.split(isSeparator: { $0 == " " })
    ///                          .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don't", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.characters.split(maxSplits: 1, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `true` for the `allowEmptySlices` parameter, so
    /// the returned array contains empty strings where spaces were repeated.
    ///
    ///     print(line.characters.split(omittingEmptySubsequences: false, isSeparator: { $0 == " " })
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, isSeparator: @noescape (Self.Iterator.Element) throws -> Bool) rethrows -> [AnySequence<Self.Iterator.Element>]

    /// Returns a value less than or equal to the number of elements in
    /// the sequence, nondestructively.
    ///
    /// - Complexity: O(N).
    public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: @noescape (Self.Iterator.Element) throws -> Swift.Void) rethrows
}

extension Sequence {

    /// Returns the first element of the sequence that satisfies the given
    /// predicate or nil if no such element is found.
    ///
    /// - Parameter where: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element is a match.
    /// - Returns: The first match or `nil` if there was no match.
    public func first(where predicate: @noescape (Self.Iterator.Element) throws -> Bool) rethrows -> Self.Iterator.Element?
}

extension Sequence where Iterator.Element : Equatable {

    /// Returns the longest possible subsequences of the sequence, in order,
    /// around elements equal to the given element. Elements that are used to
    /// split the sequence are not returned as part of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.characters.split(separator: " ")
    ///                          .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don't", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.characters.split(separator: " ", maxSplits: 1)
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.characters.split(separator: " ", omittingEmptySubsequences: false)
    ///                           .map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the sequence and for each instance of `separator` at the
    ///     start or end of the sequence. If `true`, only nonempty subsequences
    ///     are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(separator: Self.Iterator.Element, maxSplits: Int = default, omittingEmptySubsequences: Bool = default) -> [AnySequence<Self.Iterator.Element>]
}

extension Sequence where SubSequence : Sequence, SubSequence.Iterator.Element == Iterator.Element, SubSequence.SubSequence == SubSequence {

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1).
    public func dropFirst(_ n: Int) -> AnySequence<Self.Iterator.Element>

    /// Returns a subsequence containing all but the given number of final 
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty 
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> AnySequence<Self.Iterator.Element>

    /// Returns a subsequence, up to the specified maximum length, containing the
    /// initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1)
    public func prefix(_ maxLength: Int) -> AnySequence<Self.Iterator.Element>
}

extension Sequence {

    /// Returns a subsequence containing all but the first element of the
    /// sequence.
    ///
    /// For example:
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst())
    ///     // Prints "[2, 3, 4, 5]"
    ///
    /// - Complexity: O(1)
    public func dropFirst() -> Self.SubSequence

    /// Returns a subsequence containing all but the last element of the sequence.
    ///
    /// The sequence must be finite.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast())
    ///     // Prints "[1, 2, 3, 4]"
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast() -> Self.SubSequence
}

extension Sequence {

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero, and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     > for (n, c) in "Swift".characters.enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    public func enumerated() -> EnumeratedSequence<Self>
}

extension Sequence {

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `isOrderedBefore(a, a)` is always `false`. (Irreflexivity)
    /// - If `isOrderedBefore(a, b)` and `isOrderedBefore(b, c)` are both `true`,
    ///   then `isOrderedBefore(a, c)` is also `true`. (Transitive
    ///   comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(isOrderedBefore:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional(("Coral", 16))"
    ///
    /// - Parameter isOrderedBefore: A predicate that returns `true` if its first
    ///   argument should be ordered before its second argument; otherwise,
    ///   `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `isOrderedBefore`. If the sequence has no elements, returns `nil`.
    ///
    /// - SeeAlso: `min()`
    public func min(isOrderedBefore: @noescape (Self.Iterator.Element, Self.Iterator.Element) throws -> Bool) rethrows -> Self.Iterator.Element?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `isOrderedBefore(a, a)` is always `false`. (Irreflexivity)
    /// - If `isOrderedBefore(a, b)` and `isOrderedBefore(b, c)` are both `true`,
    ///   then `isOrderedBefore(a, c)` is also `true`. (Transitive
    ///   comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(isOrderedBefore:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional(("Heliotrope", 296))"
    ///
    /// - Parameter isOrderedBefore:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    ///
    /// - SeeAlso: `max()`
    public func max(isOrderedBefore: @noescape (Self.Iterator.Element, Self.Iterator.Element) throws -> Bool) rethrows -> Self.Iterator.Element?
}

extension Sequence where Iterator.Element : Comparable {

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - SeeAlso: `min(isOrderedBefore:)`
    public func min() -> Self.Iterator.Element?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    ///
    /// - SeeAlso: `max(isOrderedBefore:)`
    public func max() -> Self.Iterator.Element?
}

extension Sequence {

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `isEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `isEquivalent(a, b)` implies `isEquivalent(b, a)`. (Symmetry)
    /// - If `isEquivalent(a, b)` and `isEquivalent(b, c)` are both `true`, then
    ///   `isEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - isEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. Returns
    ///   `true` if `possiblePrefix` has no elements.
    ///
    /// - SeeAlso: `starts(with:)`
    public func starts<PossiblePrefix : Sequence where PossiblePrefix.Iterator.Element == Iterator.Element>(with possiblePrefix: PossiblePrefix, isEquivalent: @noescape (Self.Iterator.Element, Self.Iterator.Element) throws -> Bool) rethrows -> Bool
}

extension Sequence where Iterator.Element : Equatable {

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// For example:
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. Returns `true`
    ///   if `possiblePrefix` has no elements.
    ///
    /// - SeeAlso: `starts(with:isEquivalent:)`
    public func starts<PossiblePrefix : Sequence where PossiblePrefix.Iterator.Element == Iterator.Element>(with possiblePrefix: PossiblePrefix) -> Bool
}

extension Sequence {

    /// Returns a Boolean value indicating whether the sequence and a given
    /// sequence contain equivalent elements, using the given predicate as the
    /// equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `isEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `isEquivalent(a, b)` implies `isEquivalent(b, a)`. (Symmetry)
    /// - If `isEquivalent(a, b)` and `isEquivalent(b, c)` are both `true`, then
    ///   `isEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - isEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `isEquivalent` as the equivalence test; otherwise, `false.`
    ///
    /// - SeeAlso: `elementsEqual(_:)`
    public func elementsEqual<OtherSequence : Sequence where OtherSequence.Iterator.Element == Iterator.Element>(_ other: OtherSequence, isEquivalent: @noescape (Self.Iterator.Element, Self.Iterator.Element) throws -> Bool) rethrows -> Bool
}

extension Sequence where Iterator.Element : Equatable {

    /// Returns a Boolean value indicating whether the sequence and a given
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// For example:
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    ///
    /// - SeeAlso: `elementsEqual(_:isEquivalent:)`
    public func elementsEqual<OtherSequence : Sequence where OtherSequence.Iterator.Element == Iterator.Element>(_ other: OtherSequence) -> Bool
}

extension Sequence {

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical ("dictionary") ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `isOrderedBefore(a, a)` is always `false`. (Irreflexivity)
    /// - If `isOrderedBefore(a, b)` and `isOrderedBefore(b, c)` are both `true`,
    ///   then `isOrderedBefore(a, c)` is also `true`. (Transitive
    ///   comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - isOrderedBefore:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `isOrderedBefore`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    /// - SeeAlso: `lexicographicallyPrecedes(_:)`
    public func lexicographicallyPrecedes<OtherSequence : Sequence where OtherSequence.Iterator.Element == Iterator.Element>(_ other: OtherSequence, isOrderedBefore: @noescape (Self.Iterator.Element, Self.Iterator.Element) throws -> Bool) rethrows -> Bool
}

extension Sequence where Iterator.Element : Comparable {

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical ("dictionary") ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// For example:
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, you should use `String` APIs that
    ///   perform localized comparison.
    /// - SeeAlso: `lexicographicallyPrecedes(_:isOrderedBefore:)`
    public func lexicographicallyPrecedes<OtherSequence : Sequence where OtherSequence.Iterator.Element == Iterator.Element>(_ other: OtherSequence) -> Bool
}

extension Sequence where Iterator.Element : Equatable {

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    public func contains(_ element: Self.Iterator.Element) -> Bool
}

extension Sequence {

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    /// 
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    public func contains(_ predicate: @noescape (Self.Iterator.Element) throws -> Bool) rethrows -> Bool
}

extension Sequence {

    /// Returns the result of calling the given combining closure with each
    /// element of this sequence and an accumulating value.
    ///
    /// The `combine` closure is called sequentially with an accumulating
    /// value initialized to `initial` and each element of the sequence. This
    /// example shows how to find the sum of an array of numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let addTwo: (Int, Int) -> Int = { x, y in x + y }
    ///     let numberSum = numbers.reduce(0, combine: addTwo)
    ///     // 'numberSum' == 10
    ///
    /// When `numbers.reduce(_:combine:)` is called, the following steps
    /// occur:
    ///
    /// 1. The `combine` closure is called with the initial value and the
    ///    first element of `numbers`, returning the sum: `1`.
    /// 2. The closure is called again repeatedly with the previous call's
    ///    return value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// - Parameters:
    ///   - initial: A value to use as the initial value for accumulation.
    ///   - combine: A closure that combines an accumulating value and an
    ///     element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `combine` closure or returned to the
    ///     caller.
    /// - Returns: The final accumulated value.
    public func reduce<T>(_ initial: T, combine: @noescape (T, Self.Iterator.Element) throws -> T) rethrows -> T
}

extension Sequence {

    /// Returns an array containing the elements of this sequence in reverse
    /// order.
    ///
    /// The sequence must be finite.
    ///
    /// - Complexity: O(N), where N is the length of the sequence.
    ///
    /// - Returns: An array containing the elements of this sequence in
    ///   reverse order.
    public func reversed() -> [Self.Iterator.Element]
}

extension Sequence {

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    /// 
    ///     let mapped = numbers.map { Array(count: $0, repeatedValue: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    /// 
    ///     let flatMapped = numbers.flatMap { Array(count: $0, repeatedValue: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).flatten())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *m* is the length of this sequence
    ///   and *n* is the length of the result.
    /// - SeeAlso: `flatten()`, `map(_:)`
    public func flatMap<SegmentOfResult : Sequence>(_ transform: @noescape (Self.Iterator.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Iterator.Element]
}

extension Sequence {

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of nonoptional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    /// 
    ///     let mapped: [Int?] = numbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    /// 
    ///     let flatMapped: [Int] = numbers.flatMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *m* is the length of this sequence
    ///   and *n* is the length of the result.
    public func flatMap<ElementOfResult>(_ transform: @noescape (Self.Iterator.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]
}

extension Sequence where Self : _SequenceWrapper, Self.Iterator == Self.Base.Iterator {

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> Self.Iterator

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array to
    /// lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercaseString }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.characters.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: @noescape (Self.Iterator.Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter` is used to include only names shorter than five
    /// characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.characters.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter includeElement: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `includeElement` allowed.
    public func filter(_ includeElement: @noescape (Self.Iterator.Element) throws -> Bool) rethrows -> [Self.Iterator.Element]
}

extension Sequence where Iterator.Element == String {

    /// Returns a new string by concatenating the elements of the sequence,
    /// adding the given separator between each element.
    ///
    /// The following example shows how an array of strings can be joined to a
    /// single, comma-separated string:
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let list = cast.joined(separator: ", ")
    ///     print(list)
    ///     // Prints "Vivien, Marlon, Kim, Karl"
    ///
    /// - Parameter separator: A string to insert between each of the elements
    ///   in this sequence.
    /// - Returns: A single, concatenated string.
    public func joined(separator: String) -> String
}

/// An unordered collection of unique elements.
///
/// You use a set instead of an array when you need to test efficiently for
/// membership and you aren't concerned with the order of the elements in the
/// collection, or when you need to ensure that each element appears only once
/// in a collection.
///
/// You can create a set with any element type that conforms to the `Hashable`
/// protocol. By default, most types in the standard library are hashable,
/// including strings, numeric and Boolean types, enumeration cases without
/// associated values, and even sets themselves.
///
/// Swift makes it as easy to create a new set as to create a new array. Simply
/// assign an array literal to a variable or constant with the `Set` type
/// specified.
///
///     let ingredients: Set = ["cocoa beans", "sugar", "cocoa butter", "salt"]
///     if ingredients.contains("sugar") {
///         print("No thanks, too sweet.")
///     }
///     // Prints "No thanks, too sweet."
///
/// Set Operations
/// ==============
///
/// Sets provide a suite of mathematical set operations. For example, you can
/// efficiently test a set for membership of an element or check its
/// intersection with another set:
///
/// - Use the `contains(_:)` method to test whether a set contains a specific
///   element.
/// - Use the "equal to" operator (`==`) to test whether two sets contain the
///   same elements.
/// - Use the `isSubset(of:)` method to test whether a set contains all the
///   elements of another set or sequence.
/// - Use the `isSuperset(of:)` method to test whether all elements of a set
///   are contained in another set or sequence.
/// - Use the `isStrictSubset(of:)` and `isStrictSuperset(of:)` methods to test
///   whether a set is a subset or superset of, but not equal to, another set.
/// - Use the `isDisjoint(with:)` method to test whether a set has any elements
///   in common with another set.
///
/// You can also combine, exclude, or subtract the elements of two sets:
///
/// - Use the `union(_:)` method to create a new set with the elements of a set
///   and another set or sequence.
/// - Use the `intersection(_:)` method to create a new set with only the
///   elements common to a set and another set or sequence.
/// - Use the `symmetricDifference(_:)` method to create a new set with the
///   elements that are in either a set or another set or sequence, but not in
///   both.
/// - Use the `subtracting(_:)` method to create a new set with the elements of
///   a set that are not also in another set or sequence.
///
/// You can modify a set in place by using these methods' mutating
/// counterparts: `formUnion(_:)`, `formIntersection(_:)`,
/// `formSymmetricDifference(_:)`, and `subtract(_:)`.
///
/// Set operations are not limited to use with other sets. Instead, you can
/// perform set operations with another set, an array, or any other sequence
/// type.
///
///     var primes: Set = [2, 3, 5, 7]
///
///     // Tests whether primes is a subset of a Range<Int>
///     print(primes.isSubset(of: 0..<10))
///     // Prints "true"
///
///     // Performs an intersection with an Array<Int>
///     let favoriteNumbers = [5, 7, 15, 21]
///     print(primes.intersection(favoriteNumbers))
///     // Prints "[5, 7]"
///
///
/// Sequence and Collection Operations
/// ==================================
///
/// In addition to the `Set` type's set operations, you can use any nonmutating
/// sequence or collection methods with a set.
///
///     if primes.isEmpty {
///         print("No primes!")
///     } else {
///         print("We have \(primes.count) primes.")
///     }
///     // Prints "We have 4 primes."
///
///     let primesSum = primes.reduce(0, combine: +)
///     // 'primesSum' == 17
///
///     let primeStrings = primes.sorted().map(String.init)
///     // 'primeStrings' == ["2", "3", "5", "7"]
///
/// You can iterate through a set's unordered elements with a `for`-`in` loop.
///
///     for number in primes {
///         print(number)
///     }
///     // Prints "5"
///     // Prints "7"
///     // Prints "2"
///     // Prints "3"
///
/// Many sequence and collection operations return an array or a type-erasing
/// collection wrapper instead of a set. To restore efficient set operations,
/// create a new set from the result.
///
///     let morePrimes = primes.union([11, 13, 17, 19])
///
///     let laterPrimes = morePrimes.filter { $0 > 10 }
///     // 'laterPrimes' is of type Array<Int>
///
///     let laterPrimesSet = Set(morePrimes.filter { $0 > 10 })
///     // 'laterPrimesSet' is of type Set<Int>
///
/// Bridging Between Set and NSSet
/// ==============================
///
/// You can bridge between `Set` and `NSSet` using the `as` operator. For
/// bridging to be possible, the `Element` type of a set must be a class, an
/// `@objc` protocol (a protocol imported from Objective-C or marked with the
/// `@objc` attribute), or a type that bridges to a Foundation type.
///
/// Bridging from `Set` to `NSSet` always takes O(1) time and space. When the
/// set's `Element` type is neither a class nor an `@objc` protocol, any
/// required bridging of elements occurs at the first access of each element,
/// so the first operation that uses the contents of the set (for example, a
/// membership test) can take O(N).
///
/// Bridging from `NSSet` to `Set` first calls the `copy(with:)` method
/// (`- copyWithZone:` in Objective-C) on the set to get an immutable copy and
/// then performs additional Swift bookkeeping work that takes O(1) time. For
/// instances of `NSSet` that are already immutable, `copy(with:)` returns the
/// same set in constant time; otherwise, the copying performance is
/// unspecified. The instances of `NSSet` and `Set` share storage using the
/// same copy-on-write optimization that is used when two instances of `Set`
/// share storage.
///
/// - SeeAlso: `Hashable`
public struct Set<Element : Hashable> : SetAlgebra, Hashable, Collection, ArrayLiteralConvertible {

    /// The index type for subscripting the set.
    public typealias Index = SetIndex<Element>

    /// Creates a new, empty set with at least the specified number of elements'
    /// worth of storage.
    ///
    /// Use this initializer to avoid repeated reallocations of a set's storage
    /// if you know you'll be adding elements to the set after creation. The
    /// actual capacity of the created set will be the smallest power of 2 that
    /// is greater than or equal to `minimumCapacity`.
    ///
    /// - Parameter minimumCapacity: The minimum number of elements that the
    ///   newly created set should be able to store without reallocating its
    ///   storage.
    public init(minimumCapacity: Int)

    /// The starting position for iterating members of the set.
    ///
    /// If the set is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: SetIndex<Element> { get }

    /// The "past the end" position for the set---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// If the set is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: SetIndex<Element> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: SetIndex<Element>) -> SetIndex<Element>

    /// Returns a Boolean value that indicates whether the given element exists
    /// in the set.
    ///
    /// For example:
    ///
    ///     let primes: Set = [2, 3, 5, 7]
    ///     let x = 5
    ///     if primes.contains(x) {
    ///         print("\(x) is prime!")
    ///     } else {
    ///         print("\(x). Not prime.")
    ///     }
    ///     // Prints "5 is prime!"
    ///
    /// - Parameter member: An element to look for in the set.
    /// - Returns: `true` if `member` exists in the set; otherwise, `false`.
    public func contains(_ member: Element) -> Bool

    /// Returns the index of the given element in the set, or `nil` if the
    /// element is not a member of the set.
    ///
    /// - Parameter member: An element to search for in the set.
    /// - Returns: The index of `member` if it exists in the set; otherwise,
    ///   `nil`.
    public func index(of member: Element) -> SetIndex<Element>?

    /// Inserts the given element in the set if it is not already present.
    ///
    /// If an element equal to `newMember` is already contained in the set, this
    /// method has no effect. In the following example, a new element is
    /// inserted into `classDays`, a set of days of the week. When an existing
    /// element is inserted, the `classDays` set does not change.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.wednesday, .friday]
    ///     print(classDays.insert(.monday))
    ///     // Prints "(true, .monday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    ///     print(classDays.insert(.friday))
    ///     // Prints "(false, .friday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: `(true, newMember)` if `newMember` was not contained in the
    ///   set. If an element equal to `newMember` was already contained in the
    ///   set, the method returns `(false, oldMember)`, where `oldMember` is the
    ///   element that was equal to `newMember`. In some cases, `oldMember` may
    ///   be distinguishable from `newMember` by identity comparison or some
    ///   other means.
    public mutating func insert(_ newMember: Element) -> (inserted: Bool, memberAfterInsert: Element)

    /// Inserts the given element into the set unconditionally.
    ///
    /// If an element equal to `newMember` is already contained in the set,
    /// `newMember` replaces the existing element. In this example, an existing
    /// element is inserted into `classDays`, a set of days of the week.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.monday, .wednesday, .friday]
    ///     print(classDays.update(with: .monday))
    ///     // Prints "Optional(.monday)"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: An element equal to `newMember` if the set already contained
    ///   such a member; otherwise, `nil`. In some cases, the returned element
    ///   may be distinguishable from `newMember` by identity comparison or some
    ///   other means.
    public mutating func update(with newMember: Element) -> Element?

    /// Removes the specified element from the set.
    ///
    /// For example:
    ///
    ///     var ingredients: Set = ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///     let toRemove = "sugar"
    ///     if let removed = ingredients.remove(toRemove) {
    ///         print("The recipe is now \(removed)-free.")
    ///     }
    ///     // Prints "The recipe is now sugar-free."
    ///
    /// - Parameter member: The element to remove from the set.
    /// - Returns: The value of the `member` parameter if it was a member of the
    ///   set; otherwise, `nil`.
    public mutating func remove(_ member: Element) -> Element?

    /// Removes the element at the given index of the set.
    ///
    /// - Parameter position: The index of the member to remove. `position` must
    ///   be a valid index of the set, and must not be equal to the set's end
    ///   index.
    /// - Returns: The element that was removed from the set.
    public mutating func remove(at position: SetIndex<Element>) -> Element

    /// Removes all members from the set.
    ///
    /// - Parameter keepingCapacity: If `true`, the set's storage capacity is
    ///   preserved; if `false`, the underlying storage is released. The
    ///   default is `false`.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)

    /// Removes the first element of the set.
    ///
    /// Because a set is not an ordered collection, the "first" element may not
    /// be the first element that was added to the set. The set must not be
    /// empty.
    ///
    /// - Returns: A member of the set.
    public mutating func removeFirst() -> Element

    /// The number of elements in the set.
    public var count: Int { get }

    /// Accesses the member at the given position.
    public subscript(position: SetIndex<Element>) -> Element { get }

    /// Returns an iterator over the members of the set.
    public func makeIterator() -> SetIterator<Element>

    /// Creates a set containing the elements of the given array literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use an array literal. Instead, create a new set using an array
    /// literal as its value by enclosing a comma-separated list of values in
    /// square brackets. You can use an array literal anywhere a set is expected
    /// by the type context.
    ///
    /// Here, a set of strings is created from an array literal holding only
    /// strings.
    ///
    ///     let ingredients: Set = ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///     if ingredients.isSuperset(of: ["sugar", "salt"]) {
    ///         print("Whatever it is, it's bound to be delicious!")
    ///     }
    ///     // Prints "Whatever it is, it's bound to be delicious!"
    ///
    /// - Parameter elements: A variadic list of elements of the new set.
    public init(arrayLiteral elements: Element...)

    /// Creates an empty set.
    ///
    /// This is equivalent to initializing with an empty array literal. For
    /// example:
    ///
    ///     var emptySet = Set<Int>()
    ///     print(emptySet.isEmpty)
    ///     // Prints "true"
    /// 
    ///     emptySet = []
    ///     print(emptySet.isEmpty)
    ///     // Prints "true"
    public init()

    /// Creates a new set from a finite sequence of items.
    ///
    /// Use this initializer to create a new set from an existing sequence, for
    /// example, an array or a range.
    ///
    ///     let validIndices = Set(0..<7).subtracting([2, 4, 5])
    ///     print(validIndices)
    ///     // Prints "[6, 0, 1, 3]"
    ///
    /// This initializer can also be used to restore set methods after performing
    /// sequence operations such as `filter(_:)` or `map(_:)` on a set. For
    /// example, after filtering a set of prime numbers to remove any below 10,
    /// you can create a new set by using this initializer.
    ///
    ///     let primes: Set = [2, 3, 5, 7, 11, 13, 17, 19, 23]
    ///     let laterPrimes = Set(primes.lazy.filter { $0 > 10 })
    ///     print(laterPrimes)
    ///     // Prints "[17, 19, 23, 11, 13]"
    ///
    /// - Parameter sequence: The elements to use as members of the new set.
    public init<Source : Sequence where Source.Iterator.Element == Element>(_ sequence: Source)

    /// Returns a Boolean value that indicates whether the set is a subset of the
    /// given sequence.
    ///
    /// Set *A* is a subset of another set *B* if every member of *A* is also a
    /// member of *B*.
    ///
    ///     let employees = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isSubset(of: employees))
    ///     // Prints "true"
    ///
    /// - Parameter possibleSuperset: A sequence of elements. `possibleSuperset`
    ///   must be finite.
    /// - Returns: `true` if the set is a subset of `possibleSuperset`;
    ///   otherwise, `false`.
    public func isSubset<S : Sequence where S.Iterator.Element == Element>(of possibleSuperset: S) -> Bool

    /// Returns a Boolean value that indicates whether the set is a strict subset
    /// of the given sequence.
    ///
    /// Set *A* is a strict subset of another set *B* if every member of *A* is
    /// also a member of *B* and *B* contains at least one element that is not a
    /// member of *A*.
    ///
    ///     let employees = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isStrictSubset(of: employees))
    ///     // Prints "true"
    ///
    ///     // A set is never a strict subset of itself:
    ///     print(attendees.isStrictSubset(of: attendees))
    ///     // Prints "false"
    ///
    /// - Parameter possibleStrictSuperset: A sequence of elements.
    ///   `possibleStrictSuperset` must be finite.
    /// - Returns: `true` is the set is strict subset of
    ///   `possibleStrictSuperset`; otherwise, `false`.
    public func isStrictSubset<S : Sequence where S.Iterator.Element == Element>(of possibleStrictSuperset: S) -> Bool

    /// Returns a Boolean value that indicates whether the set is a superset of
    /// the given sequence.
    ///
    /// Set *A* is a superset of another set *B* if every member of *B* is also a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isSuperset(of: attendees))
    ///     // Prints "true"
    ///
    /// - Parameter possibleSubset: A sequence of elements. `possibleSubset` must
    ///   be finite.
    /// - Returns: `true` if the set is a superset of `possibleSubset`;
    ///   otherwise, `false`.
    public func isSuperset<S : Sequence where S.Iterator.Element == Element>(of possibleSubset: S) -> Bool

    /// Returns a Boolean value that indicates whether the set is a strict
    /// superset of the given sequence.
    ///
    /// Set *A* is a strict superset of another set *B* if every member of *B* is
    /// also a member of *A* and *A* contains at least one element that is *not*
    /// a member of *B*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isStrictSuperset(of: attendees))
    ///     // Prints "true"
    ///     print(employees.isStrictSuperset(of: employees))
    ///     // Prints "false"
    ///
    /// - Parameter possibleStrictSubset: A sequence of elements.
    ///   `possibleStrictSubset` must be finite.
    /// - Returns: `true` if the set is a strict superset of
    ///   `possibleStrictSubset`; otherwise, `false`.
    public func isStrictSuperset<S : Sequence where S.Iterator.Element == Element>(of possibleStrictSubset: S) -> Bool

    /// Returns a Boolean value that indicates whether the set has no members in
    /// common with the given sequence.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let visitors = ["Marcia", "Nathaniel", "Olivia"]
    ///     print(employees.isDisjoint(with: visitors))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    /// - Returns: `true` if the set has no elements in common with `other`;
    ///   otherwise, `false`.
    public func isDisjoint<S : Sequence where S.Iterator.Element == Element>(with other: S) -> Bool

    /// Returns a new set with the elements of both this set and the given
    /// sequence.
    ///
    /// For example:
    ///
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors = ["Marcia", "Nathaniel"]
    ///     let attendeesAndVisitors = attendees.union(visitors)
    ///     print(attendeesAndVisitors)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept. If `other` contains multiple
    /// instances of equivalent elements, only the first instance is kept. For
    /// example:
    ///
    ///     let initialIndices = Set(0..<5)
    ///     let expandedIndices = initialIndices.union([2, 3, 6, 6, 7, 7])
    ///     print(expandedIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    /// - Returns: A new set with the unique elements of this set and `other`.
    public func union<S : Sequence where S.Iterator.Element == Element>(_ other: S) -> Set<Element>

    /// Inserts the elements of the given sequence into the set.
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept. If `other` contains multiple
    /// instances of equivalent elements, only the first instance is kept.
    ///
    ///     var attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors = ["Diana", ""Marcia", "Nathaniel"]
    ///     attendees.formUnion(visitors)
    ///     print(attendees)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    public mutating func formUnion<S : Sequence where S.Iterator.Element == Element>(_ other: S)

    /// Returns a new set containing the elements of this set that do not occur
    /// in the given sequence.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let nonNeighbors = employees.subtracting(neighbors)
    ///     print(nonNeighbors)
    ///     // Prints "["Chris", "Diana", "Alicia"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    /// - Returns: A new set.
    public func subtracting<S : Sequence where S.Iterator.Element == Element>(_ other: S) -> Set<Element>

    /// Removes the elements of the given sequence from the set.
    ///
    /// For example:
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.subtract(neighbors)
    ///     print(employees)
    ///     // Prints "["Chris", "Diana", "Alicia"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    public mutating func subtract<S : Sequence where S.Iterator.Element == Element>(_ other: S)

    /// Returns a new set with the elements that are common to both this set and
    /// the given sequence.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let bothNeighborsAndEmployees = employees.intersection(neighbors)
    ///     print(bothNeighborsAndEmployees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    /// - Returns: A new set.
    public func intersection<S : Sequence where S.Iterator.Element == Element>(_ other: S) -> Set<Element>

    /// Removes the elements of the set that aren't also in the given sequence.
    ///
    /// For example:
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.formIntersection(neighbors)
    ///     print(employees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    public mutating func formIntersection<S : Sequence where S.Iterator.Element == Element>(_ other: S)

    /// Returns a new set with the elements that are either in this set or in the
    /// given sequence, but not in both.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani"]
    ///     let eitherNeighborsOrEmployees = employees.symmetricDifference(neighbors)
    ///     print(eitherNeighborsOrEmployees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    /// - Returns: A new set.
    public func symmetricDifference<S : Sequence where S.Iterator.Element == Element>(_ other: S) -> Set<Element>

    /// Replace this set with the elements contained in this set or the given
    /// set, but not both.
    ///
    /// For example:
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani"]
    ///     employees.formSymmetricDifference(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    public mutating func formSymmetricDifference<S : Sequence where S.Iterator.Element == Element>(_ other: S)

    /// The hash value for the set.
    /// 
    /// Two sets that are equal will always have equal hash values.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }

    /// A Boolean value that indicates whether the set is empty.
    public var isEmpty: Bool { get }

    /// The first element of the set.
    ///
    /// The first element of the set is not necessarily the first element added
    /// to the set. Don't expect any particular ordering of set elements.
    ///
    /// If the set is empty, the value of this property is `nil`.
    public var first: Element? { get }
}

extension Set : CustomStringConvertible, CustomDebugStringConvertible {

    /// A string that represents the contents of the set.
    public var description: String { get }

    /// A string that represents the contents of the set, suitable for debugging.
    public var debugDescription: String { get }
}

extension Set : CustomReflectable {

    /// A mirror that reflects the set.
    public var customMirror: Mirror { get }
}

extension Set {

    /// Removes and returns the first element of the set.
    ///
    /// Because a set is not an ordered collection, the "first" element may not
    /// be the first element that was added to the set.
    ///
    /// - Returns: A member of the set. If the set is empty, returns `nil`.
    public mutating func popFirst() -> Element?
}

extension Set {

    /// Removes the elements of the given set from this set.
    ///
    /// For example:
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.subtract(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: Another set.
    public mutating func subtract(_ other: Set<Element>)

    /// Returns a Boolean value that indicates whether this set is a subset of the
    /// given set.
    ///
    /// Set *A* is a subset of another set *B* if every member of *A* is also a
    /// member of *B*.
    ///
    ///     let employees = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isSubset(of: employees))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence of elements. `possibleSuperset`
    ///   must be finite.
    /// - Returns: `true` if the set is a subset of `possibleSuperset`;
    ///   otherwise, `false`.
    public func isSubset(of other: Set<Element>) -> Bool

    /// Returns a Boolean value that indicates whether this set is a superset of
    /// the given set.
    ///
    /// Set *A* is a superset of another set *B* if every member of *B* is also a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isSuperset(of: attendees))
    ///     // Prints "true"
    ///
    /// - Parameter possibleSubset: Another set.
    /// - Returns: `true` if the set is a superset of `possibleSubset`;
    ///   otherwise, `false`.
    public func isSuperset(of other: Set<Element>) -> Bool

    /// Returns a Boolean value that indicates whether this set has no members in
    /// common with the given set.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let visitors: Set = ["Marcia", "Nathaniel", "Olivia"]
    ///     print(employees.isDisjoint(with: visitors))
    ///     // Prints "true"
    ///
    /// - Parameter other: Another set.
    /// - Returns: `true` if the set has no elements in common with `other`;
    ///   otherwise, `false`.
    public func isDisjoint(with other: Set<Element>) -> Bool

    /// Returns a new set containing the elements of this set that do not occur
    /// in the given set.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let nonNeighbors = employees.subtracting(neighbors)
    ///     print(nonNeighbors)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: Another set.
    /// - Returns: A new set.
    public func subtracting(_ other: Set<Element>) -> Set<Element>

    /// Returns a Boolean value that indicates whether the set is a strict
    /// superset of the given sequence.
    ///
    /// Set *A* is a strict superset of another set *B* if every member of *B* is
    /// also a member of *A* and *A* contains at least one element that is *not*
    /// a member of *B*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isStrictSuperset(of: attendees))
    ///     // Prints "true"
    ///     print(employees.isStrictSuperset(of: employees))
    ///     // Prints "false"
    ///
    /// - Parameter possibleStrictSubset: Another set.
    /// - Returns: `true` if the set is a strict superset of
    ///   `possibleStrictSubset`; otherwise, `false`.
    public func isStrictSuperset(of other: Set<Element>) -> Bool

    /// Returns a Boolean value that indicates whether the set is a strict subset
    /// of the given sequence.
    ///
    /// Set *A* is a strict subset of another set *B* if every member of *A* is
    /// also a member of *B* and *B* contains at least one element that is not a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isStrictSubset(of: employees))
    ///     // Prints "true"
    ///
    ///     // A set is never a strict subset of itself:
    ///     print(attendees.isStrictSubset(of: attendees))
    ///     // Prints "false"
    ///
    /// - Parameter possibleStrictSuperset: Another set.
    /// - Returns: `true` if the set is a strict subset of
    ///   `possibleStrictSuperset`; otherwise, `false`.
    public func isStrictSubset(of other: Set<Element>) -> Bool

    /// Returns a new set with the elements that are common to both this set and
    /// the given sequence.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let bothNeighborsAndEmployees = employees.intersection(neighbors)
    ///     print(bothNeighborsAndEmployees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: Another set.
    /// - Returns: A new set.
    public func intersection(_ other: Set<Element>) -> Set<Element>

    /// Removes the elements of the set that are also in the given sequence and
    /// adds the members of the sequence that are not already in the set.
    ///
    /// For example:
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.formSymmetricDifference(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Chris", "Forlani", "Alicia", "Greta"]"
    ///
    /// - Parameter other: Another set.
    public mutating func formSymmetricDifference(_ other: Set<Element>)
}

/// A type that provides mathematical set operations.
///
/// You use types that conform to the `SetAlgebra` protocol when you need
/// efficient membership tests or mathematical set operations such as
/// intersection, union, and subtraction. In the standard library, you can
/// use the `Set` type with elements of any hashable type, or you can easily
/// create bit masks with `SetAlgebra` conformance using the `OptionSet`
/// protocol. See those types for more information.
///
/// - Note: Unlike ordinary set types, the `Element` type of an `OptionSet` is
///   identical to the `OptionSet` type itself. The `SetAlgebra` protocol is
///   specifically designed to accommodate both kinds of set.
///
/// Conforming to the SetAlgebra Protocol
/// =====================================
///
/// When implementing a custom type that conforms to the `SetAlgebra` protocol,
/// you must implement the required initializers and methods. For the
/// inherited methods to work properly, conforming types must meet the
/// following axioms. Assume that `S` is a custom type that conforms to the
/// `SetAlgebra` protocol, `x` and `y` are instances of `S`, and `e` is of
/// type `S.Element`---the type that the set holds.
///
/// - `S() == []`
/// - `x.intersection(x) == x`
/// - `x.intersection([]) == []`
/// - `x.union(x) == x`
/// - `x.union([]) == x`
/// - `x.contains(e)` implies `x.union(y).contains(e)`
/// - `x.union(y).contains(e)` implies `x.contains(e) || y.contains(e)`
/// - `x.contains(e) && y.contains(e)` if and only if
///   `x.intersection(y).contains(e)`
/// - `x.isSubset(of: y)` if and only if `y.isSuperset(of: x)`
/// - `x.isStrictSuperset(of: y)` if and only if
///   `x.isSuperset(of: y) && x != y`
/// - `x.isStrictSubset(of: y)` if and only if `x.isSubset(of: y) && x != y`
/// 
/// - SeeAlso: `OptionSet`, `Set`
public protocol SetAlgebra : Equatable, ArrayLiteralConvertible {

    /// A type for which the conforming type provides a containment test.
    associatedtype Element

    /// Creates an empty set.
    ///
    /// This initializer is equivalent to initializing with an empty array
    /// literal. For example, you create an empty `Set` instance with either
    /// this initializer or with an empty array literal.
    ///
    ///     var emptySet = Set<Int>()
    ///     print(emptySet.isEmpty)
    ///     // Prints "true"
    ///
    ///     emptySet = []
    ///     print(emptySet.isEmpty)
    ///     // Prints "true"
    public init()

    /// Returns a Boolean value that indicates whether the given element exists
    /// in the set.
    /// 
    /// For example:
    ///
    ///     let primes: Set = [2, 3, 5, 7]
    ///     let x = 5
    ///     if primes.contains(x) {
    ///         print("\(x) is prime!")
    ///     } else {
    ///         print("\(x). Not prime.")
    ///     }
    ///     // Prints "5 is prime!"
    ///
    /// - Parameter member: An element to look for in the set.
    /// - Returns: `true` if `member` exists in the set; otherwise, `false`.
    public func contains(_ member: Self.Element) -> Bool

    /// Returns a new set with the elements of both this and the given set.
    ///
    /// For example:
    ///
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors = ["Marcia", "Nathaniel"]
    ///     let attendeesAndVisitors = attendees.union(visitors)
    ///     print(attendeesAndVisitors)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept. For example:
    ///
    ///     let initialIndices = Set(0..<5)
    ///     let expandedIndices = initialIndices.union([2, 3, 6, 7])
    ///     print(expandedIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set with the unique elements of this set and `other`.
    ///
    /// - Note: if this set and `other` contain elements that are equal but
    ///   distinguishable (e.g. via `===`), which of these elements is present
    ///   in the result is unspecified.
    public func union(_ other: Self) -> Self

    /// Returns a new set with the elements that are common to both this set and
    /// the given set.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let bothNeighborsAndEmployees = employees.intersection(neighbors)
    ///     print(bothNeighborsAndEmployees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    ///
    /// - Note: if this set and `other` contain elements that are equal but
    ///   distinguishable (e.g. via `===`), which of these elements is present
    ///   in the result is unspecified.
    public func intersection(_ other: Self) -> Self

    /// Returns a new set with the elements that are either in this set or in the
    /// given set, but not in both.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani"]
    ///     let eitherNeighborsOrEmployees = employees.symmetricDifference(neighbors)
    ///     print(eitherNeighborsOrEmployees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    public func symmetricDifference(_ other: Self) -> Self

    /// Inserts the given element in the set if it is not already present.
    ///
    /// If an element equal to `newMember` is already contained in the set, this
    /// method has no effect. In this example, a new element is inserted into
    /// `classDays`, a set of days of the week. When an existing element is
    /// inserted, the `classDays` set does not change.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.wednesday, .friday]
    ///     print(classDays.insert(.monday))
    ///     // Prints "(true, .monday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    ///     print(classDays.insert(.friday))
    ///     // Prints "(false, .friday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: `(true, newMember)` if `newMember` was not contained in the
    ///   set. If an element equal to `newMember` was already contained in the
    ///   set, the method returns `(false, oldMember)`, where `oldMember` is the
    ///   element that was equal to `newMember`. In some cases, `oldMember` may
    ///   be distinguishable from `newMember` by identity comparison or some
    ///   other means.
    public mutating func insert(_ newMember: Self.Element) -> (inserted: Bool, memberAfterInsert: Self.Element)

    /// Removes the given element and any elements subsumed by the given element.
    ///
    /// - Parameter member: The element of the set to remove.
    /// - Returns: For ordinary sets, an element equal to `member` if `member` is
    ///   contained in the set; otherwise, `nil`. In some cases, a returned
    ///   element may be distinguishable from `newMember` by identity comparison
    ///   or some other means.
    ///
    ///   For sets where the set type and element type are the same, like
    ///   `OptionSet` types, this method returns any intersection between the set
    ///   and `[member]`, or `nil` if the intersection is empty.
    public mutating func remove(_ member: Self.Element) -> Self.Element?

    /// Inserts the given element into the set unconditionally.
    ///
    /// If an element equal to `newMember` is already contained in the set,
    /// `newMember` replaces the existing element. In this example, an existing
    /// element is inserted into `classDays`, a set of days of the week.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.monday, .wednesday, .friday]
    ///     print(classDays.update(with: .monday))
    ///     // Prints "Optional(.monday)"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: For ordinary sets, an element equal to `newMember` if the set
    ///   already contained such a member; otherwise, `nil`. In some cases, the
    ///   returned element may be distinguishable from `newMember` by identity
    ///   comparison or some other means.
    ///
    ///   For sets where the set type and element type are the same, like
    ///   `OptionSet` types, this method returns any intersection between the 
    ///   set and `[newMember]`, or `nil` if the intersection is empty.
    public mutating func update(with newMember: Self.Element) -> Self.Element?

    /// Adds the elements of the given set to the set.
    ///
    /// For example:
    ///
    ///     var attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors: Set = ["Marcia", "Nathaniel"]
    ///     attendees.formUnion(visitors)
    ///     print(attendees)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept. For example:
    ///
    ///     var initialIndices = Set(0..<5)
    ///     initialIndices.formUnion([2, 3, 6, 7])
    ///     print(initialIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func formUnion(_ other: Self)

    /// Removes the elements of this set that aren't also in the given set.
    ///
    /// For example:
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.formIntersection(neighbors)
    ///     print(employees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func formIntersection(_ other: Self)

    /// Removes the elements of the set that are also in the given set and
    /// adds the members of the given set that are not already in the set.
    ///
    /// For example:
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani"]
    ///     employees.formSymmetricDifference(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type.
    public mutating func formSymmetricDifference(_ other: Self)

    /// Returns a new set containing the elements of this set that do not occur
    /// in the given set.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let nonNeighbors = employees.subtracting(neighbors)
    ///     print(nonNeighbors)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    public func subtracting(_ other: Self) -> Self

    /// Returns a Boolean value that indicates whether the set is a subset of
    /// another set.
    ///
    /// Set *A* is a subset of another set *B* if every member of *A* is also a
    /// member of *B*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isSubset(of: employees))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a subset of `other`; otherwise, `false`.
    public func isSubset(of other: Self) -> Bool

    /// Returns a Boolean value that indicates whether the set has no members in
    /// common with the given set.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let visitors: Set = ["Marcia", "Nathaniel", "Olivia"]
    ///     print(employees.isDisjoint(with: visitors))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set has no elements in common with `other`;
    ///   otherwise, `false`.
    public func isDisjoint(with other: Self) -> Bool

    /// Returns a Boolean value that indicates whether the set is a superset of
    /// the given set.
    ///
    /// Set *A* is a superset of another set *B* if every member of *B* is also a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isSuperset(of: attendees))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a superset of `possibleSubset`;
    ///   otherwise, `false`.
    public func isSuperset(of other: Self) -> Bool

    /// A Boolean value that indicates whether the set has no elements.
    public var isEmpty: Bool { get }

    /// Creates a new set from a finite sequence of items.
    ///
    /// Use this initializer to create a new set from an existing sequence, like
    /// an array or a range:
    ///
    ///     let validIndices = Set(0..<7).subtracting([2, 4, 5])
    ///     print(validIndices)
    ///     // Prints "[6, 0, 1, 3]"
    ///
    /// - Parameter sequence: The elements to use as members of the new set.
    public init<S : Sequence where S.Iterator.Element == Element>(_ sequence: S)

    /// Removes the elements of the given set from this set.
    ///
    /// For example:
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.subtract(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func subtract(_ other: Self)
}

/// `SetAlgebra` requirements for which default implementations
/// are supplied.
///
/// - Note: A type conforming to `SetAlgebra` can implement any of
///   these initializers or methods, and those implementations will be
///   used in lieu of these defaults.
extension SetAlgebra {

    /// Creates a new set from a finite sequence of items.
    ///
    /// Use this initializer to create a new set from an existing sequence, like
    /// an array or a range:
    ///
    ///     let validIndices = Set(0..<7).subtracting([2, 4, 5])
    ///     print(validIndices)
    ///     // Prints "[6, 0, 1, 3]"
    ///
    /// - Parameter sequence: The elements to use as members of the new set.
    public convenience init<S : Sequence where S.Iterator.Element == Element>(_ sequence: S)

    /// Creates a set containing the elements of the given array literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use an array literal. Instead, create a new set using an array
    /// literal as its value by enclosing a comma-separated list of values in
    /// square brackets. You can use an array literal anywhere a set is expected
    /// by the type context.
    ///
    /// Here, a set of strings is created from an array literal holding only
    /// strings:
    ///
    ///     let ingredients: Set = ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///     if ingredients.isSuperset(of: ["sugar", "salt"]) {
    ///         print("Whatever it is, it's bound to be delicious!")
    ///     }
    ///     // Prints "Whatever it is, it's bound to be delicious!"
    ///
    /// - Parameter arrayLiteral: A list of elements of the new set.
    public convenience init(arrayLiteral: Self.Element...)

    /// Removes the elements of the given set from this set.
    ///
    /// For example:
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.subtract(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func subtract(_ other: Self)

    /// Returns a Boolean value that indicates whether the set is a subset of
    /// another set.
    ///
    /// Set *A* is a subset of another set *B* if every member of *A* is also a
    /// member of *B*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isSubset(of: employees))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a subset of `other`; otherwise, `false`.
    public func isSubset(of other: Self) -> Bool

    /// Returns a Boolean value that indicates whether the set is a superset of
    /// the given set.
    ///
    /// Set *A* is a superset of another set *B* if every member of *B* is also a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isSuperset(of: attendees))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a superset of `other`; otherwise,
    ///   `false`.
    public func isSuperset(of other: Self) -> Bool

    /// Returns a Boolean value that indicates whether the set has no members in
    /// common with the given set.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let visitors: Set = ["Marcia", "Nathaniel", "Olivia"]
    ///     print(employees.isDisjoint(with: visitors))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set has no elements in common with `other`;
    ///   otherwise, `false`.
    public func isDisjoint(with other: Self) -> Bool

    /// Returns a new set containing the elements of this set that do not occur
    /// in the given set.
    ///
    /// For example:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let nonNeighbors = employees.subtract(neighbors)
    ///     print(nonNeighbors)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    public func subtracting(_ other: Self) -> Self

    /// A Boolean value that indicates whether the set has no elements.
    public var isEmpty: Bool { get }

    /// Returns a Boolean value that indicates whether this set is a strict
    /// superset of the given set.
    ///
    /// Set *A* is a strict superset of another set *B* if every member of *B* is
    /// also a member of *A* and *A* contains at least one element that is *not*
    /// a member of *B*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isStrictSuperset(of: attendees))
    ///     // Prints "true"
    ///     print(employees.isStrictSuperset(of: employees))
    ///     // Prints "false"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a strict superset of `other`; otherwise,
    ///   `false`.
    public func isStrictSuperset(of other: Self) -> Bool

    /// Returns a Boolean value that indicates whether this set is a strict
    /// subset of the given set.
    ///
    /// Set *A* is a strict subset of another set *B* if every member of *A* is
    /// also a member of *B* and *B* contains at least one element that is not a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isStrictSubset(of: employees))
    ///     // Prints "true"
    ///
    ///     // A set is never a strict subset of itself:
    ///     print(attendees.isStrictSubset(of: attendees))
    ///     // Prints "false"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a strict subset of `other`; otherwise,
    ///   `false`.
    public func isStrictSubset(of other: Self) -> Bool
}

/// Used to access the members in an instance of `Set<Element>`.
public struct SetIndex<Element : Hashable> : Comparable {
}

/// An iterator over the members of a `Set<Element>`.
public struct SetIterator<Element : Hashable> : IteratorProtocol {

    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    ///
    /// - Precondition: No preceding call to `self.next()` has returned `nil`.
    public mutating func next() -> Element?
}

extension SetIterator : CustomReflectable {

    /// A mirror that reflects the iterator.
    public var customMirror: Mirror { get }
}

/// A set of common requirements for Swift's signed integer types.
public protocol SignedInteger : _SignedInteger, Integer {

    /// Represent this number using Swift's widest native signed integer
    /// type.
    public func toIntMax() -> IntMax

    /// Convert from Swift's widest signed integer type, trapping on
    /// overflow.
    public init(_: IntMax)
}

extension SignedInteger {

    public func distance(to other: Self) -> Int

    public func advanced(by n: Int) -> Self
}

/// Instances of conforming types can be subtracted, arithmetically
/// negated, and initialized from `0`.
///
/// Axioms:
///
/// - `x - 0 == x`
/// - `-x == 0 - x`
/// - `-(-x) == x`
public protocol SignedNumber : Comparable, IntegerLiteralConvertible {

    /// Returns the result of negating `x`.
    prefix public func -(x: Self) -> Self

    /// Returns the difference between `lhs` and `rhs`.
    public func -(lhs: Self, rhs: Self) -> Self
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(isOrderedBefore:)` method to determine the index of the day
///    with the most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(isOrderedBefore: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `Slice` instance is wrapped around a mutable
/// collection that has value semantics, such as an array, mutating the
/// original collection would trigger a copy of that collection, and not
/// affect the base collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// - Important: Use slices only for transient computation.
///   A slice may hold a reference to the entire storage of a larger
///   collection, not just to the portion it presents, even after the base
///   collection's lifetime ends. Long-term storage of a slice may therefore
///   prolong the lifetime of elements that are no longer otherwise
///   accessible, which can erroneously appear to be memory leakage.
public struct Slice<Base : Indexable> : Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Base.Index

    /// A type that can represent the number of steps between a pair of
    /// indices.
    public typealias IndexDistance = Base.IndexDistance

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Base.Index) -> Base._Element { get }

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = Slice<Base>

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.index(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Base.Index>) -> Slice<Base> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Base.Index) -> Base.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Base.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. Make
    /// sure the value passed as `n` does not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance) -> Base.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Base.Index, offsetBy n: Base.IndexDistance, limitedBy limit: Base.Index) -> Base.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the `BidirectionalCollection`
    ///   protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Base.Index, to end: Base.Index) -> Base.IndexDistance

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)
}

/// A string type designed to represent text that is known at compile time.
///
/// Instances of the `StaticString` type are immutable. `StaticString` provides
/// limited, pointer-based access to its contents, unlike Swift's more
/// commonly used `String` type. A static string can store its value as a
/// pointer to an ASCII code unit sequence, as a pointer to a UTF-8 code unit
/// sequence, or as a single Unicode scalar value.
public struct StaticString : UnicodeScalarLiteralConvertible, ExtendedGraphemeClusterLiteralConvertible, StringLiteralConvertible, CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A pointer to the beginning of the string's UTF-8 encoded representation.
    ///
    /// The static string must store a pointer to either ASCII or UTF-8 code
    /// units. Accessing this property when `hasPointerRepresentation` is
    /// `false` triggers a runtime error.
    public var utf8Start: UnsafePointer<UInt8> { get }

    /// The stored Unicode scalar value.
    ///
    /// The static string must store a single Unicode scalar value. Accessing
    /// this property when `hasPointerRepresentation` is `true` triggers a
    /// runtime error.
    public var unicodeScalar: UnicodeScalar { get }

    /// The length in bytes of the static string's ASCII or UTF-8 representation.
    ///
    /// - Warning: If the static string stores a single Unicode scalar value, the
    ///   value of `utf8CodeUnitCount` is unspecified.
    public var utf8CodeUnitCount: Int { get }

    /// A Boolean value indicating whether the static string stores a pointer to
    /// ASCII or UTF-8 code units.
    public var hasPointerRepresentation: Bool { get }

    /// A Boolean value that is `true` if the static string stores a pointer to
    /// ASCII code units.
    ///
    /// Use this property in conjunction with `hasPointerRepresentation` to
    /// determine whether a static string with pointer representation stores an
    /// ASCII or UTF-8 code unit sequence.
    ///
    /// - Warning: If the static string stores a single Unicode scalar value, the
    ///   value of `isASCII` is unspecified.
    public var isASCII: Bool { get }

    /// Invokes the given closure with a buffer containing the static string's
    /// UTF-8 code unit sequence.
    ///
    /// This method works regardless of whether the static string stores a
    /// pointer or a single Unicode scalar value.
    ///
    /// - Parameter body: A closure that takes a buffer pointer to the static
    ///   string's UTF-8 code unit sequence as its sole argument. If the closure
    ///   has a return value, it is used as the return value of the
    ///   `withUTF8Buffer(invoke:)` method.
    /// - Returns: The return value of the `body` closure, if any.
    public func withUTF8Buffer<R>(invoke body: @noescape (UnsafeBufferPointer<UInt8>) -> R) -> R

    /// Creates an empty static string.
    public init()

    public init(_builtinUnicodeScalarLiteral value: Builtin.Int32)

    /// Creates an instance initialized to a single Unicode scalar.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you initialize a static string with a Unicode scalar.
    public init(unicodeScalarLiteral value: StaticString)

    public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1)

    /// Creates an instance initialized to a single character that is made up of
    /// one or more Unicode code points.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you initialize a static string using an extended grapheme cluster.
    public init(extendedGraphemeClusterLiteral value: StaticString)

    public init(_builtinStringLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1)

    /// Creates an instance initialized to the value of a string literal.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you initialize a static string using a string literal.
    public init(stringLiteral value: StaticString)

    /// A string representation of the static string.
    public var description: String { get }

    /// A textual representation of the static string, suitable for debugging.
    public var debugDescription: String { get }
}

extension StaticString {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension StaticString {
}

/// A source of text-streaming operations.
///
/// Instances of types that conform to the `Streamable` protocol can write
/// their value to instances of any type that conforms to the `OutputStream`
/// protocol. The Swift standard library's text-related types, `String`,
/// `Character`, and `UnicodeScalar`, all conform to `Streamable`.
///
/// Conforming to the Streamable Protocol
/// =====================================
///
/// To add `Streamable` conformance to a custom type, implement the required
/// `write(to:)` method. Call the given output stream's `write(_:)` method in
/// your implementation.
public protocol Streamable {

    /// Writes a textual representation of this instance into the given output
    /// stream.
    public func write<Target : OutputStream>(to target: inout Target)
}

/// A `Sequence` of values formed by striding over a closed interval.
public struct StrideThrough<Element : Strideable> : Sequence, CustomReflectable {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> StrideThroughIterator<Element>

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// An `IteratorProtocol` for `StrideThrough<Element>`.
public struct StrideThroughIterator<Element : Strideable> : IteratorProtocol {

    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    public mutating func next() -> Element?
}

/// A `Sequence` of values formed by striding over a half-open interval.
public struct StrideTo<Element : Strideable> : Sequence, CustomReflectable {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> StrideToIterator<Element>

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// An iterator for the result of `stride(from:to:)`.
public struct StrideToIterator<Element : Strideable> : IteratorProtocol {

    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    public mutating func next() -> Element?
}

/// Conforming types are notionally continuous, one-dimensional
/// values that can be offset and measured.
public protocol Strideable : Comparable {

    /// A type that can represent the distance between two values of `Self`.
    associatedtype Stride : SignedNumber

    /// Returns a stride `x` such that `self.advanced(by: x)` approximates
    /// `other`.
    ///
    /// If `Stride` conforms to `Integer`, then `self.advanced(by: x) == other`.
    ///
    /// - Complexity: O(1).
    public func distance(to other: Self) -> Self.Stride

    /// Returns a `Self` `x` such that `self.distance(to: x)` approximates `n`.
    ///
    /// If `Stride` conforms to `Integer`, then `self.distance(to: x) == n`.
    ///
    /// - Complexity: O(1).
    public func advanced(by n: Self.Stride) -> Self
}

/// A Unicode string value.
///
/// A string is a series of characters, such as `"Swift"`. Strings in Swift are
/// Unicode correct, locale insensitive, and designed to be efficient. The
/// `String` type bridges with the Objective-C class `NSString` and offers
/// interoperability with C functions that works with strings.
///
/// You can create new strings using string literals or string interpolations.
/// A string literal is a series of characters enclosed in quotes.
///
///     let greeting = "Welcome!"
///
/// String interpolations are string literals that evaluate any included
/// expressions and convert the results to string form. String interpolations
/// are an easy way to build a string from multiple pieces. Wrap each
/// expression in a string interpolation in parentheses, prefixed by a
/// backslash.
///
///     let name = "Rosa"
///     let personalizedGreeting = "Welcome, \(name)!"
///
///     let price = 2
///     let number = 3
///     let cookiePrice = "\(number) cookies: $\(price * number)."
///
/// Combine strings using the concatenation operator (`+`).
///
///     let longerGreeting = greeting + " We're glad you're here!"
///     print(longerGreeting)
///     // Prints "Welcome! We're glad you're here!"
///
/// Modifying and Comparing Strings
/// ===============================
///
/// Strings always have value semantics. Modifying a copy of a string leaves
/// the original unaffected.
///
///     var otherGreeting = greeting
///     otherGreeting += " Have a nice time!"
///     print(otherGreeting)
///     // Prints "Welcome! Have a nice time!"
///
///     print(greeting)
///     // Prints "Welcome!"
///
/// Comparing strings for equality using the is-equal-to operator (`==`) or a
/// relational operator (like `<` and `>=`) is always performed using the
/// Unicode canonical representation. This means that different
/// representations of a string compare as being equal.
///
///     let cafe1 = "Cafe\u{301}"
///     let cafe2 = "Caf"
///     print(cafe1 == cafe2)
///     // Prints "true"
///
/// The Unicode code point `"\u{301}"` modifies the preceding character to
/// include an accent, so `"e\u{301}"` has the same canonical representation
/// as the single Unicode code point `""`.
///
/// Basic string operations are not sensitive to locale settings. This ensures
/// that string comparisons and other operations always have a single, stable
/// result, allowing strings to be used as keys in `Dictionary` instances and
/// for other purposes.
///
/// Representing Strings: Views
/// ===========================
///
/// A string is not itself a collection. Instead, it has properties that
/// present its contents as meaningful collections. Each of these collections
/// is a particular type of *view* of the string's visible and data
/// representation.
///
/// To demonstrate the different views available for every string, the
/// following examples use this `String` instance:
///
///     let cafe = "Cafe\u{301} du "
///     print(cafe)
///     // Prints "Caf du "
///
/// Character View
/// --------------
///
/// A string's `characters` property is a collection of *extended grapheme
/// clusters*, which approximate human-readable characters. Many individual
/// characters, such as "", "", and "", can be made up of multiple Unicode
/// code points. These code points are combined by Unicode's boundary
/// algorithms into extended grapheme clusters, represented by Swift's
/// `Character` type. Each element of the `characters` view is represented by
/// a `Character` instance.
///
///     print(cafe.characters.count)
///     // Prints "9"
///     print(Array(cafe.characters))
///     // Prints "["C", "a", "f", "", " ", "d", "u", " ", ""]"
///
/// Each visible character in the `cafe` string is a separate element of the
/// `characters` view.
///
/// Unicode Scalar View
/// -------------------
///
/// A string's `unicodeScalars` property is a collection of Unicode scalar
/// values, the 21-bit codes that are the basic unit of Unicode. Each scalar
/// value is represented by a `UnicodeScalar` instance and is equivalent to a
/// UTF-32 code unit.
///
///     print(cafe.unicodeScalars.count)
///     // Prints "10"
///     print(Array(cafe.unicodeScalars))
///     // Prints "["C", "a", "f", "e", "\u{0301}", " ", "d", "u", " ", "\u{0001F30D}"]"
///     print(cafe.unicodeScalars.map { $0.value })
///     // Prints "[67, 97, 102, 101, 769, 32, 100, 117, 32, 127757]"
///
/// The `unicodeScalars` view's elements comprise each Unicode scalar value in
/// the `cafe` string. In particular, because `cafe` was declared using the
/// decomposed form of the `""` character, `unicodeScalars` contains the code
/// points for both the letter `"e"` (101) and the accent character `""`
/// (769).
///
/// UTF-16 View
/// -----------
///
/// A string's `utf16` property is a collection of UTF-16 code units, the
/// 16-bit encoding form of the string's Unicode scalar values. Each code unit
/// is stored as a `UInt16` instance.
///
///     print(cafe.utf16.count)
///     // Prints "11"
///     print(Array(cafe.utf16))
///     // Prints "[67, 97, 102, 101, 769, 32, 100, 117, 32, 55356, 57101]"
///
/// The elements of the `utf16` view are the code units for the string when
/// encoded in UTF-16.
///
/// The elements of this collection match those accessed through indexed
/// `NSString` APIs.
///
///     let nscafe = cafe as NSString
///     print(nscafe.length)
///     // Prints "11"
///     print(nscafe.character(at: 3))
///     // Prints "101"
///
/// UTF-8 View
/// ----------
///
/// A string's `utf8` property is a collection of UTF-8 code units, the 8-bit
/// encoding form of the string's Unicode scalar values. Each code unit is
/// stored as a `UInt8` instance.
///
///     print(cafe.utf8.count)
///     // Prints "14"
///     print(Array(cafe.utf8))
///     // Prints "[67, 97, 102, 101, 204, 129, 32, 100, 117, 32, 240, 159, 140, 141]"
///
/// The elements of the `utf8` view are the code units for the string when
/// encoded in UTF-8. This representation matches the one used when `String`
/// instances are passed to C APIs.
///
///     let cLength = strlen(cafe)
///     print(cLength)
///     // Prints "14"
///
/// Counting the Length of a String
/// ===============================
///
/// When you need to know the length of a string, you must first consider what
/// you'll use the length for. Are you measuring the number of characters that
/// will be displayed on the screen, or are you measuring the amount of
/// storage needed for the string in a particular encoding? A single string
/// can have greatly differing lengths when measured by its different views.
///
/// For example, an ASCII character like the capital letter *A* is represented
/// by a single element in each of its four views. The Unicode scalar value of
/// *A* is `65`, which is small enough to fit in a single code unit in both
/// UTF-16 and UTF-8.
///
///     let capitalA = "A"
///     print(capitalA.characters.count)
///     // Prints "1"
///     print(capitalA.unicodeScalars.count)
///     // Prints "1"
///     print(capitalA.utf16.count)
///     // Prints "1"
///     print(capitalA.utf8.count)
///     // Prints "1"
///
///
/// On the other hand, an emoji flag character is constructed from a pair of
/// Unicode scalars values, like `"\u{1F1F5}"` and `"\u{1F1F7}"`. Each of
/// these scalar values, in turn, is too large to fit into a single UTF-16 or
/// UTF-8 code unit. As a result, each view of the string `""` reports a
/// different length.
///
///     let flag = ""
///     print(flag.characters.count)
///     // Prints "1"
///     print(flag.unicodeScalars.count)
///     // Prints "2"
///     print(flag.utf16.count)
///     // Prints "4"
///     print(flag.utf8.count)
///     // Prints "8"
///
/// Accessing String View Elements
/// ==============================
///
/// To find individual elements of a string, use the appropriate view for your
/// task. For example, to retrieve the first word of a longer string, you can
/// search the `characters` view for a space and then create a new string from
/// a prefix of the `characters` view up to that point.
///
///     let name = "Marie Curie"
///     let firstSpace = name.characters.index(of: " ")!
///     let firstName = String(name.characters.prefix(upTo: firstSpace))
///     print(firstName)
///     // Prints "Marie"
///
/// You can convert an index into one of a string's views to an index into
/// another view.
///
///     let firstSpaceUTF8 = firstSpace.samePosition(in: name.utf8)
///     print(Array(name.utf8.prefix(upTo: firstSpaceUTF8)))
///     // Prints "[77, 97, 114, 105, 101]"
///
/// Performance Optimizations
/// =========================
///
/// Although strings in Swift have value semantics, strings use a copy-on-write
/// strategy to store their data in a buffer. This buffer can then be shared
/// by different copies of a string. A string's data is only copied lazily,
/// upon mutation, when more than one string instance is using the same
/// buffer. Therefore, the first in any sequence of mutating operations may
/// cost O(*n*) time and space.
///
/// When a string's contiguous storage fills up, a new buffer must be allocated
/// and data must be moved to the new storage. String buffers use an
/// exponential growth strategy that makes appending to a string a constant
/// time operation when averaged over many append operations.
///
/// Bridging between String and NSString
/// ====================================
///
/// Any `String` instance can be bridged to `NSString` using the type-cast
/// operator (`as`), and any `String` instance that originates in Objective-C
/// may use an `NSString` instance as its storage. Because any arbitrary
/// subclass of `NSString` can become a `String` instance, there are no
/// guarantees about representation or efficiency when a `String` instance is
/// backed by `NSString` storage. Because `NSString` is immutable, it is just
/// as though the storage was shared by a copy: The first in any sequence of
/// mutating operations causes elements to be copied into unique, contiguous
/// storage which may cost O(*n*) time and space, where *n* is the length of
/// the string's encoded representation (or more, if the underlying `NSString`
/// has unusual performance characteristics).
///
/// For more information about the Unicode terms used in this discussion, see
/// the [Unicode.org glossary][glossary]. In particular, this discussion
/// mentions [extended grapheme clusters][clusters],
/// [Unicode scalar values][scalars], and [canonical equivalence][equivalence].
///
/// [glossary]: http://www.unicode.org/glossary/
/// [clusters]: http://www.unicode.org/glossary/#extended_grapheme_cluster
/// [scalars]: http://www.unicode.org/glossary/#unicode_scalar_value
/// [equivalence]: http://www.unicode.org/glossary/#canonical_equivalent
///
/// - SeeAlso: `String.CharacterView`, `String.UnicodeScalarView`,
///   `String.UTF16View`, `String.UTF8View`
public struct String {

    /// Creates an empty string.
    public init()
}

extension String {

    /// The index type for subscripting a string.
    public typealias Index = String.CharacterView.Index

    /// A type used to represent the number of steps between two `String.Index`
    /// values, where one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = IndexDistance

    /// The position of the first character in a nonempty string.
    ///
    /// In an empty string, `startIndex` is equal to `endIndex`.
    public var startIndex: Index { get }

    /// A string's "past the end" position---that is, the position one greater
    /// than the last valid subscript argument.
    ///
    /// In an empty string, `endIndex` is equal to `startIndex`.
    public var endIndex: Index { get }

    public func index(after i: Index) -> Index

    public func index(before i: Index) -> Index

    public func index(_ i: Index, offsetBy n: IndexDistance) -> Index

    public func index(_ i: Index, offsetBy n: IndexDistance, limitedBy limit: Index) -> Index?

    public func distance(from start: Index, to end: Index) -> IndexDistance

    /// Accesses the character at the given position.
    ///
    /// Indices for a subscripting a string are shared with the string's
    /// `characters` view. For example:
    ///
    ///     let greeting = "Hello, friend!"
    ///     if let i = greeting.characters.index(where: { $0 >= "A" && $0 <= "Z" }) {
    ///         print("First capital letter: \(greeting[i])")
    ///     }
    ///     // Prints "First capital letter: H"
    ///
    /// - Parameter i: A valid index of the string. `i` must be less than the
    ///   string's end index.
    public subscript(i: Index) -> Character { get }

    /// Accesses the text in the given range.
    ///
    /// - Complexity: O(*n*) if the underlying string is bridged from
    ///   Objective-C, where *n* is the length of the string; otherwise, O(1).
    public subscript(bounds: Range<Index>) -> String { get }
}

extension String {

    /// A view of a string's contents as a collection of characters.
    ///
    /// In Swift, every string provides a view of its contents as characters. In
    /// this view, many individual characters---for example, "", "", and
    /// ""---can be made up of multiple Unicode code points. These code points
    /// are combined by Unicode's boundary algorithms into *extended grapheme
    /// clusters*, represented by the `Character` type. Each element of a
    /// `CharacterView` collection is a `Character` instance.
    ///
    ///     let flowers = "Flowers "
    ///     for c in flowers {
    ///         print(c)
    ///     }
    ///     // F
    ///     // l
    ///     // o
    ///     // w
    ///     // e
    ///     // r
    ///     // s
    ///     //
    ///     // 
    ///
    /// You can convert a `String.CharacterView` instance back into a string
    /// using the `String` type's `init(_:)` initializer.
    ///
    ///     let name = "Marie Curie"
    ///     if let firstSpace = name.characters.index(of: " ") {
    ///         let firstName = String(name.characters.prefix(upTo: firstSpace))
    ///         print(firstName)
    ///     }
    ///     // Prints "Marie"
    public struct CharacterView {

        /// Creates a view of the given string.
        public init(_ text: String)
    }

    /// A view of the string's contents as a collection of characters.
    public var characters: String.CharacterView

    /// Applies the given closure to a mutable view of the string's characters.
    ///
    /// Do not use the string that is the target of this method inside the
    /// closure passed to `body`, as it may not have its correct value. 
    /// Instead, use the closure's `String.CharacterView` argument.
    ///
    /// This example below uses the `withMutableCharacters(_:)` method to truncate
    /// the string `str` at the first space and to return the remainder of the
    /// string.
    ///
    ///     var str = "All this happened, more or less."
    ///     let afterSpace = str.withMutableCharacters { chars -> String.CharacterView in
    ///         if let i = chars.index(of: " ") {
    ///             let result = chars.suffix(from: chars.index(after: i))
    ///             chars.removeSubrange(i..<chars.endIndex)
    ///             return result
    ///         }
    ///         return String.CharacterView()
    ///     }
    ///
    ///     print(str)
    ///     // Prints "All"
    ///     print(String(afterSpace))
    ///     // Prints "this happened, more or less."
    ///
    /// - Parameter body: A closure that takes a character view as its argument.
    /// - Returns: The return value of the `body` closure, if any, is the return
    ///   value of this method.
    public mutating func withMutableCharacters<R>(_ body: (inout String.CharacterView) -> R) -> R

    /// Creates a string from the given character view.
    ///
    /// Use this initializer to recover a string after performing a collection
    /// slicing operation on a character view.
    ///
    ///     let poem = "'Twas brillig, and the slithy toves / " +
    ///                "Did gyre and gimbal in the wabe: / " +
    ///                "All mimsy were the borogoves / " +
    ///                "And the mome raths outgrabe."
    ///     let excerpt = String(poem.characters.prefix(22)) + "..."
    ///     print(excerpt)
    ///     // Prints "'Twas brillig, and the..."
    ///
    /// - Parameter characters: A character view to convert to a string.
    public init(_ characters: String.CharacterView)
}

extension String {

    /// A view of a string's contents as a collection of Unicode scalar values.
    ///
    /// You can access a string's view of Unicode scalar values by using its
    /// `unicodeScalars` property. Unicode scalar values are the 21-bit codes
    /// that are the basic unit of Unicode. Each scalar value is represented by
    /// a `UnicodeScalar` instance and is equivalent to a UTF-32 code unit.
    ///
    ///     let flowers = "Flowers "
    ///     for v in flowers.unicodeScalars {
    ///         print(v.value)
    ///     }
    ///     // 70
    ///     // 108
    ///     // 111
    ///     // 119
    ///     // 101
    ///     // 114
    ///     // 115
    ///     // 32
    ///     // 128144
    ///
    /// Some characters that are visible in a string are made up of more than one
    /// Unicode scalar value. In that case, a string's `unicodeScalars` view
    /// contains more values than its `characters` view.
    ///
    ///     let flag = ""
    ///     for c in flag.characters {
    ///         print(c)
    ///     }
    ///     // 
    ///
    ///     for v in flag.unicodeScalars {
    ///         print(v.value)
    ///     }
    ///     // 127477
    ///     // 127479
    ///
    /// You can convert a `String.UnicodeScalarView` instance back into a string
    /// using the `String` type's `init(_:)` initializer.
    ///
    ///     let favemoji = "My favorite emoji is "
    ///     if let i = favemoji.unicodeScalars.index(where: { $0.value >= 128 }) {
    ///         let asciiPrefix = String(favemoji.unicodeScalars.prefix(upTo: i))
    ///         print(asciiPrefix)
    ///     }
    ///     // Prints "My favorite emoji is "
    public struct UnicodeScalarView : BidirectionalCollection, CustomStringConvertible, CustomDebugStringConvertible {

        /// A position in a string's `UnicodeScalars` view.
        ///
        /// You can convert between indices of the different string views by using
        /// conversion initializers and the `samePosition(in:)` method overloads.
        /// The following example finds the index of the solid heart pictograph in
        /// the string's character view and then converts that to the same
        /// position in the Unicode scalars view:
        ///
        ///     let hearts = "Hearts <3  "
        ///     let i = hearts.characters.index(of: "")!
        ///
        ///     let j = i.samePosition(in: hearts.unicodeScalars)
        ///     print(hearts.unicodeScalars.suffix(from: j))
        ///     // Prints " "
        ///     print(hearts.unicodeScalars[j].value)
        ///     // Prints "9829"
        public struct Index : Comparable {
        }

        /// The position of the first Unicode scalar value if the string is
        /// nonempty.
        ///
        /// If the string is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: String.UnicodeScalarView.Index { get }

        /// The "past the end" position---that is, the position one greater than
        /// the last valid subscript argument.
        ///
        /// In an empty Unicode scalars view, `endIndex` is equal to `startIndex`.
        public var endIndex: String.UnicodeScalarView.Index { get }

        /// Returns the next consecutive location after `i`.
        ///
        /// - Precondition: The next location exists.
        public func index(after i: String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index

        /// Returns the previous consecutive location before `i`.
        ///
        /// - Precondition: The previous location exists.
        public func index(before i: String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index

        /// Accesses the Unicode scalar value at the given position.
        ///
        /// The following example searches a string's Unicode scalars view for a
        /// capital letter and then prints the character and Unicode scalar value
        /// at the found index:
        ///
        ///     let greeting = "Hello, friend!"
        ///     if let i = greeting.unicodeScalars.index(where: { "A"..."Z" ~= $0 }) {
        ///         print("First capital letter: \(greeting.unicodeScalars[i])")
        ///         print("Unicode scalar value: \(greeting.unicodeScalars[i].value)")
        ///     }
        ///     // Prints "First capital letter: H"
        ///     // Prints "Unicode scalar value: 72"
        ///
        /// - Parameter position: A valid index of the character view. `position`
        ///   must be less than the view's end index.
        public subscript(position: String.UnicodeScalarView.Index) -> UnicodeScalar { get }

        /// Accesses the Unicode scalar values in the given range.
        ///
        /// The example below uses this subscript to access the scalar values up
        /// to, but not including, the first comma (`","`) in the string.
        ///
        ///     let str = "All this happened, more or less."
        ///     let i = str.unicodeScalars.index(of: ",")!
        ///     let substring = str.unicodeScalars[str.unicodeScalars.startIndex ..< i]
        ///     print(String(substring))
        ///     // Prints "All this happened"
        ///
        /// - Complexity: O(*n*) if the underlying string is bridged from
        ///   Objective-C, where *n* is the length of the string; otherwise, O(1).
        public subscript(r: Range<String.UnicodeScalarView.Index>) -> String.UnicodeScalarView { get }

        /// An iterator over the Unicode scalars that make up a `UnicodeScalarView`
        /// collection.
        public struct Iterator : IteratorProtocol {

            /// Advances to the next element and returns it.
            ///
            /// Do not call this method if a copy of the iterator has been advanced.
            ///
            /// - Returns: The next element in the collection if an element is
            ///   available; otherwise, `nil`. After returning `nil` once, this
            ///   method returns `nil` on every subsequent call.
            public mutating func next() -> UnicodeScalar?
        }

        /// Returns an iterator over the Unicode scalars that make up this view.
        ///
        /// - Returns: An iterator over this collection's `UnicodeScalar` elements.
        public func makeIterator() -> String.UnicodeScalarView.Iterator

        /// A textual representation of this instance.
        ///
        /// Instead of accessing this property directly, convert an instance of any
        /// type to a string by using the `String(_:)` initializer. For example:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// A textual representation of this instance, suitable for debugging.
        public var debugDescription: String { get }
    }

    /// Creates a string corresponding to the given collection of Unicode
    /// scalars.
    ///
    /// You can use this initializer to create a new string from a slice of
    /// another string's `unicodeScalars` view.
    ///
    ///     let picnicGuest = "Deserving porcupine"
    ///     if let i = picnicGuest.unicodeScalars.index(of: " ") {
    ///         let adjective = String(picnicGuest.unicodeScalars.prefix(upTo: i))
    ///         print(adjective)
    ///     }
    ///     // Prints "Deserving"
    ///
    /// The `adjective` constant is created by calling this initializer with a
    /// slice of the `picnicGuest.unicodeScalars` view.
    ///
    /// - Parameter unicodeScalars: A collection of Unicode scalar values.
    public init(_ unicodeScalars: String.UnicodeScalarView)

    /// The index type for a string's `unicodeScalars` view.
    public typealias UnicodeScalarIndex = String.UnicodeScalarView.Index
}

extension String {

    /// A view of a string's contents as a collection of UTF-16 code units.
    ///
    /// You can access a string's view of UTF-16 code units by using its `utf16`
    /// property. A string's UTF-16 view encodes the string's Unicode scalar
    /// values as 16-bit integers.
    ///
    ///     let flowers = "Flowers "
    ///     for v in flowers.utf16 {
    ///         print(v)
    ///     }
    ///     // 70
    ///     // 108
    ///     // 111
    ///     // 119
    ///     // 101
    ///     // 114
    ///     // 115
    ///     // 32
    ///     // 55357
    ///     // 56464
    ///
    /// Unicode scalar values that make up a string's contents can be up to 21
    /// bits long. The longer scalar values may need two `UInt16` values for
    /// storage. Those "pairs" of code units are called *surrogate pairs*.
    ///
    ///     let flowermoji = ""
    ///     for v in flowermoji.unicodeScalars {
    ///         print(v, v.value)
    ///     }
    ///     //  128144
    ///
    ///     for v in flowermoji.utf16 {
    ///         print(v)
    ///     }
    ///     // 55357
    ///     // 56464
    ///
    /// To convert a `String.UTF16View` instance back into a string, use the
    /// `String` type's `init(_:)` initializer.
    ///
    ///     let favemoji = "My favorite emoji is "
    ///     if let i = favemoji.utf16.index(where: { $0 >= 128 }) {
    ///         let asciiPrefix = String(favemoji.utf16.prefix(upTo: i))
    ///         print(asciiPrefix)
    ///     }
    ///     // Prints "My favorite emoji is "
    ///
    /// UTF16View Elements Match NSString Characters
    /// ============================================
    ///
    /// The UTF-16 code units of a string's `utf16` view match the elements
    /// accessed through indexed `NSString` APIs.
    ///
    ///     print(flowers.utf16.count)
    ///     // Prints "10"
    ///
    ///     let nsflowers = flowers as NSString
    ///     print(nsflowers.length)
    ///     // Prints "10"
    ///
    /// Unlike `NSString`, however, `String.UTF16View` does not use integer
    /// indices. If you need to access a specific position in a UTF-16 view, use
    /// Swift's index manipulation methods. The following example accesses the
    /// fourth code unit in both the `flowers` and `nsflowers` strings:
    ///
    ///     print(nsflowers.character(at: 3))
    ///     // Prints "119"
    ///
    ///     let i = flowers.utf16.index(flowers.utf16.startIndex, offsetBy: 3)
    ///     print(flowers.utf16[i])
    ///     // Prints "119"
    ///
    /// Although the Swift overlay updates many Objective-C methods to return
    /// native Swift indices and index ranges, some still return instances of
    /// `NSRange`. To convert an `NSRange` instance to a range of
    /// `String.UTF16View.Index`, follow these steps:
    ///
    /// 1. Use the `NSRange` type's `toRange` method to convert the instance to
    ///    an optional range of `Int` values.
    /// 2. Use your string's `utf16` view's index manipulation methods to convert
    ///    the integer bounds to `String.UTF16View.Index` values.
    /// 3. Create a new `Range` instance from the new index values.
    ///
    /// Here's an implementation of those steps, showing how to retrieve a
    /// substring described by an `NSRange` instance from the middle of a
    /// string.
    ///
    ///     let snowy = " Let it snow! "
    ///     let nsrange = NSRange(location: 3, length: 12)
    ///     if let r = nsrange.toRange() {
    ///         let start = snowy.utf16.index(snowy.utf16.startIndex, offsetBy: r.lowerBound)
    ///         let end = snowy.utf16.index(snowy.utf16.startIndex, offsetBy: r.upperBound)
    ///         let substringRange = start..<end
    ///         print(snowy.utf16[substringRange])
    ///     }
    ///     // Prints "Let it snow!"
    public struct UTF16View : BidirectionalCollection, CustomStringConvertible, CustomDebugStringConvertible {

        /// A position in a string's collection of UTF-16 code units.
        ///
        /// You can convert between indices of the different string views by using
        /// conversion initializers and the `samePosition(in:)` method overloads.
        /// For example, the following code sample finds the index of the first
        /// space in the string's character view and then converts that to the same
        /// position in the UTF-16 view.
        ///
        ///     let hearts = "Hearts <3  "
        ///     if let i = hearts.characters.index(of: " ") {
        ///         let j = i.samePosition(in: hearts.utf16)
        ///         print(Array(hearts.utf16.suffix(from: j)))
        ///         print(hearts.utf16.suffix(from: j))
        ///     }
        ///     // Prints "[32, 60, 51, 32, 9829, 65038, 32, 55357, 56472]"
        ///     // Prints " <3  "
        public struct Index : Comparable {
        }

        /// A type used to represent the number of steps between two indices, where
        /// one value is reachable from the other.
        ///
        /// In Swift, *reachability* refers to the ability to produce one value from
        /// the other through zero or more applications of `index(after:)`.
        public typealias IndexDistance = Int

        /// The position of the first code unit if the `String` is
        /// nonempty; identical to `endIndex` otherwise.
        public var startIndex: String.UTF16View.Index { get }

        /// The "past the end" position---that is, the position one greater than
        /// the last valid subscript argument.
        ///
        /// In an empty UTF-16 view, `endIndex` is equal to `startIndex`.
        public var endIndex: String.UTF16View.Index { get }

        /// A type that can represent the indices that are valid for subscripting the
        /// collection, in ascending order.
        public struct Indices {
        }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: String.UTF16View.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: String.UTF16View.Index) -> String.UTF16View.Index

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: String.UTF16View.Index) -> String.UTF16View.Index

        /// Returns an index that is the specified distance from the given index.
        ///
        /// The following example obtains an index advanced four positions from a
        /// string's starting index and then prints the character at that position.
        ///
        ///     let s = "Swift"
        ///     let i = s.index(s.startIndex, offsetBy: 4)
        ///     print(s[i])
        ///     // Prints "t"
        ///
        /// Advancing an index beyond a collection's ending index or offsetting it
        /// before a collection's starting index may trigger a runtime error. The
        /// value passed as `n` must not result in such an operation.
        ///
        /// - Parameters:
        ///   - i: A valid index of the collection.
        ///   - n: The distance to offset `i`. `n` must not be negative unless the
        ///     collection conforms to the `BidirectionalCollection` protocol.
        /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
        ///   this is the same value as the result of `n` calls to `index(after:)`.
        ///   If `n` is negative, this is the same value as the result of `-n` calls
        ///   to `index(before:)`.
        ///
        /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
        /// - Precondition:
        ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
        ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
        ///   value of `n`.
        public func index(_ i: String.UTF16View.Index, offsetBy n: IndexDistance) -> String.UTF16View.Index

        /// Returns an index that is the specified distance from the given index,
        /// unless that distance is beyond a given limiting index.
        ///
        /// The following example obtains an index advanced four positions from a
        /// string's starting index and then prints the character at that position. The
        /// operation doesn't require going beyond the limiting `s.endIndex` value,
        /// so it succeeds.
        ///
        ///     let s = "Swift"
        ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
        ///         print(s[i])
        ///     }
        ///     // Prints "t"
        ///
        /// The next example attempts to retrieve an index six positions from
        /// `s.startIndex` but fails, because that distance is beyond the index
        /// passed as `limit`.
        ///
        ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
        ///     print(j)
        ///     // Prints "nil"
        ///
        /// Advancing an index beyond a collection's ending index or offsetting it
        /// before a collection's starting index may trigger a runtime error. The
        /// value passed as `n` must not result in such an operation.
        ///
        /// - Parameters:
        ///   - i: A valid index of the collection.
        ///   - n: The distance to offset `i`. `n` must not be negative unless the
        ///     collection conforms to the `BidirectionalCollection` protocol.
        ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
        ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
        ///     `limit` has no effect if it is greater than `i`.
        /// - Returns: An index offset by `n` from the index `i`, unless that index
        ///   would be beyond `limit` in the direction of movement. In that case,
        ///   the method returns `nil`.
        ///
        /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
        /// - Precondition:
        ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
        ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
        ///   value of `n`.
        public func index(_ i: String.UTF16View.Index, offsetBy n: IndexDistance, limitedBy limit: String.UTF16View.Index) -> String.UTF16View.Index?

        /// Returns the distance between two indices.
        ///
        /// Unless the collection conforms to the `BidirectionalCollection` protocol,
        /// `start` must be less than or equal to `end`.
        ///
        /// - Parameters:
        ///   - start: A valid index of the collection.
        ///   - end: Another valid index of the collection. If `end` is equal to
        ///     `start`, the result is zero.
        /// - Returns: The distance between `start` and `end`. The result can be
        ///   negative only if the collection conforms to the
        ///   `BidirectionalCollection` protocol.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
        ///   resulting distance.
        public func distance(from start: String.UTF16View.Index, to end: String.UTF16View.Index) -> IndexDistance

        /// Accesses the code unit at the given position.
        ///
        /// The following example uses the subscript to print the value of a
        /// string's first UTF-16 code unit.
        ///
        ///     let greeting = "Hello, friend!"
        ///     let i = greeting.utf16.startIndex
        ///     print("First character's UTF-16 code unit: \(greeting.utf16[i])")
        ///     // Prints "First character's UTF-16 code unit: 72"
        ///
        /// - Parameter position: A valid index of the view. `position` must be
        ///   less than the view's end index.
        public subscript(i: String.UTF16View.Index) -> CodeUnit { get }

        /// Accesses the contiguous subrange of elements enclosed by the specified
        /// range.
        ///
        /// - Complexity: O(*n*) if the underlying string is bridged from
        ///   Objective-C, where *n* is the length of the string; otherwise, O(1).
        public subscript(bounds: Range<String.UTF16View.Index>) -> String.UTF16View { get }

        /// A textual representation of this instance.
        ///
        /// Instead of accessing this property directly, convert an instance of any
        /// type to a string by using the `String(_:)` initializer. For example:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// A textual representation of this instance, suitable for debugging.
        public var debugDescription: String { get }
    }

    /// A UTF-16 encoding of `self`.
    public var utf16: String.UTF16View

    /// Creates a string corresponding to the given sequence of UTF-8 code units.
    ///
    /// If `utf16` contains unpaired UTF-16 surrogates, the result is `nil`.
    ///
    /// You can use this initializer to create a new string from a slice of
    /// another string's `utf16` view.
    ///
    ///     let picnicGuest = "Deserving porcupine"
    ///     if let i = picnicGuest.utf16.index(of: 32) {
    ///         let adjective = String(picnicGuest.utf16.prefix(upTo: i))
    ///         print(adjective)
    ///     }
    ///     // Prints "Optional(Deserving)"
    ///
    /// The `adjective` constant is created by calling this initializer with a
    /// slice of the `picnicGuest.utf16` view.
    ///
    /// - Parameter utf16: A UTF-16 code sequence.
    public init?(_ utf16: String.UTF16View)

    /// The index type for subscripting a string's `utf16` view.
    public typealias UTF16Index = String.UTF16View.Index
}

extension String {

    /// A view of a string's contents as a collection of UTF-8 code units.
    ///
    /// You can access a string's view of UTF-8 code units by using its `utf8`
    /// property. A string's UTF-8 view encodes the string's Unicode scalar
    /// values as 8-bit integers.
    ///
    ///     let flowers = "Flowers "
    ///     for v in flowers.utf8 {
    ///         print(v)
    ///     }
    ///     // 70
    ///     // 108
    ///     // 111
    ///     // 119
    ///     // 101
    ///     // 114
    ///     // 115
    ///     // 32
    ///     // 240
    ///     // 159
    ///     // 146
    ///     // 144
    ///
    /// A string's Unicode scalar values can be up to 21 bits in length. To
    /// represent those scalar values using 8-bit integers, more than one UTF-8
    /// code unit is often required.
    ///
    ///     let flowermoji = ""
    ///     for v in flowermoji.unicodeScalars {
    ///         print(v, v.value)
    ///     }
    ///     //  128144
    ///
    ///     for v in flowermoji.utf8 {
    ///         print(v)
    ///     }
    ///     // 240
    ///     // 159
    ///     // 146
    ///     // 144
    ///
    /// In the encoded representation of a Unicode scalar value, each UTF-8 code
    /// unit after the first is called a *continuation byte*.
    ///
    /// UTF8View Elements Match Encoded C Strings
    /// =========================================
    ///
    /// Swift streamlines interoperation with C string APIs by letting you pass a
    /// `String` instance to a function as an `Int8` or `UInt8` pointer. When you
    /// call a C function using a `String`, Swift automatically creates a buffer
    /// of UTF-8 code units and passes a pointer to that buffer. The code units
    /// of that buffer match the code units in the string's `utf8` view.
    ///
    /// The following example uses the C `strncmp` function to compare the
    /// beginning of two Swift strings. The `strncmp` function takes two
    /// `const char*` pointers and an integer specifying the number of characters
    /// to compare. Because the strings are identical up to the 14th character,
    /// comparing only those characters results in a return value of `0`.
    ///
    ///     let s1 = "They call me 'Bell'"
    ///     let s2 = "They call me 'Stacey'"
    ///
    ///     print(strncmp(s1, s2, 14))
    ///     // Prints "0"
    ///     print(String(s1.utf8.prefix(14))
    ///     // Prints "They call me '"
    ///
    /// Extending the compared character count to 15 includes the differing
    /// characters, so a nonzero result is returned.
    ///
    ///     print(strncmp(s1, s2, 15))
    ///     // Prints "-17"
    ///     print(String(s1.utf8.prefix(14))
    ///     // Prints "They call me 'B"
    public struct UTF8View : Collection, CustomStringConvertible, CustomDebugStringConvertible {

        /// A position in a string's `UTF8View` instance.
        ///
        /// You can convert between indices of the different string views by using
        /// conversion initializers and the `samePosition(in:)` method overloads.
        /// For example, the following code sample finds the index of the first
        /// space in the string's character view and then converts that to the same
        /// position in the UTF-8 view.
        ///
        ///     let hearts = "Hearts <3  "
        ///     if let i = hearts.characters.index(of: " ") {
        ///         let j = i.samePosition(in: hearts.utf8)
        ///         print(Array(hearts.utf8.prefix(upTo: j)))
        ///         print(hearts.utf8.prefix(upTo: j))
        ///     }
        ///     // Prints "[72, 101, 97, 114, 116, 115]"
        ///     // Prints "Hearts"
        public struct Index : Comparable {
        }

        /// A type that can represent the number of steps between a pair of
        /// indices.
        public typealias IndexDistance = Int

        /// The position of the first code unit if the UTF-8 view is
        /// nonempty.
        ///
        /// If the UTF-8 view is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: String.UTF8View.Index { get }

        /// The "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// In an empty UTF-8 view, `endIndex` is equal to `startIndex`.
        public var endIndex: String.UTF8View.Index { get }

        /// Returns the next consecutive position after `i`.
        ///
        /// - Precondition: The next position is representable.
        public func index(after i: String.UTF8View.Index) -> String.UTF8View.Index

        /// Accesses the code unit at the given position.
        ///
        /// The following example uses the subscript to print the value of a
        /// string's first UTF-8 code unit.
        ///
        ///     let greeting = "Hello, friend!"
        ///     let i = greeting.utf8.startIndex
        ///     print("First character's UTF-8 code unit: \(greeting.utf8[i])")
        ///     // Prints "First character's UTF-8 code unit: 72"
        ///
        /// - Parameter position: A valid index of the view. `position`
        ///   must be less than the view's end index.
        public subscript(position: String.UTF8View.Index) -> CodeUnit { get }

        /// Accesses the contiguous subrange of elements enclosed by the specified
        /// range.
        ///
        /// - Complexity: O(*n*) if the underlying string is bridged from
        ///   Objective-C, where *n* is the length of the string; otherwise, O(1).
        public subscript(bounds: Range<String.UTF8View.Index>) -> String.UTF8View { get }

        /// A textual representation of this instance.
        ///
        /// Instead of accessing this property directly, convert an instance of any
        /// type to a string by using the `String(_:)` initializer. For example:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// A textual representation of this instance, suitable for debugging.
        public var debugDescription: String { get }
    }

    /// A UTF-8 encoding of `self`.
    public var utf8: String.UTF8View

    /// A contiguously stored null-terminated UTF-8 representation of
    /// the string.
    ///
    /// To access the underlying memory, invoke
    /// `withUnsafeBufferPointer` on the array.
    ///
    ///     let s = "Hello!"
    ///     let bytes = s.nulTerminatedUTF8
    ///     print(bytes)
    ///     // Prints "[72, 101, 108, 108, 111, 33, 0]"
    ///     
    ///     bytes.withUnsafeBufferPointer { ptr in
    ///         print(strlen(UnsafePointer(ptr.baseAddress!)))
    ///     }
    ///     // Prints "6"
    public var nulTerminatedUTF8: ContiguousArray<CodeUnit> { get }

    /// Creates a string corresponding to the given sequence of UTF-8 code units.
    ///
    /// If `utf8` is an ill-formed UTF-8 code sequence, the result is `nil`.
    ///
    /// You can use this initializer to create a new string from a slice of
    /// another string's `utf8` view.
    ///
    ///     let picnicGuest = "Deserving porcupine"
    ///     if let i = picnicGuest.utf8.index(of: 32) {
    ///         let adjective = String(picnicGuest.utf8.prefix(upTo: i))
    ///         print(adjective)
    ///     }
    ///     // Prints "Optional(Deserving)"
    ///
    /// The `adjective` constant is created by calling this initializer with a
    /// slice of the `picnicGuest.utf8` view.
    ///
    /// - Parameter utf8: A UTF-8 code sequence.
    public init?(_ utf8: String.UTF8View)

    /// The index type for subscripting a string's `utf8` view.
    public typealias UTF8Index = String.UTF8View.Index
}

extension String {

    /// Creates a string containing the given character.
    ///
    /// - Parameter c: The character to convert to a string.
    public init(_ c: Character)
}

extension String {

    /// Creates a new string by copying the null-terminated UTF-8 data referenced
    /// by the given pointer.
    ///
    /// If `cString` contains ill-formed UTF-8 code unit sequences, this
    /// initializer replaces them with the Unicode replacement character
    /// (`"\u{FFFD}"`).
    ///
    /// The following example calls this initializer with pointers to the
    /// contents of two different `CChar` arrays---the first with well-formed
    /// UTF-8 code unit sequences and the second with an ill-formed sequence at
    /// the end.
    ///
    ///     let validUTF8: [CChar] = [67, 97, 102, -61, -87, 0]
    ///     validUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(cString: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "Caf"
    ///
    ///     let invalidUTF8: [CChar] = [67, 97, 102, -61, 0]
    ///     invalidUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(cString: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "Caf"
    ///
    /// - Parameter cString: A pointer to a null-terminated UTF-8 code sequence.
    public init(cString: UnsafePointer<CChar>)

    /// Creates a new string by copying and validating the null-terminated UTF-8
    /// data referenced by the given pointer.
    ///
    /// This initializer does not try to repair ill-formed UTF-8 code unit
    /// sequences. If any are found, the result of the initializer is `nil`.
    ///
    /// The following example calls this initializer with pointers to the
    /// contents of two different `CChar` arrays---the first with well-formed
    /// UTF-8 code unit sequences and the second with an ill-formed sequence at
    /// the end.
    ///
    ///     let validUTF8: [CChar] = [67, 97, 102, -61, -87, 0]
    ///     validUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(validatingUTF8: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "Optional(Caf)"
    ///
    ///     let invalidUTF8: [CChar] = [67, 97, 102, -61, 0]
    ///     invalidUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(validatingUTF8: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "nil"
    ///
    /// - Parameter cString: A pointer to a null-terminated UTF-8 code sequence.
    public init?(validatingUTF8 cString: UnsafePointer<CChar>)

    /// Creates a new string by copying the null-terminated data referenced by
    /// the given pointer using the specified encoding.
    ///
    /// When you pass `true` as `isRepairing`, this method replaces ill-formed
    /// sequences with the Unicode replacement character (`"\u{FFFD}"`);
    /// otherwise, an ill-formed sequence causes this method to stop decoding
    /// and return `nil`.
    ///
    /// The following example calls this method with pointers to the contents of
    /// two different `CChar` arrays---the first with well-formed UTF-8 code
    /// unit sequences and the second with an ill-formed sequence at the end.
    ///
    ///     let validUTF8: [UInt8] = [67, 97, 102, 195, 169, 0]
    ///     validUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String.decodeCString(ptr.baseAddress,
    ///                                      as: UTF8.self,
    ///                                      repairingInvalidCodeUnits: true)
    ///         print(s)
    ///     }
    ///     // Prints "Optional((Caf, false))"
    ///
    ///     let invalidUTF8: [UInt8] = [67, 97, 102, 195, 0]
    ///     invalidUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String.decodeCString(ptr.baseAddress,
    ///                                      as: UTF8.self,
    ///                                      repairingInvalidCodeUnits: true)
    ///         print(s)
    ///     }
    ///     // Prints "Optional((Caf, true))"
    ///
    /// - Parameters:
    ///   - cString: A pointer to a null-terminated code sequence encoded in
    ///     `encoding`.
    ///   - encoding: The Unicode encoding of the data referenced by `cString`.
    ///   - isRepairing: Pass `true` to create a new string, even when the data
    ///     referenced by `cString` contains ill-formed sequences. Ill-formed
    ///     sequences are replaced with the Unicode replacement character
    ///     (`"\u{FFFD}"`). Pass `false` to interrupt the creation of the new
    ///     string if an ill-formed sequence is detected.
    /// - Returns: A tuple with the new string and a Boolean value that indicates
    ///   whether any repairs were made. If `isRepairing` is `false` and an
    ///   ill-formed sequence is detected, this method returns `nil`.
    ///
    /// - SeeAlso: `UnicodeCodec`
    public static func decodeCString<Encoding : UnicodeCodec>(_ cString: UnsafePointer<Encoding.CodeUnit>?, as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Bool = default) -> (result: String, repairsMade: Bool)?
}

extension String {

    /// Invokes the given closure on the contents of the string, represented as a
    /// pointer to a null-terminated sequence of UTF-8 code units.
    ///
    /// The `withCString(_:)` method ensures that the sequence's lifetime extends
    /// through the execution of `f`.
    ///
    /// - Parameter f: A closure that takes a pointer to the string's UTF-8 code
    ///   unit sequence as its sole argument. If the closure has a return value,
    ///   it is used as the return value of the `withCString(_:)` method.
    /// - Returns: The return value of the `f` closure, if any.
    public func withCString<Result>(_ f: @noescape (UnsafePointer<Int8>) throws -> Result) rethrows -> Result
}

extension String : CustomReflectable {

    /// A mirror that reflects the `String` instance.
    public var customMirror: Mirror { get }
}

extension String : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension String : OutputStream {

    /// Appends the given string to this string.
    /// 
    /// - Parameter other: A string to append.
    public mutating func write(_ other: String)
}

extension String : Streamable {

    /// Writes the string into the given output stream.
    /// 
    /// - Parameter target: An output stream.
    public func write<Target : OutputStream>(to target: inout Target)
}

extension String {

    public init(_builtinUnicodeScalarLiteral value: Builtin.Int32)
}

extension String : UnicodeScalarLiteralConvertible {

    /// Creates an instance initialized to the given Unicode scalar value.
    ///
    /// Don't call this initializer directly. It may be used by the compiler when
    /// you initialize a string using a string literal that contains a single
    /// Unicode scalar value.
    public init(unicodeScalarLiteral value: String)
}

extension String {

    public init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1)
}

extension String : ExtendedGraphemeClusterLiteralConvertible {

    /// Creates an instance initialized to the given extended grapheme cluster
    /// literal.
    ///
    /// Don't call this initializer directly. It may be used by the compiler when
    /// you initialize a string using a string literal containing a single
    /// extended grapheme cluster.
    public init(extendedGraphemeClusterLiteral value: String)
}

extension String {

    public init(_builtinUTF16StringLiteral start: Builtin.RawPointer, utf16CodeUnitCount: Builtin.Word)
}

extension String {

    public init(_builtinStringLiteral start: Builtin.RawPointer, utf8CodeUnitCount: Builtin.Word, isASCII: Builtin.Int1)
}

extension String : StringLiteralConvertible {

    /// Creates an instance initialized to the given string value.
    ///
    /// Don't call this initializer directly. It is used by the compiler when you
    /// initialize a string using a string literal. For example:
    ///
    ///     let nextStop = "Clark & Lake"
    ///
    /// This assignment to the `nextStop` constant calls this string literal
    /// initializer behind the scenes.
    public init(stringLiteral value: String)
}

extension String : CustomDebugStringConvertible {

    /// A representation of the string that is suitable for debugging.
    public var debugDescription: String { get }
}

extension String : Equatable {
}

extension String : Comparable {
}

extension String {

    /// Appends the given string to this string.
    ///
    /// The following example builds a customized greeting by using the
    /// `append(_:)` method:
    ///
    ///     var greeting = "Hello, "
    ///     if let name = getUserName() {
    ///         greeting.append(name)
    ///     } else {
    ///         greeting.append("friend")
    ///     }
    ///     print(greeting)
    ///     // Prints "Hello, friend"
    ///
    /// - Parameter other: Another string.
    public mutating func append(_ other: String)

    /// Appends the given Unicode scalar to the string.
    ///
    /// - Parameter x: A Unicode scalar value.
    ///
    /// - Complexity: Appending a Unicode scalar to a string averages to O(1)
    ///   over many additions.
    public mutating func append(_ x: UnicodeScalar)
}

extension String : Hashable {

    /// The string's hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }
}

extension String {

    /// Returns a lowercase version of the string.
    ///
    /// Here's an example of transforming a string to all lowercase letters.
    ///
    ///     let cafe = "Caf "
    ///     print(cafe.lowercased())
    ///     // Prints "caf "
    ///
    /// - Returns: A lowercase copy of the string.
    ///
    /// - Complexity: O(n)
    public func lowercased() -> String

    /// Returns an uppercase version of the string.
    ///
    /// The following example transforms a string to uppercase letters:
    ///
    ///     let cafe = "Caf "
    ///     print(cafe.uppercased())
    ///     // Prints "CAF "
    ///
    /// - Returns: An uppercase copy of the string.
    ///
    /// - Complexity: O(n)
    public func uppercased() -> String
}

extension String {
}

extension String : StringInterpolationConvertible {

    /// Creates a new string by concatenating the given interpolations.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you create a string using string interpolation. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (`\(`...`)`).
    ///
    ///     let price = 2
    ///     let number = 3
    ///     let message = "If one cookie costs \(price) dollars, " +
    ///                   "\(number) cookies cost \(price * number) dollars."
    ///     print(message)
    ///     // Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    public init(stringInterpolation strings: String...)

    /// Creates a string containing the given expression's textual
    /// representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init<T>(stringInterpolationSegment expr: T)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: String)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: Character)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: UnicodeScalar)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: Bool)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: Float32)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: Float64)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: UInt8)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: Int8)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: UInt16)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: Int16)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: UInt32)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: Int32)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: UInt64)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: Int64)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: UInt)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    ///
    /// - SeeAlso: `StringInterpolationConvertible`
    public init(stringInterpolationSegment expr: Int)
}

extension String {

    /// Creates a string representing the given character repeated the specified
    /// number of times.
    ///
    /// For example, use this initializer to create a string with ten `"0"`
    /// characters in a row.
    ///
    ///     let zeroes = String("0" as Character, count: 10)
    ///     print(zeroes)
    ///     // Prints "0000000000"
    public init(repeating repeatedValue: Character, count: Int)

    /// Creates a string representing the given Unicode scalar repeated the
    /// specified number of times.
    ///
    /// For example, use this initializer to create a string with ten `"0"`
    /// scalars in a row.
    ///
    ///     let zeroes = String("0" as UnicodeScalar, count: 10)
    ///     print(zeroes)
    ///     // Prints "0000000000"
    public init(repeating repeatedValue: UnicodeScalar, count: Int)

    /// A Boolean value indicating whether a string has no characters.
    public var isEmpty: Bool { get }
}

extension String {

    /// Returns a Boolean value indicating whether the string begins with the
    /// specified prefix.
    ///
    /// The comparison is both case sensitive and Unicode safe. The
    /// case-sensitive comparision will only match strings whose corresponding
    /// characters have the same case.
    ///
    ///     let cafe = "Caf du Monde"
    ///
    ///     // Case sensitive
    ///     print(cafe.hasPrefix("caf"))
    ///     // Prints "false"
    ///
    /// The Unicode-safe comparison matches Unicode scalar values rather than the
    /// code points used to compose them. The example below uses two strings
    /// with different forms of the `""` character---the first uses the composed
    /// form and the second uses the decomposed form.
    ///
    ///     // Unicode safe
    ///     let composedCafe = "Caf"
    ///     let decomposedCafe = "Cafe\u{0301}"
    ///
    ///     print(cafe.hasPrefix(composedCafe))
    ///     // Prints "true"
    ///     print(cafe.hasPrefix(decomposedCafe))
    ///     // Prints "true"
    ///
    /// - Parameter prefix: A possible prefix to test against this string.
    ///   Passing an empty string (`""`) as `prefix` always results in `false`.
    /// - Returns: `true` if the string begins with `prefix`, otherwise, `false`.
    public func hasPrefix(_ prefix: String) -> Bool

    /// Returns a Boolean value indicating whether the string ends with the
    /// specified suffix.
    ///
    /// The comparison is both case sensitive and Unicode safe. The
    /// case-sensitive comparision will only match strings whose corresponding
    /// characters have the same case.
    ///
    ///     let plans = "Let's meet at the caf"
    ///
    ///     // Case sensitive
    ///     print(plans.hasSuffix("Caf"))
    ///     // Prints "false"
    ///
    /// The Unicode-safe comparison matches Unicode scalar values rather than the
    /// code points used to compose them. The example below uses two strings
    /// with different forms of the `""` character---the first uses the composed
    /// form and the second uses the decomposed form.
    ///
    ///     // Unicode safe
    ///     let composedCafe = "caf"
    ///     let decomposedCafe = "cafe\u{0301}"
    ///
    ///     print(plans.hasSuffix(composedCafe))
    ///     // Prints "true"
    ///     print(plans.hasSuffix(decomposedCafe))
    ///     // Prints "true"
    ///
    /// - Parameter suffix: A possible suffix to test against this string.
    ///   Passing an empty string (`""`) as `suffix` always results in `false`.
    /// - Returns: `true` if the string ends with `suffix`, otherwise, `false`.
    public func hasSuffix(_ suffix: String) -> Bool
}

extension String {

    /// Creates a string representing the given value in base 10.
    ///
    /// The following example converts the maximal `Int` value to a string and
    /// prints its length:
    ///
    ///     let max = String(Int.max)
    ///     print("\(max) has \(max.utf16.count) digits.")
    ///     // Prints "9223372036854775807 has 19 digits."
    public init<T : _SignedInteger>(_ v: T)

    /// Creates a string representing the given value in base 10.
    ///
    /// The following example converts the maximal `UInt` value to a string and
    /// prints its length:
    ///
    ///     let max = String(UInt.max)
    ///     print("\(max) has \(max.utf16.count) digits.")
    ///     // Prints "18446744073709551615 has 20 digits."
    public init<T : UnsignedInteger>(_ v: T)

    /// Creates a string representing the given value in the specified base.
    ///
    /// Numerals greater than 9 are represented as Roman letters. These letters
    /// start with `"A"` if `uppercase` is `true`; otherwise, with `"a"`.
    /// 
    ///     let v = 999_999
    ///     print(String(v, radix: 2))
    ///     // Prints "11110100001000111111"
    ///
    ///     print(String(v, radix: 16))
    ///     // Prints "f423f"
    ///     print(String(v, radix: 16, uppercase: true))
    ///     // Prints "F423F"
    ///
    /// - Parameters:
    ///   - value: The value to convert to a string.
    ///   - radix: The base to use for the string representation. `radix` must be
    ///     at least 2 and at most 36.
    ///   - uppercase: Pass `true` to use uppercase letters to represent numerals
    ///     greater than 9, or `false` to use lowercase letters. The default is
    ///     `false`.
    public init<T : _SignedInteger>(_ value: T, radix: Int, uppercase: Bool = default)

    /// Creates a string representing the given value in the specified base.
    ///
    /// Numerals greater than 9 are represented as Roman letters. These letters
    /// start with `"A"` if `uppercase` is `true`; otherwise, with `"a"`.
    ///
    ///     let v: UInt = 999_999
    ///     print(String(v, radix: 2))
    ///     // Prints "11110100001000111111"
    ///
    ///     print(String(v, radix: 16))
    ///     // Prints "f423f"
    ///     print(String(v, radix: 16, uppercase: true))
    ///     // Prints "F423F"
    ///
    /// - Parameters:
    ///   - value: The value to convert to a string.
    ///   - radix: The base to use for the string representation. `radix` must be
    ///     at least 2 and at most 36.
    ///   - uppercase: Pass `true` to use uppercase letters to represent numerals
    ///     greater than 9, or `false` to use lowercase letters. The default is
    ///     `false`.
    public init<T : UnsignedInteger>(_ value: T, radix: Int, uppercase: Bool = default)
}

extension String {

    /// Creates a new string containing the characters in the given sequence.
    ///
    /// You can use this initializer to create a new string from the result of
    /// one or more operations on a string's `characters` view. For example:
    ///
    ///     let str = "The rain in Spain stays mainly in the plain."
    ///
    ///     let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    ///     let disemvowelled = String(str.characters.lazy.filter { !vowels.contains($0) })
    ///
    ///     print(disemvowelled)
    ///     // Prints "Th rn n Spn stys mnly n th pln."
    ///
    /// - Parameter characters: A sequence of characters.
    public init<S : Sequence where S.Iterator.Element == Character>(_ characters: S)

    /// Reserves enough space in the string's underlying storage to store the
    /// specified number of ASCII characters.
    ///
    /// Because each character in a string can require more than a single ASCII
    /// character's worth of storage, additional allocation may be necessary
    /// when adding characters to a string after a call to
    /// `reserveCapacity(_:)`.
    ///
    /// - Parameter n: The minimum number of ASCII character's worth of storage
    ///   to allocate.
    ///
    /// - Complexity: O(*n*)
    public mutating func reserveCapacity(_ n: Int)

    /// Appends the given character to the string.
    ///
    /// The following example adds an emoji globe to the end of a string.
    ///
    ///     var globe = "Globe "
    ///     globe.append("")
    ///     print(globe)
    ///     // Prints "Globe "
    ///
    /// - Parameter c: The character to append to the string.
    public mutating func append(_ c: Character)

    /// Appends the characters in the given sequence to the string.
    /// 
    /// - Parameter newElements: A sequence of characters.
    public mutating func append<S : Sequence where S.Iterator.Element == Character>(contentsOf newElements: S)

    /// Replaces the text within the specified bounds with the given characters.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - bounds: The range of text to replace. The bounds of the range must be
    ///     valid indices of the string.
    ///   - newElements: The new characters to add to the string.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the string and
    ///   `newElements`. If the call to `replaceSubrange(_:with:)` simply
    ///   removes text at the end of the string, the complexity is O(*n*), where
    ///   *n* is equal to `bounds.count`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Character>(_ bounds: Range<Index>, with newElements: C)

    /// Replaces the text within the specified bounds with the given string.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - bounds: The range of text to replace. The bounds of the range must be
    ///     valid indices of the string.
    ///   - newElements: The new text to add to the string.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the string and
    ///   `newElements`. If the call to `replaceSubrange(_:with:)` simply
    ///   removes text at the end of the string, the complexity is O(*n*), where
    ///   *n* is equal to `bounds.count`.
    public mutating func replaceSubrange(_ bounds: Range<Index>, with newElements: String)

    /// Replaces the text within the specified bounds with the given characters.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - bounds: The range of text to replace. The bounds of the range must be
    ///     valid indices of the string.
    ///   - newElements: The new characters to add to the string.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the string and
    ///   `newElements`. If the call to `replaceSubrange(_:with:)` simply
    ///   removes text at the end of the string, the complexity is O(*n*), where
    ///   *n* is equal to `bounds.count`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Character>(_ bounds: ClosedRange<Index>, with newElements: C)

    /// Replaces the text within the specified bounds with the given string.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - bounds: The range of text to replace. The bounds of the range must be
    ///     valid indices of the string.
    ///   - newElements: The new text to add to the string.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the string and
    ///   `newElements`. If the call to `replaceSubrange(_:with:)` simply
    ///   removes text at the end of the string, the complexity is O(*n*), where
    ///   *n* is equal to `bounds.count`.
    public mutating func replaceSubrange(_ bounds: ClosedRange<Index>, with newElements: String)

    /// Inserts a new character at the specified position.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - newElement: The new character to insert into the string.
    ///   - i: A valid index of the string. If `i` is equal to the string's end
    ///     index, this methods appends `newElement` to the string.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the string.
    public mutating func insert(_ newElement: Character, at i: Index)

    /// Inserts a collection of characters at the specified position.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - newElements: A collection of `Character` elements to insert into the
    ///     string.
    ///   - i: A valid index of the string. If `i` is equal to the string's end
    ///     index, this methods appends the contents of `newElements` to the
    ///     string.
    ///
    /// - Complexity: O(*n*), where *n* is the combined length of the string and
    ///   `newElements`.
    public mutating func insert<S : Collection where S.Iterator.Element == Character>(contentsOf newElements: S, at i: Index)

    /// Removes and returns the character at the specified position.
    ///
    /// All the elements following `i` are moved to close the gap. This example
    /// removes the hyphen from the middle of a string.
    ///
    ///     var nonempty = "non-empty"
    ///     if let i = nonempty.characters.index(of: "-") {
    ///         nonempty.remove(at: i)
    ///     }
    ///     print(nonempty)
    ///     // Prints "nonempty"
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameter i: The position of the character to remove. `i` must be a
    ///   valid index of the string that is not equal to the string's end index.
    /// - Returns: The character that was removed.
    public mutating func remove(at i: Index) -> Character

    /// Removes the characters in the given range.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameter bounds: The range of the elements to remove. The upper and
    ///   lower bounds of `bounds` must be valid indices of the string.
    public mutating func removeSubrange(_ bounds: Range<Index>)

    /// Removes the characters in the given range.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameter bounds: The range of the elements to remove. The upper and
    ///   lower bounds of `bounds` must be valid indices of the string and not
    ///   equal to the string's end index.
    public mutating func removeSubrange(_ bounds: ClosedRange<Index>)

    /// Replaces this string with the empty string.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameter keepCapacity: Pass `true` to prevent the release of the
    ///   string's allocated storage. Retaining the storage can be a useful
    ///   optimization when you're planning to grow the string again. The
    ///   default value is `false`.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)
}

extension String {

    /// The string's value represented as a collection of Unicode scalar values.
    public var unicodeScalars: String.UnicodeScalarView
}

extension String {
}

extension String : MirrorPath {
}

extension String {

    /// Creates a string representing the given value.
    ///
    /// Use this initializer to convert an instance of any type to its preferred
    /// representation as a `String` instance. The initializer creates the
    /// string representation of `instance` in one of the following ways,
    /// depending on its protocol conformance:
    ///
    /// - If `instance` conforms to the `Streamable` protocol, the result is
    ///   obtained by calling `instance.write(to: s)` on an empty string `s`.
    /// - If `instance` conforms to the `CustomStringConvertible` protocol, the
    ///   result is `instance.description`.
    /// - If `instance` conforms to the `CustomDebugStringConvertible` protocol,
    ///   the result is `instance.debugDescription`.
    /// - An unspecified result is supplied automatically by the Swift standard
    ///   library.
    ///
    /// For example, this custom `Point` struct uses the default representation
    /// supplied by the standard library.
    ///
    ///     struct Point {
    ///         let x: Int, y: Int
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     print(String(p))
    ///     // Prints "Point(x: 21, y: 30)"
    ///
    /// After adding `CustomStringConvertible` conformance by implementing the
    /// `description` property, `Point` provides its own custom representation.
    ///
    ///     extension Point: CustomStringConvertible {
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     print(String(p))
    ///     // Prints "(21, 30)"
    ///
    /// - SeeAlso: `String.init<Subject>(reflecting: Subject)`
    public init<Subject>(_ instance: Subject)

    /// Creates a string with a detailed representation of the given value,
    /// suitable for debugging.
    ///
    /// Use this initializer to convert an instance of any type to its custom
    /// debugging representation. The initializer creates the string
    /// representation of `instance` in one of the following ways, depending on
    /// its protocol conformance:
    ///
    /// - If `subject` conforms to the `CustomDebugStringConvertible` protocol,
    ///   the result is `subject.debugDescription`.
    /// - If `subject` conforms to the `CustomStringConvertible` protocol, the
    ///   result is `subject.description`.
    /// - If `subject` conforms to the `Streamable` protocol, the result is
    ///   obtained by calling `subject.write(to: s)` on an empty string `s`.
    /// - An unspecified result is supplied automatically by the Swift standard
    ///   library.
    ///
    /// For example, this custom `Point` struct uses the default representation
    /// supplied by the standard library.
    ///
    ///     struct Point {
    ///         let x: Int, y: Int
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     print(String(reflecting: p))
    ///     // Prints "p: Point = {
    ///     //           x = 21
    ///     //           y = 30
    ///     //         }"
    ///
    /// After adding `CustomDebugStringConvertible` conformance by implementing
    /// the `debugDescription` property, `Point` provides its own custom
    /// debugging representation.
    ///
    ///     extension Point: CustomDebugStringConvertible {
    ///         var debugDescription: String {
    ///             return "Point(x: \(x), y: \(y))"
    ///         }
    ///     }
    ///
    ///     print(String(reflecting: p))
    ///     // Prints "Point(x: 21, y: 30)"
    ///
    /// - SeeAlso: `String.init<Subject>(Subject)`
    public init<Subject>(reflecting subject: Subject)
}

/// `String.CharacterView` is a collection of `Character`.
extension String.CharacterView : BidirectionalCollection {

    /// A position in a string's `CharacterView` instance.
    ///
    /// You can convert between indices of the different string views by using
    /// conversion initializers and the `samePosition(in:)` method overloads.
    /// The following example finds the index of the first space in the string's
    /// character view and then converts that to the same position in the UTF-8
    /// view:
    ///
    ///     let hearts = "Hearts <3  "
    ///     if let i = hearts.characters.index(of: " ") {
    ///         let j = i.samePosition(in: hearts.utf8)
    ///         print(Array(hearts.utf8.prefix(upTo: j)))
    ///     }
    ///     // Prints "[72, 101, 97, 114, 116, 115]"
    public struct Index : Comparable, CustomPlaygroundQuickLookable {

        /// A custom playground quick look for this instance.
        ///
        /// If this type has value semantics, the `PlaygroundQuickLook` instance
        /// should be unaffected by subsequent mutations.
        public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
    }

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Int

    /// The position of the first character in a nonempty character view.
    /// 
    /// In an empty character view, `startIndex` is equal to `endIndex`.
    public var startIndex: String.CharacterView.Index { get }

    /// A character view's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// In an empty character view, `endIndex` is equal to `startIndex`.
    public var endIndex: String.CharacterView.Index { get }

    /// Returns the next consecutive position after `i`.
    ///
    /// - Precondition: The next position is valid.
    public func index(after i: String.CharacterView.Index) -> String.CharacterView.Index

    /// Returns the previous consecutive position before `i`.
    ///
    /// - Precondition: The previous position is valid.
    public func index(before i: String.CharacterView.Index) -> String.CharacterView.Index

    /// Accesses the character at the given position.
    ///
    /// The following example searches a string's character view for a capital
    /// letter and then prints the character at the found index:
    ///
    ///     let greeting = "Hello, friend!"
    ///     if let i = greeting.characters.index(where: { "A"..."Z" ~= $0 }) {
    ///         print("First capital letter: \(greeting.characters[i])")
    ///     }
    ///     // Prints "First capital letter: H"
    ///
    /// - Parameter position: A valid index of the character view. `position`
    ///   must be less than the view's end index.
    public subscript(i: String.CharacterView.Index) -> Character { get }
}

extension String.CharacterView : RangeReplaceableCollection {

    /// Creates an empty character view.
    public init()

    /// Replaces the characters within the specified bounds with the given
    /// characters.
    ///
    /// Invalidates all indices with respect to the string.
    ///
    /// - Parameters:
    ///   - bounds: The range of characters to replace. The bounds of the range
    ///     must be valid indices of the character view.
    ///   - newElements: The new characters to add to the view.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the character
    ///   view and `newElements`. If the call to `replaceSubrange(_:with:)`
    ///   simply removes characters at the end of the view, the complexity is
    ///   O(*n*), where *n* is equal to `bounds.count`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == Character>(_ bounds: Range<String.CharacterView.Index>, with newElements: C)

    /// Reserves enough space in the character view's underlying storage to store
    /// the specified number of ASCII characters.
    ///
    /// Because each element of a character view can require more than a single
    /// ASCII character's worth of storage, additional allocation may be
    /// necessary when adding characters to the character view after a call to
    /// `reserveCapacity(_:)`.
    ///
    /// - Parameter n: The minimum number of ASCII character's worth of storage
    ///   to allocate.
    ///
    /// - Complexity: O(*n*), where *n* is the capacity being reserved.
    public mutating func reserveCapacity(_ n: Int)

    /// Appends the given character to the character view.
    ///
    /// - Parameter c: The character to append to the character view.
    public mutating func append(_ c: Character)

    /// Appends the characters in the given sequence to the character view.
    /// 
    /// - Parameter newElements: A sequence of characters.
    public mutating func append<S : Sequence where S.Iterator.Element == Character>(contentsOf newElements: S)

    /// Creates a new character view containing the characters in the given
    /// sequence.
    ///
    /// - Parameter characters: A sequence of characters.
    public init<S : Sequence where S.Iterator.Element == Character>(_ characters: S)
}

extension String.CharacterView {

    /// Accesses the characters in the given range.
    ///
    /// The example below uses this subscript to access the characters up to, but
    /// not including, the first comma (`","`) in the string.
    ///
    ///     let str = "All this happened, more or less."
    ///     let i = str.characters.index(of: ",")!
    ///     let substring = str.characters[str.characters.startIndex ..< i]
    ///     print(String(substring))
    ///     // Prints "All this happened"
    ///
    /// - Complexity: O(*n*) if the underlying string is bridged from
    ///   Objective-C, where *n* is the length of the string; otherwise, O(1).
    public subscript(bounds: Range<String.CharacterView.Index>) -> String.CharacterView { get }
}

extension String.UnicodeScalarView : RangeReplaceableCollection {

    /// Creates an empty view instance.
    public init()

    /// Reserves enough space in the view's underlying storage to store the
    /// specified number of ASCII characters.
    ///
    /// Because a Unicode scalar value can require more than a single ASCII
    /// character's worth of storage, additional allocation may be necessary
    /// when adding to a Unicode scalar view after a call to
    /// `reserveCapacity(_:)`.
    ///
    /// - Parameter n: The minimum number of ASCII character's worth of storage
    ///   to allocate.
    ///
    /// - Complexity: O(*n*), where *n* is the capacity being reserved.
    public mutating func reserveCapacity(_ n: Int)

    /// Appends the given Unicode scalar to the view.
    ///
    /// - Parameter c: The character to append to the string.
    public mutating func append(_ x: UnicodeScalar)

    /// Appends the Unicode scalar values in the given sequence to the view.
    ///
    /// - Parameter newElements: A sequence of Unicode scalar values.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting view.
    public mutating func append<S : Sequence where S.Iterator.Element == UnicodeScalar>(contentsOf newElements: S)

    /// Replaces the elements within the specified bounds with the given Unicode
    /// scalar values.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - bounds: The range of elements to replace. The bounds of the range
    ///     must be valid indices of the view.
    ///   - newElements: The new Unicode scalar values to add to the string.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the view and
    ///   `newElements`. If the call to `replaceSubrange(_:with:)` simply
    ///   removes elements at the end of the string, the complexity is O(*n*),
    ///   where *n* is equal to `bounds.count`.
    public mutating func replaceSubrange<C : Collection where C.Iterator.Element == UnicodeScalar>(_ bounds: Range<String.UnicodeScalarView.Index>, with newElements: C)
}

extension String.UnicodeScalarView : CustomReflectable {

    /// Returns a mirror that reflects the Unicode scalars view of a string.
    public var customMirror: Mirror { get }
}

extension String.UnicodeScalarView : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension String.UTF16View : CustomReflectable {

    /// Returns a mirror that reflects the UTF-16 view of a string.
    public var customMirror: Mirror { get }
}

extension String.UTF16View : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension String.UTF8View : CustomReflectable {

    /// Returns a mirror that reflects the UTF-8 view of a string.
    public var customMirror: Mirror { get }
}

extension String.UTF8View : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension String.CharacterView.Index {

    /// Creates an index in the given string that corresponds exactly to the
    /// specified `UnicodeScalarView` position.
    ///
    /// The following example converts the position of the Unicode scalar `"e"`
    /// into its corresponding position in the string's character view. The
    /// character at that position is the composed `""` character.
    ///
    ///     let cafe = "Cafe\u{0301}"
    ///     print(cafe)
    ///     // Prints "Caf"
    ///
    ///     let scalarsIndex = cafe.unicodeScalars.index(of: "e")!
    ///     let charactersIndex = String.Index(scalarsIndex, within: cafe)!
    ///
    ///     print(String(cafe.characters.prefix(through: charactersIndex)))
    ///     // Prints "Caf"
    ///
    /// If the position passed in `unicodeScalarIndex` doesn't have an exact
    /// corresponding position in `other.characters`, the result of the
    /// initializer is `nil`. For example, an attempt to convert the position of
    /// the combining acute accent (`"\u{0301}"`) fails. Combining Unicode
    /// scalars do not have their own position in a character view.
    ///
    ///     let nextIndex = String.Index(cafe.unicodeScalars.index(after: scalarsIndex),
    ///                                  within: cafe)
    ///     print(nextIndex)
    ///     // Prints "nil"
    ///
    /// - Parameters:
    ///   - unicodeScalarIndex: A position in the `unicodeScalars` view of the
    ///     `other` parameter.
    ///   - other: The string referenced by both `unicodeScalarIndex` and the
    ///     resulting index.
    public init?(_ unicodeScalarIndex: UnicodeScalarIndex, within other: String)

    /// Creates an index in the given string that corresponds exactly to the
    /// specified `UTF16View` position.
    ///
    /// The following example finds the position of a space in a string's `utf16`
    /// view and then converts that position to an index in the the string's
    /// `characters` view. The value `32` is the UTF-16 encoded value of a space
    /// character.
    ///
    ///     let cafe = "Caf "
    ///
    ///     let utf16Index = cafe.utf16.index(of: 32)!
    ///     let charactersIndex = String.Index(utf16Index, within: cafe)!
    ///
    ///     print(String(cafe.characters.prefix(upTo: charactersIndex)))
    ///     // Prints "Caf"
    ///
    /// If the position passed in `utf16Index` doesn't have an exact
    /// corresponding position in `other.characters`, the result of the
    /// initializer is `nil`. For example, an attempt to convert the position of
    /// the trailing surrogate of a UTF-16 surrogate pair fails.
    ///
    /// The next example attempts to convert the indices of the two UTF-16 code
    /// points that represent the teacup emoji (`""`). The index of the lead
    /// surrogate is successfully converted to a position in `other.characters`,
    /// but the index of the trailing surrogate is not.
    ///
    ///     let emojiHigh = cafe.utf16.index(after: utf16Index)
    ///     print(String.Index(emojiHigh, within: cafe))
    ///     // Prints "Optional(String.Index(...))"
    ///
    ///     let emojiLow = cafe.utf16.index(after: emojiHigh)
    ///     print(String.Index(emojiLow, within: cafe))
    ///     // Prints "nil"
    ///
    /// - Parameters:
    ///   - utf16Index: A position in the `utf16` view of the `other` parameter.
    ///   - other: The string referenced by both `utf16Index` and the resulting
    ///     index.
    public init?(_ utf16Index: UTF16Index, within other: String)

    /// Creates an index in the given string that corresponds exactly to the
    /// specified `UTF8View` position.
    ///
    /// If the position passed in `utf8Index` doesn't have an exact corresponding
    /// position in `other.characters`, the result of the initializer is `nil`.
    /// For example, an attempt to convert the position of a UTF-8 continuation
    /// byte returns `nil`.
    ///
    /// - Parameters:
    ///   - utf8Index: A position in the `utf8` view of the `other` parameter.
    ///   - other: The string referenced by both `utf8Index` and the resulting
    ///     index.
    public init?(_ utf8Index: UTF8Index, within other: String)

    /// Returns the position in the given UTF-8 view that corresponds exactly to
    /// this index.
    ///
    /// The index must be a valid index of `String(utf8).characters`.
    ///
    /// This example first finds the position of the character `""` and then uses
    /// this method find the same position in the string's `utf8` view.
    ///
    ///     let cafe = "Caf"
    ///     if let i = cafe.characters.index(of: "") {
    ///         let j = i.samePosition(in: cafe.utf8)
    ///         print(Array(cafe.utf8.suffix(from: j)))
    ///     }
    ///     // Prints "[195, 169]"
    ///
    /// - Parameter utf8: The view to use for the index conversion.
    /// - Returns: The position in `utf8` that corresponds exactly to this index.
    public func samePosition(in utf8: String.UTF8View) -> String.UTF8View.Index

    /// Returns the position in the given UTF-16 view that corresponds exactly to
    /// this index.
    ///
    /// The index must be a valid index of `String(utf16).characters`.
    ///
    /// This example first finds the position of the character `""` and then uses
    /// this method find the same position in the string's `utf16` view.
    ///
    ///     let cafe = "Caf"
    ///     if let i = cafe.characters.index(of: "") {
    ///         let j = i.samePosition(in: cafe.utf16)
    ///         print(cafe.utf16[j])
    ///     }
    ///     // Prints "233"
    ///
    /// - Parameter utf16: The view to use for the index conversion.
    /// - Returns: The position in `utf16` that corresponds exactly to this index.
    public func samePosition(in utf16: String.UTF16View) -> String.UTF16View.Index

    /// Returns the position in the given view of Unicode scalars that
    /// corresponds exactly to this index.
    ///
    /// The index must be a valid index of `String(unicodeScalars).characters`.
    ///
    /// This example first finds the position of the character `""` and then uses
    /// this method find the same position in the string's `unicodeScalars`
    /// view.
    ///
    ///     let cafe = "Caf"
    ///     if let i = cafe.characters.index(of: "") {
    ///         let j = i.samePosition(in: cafe.unicodeScalars)
    ///         print(cafe.unicodeScalars[j])
    ///     }
    ///     // Prints ""
    ///
    /// - Parameter unicodeScalars: The view to use for the index conversion.
    /// - Returns: The position in `unicodeScalars` that corresponds exactly to
    ///   this index.
    public func samePosition(in unicodeScalars: String.UnicodeScalarView) -> String.UnicodeScalarView.Index
}

extension String.UnicodeScalarView.UnicodeScalarIndex {

    /// Creates an index in the given Unicode scalars view that corresponds
    /// exactly to the specified `UTF16View` position.
    ///
    /// The following example finds the position of a space in a string's `utf16`
    /// view and then converts that position to an index in the the string's
    /// `unicodeScalars` view:
    ///
    ///     let cafe = "Caf "
    ///
    ///     let utf16Index = cafe.utf16.index(of: 32)!
    ///     let scalarIndex = String.UnicodeScalarView.Index(utf16Index, within: cafe.unicodeScalars)!
    ///
    ///     print(String(cafe.unicodeScalars.prefix(upTo: scalarIndex)))
    ///     // Prints "Caf"
    ///
    /// If the position passed in `utf16Index` doesn't have an exact
    /// corresponding position in `unicodeScalars`, the result of the
    /// initializer is `nil`. For example, an attempt to convert the position of
    /// the trailing surrogate of a UTF-16 surrogate pair fails.
    ///
    /// - Parameters:
    ///   - utf16Index: A position in the `utf16` view of the `characters`
    ///     parameter.
    ///   - unicodeScalars: The `UnicodeScalarView` instance referenced by both
    ///     `utf16Index` and the resulting index.
    public init?(_ utf16Index: UTF16Index, within unicodeScalars: String.UnicodeScalarView)

    /// Creates an index in the given Unicode scalars view that corresponds
    /// exactly to the specified `UTF8View` position.
    ///
    /// If the position passed as `utf8Index` doesn't have an exact corresponding
    /// position in `unicodeScalars`, the result of the initializer is `nil`.
    /// For example, an attempt to convert the position of a UTF-8 continuation
    /// byte returns `nil`.
    ///
    /// - Parameters:
    ///   - utf8Index: A position in the `utf8` view of the `characters`
    ///     parameter.
    ///   - unicodeScalars: The `UnicodeScalarView` instance referenced by both
    ///     `utf8Index` and the resulting index.
    public init?(_ utf8Index: UTF8Index, within unicodeScalars: String.UnicodeScalarView)

    /// Creates an index in the given Unicode scalars view that corresponds
    /// exactly to the specified string position.
    ///
    /// The following example converts the position of the teacup emoji (`""`)
    /// into its corresponding position in the string's `unicodeScalars` view.
    ///
    ///     let cafe = "Caf "
    ///     let characterIndex = cafe.characters.index(of: "")!
    ///     let scalarIndex = String.UnicodeScalarView.Index(characterIndex, within: cafe.unicodeScalars)
    ///
    ///     print(cafe.unicodeScalars.suffix(from: scalarIndex))
    ///     // Prints ""
    ///
    /// - Parameters:
    ///   - characterIndex: A position in a `CharacterView` instance.
    ///     `characterIndex` must be an element of
    ///     `String(utf8).characters.indices`.
    ///   - utf8: The `UTF8View` in which to find the new position.
    public init(_ characterIndex: Index, within unicodeScalars: String.UnicodeScalarView)

    /// Returns the position in the given UTF-8 view that corresponds exactly to
    /// this index.
    ///
    /// The index must be a valid index of `String(utf8).unicodeScalars`.
    ///
    /// This example first finds the position of the character `""` and then uses
    /// this method find the same position in the string's `utf8` view.
    ///
    ///     let cafe = "Caf"
    ///     if let i = cafe.unicodeScalars.index(of: "") {
    ///         let j = i.samePosition(in: cafe.utf8)
    ///         print(Array(cafe.utf8.suffix(from: j)))
    ///     }
    ///     // Prints "[195, 169]"
    ///
    /// - Parameter utf8: The view to use for the index conversion.
    /// - Returns: The position in `utf8` that corresponds exactly to this index.
    public func samePosition(in utf8: String.UTF8View) -> String.UTF8View.Index

    /// Returns the position in the given UTF-16 view that corresponds exactly to
    /// this index.
    ///
    /// The index must be a valid index of `String(utf16).unicodeScalars`.
    ///
    /// This example first finds the position of the character `""` and then uses
    /// this method find the same position in the string's `utf16` view.
    ///
    ///     let cafe = "Caf"
    ///     if let i = cafe.characters.index(of: "") {
    ///         let j = i.samePosition(in: cafe.utf16)
    ///         print(cafe.utf16[j])
    ///     }
    ///     // Prints "233"
    ///
    /// - Parameter utf16: The view to use for the index conversion.
    /// - Returns: The position in `utf16` that corresponds exactly to this index.
    public func samePosition(in utf16: String.UTF16View) -> String.UTF16View.Index

    /// Returns the position in the given string that corresponds exactly to this
    /// index.
    ///
    /// This index must be a valid index of `characters.unicodeScalars`.
    ///
    /// This example first finds the position of a space (UTF-8 code point `32`)
    /// in a string's `utf8` view and then uses this method find the same position
    /// in the string.
    ///
    ///     let cafe = "Caf "
    ///     let i = cafe.unicodeScalars.index(of: "")
    ///     let j = i.samePosition(in: cafe)!
    ///     print(cafe.suffix(from: j))
    ///     // Prints ""
    ///
    /// - Parameter characters: The string to use for the index conversion.
    /// - Returns: The position in `characters` that corresponds exactly to
    ///   this index. If this index does not have an exact corresponding
    ///   position in `characters`, this method returns `nil`. For example,
    ///   an attempt to convert the position of a UTF-8 continuation byte
    ///   returns `nil`.
    public func samePosition(in characters: String) -> Index?
}

extension String.UTF16View.Index {

    /// Creates an index in the given UTF-16 view that corresponds exactly to the
    /// specified `UTF8View` position.
    ///
    /// The following example finds the position of a space in a string's `utf8`
    /// view and then converts that position to an index in the the string's
    /// `utf16` view.
    ///
    ///     let cafe = "Caf "
    ///
    ///     let utf8Index = cafe.utf8.index(of: 32)!
    ///     let utf16Index = String.UTF16View.Index(utf8Index, within: cafe.utf16)!
    ///
    ///     print(cafe.utf16.prefix(upTo: utf16Index))
    ///     // Prints "Caf"
    ///
    /// If the position passed as `utf8Index` doesn't have an exact corresponding
    /// position in `utf16`, the result of the initializer is `nil`. For
    /// example, because UTF-8 and UTF-16 represent high Unicode code points
    /// differently, an attempt to convert the position of a UTF-8 continuation
    /// byte fails.
    ///
    /// - Parameters:
    ///   - utf8Index: A position in a `UTF8View` instance. `utf8Index` must be
    ///     an element in `String(utf16).utf8.indices`.
    ///   - utf16: The `UTF16View` in which to find the new position.
    public init?(_ utf8Index: UTF8Index, within utf16: String.UTF16View)

    /// Creates an index in the given UTF-16 view that corresponds exactly to the
    /// specified `UnicodeScalarView` position.
    ///
    /// The following example finds the position of a space in a string's `utf8`
    /// view and then converts that position to an index in the the string's
    /// `utf16` view.
    ///
    ///     let cafe = "Caf "
    ///
    ///     let scalarIndex = cafe.unicodeScalars.index(of: "")!
    ///     let utf16Index = String.UTF16View.Index(scalarIndex, within: cafe.utf16)
    ///
    ///     print(cafe.utf16.prefix(through: utf16Index))
    ///     // Prints "Caf"
    ///
    /// - Parameters:
    ///   - unicodeScalarIndex: A position in a `UnicodeScalarView` instance.
    ///     `unicodeScalarIndex` must be an element in
    ///     `String(utf16).unicodeScalarIndex.indices`.
    ///   - utf16: The `UTF16View` in which to find the new position.
    public init(_ unicodeScalarIndex: UnicodeScalarIndex, within utf16: String.UTF16View)

    /// Creates an index in the given UTF-16 view that corresponds exactly to the
    /// specified `CharacterView` position.
    ///
    /// The following example finds the position of a space in a string's `characters`
    /// view and then converts that position to an index in the the string's
    /// `utf16` view.
    ///
    ///     let cafe = "Caf "
    ///
    ///     let characterIndex = cafe.characters.index(of: "")!
    ///     let utf16Index = String.UTF16View.Index(characterIndex, within: cafe.utf16)
    ///
    ///     print(cafe.utf16.prefix(through: utf16Index))
    ///     // Prints "Caf"
    ///
    /// - Parameters:
    ///   - characterIndex: A position in a `CharacterView` instance.
    ///     `characterIndex` must be an element in
    ///     `String(utf16).characters.indices`.
    ///   - utf16: The `UTF16View` in which to find the new position.
    public init(_ characterIndex: Index, within utf16: String.UTF16View)

    /// Returns the position in the given UTF-8 view that corresponds exactly to
    /// this index.
    ///
    /// The index must be a valid index of `String(utf8).utf16`.
    ///
    /// This example first finds the position of a space (UTF-16 code point `32`)
    /// in a string's `utf16` view and then uses this method to find the same
    /// position in the string's `utf8` view.
    ///
    ///     let cafe = "Caf "
    ///     let i = cafe.utf16.index(of: 32)!
    ///     let j = i.samePosition(in: cafe.utf8)!
    ///     print(Array(cafe.utf8.prefix(upTo: j)))
    ///     // Prints "[67, 97, 102, 195, 169]"
    ///
    /// - Parameter utf8: The view to use for the index conversion.
    /// - Returns: The position in `utf8` that corresponds exactly to this index.
    ///   If this index does not have an exact corresponding position in `utf8`,
    ///   this method returns `nil`. For example, an attempt to convert the
    ///   position of a UTF-16 trailing surrogate returns `nil`.
    public func samePosition(in utf8: String.UTF8View) -> String.UTF8View.Index?

    /// Returns the position in the given view of Unicode scalars that
    /// corresponds exactly to this index.
    ///
    /// This index must be a valid index of `String(unicodeScalars).utf16`.
    ///
    /// This example first finds the position of a space (UTF-16 code point `32`)
    /// in a string's `utf16` view and then uses this method to find the same
    /// position in the string's `unicodeScalars` view.
    ///
    ///     let cafe = "Caf "
    ///     let i = cafe.utf16.index(of: 32)!
    ///     let j = i.samePosition(in: cafe.unicodeScalars)!
    ///     print(cafe.unicodeScalars.prefix(upTo: j))
    ///     // Prints "Caf"
    ///
    /// - Parameter unicodeScalars: The view to use for the index conversion.
    /// - Returns: The position in `unicodeScalars` that corresponds exactly to
    ///   this index. If this index does not have an exact corresponding
    ///   position in `unicodeScalars`, this method returns `nil`. For example,
    ///   an attempt to convert the position of a UTF-16 trailing surrogate
    ///   returns `nil`.
    public func samePosition(in unicodeScalars: String.UnicodeScalarView) -> UnicodeScalarIndex?

    /// Returns the position in the given string that corresponds exactly to this
    /// index.
    ///
    /// This index must be a valid index of `characters.utf16`.
    ///
    /// This example first finds the position of a space (UTF-16 code point `32`)
    /// in a string's `utf16` view and then uses this method find the same position
    /// in the string.
    ///
    ///     let cafe = "Caf "
    ///     let i = cafe.utf16.index(of: 32)!
    ///     let j = i.samePosition(in: cafe)!
    ///     print(cafe[cafe.startIndex ..< j])
    ///     // Prints "Caf"
    ///
    /// - Parameter characters: The string to use for the index conversion.
    /// - Returns: The position in `characters` that corresponds exactly to this
    ///   index. If this index does not have an exact corresponding position in
    ///   `characters`, this method returns `nil`. For example, an attempt to
    ///   convert the position of a UTF-16 trailing surrogate returns `nil`.
    public func samePosition(in characters: String) -> Index?
}

extension String.UTF16View.Indices : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = String.UTF16View.Index

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = IndexDistance

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = String.UTF16View.Indices

    /// A sequence that can represent a contiguous subrange of the collection's
    /// elements.
    public typealias SubSequence = String.UTF16View.Indices

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.index(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Index { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Indices { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(i: Index) -> Index { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Index>) -> String.UTF16View.Indices { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Index) -> Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Index) -> Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - SeeAlso: `index(_:offsetBy:limitedBy:)`, `formIndex(_:offsetBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Index, offsetBy n: IndexDistance) -> Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position. The
    /// operation doesn't require going beyond the limiting `s.endIndex` value,
    /// so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// Advancing an index beyond a collection's ending index or offsetting it
    /// before a collection's starting index may trigger a runtime error. The
    /// value passed as `n` must not result in such an operation.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - SeeAlso: `index(_:offsetBy:)`, `formIndex(_:offsetBy:limitedBy:)`
    /// - Precondition:
    ///   - If `n > 0`, `n <= self.distance(from: i, to: self.endIndex)`
    ///   - If `n < 0`, `n >= self.distance(from: i, to: self.startIndex)`
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Index, offsetBy n: IndexDistance, limitedBy limit: Index) -> Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Index, to end: Index) -> IndexDistance
}

extension String.UTF8View.Index {

    /// Creates an index in the given UTF-8 view that corresponds exactly to the
    /// specified `UTF16View` position.
    ///
    /// The following example finds the position of a space in a string's `utf16`
    /// view and then converts that position to an index in the the string's
    /// `utf8` view.
    ///
    ///     let cafe = "Caf "
    ///
    ///     let utf16Index = cafe.utf16.index(of: 32)!
    ///     let utf8Index = String.UTF8View.Index(utf16Index, within: cafe.utf8)!
    ///
    ///     print(Array(cafe.utf8.prefix(upTo: utf8Index)))
    ///     // Prints "[67, 97, 102, 195, 169]"
    ///
    /// If the position passed in `utf16Index` doesn't have an exact
    /// corresponding position in `utf8`, the result of the initializer is
    /// `nil`. For example, because UTF-8 and UTF-16 represent high Unicode code
    /// points differently, an attempt to convert the position of the trailing
    /// surrogate of a UTF-16 surrogate pair fails.
    ///
    /// The next example attempts to convert the indices of the two UTF-16 code
    /// points that represent the teacup emoji (`""`). The index of the lead
    /// surrogate is successfully converted to a position in `utf8`, but the
    /// index of the trailing surrogate is not.
    ///
    ///     let emojiHigh = cafe.utf16.index(after: utf16Index)
    ///     print(String.UTF8View.Index(emojiHigh, within: cafe.utf8))
    ///     // Prints "Optional(String.Index(...))"
    ///
    ///     let emojiLow = cafe.utf16.index(after: emojiHigh)
    ///     print(String.UTF8View.Index(emojiLow, within: cafe.utf8))
    ///     // Prints "nil"
    ///
    /// - Parameters:
    ///   - utf16Index: A position in a `UTF16View` instance. `utf16Index` must
    ///     be an element in `String(utf8).utf16.indices`.
    ///   - utf8: The `UTF8View` in which to find the new position.
    public init?(_ utf16Index: UTF16Index, within utf8: String.UTF8View)

    /// Creates an index in the given UTF-8 view that corresponds exactly to the
    /// specified `UnicodeScalarView` position.
    ///
    /// The following example converts the position of the Unicode scalar `"e"`
    /// into its corresponding position in the string's `utf8` view.
    ///
    ///     let cafe = "Cafe\u{0301}"
    ///     let scalarsIndex = cafe.unicodeScalars.index(of: "e")!
    ///     let utf8Index = String.UTF8View.Index(scalarsIndex, within: cafe.utf8)
    ///
    ///     print(Array(cafe.utf8.prefix(through: utf8Index)))
    ///     // Prints "[67, 97, 102, 101]"
    ///
    /// - Parameters:
    ///   - unicodeScalarIndex: A position in a `UnicodeScalarView` instance.
    ///     `unicodeScalarIndex` must be an element of
    ///     `String(utf8).unicodeScalars.indices`.
    ///   - utf8: The `UTF8View` in which to find the new position.
    public init(_ unicodeScalarIndex: UnicodeScalarIndex, within utf8: String.UTF8View)

    /// Creates an index in the given UTF-8 view that corresponds exactly to the
    /// specified string position.
    ///
    /// The following example converts the position of the teacup emoji (`""`)
    /// into its corresponding position in the string's `utf8` view.
    ///
    ///     let cafe = "Caf "
    ///     let characterIndex = cafe.characters.index(of: "")!
    ///     let utf8Index = String.UTF8View.Index(characterIndex, within: cafe.utf8)
    ///
    ///     print(Array(cafe.utf8.suffix(from: utf8Index)))
    ///     // Prints "[240, 159, 141, 181]"
    ///
    /// - Parameters:
    ///   - characterIndex: A position in a `CharacterView` instance.
    ///     `characterIndex` must be an element of
    ///     `String(utf8).characters.indices`.
    ///   - utf8: The `UTF8View` in which to find the new position.
    public init(_ characterIndex: Index, within utf8: String.UTF8View)

    /// Returns the position in the given UTF-16 view that corresponds exactly to
    /// this index.
    ///
    /// The index must be a valid index of `String(utf16).utf8`.
    ///
    /// This example first finds the position of a space (UTF-8 code point `32`)
    /// in a string's `utf8` view and then uses this method to find the same
    /// position in the string's `utf16` view.
    ///
    ///     let cafe = "Caf "
    ///     let i = cafe.utf8.index(of: 32)!
    ///     let j = i.samePosition(in: cafe.utf16)!
    ///     print(cafe.utf16.prefix(upTo: j))
    ///     // Prints "Caf"
    ///
    /// - Parameter utf16: The view to use for the index conversion.
    /// - Returns: The position in `utf16` that corresponds exactly to this
    ///   index. If this index does not have an exact corresponding position in
    ///   `utf16`, this method returns `nil`. For example, an attempt to convert
    ///   the position of a UTF-8 continuation byte returns `nil`.
    public func samePosition(in utf16: String.UTF16View) -> String.UTF16View.Index?

    /// Returns the position in the given view of Unicode scalars that
    /// corresponds exactly to this index.
    ///
    /// This index must be a valid index of `String(unicodeScalars).utf8`.
    ///
    /// This example first finds the position of a space (UTF-8 code point `32`)
    /// in a string's `utf8` view and then uses this method to find the same position
    /// in the string's `unicodeScalars` view.
    ///
    ///     let cafe = "Caf "
    ///     let i = cafe.utf8.index(of: 32)!
    ///     let j = i.samePosition(in: cafe.unicodeScalars)!
    ///     print(cafe.unicodeScalars.prefix(upTo: j))
    ///     // Prints "Caf"
    ///
    /// - Parameter unicodeScalars: The view to use for the index conversion.
    /// - Returns: The position in `unicodeScalars` that corresponds exactly to
    ///   this index. If this index does not have an exact corresponding
    ///   position in `unicodeScalars`, this method returns `nil`. For example,
    ///   an attempt to convert the position of a UTF-8 continuation byte
    ///   returns `nil`.
    public func samePosition(in unicodeScalars: String.UnicodeScalarView) -> UnicodeScalarIndex?

    /// Returns the position in the given string that corresponds exactly to this
    /// index.
    ///
    /// This index must be a valid index of `characters.utf8`.
    ///
    /// This example first finds the position of a space (UTF-8 code point `32`)
    /// in a string's `utf8` view and then uses this method find the same position
    /// in the string.
    ///
    ///     let cafe = "Caf "
    ///     let i = cafe.utf8.index(of: 32)!
    ///     let j = i.samePosition(in: cafe)!
    ///     print(cafe[cafe.startIndex ..< j])
    ///     // Prints "Caf"
    ///
    /// - Parameter characters: The string to use for the index conversion.
    /// - Returns: The position in `characters` that corresponds exactly to
    ///   this index. If this index does not have an exact corresponding
    ///   position in `characters`, this method returns `nil`. For example,
    ///   an attempt to convert the position of a UTF-8 continuation byte
    ///   returns `nil`.
    public func samePosition(in characters: String) -> Index?
}

/// A type that can be initialized by string interpolation with a string
/// literal that includes expressions.
///
/// Use string interpolation to include one or more expressions in a string
/// literal, wrapped in a set of parentheses and prefixed by a backslash. For
/// example:
///
///     let price = 2
///     let number = 3
///     let message = "One cookie: $\(price), \(number) cookies: $\(price * number)."
///     print(message)
///     // Prints "One cookie: $2, 3 cookies: $6."
///
/// Conforming to the StringInterpolationConvertible Protocol
/// =========================================================
///
/// To use string interpolation to initialize instances of your custom type,
/// implement the required initializers for `StringInterpolationConvertible`
/// conformance. String interpolation is a multiple-step initialization
/// process. When you use string interpolation, the following steps occur:
///
/// 1. The string literal is broken into pieces. Each segment of the string
///    literal before, between, and after any included expressions, along with
///    the individual expressions themselves, are passed to the
///    `init(stringInterpolationSegment:)` initializer.
/// 2. The results of those calls are passed to the
///    `init(stringInterpolation:)` initializer in the order in which they
///    appear in the string literal.
///
/// In other words, initializing the `message` constant in the example above
/// using string interpolation is equivalent to the following code:
///
///     let message = String(stringInterpolation:
///           String(stringInterpolationSegment: "One cookie: $"),
///           String(stringInterpolationSegment: price),
///           String(stringInterpolationSegment: ", "),
///           String(stringInterpolationSegment: number),
///           String(stringInterpolationSegment: " cookies: $"),
///           String(stringInterpolationSegment: price * number),
///           String(stringInterpolationSegment: "."))
public protocol StringInterpolationConvertible {

    /// Creates an instance by concatenating the given values.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use string interpolation. For example:
    ///
    ///     let s = "\(5) x \(2) = \(5 * 2)"
    ///     print(s)
    ///     // Prints "5 x 2 = 10"
    ///
    /// After calling `init(stringInterpolationSegment:)` with each segment of
    /// the string literal, this initializer is called with their string
    /// representations.
    ///
    /// - Parameter strings: An array of instances of the conforming type.
    public init(stringInterpolation strings: Self...)

    /// Creates an instance containing the appropriate representation for the
    /// given value.
    ///
    /// Do not call this initializer directly. It is used by the compiler for
    /// each string interpolation segment when you use string interpolation. For
    /// example:
    ///
    ///     let s = "\(5) x \(2) = \(5 * 2)"
    ///     print(s)
    ///     // Prints "5 x 2 = 10"
    ///
    /// This initializer is called five times when processing the string literal
    /// in the example above; once each for the following: the integer `5`, the
    /// string `" x "`, the integer `2`, the string `" = "`, and the result of
    /// the expression `5 * 2`.
    ///
    /// - Parameter expr: The expression to represent.
    public init<T>(stringInterpolationSegment expr: T)
}

/// A type that can be initialized with a string literal.
///
/// The `String` and `StaticString` types conform to the
/// `StringLiteralConvertible` protocol. You can initialize a variable or
/// constant of either of these types using a string literal of any length.
///
///     let picnicGuest = "Deserving porcupine"
///
/// Conforming to StringLiteralConvertible
/// ======================================
///
/// To add `StringLiteralConvertible` conformance to your custom type,
/// implement the required initializer.
public protocol StringLiteralConvertible : ExtendedGraphemeClusterLiteralConvertible {

    /// A type that can represent a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    associatedtype StringLiteralType

    /// Creates an instance initialized to the given string value.
    public init(stringLiteral value: Self.StringLiteralType)
}

/// The default type for an otherwise-unconstrained string literal.
public typealias StringLiteralType = String

/// A 64-bit unsigned integer value
/// type.
public struct UInt : UnsignedInteger, Comparable, Equatable {

    /// Create an instance initialized to zero.
    public init()

    public init(_ v: Builtin.Word)

    /// Create an instance initialized to `value`.
    public init(_ value: UInt)

    /// Creates an integer from its big-endian representation, changing the
    /// byte order if necessary.
    public init(bigEndian value: UInt)

    /// Creates an integer from its little-endian representation, changing the
    /// byte order if necessary.
    public init(littleEndian value: UInt)

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: UInt)

    /// Returns the big-endian representation of the integer, changing the
    /// byte order if necessary.
    public var bigEndian: UInt { get }

    /// Returns the little-endian representation of the integer, changing the
    /// byte order if necessary.
    public var littleEndian: UInt { get }

    /// Returns the current integer with the byte order swapped.
    public var byteSwapped: UInt { get }

    public static var max: UInt { get }

    public static var min: UInt { get }
}

extension UInt {

    public init(bitPattern pointer: OpaquePointer?)
}

extension UInt : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension UInt : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension UInt {

    /// Add `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func addWithOverflow(_ lhs: UInt, _ rhs: UInt) -> (UInt, overflow: Bool)

    /// Subtract `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func subtractWithOverflow(_ lhs: UInt, _ rhs: UInt) -> (UInt, overflow: Bool)

    /// Multiply `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func multiplyWithOverflow(_ lhs: UInt, _ rhs: UInt) -> (UInt, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// a result and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func divideWithOverflow(_ lhs: UInt, _ rhs: UInt) -> (UInt, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// the remainder and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func remainderWithOverflow(_ lhs: UInt, _ rhs: UInt) -> (UInt, overflow: Bool)

    /// Represent this number using Swift's widest native unsigned
    /// integer type.
    public func toUIntMax() -> UIntMax

    /// Explicitly convert to `IntMax`, trapping on overflow (except in -Ounchecked builds).
    public func toIntMax() -> IntMax
}

extension UInt {

    public init(_ v: UInt8)

    public init(_ v: Int8)

    public init(_ v: UInt16)

    public init(_ v: Int16)

    public init(_ v: UInt32)

    public init(_ v: Int32)

    /// Convert from Swift's widest unsigned integer type, trapping on
    /// overflow.
    public init(_ v: UInt64)

    /// Construct a `UInt` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt64)

    public init(_ v: Int64)

    /// Construct a `UInt` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int64)

    public init(_ v: Int)

    /// Construct a `UInt` having the same memory representation as
    /// the `Int` `bitPattern`.  No range or overflow checking
    /// occurs, and the resulting `UInt` may not have the same numeric
    /// value as `bitPattern`--it is only guaranteed to use the same
    /// pattern of bits.
    public init(bitPattern: Int)
}

extension UInt : BitwiseOperations {

    /// The empty bitset of type `UInt`.
    public static var allZeros: UInt { get }
}

extension UInt {

    /// Creates a UInt whose value is `other` rounded towards zero.
    public init(_ other: Float)

    /// Creates a UInt whose value is `other` rounded towards zero.
    public init(_ other: Double)

    /// Creates a UInt whose value is `other` rounded towards zero.
    public init(_ other: Float80)
}

extension UInt {

    /// Construct from an ASCII representation in the given `radix`.
    ///
    /// If `text` does not match the regular expression
    /// "[+-]?[0-9a-zA-Z]+", or the value it denotes in the given `radix`
    /// is not representable, the result is `nil`.
    public init?(_ text: String, radix: Int = default)
}

extension UInt : CustomReflectable {

    /// A mirror that reflects the `UInt` instance.
    public var customMirror: Mirror { get }
}

extension UInt : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UInt {

    /// Create a `UInt` that captures the full value of `objectID`.
    public init(_ objectID: ObjectIdentifier)
}

extension UInt {

    public init<U>(bitPattern: UnsafeMutablePointer<U>?)
}

extension UInt {

    public init<U>(bitPattern: UnsafePointer<U>?)
}

extension UInt : CVarArg {
}

/// A 16-bit unsigned integer value
/// type.
public struct UInt16 : UnsignedInteger, Comparable, Equatable {

    /// Create an instance initialized to zero.
    public init()

    /// Create an instance initialized to `value`.
    public init(_ value: UInt16)

    /// Creates an integer from its big-endian representation, changing the
    /// byte order if necessary.
    public init(bigEndian value: UInt16)

    /// Creates an integer from its little-endian representation, changing the
    /// byte order if necessary.
    public init(littleEndian value: UInt16)

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: UInt16)

    /// Returns the big-endian representation of the integer, changing the
    /// byte order if necessary.
    public var bigEndian: UInt16 { get }

    /// Returns the little-endian representation of the integer, changing the
    /// byte order if necessary.
    public var littleEndian: UInt16 { get }

    /// Returns the current integer with the byte order swapped.
    public var byteSwapped: UInt16 { get }

    public static var max: UInt16 { get }

    public static var min: UInt16 { get }
}

extension UInt16 : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension UInt16 : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension UInt16 {

    /// Add `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func addWithOverflow(_ lhs: UInt16, _ rhs: UInt16) -> (UInt16, overflow: Bool)

    /// Subtract `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func subtractWithOverflow(_ lhs: UInt16, _ rhs: UInt16) -> (UInt16, overflow: Bool)

    /// Multiply `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func multiplyWithOverflow(_ lhs: UInt16, _ rhs: UInt16) -> (UInt16, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// a result and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func divideWithOverflow(_ lhs: UInt16, _ rhs: UInt16) -> (UInt16, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// the remainder and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func remainderWithOverflow(_ lhs: UInt16, _ rhs: UInt16) -> (UInt16, overflow: Bool)

    /// Represent this number using Swift's widest native unsigned
    /// integer type.
    public func toUIntMax() -> UIntMax

    /// Explicitly convert to `IntMax`.
    public func toIntMax() -> IntMax
}

extension UInt16 {

    public init(_ v: UInt8)

    public init(_ v: Int8)

    public init(_ v: Int16)

    public init(_ v: UInt32)

    /// Construct a `UInt16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt32)

    public init(_ v: Int32)

    /// Construct a `UInt16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int32)

    /// Convert from Swift's widest unsigned integer type, trapping on
    /// overflow.
    public init(_ v: UInt64)

    /// Construct a `UInt16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt64)

    public init(_ v: Int64)

    /// Construct a `UInt16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int64)

    public init(_ v: UInt)

    /// Construct a `UInt16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt)

    public init(_ v: Int)

    /// Construct a `UInt16` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int)

    /// Construct a `UInt16` having the same memory representation as
    /// the `Int16` `bitPattern`.  No range or overflow checking
    /// occurs, and the resulting `UInt16` may not have the same numeric
    /// value as `bitPattern`--it is only guaranteed to use the same
    /// pattern of bits.
    public init(bitPattern: Int16)
}

extension UInt16 : BitwiseOperations {

    /// The empty bitset of type `UInt16`.
    public static var allZeros: UInt16 { get }
}

extension UInt16 {

    /// Creates a UInt16 whose value is `other` rounded towards zero.
    public init(_ other: Float)

    /// Creates a UInt16 whose value is `other` rounded towards zero.
    public init(_ other: Double)

    /// Creates a UInt16 whose value is `other` rounded towards zero.
    public init(_ other: Float80)
}

extension UInt16 {

    /// Construct from an ASCII representation in the given `radix`.
    ///
    /// If `text` does not match the regular expression
    /// "[+-]?[0-9a-zA-Z]+", or the value it denotes in the given `radix`
    /// is not representable, the result is `nil`.
    public init?(_ text: String, radix: Int = default)
}

extension UInt16 : CustomReflectable {

    /// A mirror that reflects the `UInt16` instance.
    public var customMirror: Mirror { get }
}

extension UInt16 : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension CodeUnit {
}

extension UInt16 : CVarArg {
}

/// A 32-bit unsigned integer value
/// type.
public struct UInt32 : UnsignedInteger, Comparable, Equatable {

    /// Create an instance initialized to zero.
    public init()

    /// Create an instance initialized to `value`.
    public init(_ value: UInt32)

    /// Creates an integer from its big-endian representation, changing the
    /// byte order if necessary.
    public init(bigEndian value: UInt32)

    /// Creates an integer from its little-endian representation, changing the
    /// byte order if necessary.
    public init(littleEndian value: UInt32)

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: UInt32)

    /// Returns the big-endian representation of the integer, changing the
    /// byte order if necessary.
    public var bigEndian: UInt32 { get }

    /// Returns the little-endian representation of the integer, changing the
    /// byte order if necessary.
    public var littleEndian: UInt32 { get }

    /// Returns the current integer with the byte order swapped.
    public var byteSwapped: UInt32 { get }

    public static var max: UInt32 { get }

    public static var min: UInt32 { get }
}

extension UInt32 : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension UInt32 : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension UInt32 {

    /// Add `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func addWithOverflow(_ lhs: UInt32, _ rhs: UInt32) -> (UInt32, overflow: Bool)

    /// Subtract `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func subtractWithOverflow(_ lhs: UInt32, _ rhs: UInt32) -> (UInt32, overflow: Bool)

    /// Multiply `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func multiplyWithOverflow(_ lhs: UInt32, _ rhs: UInt32) -> (UInt32, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// a result and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func divideWithOverflow(_ lhs: UInt32, _ rhs: UInt32) -> (UInt32, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// the remainder and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func remainderWithOverflow(_ lhs: UInt32, _ rhs: UInt32) -> (UInt32, overflow: Bool)

    /// Represent this number using Swift's widest native unsigned
    /// integer type.
    public func toUIntMax() -> UIntMax

    /// Explicitly convert to `IntMax`.
    public func toIntMax() -> IntMax
}

extension UInt32 {

    public init(_ v: UInt8)

    public init(_ v: Int8)

    public init(_ v: UInt16)

    public init(_ v: Int16)

    public init(_ v: Int32)

    /// Convert from Swift's widest unsigned integer type, trapping on
    /// overflow.
    public init(_ v: UInt64)

    /// Construct a `UInt32` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt64)

    public init(_ v: Int64)

    /// Construct a `UInt32` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int64)

    public init(_ v: UInt)

    /// Construct a `UInt32` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt)

    public init(_ v: Int)

    /// Construct a `UInt32` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int)

    /// Construct a `UInt32` having the same memory representation as
    /// the `Int32` `bitPattern`.  No range or overflow checking
    /// occurs, and the resulting `UInt32` may not have the same numeric
    /// value as `bitPattern`--it is only guaranteed to use the same
    /// pattern of bits.
    public init(bitPattern: Int32)
}

extension UInt32 : BitwiseOperations {

    /// The empty bitset of type `UInt32`.
    public static var allZeros: UInt32 { get }
}

extension UInt32 {

    /// Creates a UInt32 whose value is `other` rounded towards zero.
    public init(_ other: Float)

    /// Creates a UInt32 whose value is `other` rounded towards zero.
    public init(_ other: Double)

    /// Creates a UInt32 whose value is `other` rounded towards zero.
    public init(_ other: Float80)
}

extension UInt32 {

    /// Construct from an ASCII representation in the given `radix`.
    ///
    /// If `text` does not match the regular expression
    /// "[+-]?[0-9a-zA-Z]+", or the value it denotes in the given `radix`
    /// is not representable, the result is `nil`.
    public init?(_ text: String, radix: Int = default)
}

extension UInt32 : CustomReflectable {

    /// A mirror that reflects the `UInt32` instance.
    public var customMirror: Mirror { get }
}

extension UInt32 : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UInt32 {

    /// Construct with value `v.value`.
    ///
    /// - Precondition: `v.value` can be represented as UInt32.
    public init(_ v: UnicodeScalar)
}

extension UInt32 : CVarArg {
}

/// A 64-bit unsigned integer value
/// type.
public struct UInt64 : UnsignedInteger, Comparable, Equatable {

    /// Create an instance initialized to zero.
    public init()

    /// Create an instance initialized to `value`.
    public init(_ value: UInt64)

    /// Creates an integer from its big-endian representation, changing the
    /// byte order if necessary.
    public init(bigEndian value: UInt64)

    /// Creates an integer from its little-endian representation, changing the
    /// byte order if necessary.
    public init(littleEndian value: UInt64)

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: UInt64)

    /// Returns the big-endian representation of the integer, changing the
    /// byte order if necessary.
    public var bigEndian: UInt64 { get }

    /// Returns the little-endian representation of the integer, changing the
    /// byte order if necessary.
    public var littleEndian: UInt64 { get }

    /// Returns the current integer with the byte order swapped.
    public var byteSwapped: UInt64 { get }

    public static var max: UInt64 { get }

    public static var min: UInt64 { get }
}

extension UInt64 : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension UInt64 : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension UInt64 {

    /// Add `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func addWithOverflow(_ lhs: UInt64, _ rhs: UInt64) -> (UInt64, overflow: Bool)

    /// Subtract `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func subtractWithOverflow(_ lhs: UInt64, _ rhs: UInt64) -> (UInt64, overflow: Bool)

    /// Multiply `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func multiplyWithOverflow(_ lhs: UInt64, _ rhs: UInt64) -> (UInt64, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// a result and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func divideWithOverflow(_ lhs: UInt64, _ rhs: UInt64) -> (UInt64, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// the remainder and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func remainderWithOverflow(_ lhs: UInt64, _ rhs: UInt64) -> (UInt64, overflow: Bool)

    /// Represent this number using Swift's widest native unsigned
    /// integer type.
    public func toUIntMax() -> UIntMax

    /// Explicitly convert to `IntMax`, trapping on overflow (except in -Ounchecked builds).
    public func toIntMax() -> IntMax
}

extension UInt64 {

    public init(_ v: UInt8)

    public init(_ v: Int8)

    public init(_ v: UInt16)

    public init(_ v: Int16)

    public init(_ v: UInt32)

    public init(_ v: Int32)

    public init(_ v: Int64)

    public init(_ v: UInt)

    public init(_ v: Int)

    /// Construct a `UInt64` having the same memory representation as
    /// the `Int64` `bitPattern`.  No range or overflow checking
    /// occurs, and the resulting `UInt64` may not have the same numeric
    /// value as `bitPattern`--it is only guaranteed to use the same
    /// pattern of bits.
    public init(bitPattern: Int64)
}

extension UInt64 : BitwiseOperations {

    /// The empty bitset of type `UInt64`.
    public static var allZeros: UInt64 { get }
}

extension UInt64 {

    /// Creates a UInt64 whose value is `other` rounded towards zero.
    public init(_ other: Float)

    /// Creates a UInt64 whose value is `other` rounded towards zero.
    public init(_ other: Double)

    /// Creates a UInt64 whose value is `other` rounded towards zero.
    public init(_ other: Float80)
}

extension UInt64 {

    /// Construct from an ASCII representation in the given `radix`.
    ///
    /// If `text` does not match the regular expression
    /// "[+-]?[0-9a-zA-Z]+", or the value it denotes in the given `radix`
    /// is not representable, the result is `nil`.
    public init?(_ text: String, radix: Int = default)
}

extension UInt64 : CustomReflectable {

    /// A mirror that reflects the `UInt64` instance.
    public var customMirror: Mirror { get }
}

extension UInt64 : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UInt64 {

    /// Construct with value `v.value`.
    ///
    /// - Precondition: `v.value` can be represented as UInt64.
    public init(_ v: UnicodeScalar)
}

extension UInt64 : CVarArg {
}

/// An 8-bit unsigned integer value
/// type.
public struct UInt8 : UnsignedInteger, Comparable, Equatable {

    /// Create an instance initialized to zero.
    public init()

    /// Create an instance initialized to `value`.
    public init(_ value: UInt8)

    public init(_builtinIntegerLiteral value: Builtin.Int2048)

    /// Create an instance initialized to `value`.
    public init(integerLiteral value: UInt8)

    public static var max: UInt8 { get }

    public static var min: UInt8 { get }
}

extension UInt8 : Hashable {

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }
}

extension UInt8 : CustomStringConvertible {

    /// A textual representation of `self`.
    public var description: String { get }
}

extension UInt8 {

    /// Add `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func addWithOverflow(_ lhs: UInt8, _ rhs: UInt8) -> (UInt8, overflow: Bool)

    /// Subtract `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func subtractWithOverflow(_ lhs: UInt8, _ rhs: UInt8) -> (UInt8, overflow: Bool)

    /// Multiply `lhs` and `rhs`, returning a result and a
    /// `Bool` that is `true` iff the operation caused an arithmetic
    /// overflow.
    public static func multiplyWithOverflow(_ lhs: UInt8, _ rhs: UInt8) -> (UInt8, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// a result and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func divideWithOverflow(_ lhs: UInt8, _ rhs: UInt8) -> (UInt8, overflow: Bool)

    /// Divide `lhs` and `rhs`, returning
    /// the remainder and a `Bool`
    /// that is `true` iff the operation caused an arithmetic overflow.
    public static func remainderWithOverflow(_ lhs: UInt8, _ rhs: UInt8) -> (UInt8, overflow: Bool)

    /// Represent this number using Swift's widest native unsigned
    /// integer type.
    public func toUIntMax() -> UIntMax

    /// Explicitly convert to `IntMax`.
    public func toIntMax() -> IntMax
}

extension UInt8 {

    public init(_ v: Int8)

    public init(_ v: UInt16)

    /// Construct a `UInt8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt16)

    public init(_ v: Int16)

    /// Construct a `UInt8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int16)

    public init(_ v: UInt32)

    /// Construct a `UInt8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt32)

    public init(_ v: Int32)

    /// Construct a `UInt8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int32)

    /// Convert from Swift's widest unsigned integer type, trapping on
    /// overflow.
    public init(_ v: UInt64)

    /// Construct a `UInt8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt64)

    public init(_ v: Int64)

    /// Construct a `UInt8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int64)

    public init(_ v: UInt)

    /// Construct a `UInt8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: UInt)

    public init(_ v: Int)

    /// Construct a `UInt8` having the same bitwise representation as
    /// the least significant bits of the provided bit pattern.
    ///
    /// No range or overflow checking occurs.
    public init(truncatingBitPattern: Int)

    /// Construct a `UInt8` having the same memory representation as
    /// the `Int8` `bitPattern`.  No range or overflow checking
    /// occurs, and the resulting `UInt8` may not have the same numeric
    /// value as `bitPattern`--it is only guaranteed to use the same
    /// pattern of bits.
    public init(bitPattern: Int8)
}

extension UInt8 : BitwiseOperations {

    /// The empty bitset of type `UInt8`.
    public static var allZeros: UInt8 { get }
}

extension UInt8 {

    /// Creates a UInt8 whose value is `other` rounded towards zero.
    public init(_ other: Float)

    /// Creates a UInt8 whose value is `other` rounded towards zero.
    public init(_ other: Double)

    /// Creates a UInt8 whose value is `other` rounded towards zero.
    public init(_ other: Float80)
}

extension UInt8 {

    /// Construct from an ASCII representation in the given `radix`.
    ///
    /// If `text` does not match the regular expression
    /// "[+-]?[0-9a-zA-Z]+", or the value it denotes in the given `radix`
    /// is not representable, the result is `nil`.
    public init?(_ text: String, radix: Int = default)
}

extension UInt8 : CustomReflectable {

    /// A mirror that reflects the `UInt8` instance.
    public var customMirror: Mirror { get }
}

extension UInt8 : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension CodeUnit {
}

extension UInt8 {

    /// Construct with value `v.value`.
    ///
    /// - Precondition: `v.value` can be represented as ASCII (0..<128).
    public init(ascii v: UnicodeScalar)
}

extension UInt8 : CVarArg {
}

/// The largest native unsigned integer type.
public typealias UIntMax = UInt64

/// A codec for translating between Unicode scalar values and UTF-16 code
/// units.
public struct UTF16 : UnicodeCodec {

    /// A type that can hold code unit values for this encoding.
    public typealias CodeUnit = UInt16

    /// Creates an instance of the UTF-16 codec.
    public init()

    /// Starts or continues decoding a UTF-16 sequence.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `UnicodeScalar` or an error.
    ///
    /// The following example decodes the UTF-16 encoded bytes of a string into an
    /// array of `UnicodeScalar` instances. This is a demonstration only---if
    /// you need the Unicode scalar representation of a string, use its
    /// `unicodeScalars` view.
    ///
    ///     let str = "Unicode"
    ///     print(Array(str.utf16))
    ///     // Prints "[10024, 85, 110, 105, 99, 111, 100, 101, 10024]"
    ///
    ///     var codeUnitIterator = str.utf16.makeIterator()
    ///     var scalars: [UnicodeScalar] = []
    ///     var utf16Decoder = UTF16()
    ///     Decode: while true {
    ///         switch utf16Decoder.decode(&codeUnitIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter next: An iterator of code units to be decoded. `next` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    public mutating func decode<I : IteratorProtocol where I.Element == CodeUnit>(_ input: inout I) -> UnicodeDecodingResult

    /// Encodes a Unicode scalar as a series of code units by calling the given
    /// closure on each code unit.
    ///
    /// For example, the musical fermata symbol ("") is a single Unicode scalar
    /// value (`\u{1D110}`) but requires two code units for its UTF-16
    /// representation. The following code encodes a fermata in UTF-16:
    ///
    ///     var codeUnits: [UTF16.CodeUnit] = []
    ///     UTF16.encode("", sendingOutputTo: { codeUnits.append($0) })
    ///     print(codeUnits)
    ///     // Prints "[55348, 56592]"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    public static func encode(_ input: UnicodeScalar, sendingOutputTo processCodeUnit: @noescape (CodeUnit) -> Swift.Void)
}

extension UTF16 {

    /// Returns the number of code units required to encode the given Unicode
    /// scalar.
    ///
    /// Because a Unicode scalar value can require up to 21 bits to store its
    /// value, some Unicode scalars are represented in UTF-16 by a pair of
    /// 16-bit code units. The first and second code units of the pair,
    /// designated *leading* and *trailing* surrogates, make up a *surrogate
    /// pair*.
    ///
    ///     let anA: UnicodeScalar = "A"
    ///     print(anA.value)
    ///     // Prints "65"
    ///     print(UTF16.width(anA))
    ///     // Prints "1"
    ///
    ///     let anApple: UnicodeScalar = ""
    ///     print(anApple.value)
    ///     // Prints "127822"
    ///     print(UTF16.width(anApple))
    ///     // Prints "2"
    ///
    /// - Parameter x: A Unicode scalar value.
    /// - Returns: The width of `x` when encoded in UTF-16, either `1` or `2`.
    public static func width(_ x: UnicodeScalar) -> Int

    /// Returns the high-surrogate code unit of the surrogate pair representing
    /// the specifed Unicode scalar.
    ///
    /// Because a Unicode scalar value can require up to 21 bits to store its
    /// value, some Unicode scalars are represented in UTF-16 by a pair of
    /// 16-bit code units. The first and second code units of the pair,
    /// designated *leading* and *trailing* surrogates, make up a *surrogate
    /// pair*.
    ///
    ///     let apple: UnicodeScalar = ""
    ///     print(UTF16.leadSurrogate(apple)
    ///     // Prints "55356"
    ///
    /// - Parameter x: A Unicode scalar value. `x` must be represented by a
    ///   surrogate pair when encoded in UTF-16. To check whether `x` is
    ///   represented by a surrogate pair, use `UTF16.width(x) == 2`.
    /// - Returns: The leading surrogate code unit of `x` when encoded in UTF-16.
    ///
    /// - SeeAlso: `UTF16.width(_:)`, `UTF16.trailSurrogate(_:)`
    public static func leadSurrogate(_ x: UnicodeScalar) -> CodeUnit

    /// Returns the low-surrogate code unit of the surrogate pair representing
    /// the specifed Unicode scalar.
    ///
    /// Because a Unicode scalar value can require up to 21 bits to store its
    /// value, some Unicode scalars are represented in UTF-16 by a pair of
    /// 16-bit code units. The first and second code units of the pair,
    /// designated *leading* and *trailing* surrogates, make up a *surrogate
    /// pair*.
    ///
    ///     let apple: UnicodeScalar = ""
    ///     print(UTF16.trailSurrogate(apple)
    ///     // Prints "57166"
    ///
    /// - Parameter x: A Unicode scalar value. `x` must be represented by a
    ///   surrogate pair when encoded in UTF-16. To check whether `x` is
    ///   represented by a surrogate pair, use `UTF16.width(x) == 2`.
    /// - Returns: The trailing surrogate code unit of `x` when encoded in UTF-16.
    ///
    /// - SeeAlso: `UTF16.width(_:)`, `UTF16.leadSurrogate(_:)`
    public static func trailSurrogate(_ x: UnicodeScalar) -> CodeUnit

    /// Returns a Boolean value indicating whether the specified code unit is a
    /// high-surrogate code unit.
    ///
    /// Here's an example of checking whether each code unit in a string's
    /// `utf16` view is a lead surrogate. The `apple` string contains a single
    /// emoji character made up of a surrogate pair when encoded in UTF-16.
    ///
    ///     let apple = ""
    ///     for unit in apple.utf16 {
    ///         print(UTF16.isLeadSurrogate(unit))
    ///     }
    ///     // Prints "true"
    ///     // Prints "false"
    ///
    /// This method does not validate the encoding of a UTF-16 sequence beyond
    /// the specified code unit. Specifically, it does not validate that a
    /// low-surrogate code unit follows `x`.
    ///
    /// - Parameter x: A UTF-16 code unit.
    /// - Returns: `true` if `x` is a high-surrogate code unit; otherwise,
    ///   `false`.
    ///
    /// - SeeAlso: `UTF16.width(_:)`, `UTF16.leadSurrogate(_:)`
    public static func isLeadSurrogate(_ x: CodeUnit) -> Bool

    /// Returns a Boolean value indicating whether the specified code unit is a
    /// low-surrogate code unit.
    ///
    /// Here's an example of checking whether each code unit in a string's
    /// `utf16` view is a trailing surrogate. The `apple` string contains a
    /// single emoji character made up of a surrogate pair when encoded in
    /// UTF-16.
    ///
    ///     let apple = ""
    ///     for unit in apple.utf16 {
    ///         print(UTF16.isTrailSurrogate(unit))
    ///     }
    ///     // Prints "false"
    ///     // Prints "true"
    ///
    /// This method does not validate the encoding of a UTF-16 sequence beyond
    /// the specified code unit. Specifically, it does not validate that a
    /// high-surrogate code unit precedes `x`.
    ///
    /// - Parameter x: A UTF-16 code unit.
    /// - Returns: `true` if `x` is a low-surrogate code unit; otherwise,
    ///   `false`.
    ///
    /// - SeeAlso: `UTF16.width(_:)`, `UTF16.leadSurrogate(_:)`
    public static func isTrailSurrogate(_ x: CodeUnit) -> Bool

    /// Returns the number of UTF-16 code units required for the given code unit
    /// sequence when transcoded to UTF-16, and a Boolean value indicating
    /// whether the sequence was found to contain only ASCII characters.
    ///
    /// The following example finds the length of the UTF-16 encoding of the
    /// string `"Fermata "`, starting with its UTF-8 representation.
    ///
    ///     let fermata = "Fermata "
    ///     let bytes = fermata.utf8
    ///     print(Array(bytes))
    ///     // Prints "[70, 101, 114, 109, 97, 116, 97, 32, 240, 157, 132, 144]"
    ///
    ///     let result = transcodedLength(of: bytes.makeIterator(),
    ///                                   decodedAs: UTF8.self,
    ///                                   repairingIllFormedSequences: false)
    ///     print(result)
    ///     // Prints "Optional((10, false))"
    ///
    /// - Parameters:
    ///   - input: An iterator of code units to be translated, encoded as
    ///     `sourceEncoding`. If `repairingIllFormedSequences` is `true`, the
    ///     entire iterator will be exhausted. Otherwise, iteration will stop if
    ///     an ill-formed sequence is detected.
    ///   - sourceEncoding: The Unicode encoding of `input`.
    ///   - repairingIllFormedSequences: Pass `true` to measure the length of
    ///     `input` even when `input` contains ill-formed sequences. Each
    ///     ill-formed sequence is replaced with a Unicode replacement character
    ///     (`"\u{FFFD}"`) and is measured as such. Pass `false` to immediately
    ///     stop measuring `input` when an ill-formed sequence is encountered.
    /// - Returns: A tuple containing the number of UTF-16 code units required to
    ///   encode `input` and a Boolean value that indicates whether the `input`
    ///   contained only ASCII characters. If `repairingIllFormedSequences` is
    ///   `false` and an ill-formed sequence is detected, this method returns
    ///   `nil`.
    public static func transcodedLength<Encoding : UnicodeCodec, Input : IteratorProtocol where Encoding.CodeUnit == Input.Element>(of input: Input, decodedAs sourceEncoding: Encoding.Type, repairingIllFormedSequences: Bool) -> (count: Int, isASCII: Bool)?
}

/// A codec for translating between Unicode scalar values and UTF-32 code
/// units.
public struct UTF32 : UnicodeCodec {

    /// A type that can hold code unit values for this encoding.
    public typealias CodeUnit = UInt32

    /// Creates an instance of the UTF-32 codec.
    public init()

    /// Starts or continues decoding a UTF-32 sequence.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `UnicodeScalar` or an error.
    ///
    /// The following example decodes the UTF-16 encoded bytes of a string
    /// into an array of `UnicodeScalar` instances. This is a demonstration
    /// only---if you need the Unicode scalar representation of a string, use
    /// its `unicodeScalars` view.
    ///
    ///     // UTF-32 representation of "Unicode"
    ///     let codeUnits: [UTF32.CodeUnit] =
    ///             [10024, 85, 110, 105, 99, 111, 100, 101, 10024]
    ///
    ///     var codeUnitIterator = codeUnits.makeIterator()
    ///     var scalars: [UnicodeScalar] = []
    ///     var utf32Decoder = UTF32()
    ///     Decode: while true {
    ///         switch utf32Decoder.decode(&codeUnitIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter next: An iterator of code units to be decoded. `next` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    public mutating func decode<I : IteratorProtocol where I.Element == CodeUnit>(_ input: inout I) -> UnicodeDecodingResult

    /// Encodes a Unicode scalar as a UTF-32 code unit by calling the given
    /// closure.
    ///
    /// For example, like every Unicode scalar, the musical fermata symbol ("")
    /// can be represented in UTF-32 as a single code unit. The following code
    /// encodes a fermata in UTF-32:
    ///
    ///     var codeUnit: UTF32.CodeUnit = 0
    ///     UTF32.encode("", sendingOutputTo: { codeUnit = $0 })
    ///     print(codeUnit)
    ///     // Prints "119056"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    public static func encode(_ input: UnicodeScalar, sendingOutputTo processCodeUnit: @noescape (CodeUnit) -> Swift.Void)
}

/// A codec for translating between Unicode scalar values and UTF-8 code
/// units.
public struct UTF8 : UnicodeCodec {

    /// A type that can hold code unit values for this encoding.
    public typealias CodeUnit = UInt8

    /// Creates an instance of the UTF-8 codec.
    public init()

    /// Starts or continues decoding a UTF-8 sequence.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `UnicodeScalar` or an error.
    ///
    /// The following example decodes the UTF-8 encoded bytes of a string into an
    /// array of `UnicodeScalar` instances. This is a demonstration only---if
    /// you need the Unicode scalar representation of a string, use its
    /// `unicodeScalars` view.
    ///
    ///     let str = "Unicode"
    ///     print(Array(str.utf8))
    ///     // Prints "[226, 156, 168, 85, 110, 105, 99, 111, 100, 101, 226, 156, 168]"
    ///
    ///     var bytesIterator = str.utf8.makeIterator()
    ///     var scalars: [UnicodeScalar] = []
    ///     var utf8Decoder = UTF8()
    ///     Decode: while true {
    ///         switch utf8Decoder.decode(&bytesIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter next: An iterator of code units to be decoded. `next` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    public mutating func decode<I : IteratorProtocol where I.Element == CodeUnit>(_ next: inout I) -> UnicodeDecodingResult

    /// Encodes a Unicode scalar as a series of code units by calling the given
    /// closure on each code unit.
    ///
    /// For example, the musical fermata symbol ("") is a single Unicode scalar
    /// value (`\u{1D110}`) but requires four code units for its UTF-8
    /// representation. The following code encodes a fermata in UTF-8:
    ///
    ///     var bytes: [UTF8.CodeUnit] = []
    ///     UTF8.encode("", sendingOutputTo: { bytes.append($0) })
    ///     print(bytes)
    ///     // Prints "[240, 157, 132, 144]"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    public static func encode(_ input: UnicodeScalar, sendingOutputTo processCodeUnit: @noescape (CodeUnit) -> Swift.Void)

    /// Returns a Boolean value indicating whether the specified code unit is a
    /// UTF-8 continuation byte.
    ///
    /// Continuation bytes take the form `0b10xxxxxx`. For example, a lowercase
    /// "e" with an acute accent above it (`""`) uses 2 bytes for its UTF-8
    /// representation: `0b11000011` (195) and `0b10101001` (169). The second
    /// byte is a continuation byte.
    ///
    ///     let eAcute = ""
    ///     for codePoint in eAcute.utf8 {
    ///         print(codePoint, UTF8.isContinuation(codePoint))
    ///     }
    ///     // Prints "195 false"
    ///     // Prints "169 true"
    ///
    /// - Parameter byte: A UTF-8 code unit.
    /// - Returns: `true` if `byte` is a continuation byte; otherwise, `false`.
    public static func isContinuation(_ byte: CodeUnit) -> Bool
}

/// A Unicode encoding form that translates between Unicode scalar values and
/// form-specific code units.
///
/// The `UnicodeCodec` protocol declares methods that decode code unit
/// sequences into Unicode scalar values and encode Unicode scalar values
/// into code unit sequences. The standard library implements codecs for the
/// UTF-8, UTF-16, and UTF-32 encoding schemes as the `UTF8`, `UTF16`, and
/// `UTF32` types, respectively. Use the `UnicodeScalar` type to work with
/// decoded Unicode scalar values.
///
/// - SeeAlso: `UTF8`, `UTF16`, `UTF32`, `UnicodeScalar`
public protocol UnicodeCodec {

    /// A type that can hold code unit values for this encoding.
    associatedtype CodeUnit

    /// Creates an instance of the codec.
    public init()

    /// Starts or continues decoding a code unit sequence into Unicode scalar
    /// values.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `UnicodeScalar` or an error.
    ///
    /// The following example decodes the UTF-8 encoded bytes of a string into an
    /// array of `UnicodeScalar` instances:
    ///
    ///     let str = "Unicode"
    ///     print(Array(str.utf8))
    ///     // Prints "[226, 156, 168, 85, 110, 105, 99, 111, 100, 101, 226, 156, 168]"
    ///
    ///     var bytesIterator = str.utf8.makeIterator()
    ///     var scalars: [UnicodeScalar] = []
    ///     var utf8Decoder = UTF8()
    ///     Decode: while true {
    ///         switch utf8Decoder.decode(&bytesIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter next: An iterator of code units to be decoded. `next` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    public mutating func decode<I : IteratorProtocol where I.Element == CodeUnit>(_ next: inout I) -> UnicodeDecodingResult

    /// Encodes a Unicode scalar as a series of code units by calling the given
    /// closure on each code unit.
    ///
    /// For example, the musical fermata symbol ("") is a single Unicode scalar
    /// value (`\u{1D110}`) but requires four code units for its UTF-8
    /// representation. The following code uses the `UTF8` codec to encode a
    /// fermata in UTF-8:
    ///
    ///     var bytes: [UTF8.CodeUnit] = []
    ///     UTF8.encode("", sendingOutputTo: { bytes.append($0) })
    ///     print(bytes)
    ///     // Prints "[240, 157, 132, 144]"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    public static func encode(_ input: UnicodeScalar, sendingOutputTo processCodeUnit: @noescape (Self.CodeUnit) -> Swift.Void)
}

/// The result of one Unicode decoding step.
///
/// Each `UnicodeDecodingResult` instance can represent a Unicode scalar value,
/// an indication that no more Unicode scalars are available, or an indication
/// of a decoding error.
/// 
/// - SeeAlso: `UnicodeCodec.decode(next:)`
public enum UnicodeDecodingResult : Equatable {

    /// A decoded Unicode scalar value.
    case scalarValue(UnicodeScalar)

    /// An indication that no more Unicode scalars are available in the input.
    case emptyInput

    /// An indication of a decoding error.
    case error
}

/// A Unicode scalar value.
///
/// The `UnicodeScalar` type, representing a single Unicode scalar value, is
/// the element type of a string's `unicodeScalars` collection.
///
/// You can create a `UnicodeScalar` instance by using a string literal that
/// contains a single character representing exactly one Unicode scalar value.
///
///     let letterK: UnicodeScalar = "K"
///     let kim: UnicodeScalar = ""
///     print(letterK, kim)
///     // Prints "K "
///
/// You can also create Unicode scalar values directly from their numeric
/// representation.
///
///     let airplane = UnicodeScalar(9992)
///     print(airplane)
///     // Prints ""
public struct UnicodeScalar : UnicodeScalarLiteralConvertible {

    /// A numeric representation of the Unicode scalar.
    public var value: UInt32 { get }

    public init(_builtinUnicodeScalarLiteral value: Builtin.Int32)

    /// Creates a Unicode scalar with the specified value.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you use a string literal to initialize a `UnicodeScalar` instance.
    ///
    ///     let letterK: UnicodeScalar = "K"
    ///     print(letterK)
    ///     // Prints "K"
    ///
    /// In this example, the assignment to the `letterK` constant is handled by
    /// this initializer behind the scenes.
    public init(unicodeScalarLiteral value: UnicodeScalar)

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// For example, the following code sample creates a `UnicodeScalar` instance
    /// with a value of an emoji character:
    ///
    ///     let codepoint: UInt32 = 127881
    ///     let emoji = UnicodeScalar(codepoint)
    ///     print(emoji)
    ///     // Prints ""
    ///
    /// - Parameter v: The Unicode code point to use for the scalar. `v` must be
    ///   a valid Unicode scalar value, in the range `0...0xD7FF` or
    ///   `0xE000...0x10FFFF`.
    public init(_ v: UInt32)

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// For example, the following code sample creates a `UnicodeScalar` instance
    /// with a value of ``, the Korean word for rice:
    ///
    ///     let codepoint: UInt16 = 48165
    ///     let bap = UnicodeScalar(codepoint)
    ///     print(bap)
    ///     // Prints ""
    ///
    /// - Parameter v: The Unicode code point to use for the scalar. `v` must be
    ///   a valid Unicode scalar value, in the range `0...0xD7FF` or
    ///   `0xE000...0xFFFF`.
    public init(_ v: UInt16)

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// For example, the following code sample creates a `UnicodeScalar` instance
    /// with a value of `7`:
    ///
    ///     let codepoint: UInt8 = 55
    ///     let seven = UnicodeScalar(codepoint)
    ///     print(seven)
    ///     // Prints "7"
    ///
    /// - Parameter v: The code point to use for the scalar.
    public init(_ v: UInt8)

    /// Creates a duplicate of the given Unicode scalar.
    public init(_ v: UnicodeScalar)

    /// Returns a string representation of the Unicode scalar.
    ///
    /// Scalar values representing characters that are normally unprintable or
    /// that otherwise require escaping are escaped with a backslash.
    ///
    ///     let tab = UnicodeScalar(9)
    ///     print(tab)
    ///     // Prints " "
    ///     print(tab.escaped(asASCII: false))
    ///     // Prints "\t"
    ///
    /// When the `forceASCII` parameter is `true`, a `UnicodeScalar` instance
    /// with a value greater than 127 is represented using an escaped numeric
    /// value; otherwise, non-ASCII characters are represented using their
    /// typical string value.
    ///
    ///     let bap = UnicodeScalar(48165)
    ///     print(bap.escaped(asASCII: false))
    ///     // Prints ""
    ///     print(bap.escaped(asASCII: true))
    ///     // Prints "\u{BC25}"
    ///
    /// - Parameter forceASCII: Pass `true` if you need the result to use only
    ///   ASCII characters; otherwise, pass `false`.
    /// - Returns: A string representation of the scalar.
    public func escaped(asASCII forceASCII: Bool) -> String

    /// A Boolean value indicating whether the Unicode scalar is an ASCII
    /// character.
    ///
    /// ASCII characters have a scalar value between 0 and 127, inclusive. For
    /// example:
    ///
    ///     let canyon = "Can"
    ///     for scalar in canyon.unicodeScalars {
    ///         print(scalar, scalar.isASCII, scalar.value)
    ///     }
    ///     // Prints "C true 67"
    ///     // Prints "a true 97"
    ///     // Prints " false 241"
    ///     // Prints " false 243"
    ///     // Prints "n true 110"
    public var isASCII: Bool { get }
}

extension UnicodeScalar : CustomReflectable {

    /// A mirror that reflects the `UnicodeScalar` instance.
    public var customMirror: Mirror { get }
}

extension UnicodeScalar : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UnicodeScalar : Streamable {

    /// Writes the textual representation of the Unicode scalar into the given
    /// output stream.
    ///
    /// - Parameter target: An output stream.
    public func write<Target : OutputStream>(to target: inout Target)
}

extension UnicodeScalar : CustomStringConvertible, CustomDebugStringConvertible {

    /// An escaped textual representation of the Unicode scalar.
    public var description: String { get }

    /// An escaped textual representation of the Unicode scalar, suitable for
    /// debugging.
    public var debugDescription: String { get }
}

extension UnicodeScalar : Hashable {

    /// The Unicode scalar's hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }
}

extension UnicodeScalar {

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// For example, the following code sample creates a `UnicodeScalar` instance
    /// with a value of an emoji character:
    ///
    ///     let codepoint = 127881
    ///     let emoji = UnicodeScalar(codepoint)
    ///     print(emoji)
    ///     // Prints ""
    ///
    /// - Parameter v: The Unicode code point to use for the scalar. `v` must be
    ///   a valid Unicode scalar value, in the ranges `0...0xD7FF` or
    ///   `0xE000...0x10FFFF`.
    public init(_ v: Int)
}

extension UnicodeScalar : Comparable, Equatable {
}

/// A type that can be initialized with a string literal containing a single
/// Unicode scalar value.
///
/// The `String`, `StaticString`, `Character`, and `UnicodeScalar` types all
/// conform to the `UnicodeScalarLiteralConvertible` protocol. You can
/// initialize a variable of any of these types using a string literal that
/// holds a single Unicode scalar.
///
///     let : UnicodeScalar = ""
///     print()
///     // Prints ""
///
/// Conforming to UnicodeScalarLiteralConvertible
/// =============================================
///
/// To add `UnicodeScalarLiteralConvertible` conformance to your custom type,
/// implement the required initializer.
public protocol UnicodeScalarLiteralConvertible {

    /// A type that can represent a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `UnicodeScalar`,
    /// `String`, and `StaticString`.
    associatedtype UnicodeScalarLiteralType

    /// Creates an instance initialized to the given value.
    public init(unicodeScalarLiteral value: Self.UnicodeScalarLiteralType)
}

/// The default type for an otherwise-unconstrained unicode scalar literal.
public typealias UnicodeScalarType = String

/// A type for propagating an unmanaged object reference.
///
/// When you use this type, you become partially responsible for
/// keeping the object alive.
public struct Unmanaged<Instance : AnyObject> {

    /// Unsafely turn an opaque C pointer into an unmanaged
    /// class reference.
    ///
    /// This operation does not change reference counts.
    ///
    ///     let str: CFString = Unmanaged.fromOpaque(ptr).takeUnretainedValue()
    public static func fromOpaque(_ value: UnsafePointer<Swift.Void>) -> Unmanaged<Instance>

    /// Unsafely convert an unmanaged class reference to a pointer
    ///
    /// This operation does not change reference counts.
    ///
    ///     let str0: CFString = "boxcar"
    ///     let bits = Unmanaged.passUnretained(str0)
    ///     let str1 = Unmanaged<CFString>(bits).object
    public func toOpaque() -> UnsafeMutablePointer<Swift.Void>

    /// Create an unmanaged reference with an unbalanced retain.
    /// The object will leak if nothing eventually balances the retain.
    ///
    /// This is useful when passing an object to an API which Swift
    /// does not know the ownership rules for, but you know that the
    /// API expects you to pass the object at +1.
    public static func passRetained(_ value: Instance) -> Unmanaged<Instance>

    /// Create an unmanaged reference without performing an unbalanced
    /// retain.
    ///
    /// This is useful when passing a reference to an API which Swift
    /// does not know the ownership rules for, but you know that the
    /// API expects you to pass the object at +0.
    ///
    ///     CFArraySetValueAtIndex(.passUnretained(array), i,
    ///                            .passUnretained(object))
    public static func passUnretained(_ value: Instance) -> Unmanaged<Instance>

    /// Get the value of this unmanaged reference as a managed
    /// reference without consuming an unbalanced retain of it.
    ///
    /// This is useful when a function returns an unmanaged reference
    /// and you know that you're not responsible for releasing the result.
    public func takeUnretainedValue() -> Instance

    /// Get the value of this unmanaged reference as a managed
    /// reference and consume an unbalanced retain of it.
    ///
    /// This is useful when a function returns an unmanaged reference
    /// and you know that you're responsible for releasing the result.
    public func takeRetainedValue() -> Instance

    /// Perform an unbalanced retain of the object.
    public func retain() -> Unmanaged<Instance>

    /// Perform an unbalanced release of the object.
    public func release()

    /// Perform an unbalanced autorelease of the object.
    public func autorelease() -> Unmanaged<Instance>
}

/// A non-owning pointer to buffer of  `Element`s stored
/// contiguously in memory, presenting a `Collection` interface to the
/// underlying elements.
///
/// The pointer should be aligned to `alignof(Element.self)`.
public struct UnsafeBufferPointer<Element> : Indexable, Collection, RandomAccessCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Int

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Int

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying a `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<UnsafeBufferPointer<Element>>

    /// Always zero, which is the index of the first element in a
    /// non-empty buffer.
    public var startIndex: Int { get }

    /// The "past the end" position---that is, the position one greater than the
    /// last valid subscript argument.
    ///
    /// The `endIndex` property of an `UnsafeBufferPointer` instance is
    /// always identical to `count`.
    public var endIndex: Int { get }

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = CountableRange<Int>

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Indices { get }

    /// Access the `i`th element in the buffer.
    public subscript(i: Int) -> Element { get }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Int>) -> RandomAccessSlice<UnsafeBufferPointer<Element>> { get }

    /// Construct an UnsafePointer over the `count` contiguous
    /// `Element` instances beginning at `start`.
    ///
    /// If `start` is nil, `count` must be 0. However, `count` may be 0 even for
    /// a nonzero `start`.
    public init(start: UnsafePointer<Element>?, count: Int)

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> UnsafeBufferPointerIterator<Element>

    /// A pointer to the first element of the buffer.
    public var baseAddress: UnsafePointer<Element>? { get }

    /// The number of elements in the buffer.
    public var count: Int { get }
}

extension UnsafeBufferPointer : CustomDebugStringConvertible {

    /// A textual representation of `self`, suitable for debugging.
    public var debugDescription: String { get }
}

/// An iterator for the elements in the buffer referenced by
/// `UnsafeBufferPointer` or `UnsafeMutableBufferPointer`.
public struct UnsafeBufferPointerIterator<Element> : IteratorProtocol, Sequence {

    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    public mutating func next() -> Element?
}

/// A non-owning pointer to buffer of mutable `Element`s stored
/// contiguously in memory, presenting a `Collection` interface to the
/// underlying elements.
///
/// The pointer should be aligned to `alignof(Element.self)`.
public struct UnsafeMutableBufferPointer<Element> : MutableIndexable, MutableCollection, RandomAccessCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    ///
    /// - SeeAlso: endIndex
    public typealias Index = Int

    /// A type used to represent the number of steps between two indices, where
    /// one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Int

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying a `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<UnsafeMutableBufferPointer<Element>>

    /// Always zero, which is the index of the first element in a
    /// non-empty buffer.
    public var startIndex: Int { get }

    /// The "past the end" position---that is, the position one greater than the
    /// last valid subscript argument.
    ///
    /// The `endIndex` property of an `UnsafeMutableBufferPointer` instance is
    /// always identical to `count`.
    public var endIndex: Int { get }

    /// A type that can represent the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = CountableRange<Int>

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Indices { get }

    /// Access the `i`th element in the buffer.
    public subscript(i: Int) -> Element { get nonmutating set }

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the collection's indices. The upper and
    ///   lower bounds of the `bounds` range must be valid indices of the
    ///   collection.
    public subscript(bounds: Range<Int>) -> MutableRandomAccessSlice<UnsafeMutableBufferPointer<Element>>

    /// Construct an UnsafeMutablePointer over the `count` contiguous
    /// `Element` instances beginning at `start`.
    ///
    /// If `start` is nil, `count` must be 0. However, `count` may be 0 even for
    /// a nonzero `start`.
    public init(start: UnsafeMutablePointer<Element>?, count: Int)

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> UnsafeBufferPointerIterator<Element>

    /// A pointer to the first element of the buffer.
    public var baseAddress: UnsafeMutablePointer<Element>? { get }

    /// The number of elements in the buffer.
    public var count: Int { get }
}

extension UnsafeMutableBufferPointer : CustomDebugStringConvertible {

    /// A textual representation of `self`, suitable for debugging.
    public var debugDescription: String { get }
}

/// A raw pointer for accessing data of type `Pointee`.  This type
/// provides no automated memory management, and therefore must
/// be handled with great care to ensure safety.
///
/// Instances must be aligned to `alignof(Pointee.self)`, i.e.
/// `(UnsafePointer<Int8>(self) - nil) % alignof(Pointee.self) == 0`
///
/// The memory referenced by an instance can be in one of the following states:
///
/// - Memory is not allocated (for example, pointer is null, or memory has
///   been deallocated previously).
///
/// - Memory is allocated, but value has not been initialized.
///
/// - Memory is allocated and value is initialized.
public struct UnsafeMutablePointer<Pointee> : Strideable, Hashable {

    public typealias Distance = Int

    /// Convert from an opaque pointer to a typed pointer.
    public init(_ from: OpaquePointer)

    /// Convert from an opaque pointer to a typed pointer.
    ///
    /// Returns nil if `from` is nil.
    public init?(_ from: OpaquePointer?)

    /// Construct an `UnsafeMutablePointer` with a given pattern of bits.
    public init?(bitPattern: Int)

    /// Construct an `UnsafeMutablePointer` with a given pattern of bits.
    public init?(bitPattern: UInt)

    /// Convert from any `UnsafeMutablePointer`, possibly with a
    /// different `Pointee`.
    ///
    /// - Warning: the behavior of accesses to pointee as a type
    ///   different from that to which it was initialized is undefined.
    public init<U>(_ from: UnsafeMutablePointer<U>)

    /// Convert from any `UnsafeMutablePointer`, possibly with a
    /// different `Pointee`.
    ///
    /// Returns nil if `from` is nil.
    ///
    /// - Warning: the behavior of accesses to pointee as a type
    ///   different from that to which it was initialized is undefined.
    public init?<U>(_ from: UnsafeMutablePointer<U>?)

    /// Convert from any `UnsafePointer`, possibly with a
    /// different `Pointee`.
    ///
    /// - Warning: the behavior of accesses to pointee as a type
    ///   different from that to which it was initialized is undefined.
    public init<U>(_ from: UnsafePointer<U>)

    /// Convert from any `UnsafePointer`, possibly with a
    /// different `Pointee`.
    ///
    /// Returns nil if `from` is nil.
    ///
    /// - Warning: the behavior of accesses to pointee as a type
    ///   different from that to which it was initialized is undefined.
    public init?<U>(_ from: UnsafePointer<U>?)

    /// Allocate and point at uninitialized aligned memory for `count`
    /// instances of `Pointee`.
    ///
    /// - Postcondition: The pointee is allocated, but not initialized.
    public init(allocatingCapacity count: Int)

    /// Deallocate uninitialized memory allocated for `count` instances
    /// of `Pointee`.
    ///
    /// - Precondition: The memory is not initialized.
    ///
    /// - Postcondition: The memory has been deallocated.
    public func deallocateCapacity(_ num: Int)

    /// Access the `Pointee` instance referenced by `self`.
    ///
    /// - Precondition: the pointee has been initialized with an instance of
    ///   type `Pointee`.
    public var pointee: Pointee { get nonmutating set }

    public func initialize(with newValue: Pointee, count: Int = default)

    /// Retrieve the `pointee`, returning the referenced memory to an
    /// uninitialized state.
    ///
    /// Equivalent to `{ defer { deinitialize() }; return pointee }()`, but
    /// more efficient.
    ///
    /// - Precondition: The pointee is initialized.
    ///
    /// - Postcondition: The memory is uninitialized.
    public func move() -> Pointee

    /// Replace `count` initialized `Pointee`s starting at `self` with
    /// the `count` `Pointee`s at `source`, proceeding forward from
    /// `self` to `self + count - 1`.
    ///
    /// - Precondition: `count >= 0`
    ///
    /// - Precondition: `self` either precedes `source` or follows
    ///   `source + count - 1`.
    ///
    /// - Precondition: The `Pointee`s at `self..<self + count` and
    ///   `source..<source + count` are initialized.
    public func assignFrom(_ source: UnsafeMutablePointer<Pointee>, count: Int)

    /// Replace `count` initialized `Pointee`s starting at `self` with
    /// the `count` `Pointee`s at `source`, proceeding backward from
    /// `self + count - 1` to `self`.
    ///
    /// Use `assignBackwardFrom` when copying elements into later memory
    /// that may overlap with the source range.
    ///
    /// - Precondition: `count >= 0`
    ///
    /// - Precondition: `source` either precedes `self` or follows
    ///   `self + count - 1`.
    ///
    /// - Precondition: The `Pointee`s at `self..<self + count` and
    ///   `source..<source + count` are initialized.
    public func assignBackwardFrom(_ source: UnsafeMutablePointer<Pointee>, count: Int)

    /// Initialize memory starting at `self` with `count` `Pointee`s
    /// beginning at `source`, proceeding forward from `self` to `self +
    /// count - 1`, and returning the source memory to an uninitialized
    /// state.
    ///
    /// - Precondition: `count >= 0`
    ///
    /// - Precondition: `self` either precedes `source` or follows `source +
    ///   count - 1`.
    ///
    /// - Precondition: The memory at `self..<self + count` is uninitialized
    ///   and the `Pointees` at `source..<source + count` are
    ///   initialized.
    ///
    /// - Postcondition: The `Pointee`s at `self..<self + count` are
    ///   initialized and the memory at `source..<source + count` is
    ///   uninitialized.
    public func moveInitializeFrom(_ source: UnsafeMutablePointer<Pointee>, count: Int)

    /// Initialize memory starting at `self` with `count` `Pointee`s
    /// beginning at `source`, proceeding backward from `self + count - 1`
    /// to `self`, and returning the source memory to an uninitialized
    /// state.
    ///
    /// - Precondition: `count >= 0`
    ///
    /// - Precondition: `source` either precedes `self` or follows
    ///   `self + count - 1`.
    ///
    /// - Precondition: The memory at `self..<self + count` is uninitialized
    ///   and the `Pointees` at `source..<source + count` are
    ///   initialized.
    ///
    /// - Postcondition: The `Pointee`s at `self..<self + count` are
    ///   initialized and the memory at `source..<source + count` is
    ///   uninitialized.
    public func moveInitializeBackwardFrom(_ source: UnsafeMutablePointer<Pointee>, count: Int)

    /// Initialize memory starting at `self` with `count` `Pointee`s
    /// beginning at `source`, proceeding forward from `self` to `self +
    /// count - 1`.
    ///
    /// - Precondition: `count >= 0`
    ///
    /// - Precondition: `self` either precedes `source` or follows `source +
    ///   count - 1`.
    ///
    /// - Precondition: The memory at `self..<self + count` is uninitialized
    ///   and the `Pointees` at `source..<source + count` are
    ///   initialized.
    ///
    /// - Postcondition: The `Pointee`s at `self..<self + count` and
    ///   `source..<source + count` are initialized.
    public func initializeFrom(_ source: UnsafeMutablePointer<Pointee>, count: Int)

    /// Initialize memory starting at `self` with the elements of `source`.
    ///
    /// - Precondition: The memory at `self..<self + count` is
    ///   uninitialized.
    ///
    /// - Postcondition: The `Pointee`s at `self..<self + count` are
    ///   initialized.
    public func initializeFrom<C : Collection where C.Iterator.Element == Pointee>(_ source: C)

    /// Replace `count` initialized `Pointee`s starting at `self` with
    /// the `count` `Pointee`s starting at `source`, returning the
    /// source memory to an uninitialized state.
    ///
    /// - Precondition: `count >= 0`
    ///
    /// - Precondition: The source and destination ranges do not overlap
    ///
    /// - Precondition: The `Pointee`s at `self..<self + count` and
    ///   `source..<source + count` are initialized.
    ///
    /// - Postcondition: The `Pointee`s at `self..<self + count` are
    ///   initialized and the `Pointees` at `source..<source + count`
    ///   are uninitialized.
    public func moveAssignFrom(_ source: UnsafeMutablePointer<Pointee>, count: Int)

    /// De-initialize the `count` `Pointee`s starting at `self`, returning
    /// their memory to an uninitialized state.
    ///
    /// - Precondition: The `Pointee`s at `self..<self + count` are
    ///   initialized.
    ///
    /// - Postcondition: The memory is uninitialized.
    public func deinitialize(count: Int = default)

    /// Access the pointee at `self + i`.
    ///
    /// - Precondition: the pointee at `self + i` is initialized.
    public subscript(i: Int) -> Pointee { get nonmutating set }

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }

    /// Returns the next consecutive position.
    public func successor() -> UnsafeMutablePointer<Pointee>

    /// Returns the previous consecutive position.
    public func predecessor() -> UnsafeMutablePointer<Pointee>

    /// Return `end - self`.
    public func distance(to x: UnsafeMutablePointer<Pointee>) -> Int

    /// Return `self + n`.
    public func advanced(by n: Int) -> UnsafeMutablePointer<Pointee>
}

extension UnsafeMutablePointer : CustomDebugStringConvertible {

    /// A textual representation of `self`, suitable for debugging.
    public var debugDescription: String { get }
}

extension UnsafeMutablePointer : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension UnsafeMutablePointer : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UnsafeMutablePointer {
}

extension UnsafeMutablePointer : CVarArg {
}

/// A raw pointer for accessing data of type `Pointee`.  This type
/// provides no automated memory management, and therefore must
/// be handled with great care to ensure safety.
///
/// Instances must be aligned to `alignof(Pointee.self)`, i.e.
/// `(UnsafePointer<Int8>(self) - nil) % alignof(Pointee.self) == 0`
///
/// The memory referenced by an instance can be in one of the following states:
///
/// - Memory is not allocated (for example, pointer is null, or memory has
///   been deallocated previously).
///
/// - Memory is allocated, but value has not been initialized.
///
/// - Memory is allocated and value is initialized.
public struct UnsafePointer<Pointee> : Strideable, Hashable {

    public typealias Distance = Int

    /// Convert from an opaque pointer to a typed pointer.
    public init(_ from: OpaquePointer)

    /// Convert from an opaque pointer to a typed pointer.
    ///
    /// Returns nil if `from` is nil.
    public init?(_ from: OpaquePointer?)

    /// Construct an `UnsafePointer` with a given pattern of bits.
    public init?(bitPattern: Int)

    /// Construct an `UnsafePointer` with a given pattern of bits.
    public init?(bitPattern: UInt)

    /// Convert from any `UnsafeMutablePointer`, possibly with a
    /// different `Pointee`.
    ///
    /// - Warning: the behavior of accesses to pointee as a type
    ///   different from that to which it was initialized is undefined.
    public init<U>(_ from: UnsafeMutablePointer<U>)

    /// Convert from any `UnsafeMutablePointer`, possibly with a
    /// different `Pointee`.
    ///
    /// Returns nil if `from` is nil.
    ///
    /// - Warning: the behavior of accesses to pointee as a type
    ///   different from that to which it was initialized is undefined.
    public init?<U>(_ from: UnsafeMutablePointer<U>?)

    /// Convert from any `UnsafePointer`, possibly with a
    /// different `Pointee`.
    ///
    /// - Warning: the behavior of accesses to pointee as a type
    ///   different from that to which it was initialized is undefined.
    public init<U>(_ from: UnsafePointer<U>)

    /// Convert from any `UnsafePointer`, possibly with a
    /// different `Pointee`.
    ///
    /// Returns nil if `from` is nil.
    ///
    /// - Warning: the behavior of accesses to pointee as a type
    ///   different from that to which it was initialized is undefined.
    public init?<U>(_ from: UnsafePointer<U>?)

    /// Access the `Pointee` instance referenced by `self`.
    ///
    /// - Precondition: the pointee has been initialized with an instance of
    ///   type `Pointee`.
    public var pointee: Pointee { get }

    /// Access the pointee at `self + i`.
    ///
    /// - Precondition: the pointee at `self + i` is initialized.
    public subscript(i: Int) -> Pointee { get }

    /// The hash value.
    ///
    /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`.
    ///
    /// - Note: The hash value is not guaranteed to be stable across
    ///   different invocations of the same program.  Do not persist the
    ///   hash value across program runs.
    public var hashValue: Int { get }

    /// Returns the next consecutive position.
    public func successor() -> UnsafePointer<Pointee>

    /// Returns the previous consecutive position.
    public func predecessor() -> UnsafePointer<Pointee>

    /// Return `end - self`.
    public func distance(to x: UnsafePointer<Pointee>) -> Int

    /// Return `self + n`.
    public func advanced(by n: Int) -> UnsafePointer<Pointee>
}

extension UnsafePointer : CustomDebugStringConvertible {

    /// A textual representation of `self`, suitable for debugging.
    public var debugDescription: String { get }
}

extension UnsafePointer : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension UnsafePointer : CustomPlaygroundQuickLookable {

    /// A custom playground quick look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UnsafePointer {
}

extension UnsafePointer : CVarArg {
}

/// A set of common requirements for Swift's unsigned integer types.
public protocol UnsignedInteger : _DisallowMixedSignArithmetic, Integer {

    /// Represent this number using Swift's widest native unsigned
    /// integer type.
    public func toUIntMax() -> UIntMax

    /// Convert from Swift's widest unsigned integer type, trapping on
    /// overflow.
    public init(_: UIntMax)
}

extension UnsignedInteger {

    public func distance(to other: Self) -> Int

    public func advanced(by n: Int) -> Self
}

/// The return type of functions that don't explicitly specify a return type;
/// an empty tuple (i.e., `()`).
///
/// When declaring a function or method, you don't need to specify a return
/// type if no value will be returned. However, the type of a function,
/// method, or closure always includes a return type, which is `Void` if
/// otherwise unspecified.
///
/// Use `Void` or an empty tuple as the return type when declaring a
/// closure, function, or method that doesn't return a value.
///
///     // No return type declared:
///     func logMessage(s: String) {
///         print("Message: \(s)")
///     }
///
///     let logger: String -> Void = logMessage
///     logger("This is a void function")
///     // Prints "Message: This is a void function"
public typealias Void = ()

/// An iterator for `Zip2Sequence`.
public struct Zip2Iterator<Iterator1 : IteratorProtocol, Iterator2 : IteratorProtocol> : IteratorProtocol {

    /// The type of element returned by `next()`.
    public typealias Element = (Iterator1.Element, Iterator2.Element)

    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    ///
    /// - Precondition: `next()` has not been applied to a copy of `self`
    ///   since the copy was made, and no preceding call to `self.next()`
    ///   has returned `nil`.
    public mutating func next() -> (Iterator1.Element, Iterator2.Element)?
}

/// A sequence of pairs built out of two underlying sequences, where
/// the elements of the `i`th pair are the `i`th elements of each
/// underlying sequence.
public struct Zip2Sequence<Sequence1 : Sequence, Sequence2 : Sequence> : Sequence {

    public typealias Stream1 = Sequence1.Iterator

    public typealias Stream2 = Sequence2.Iterator

    /// A type whose instances can produce the elements of this
    /// sequence, in order.
    public typealias Iterator = Zip2Iterator<Sequence1.Iterator, Sequence2.Iterator>

    /// Construct an instance that makes pairs of elements from `sequence1` and
    /// `sequence2`.
    public init(_sequence1 sequence1: Sequence1, _sequence2 sequence2: Sequence2)

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> Zip2Iterator<Sequence1.Iterator, Sequence2.Iterator>
}

/// Returns the bits that are set in exactly one of the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func ^(lhs: UInt32, rhs: UInt32) -> UInt32

/// Returns the bits that are set in exactly one of the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func ^(lhs: Int, rhs: Int) -> Int

/// Returns the bits that are set in exactly one of the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func ^(lhs: UInt, rhs: UInt) -> UInt

/// Returns the bits that are set in exactly one of the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func ^(lhs: Int64, rhs: Int64) -> Int64

/// Returns the bits that are set in exactly one of the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func ^(lhs: UInt64, rhs: UInt64) -> UInt64

/// Returns the bits that are set in exactly one of the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func ^(lhs: Int32, rhs: Int32) -> Int32

/// Returns the bits that are set in exactly one of the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func ^(lhs: Int16, rhs: Int16) -> Int16

/// Returns the bits that are set in exactly one of the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func ^(lhs: UInt16, rhs: UInt16) -> UInt16

/// Returns the bits that are set in exactly one of the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func ^(lhs: Int8, rhs: Int8) -> Int8

/// Returns the bits that are set in exactly one of the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func ^(lhs: UInt8, rhs: UInt8) -> UInt8

/// Calculates the bits that are set in exactly one of the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func ^=(lhs: inout Int, rhs: Int)

/// Calculates the bits that are set in exactly one of the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func ^=(lhs: inout UInt64, rhs: UInt64)

/// Calculates the bits that are set in exactly one of the two arguments and
/// stores the result in the first argument.
///
/// - Parameters:
///   - lhs: A value to update with the bits that are set in exactly one of the
///     two arguments.
///   - rhs: Another value.
public func ^=<T : BitwiseOperations>(lhs: inout T, rhs: T)

/// Calculates the bits that are set in exactly one of the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func ^=(lhs: inout Int16, rhs: Int16)

/// Calculates the bits that are set in exactly one of the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func ^=(lhs: inout Int8, rhs: Int8)

/// Calculates the bits that are set in exactly one of the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func ^=(lhs: inout UInt16, rhs: UInt16)

/// Calculates the bits that are set in exactly one of the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func ^=(lhs: inout UInt, rhs: UInt)

/// Calculates the bits that are set in exactly one of the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func ^=(lhs: inout Int64, rhs: Int64)

/// Calculates the bits that are set in exactly one of the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func ^=(lhs: inout UInt32, rhs: UInt32)

/// Calculates the bits that are set in exactly one of the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func ^=(lhs: inout UInt8, rhs: UInt8)

/// Calculates the bits that are set in exactly one of the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func ^=(lhs: inout Int32, rhs: Int32)

/// This protocol is an implementation detail of `UnsignedInteger`;
/// do not use it directly.
public protocol _DisallowMixedSignArithmetic : _Integer {
}

/// This protocol is an implementation detail of `Integer`; do not use it
/// directly.
public protocol _Incrementable : Equatable {
}

/// This protocol is an implementation detail of `Integer`; do
/// not use it directly.
public protocol _Integer : IntegerLiteralConvertible, CustomStringConvertible, Hashable, IntegerArithmetic, BitwiseOperations, _Incrementable {
}

/// This protocol is an implementation detail of `IntegerArithmetic`; do
/// not use it directly.
///
/// Its requirements are inherited by `IntegerArithmetic` and thus must
/// be satisfied by types conforming to that protocol.
public protocol _IntegerArithmetic {

    /// Adds `lhs` and `rhs`, returning the result and a `Bool` that is
    /// `true` iff the operation caused an arithmetic overflow.
    public static func addWithOverflow(_ lhs: Self, _ rhs: Self) -> (Self, overflow: Bool)

    /// Subtracts `lhs` and `rhs`, returning the result and a `Bool` that is
    /// `true` iff the operation caused an arithmetic overflow.
    public static func subtractWithOverflow(_ lhs: Self, _ rhs: Self) -> (Self, overflow: Bool)

    /// Multiplies `lhs` and `rhs`, returning the result and a `Bool` that is
    /// `true` iff the operation caused an arithmetic overflow.
    public static func multiplyWithOverflow(_ lhs: Self, _ rhs: Self) -> (Self, overflow: Bool)

    /// Divides `lhs` and `rhs`, returning the result and a `Bool` that is
    /// `true` iff the operation caused an arithmetic overflow.
    public static func divideWithOverflow(_ lhs: Self, _ rhs: Self) -> (Self, overflow: Bool)

    /// Divides `lhs` and `rhs`, returning the remainder and a `Bool` that is
    /// `true` iff the operation caused an arithmetic overflow.
    public static func remainderWithOverflow(_ lhs: Self, _ rhs: Self) -> (Self, overflow: Bool)
}

/// A type that is just a wrapper over some base Sequence
public protocol _SequenceWrapper {

    associatedtype Base : Sequence

    associatedtype Iterator : IteratorProtocol = Self.Base.Iterator
}

extension _SequenceWrapper where Self : Sequence, Self.Iterator == Self.Base.Iterator {

    /// Returns a value less than or equal to the number of elements in
    /// the sequence, nondestructively.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence if the
    ///   sequence is a collection or wraps a collection; otherwise, O(1).
    public var underestimatedCount: Int { get }
}

/// This protocol is an implementation detail of `SignedInteger`;
/// do not use it directly.
public protocol _SignedInteger : _Integer, SignedNumber {

    /// Represent this number using Swift's widest native signed integer
    /// type.
    public func toIntMax() -> IntMax

    /// Convert from Swift's widest signed integer type, trapping on
    /// overflow.
    public init(_: IntMax)
}

/// Returns the absolute value of `x`.
///
/// Concrete instances of `SignedNumber` can specialize this
/// function by conforming to `AbsoluteValuable`.
public func abs<T : SignedNumber>(_ x: T) -> T

/// Returns the minimum memory alignment of `T`.
public func alignof<T>(_: T.Type) -> Int

/// Returns the minimum memory alignment of `T`.
public func alignofValue<T>(_: T) -> Int

/// Traditional C-style assert with an optional message.
///
/// Use this function for internal sanity checks that are active
/// during testing but do not impact performance of shipping code.
/// To check for invalid usage in Release builds; see `precondition`.
///
/// * In playgrounds and -Onone builds (the default for Xcode's Debug
///   configuration): if `condition` evaluates to false, stop program
///   execution in a debuggable state after printing `message`.
///
/// * In -O builds (the default for Xcode's Release configuration),
///   `condition` is not evaluated, and there are no effects.
///
/// * In -Ounchecked builds, `condition` is not evaluated, but the
///   optimizer may assume that it *would* evaluate to `true`. Failure
///   to satisfy that assumption in -Ounchecked builds is a serious
///   programming error.
public func assert(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)

/// Indicate that an internal sanity check failed.
///
/// Use this function to stop the program, without impacting the
/// performance of shipping code, when control flow is not expected to
/// reach the call (e.g. in the `default` case of a `switch` where you
/// have knowledge that one of the other cases must be satisfied). To
/// protect code from invalid usage in Release builds; see
/// `preconditionFailure`.
///
/// * In playgrounds and -Onone builds (the default for Xcode's Debug
///   configuration) stop program execution in a debuggable state
///   after printing `message`.
///
/// * In -O builds, has no effect.
///
/// * In -Ounchecked builds, the optimizer may assume that this
///   function will never be called. Failure to satisfy that assumption
///   is a serious programming error.
public func assertionFailure(_ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)

/// Writes the textual representations of `items` most suitable for
/// debugging, separated by `separator` and terminated by
/// `terminator`, into `output`.
///
/// The textual representations are obtained for each `item` via
/// the expression `String(reflecting: item)`.
///
/// - Note: To print without a trailing newline, pass `terminator: ""`
///
/// - SeeAlso: `print`, `Streamable`, `CustomStringConvertible`,
///   `CustomDebugStringConvertible`
public func debugPrint<Target : OutputStream>(_ items: Swift.Any..., separator: String = default, terminator: String = default, to output: inout Target)

/// Writes the textual representations of `items` most suitable for
/// debugging, separated by `separator` and terminated by
/// `terminator`, into the standard output.
///
/// The textual representations are obtained for each `item` via
/// the expression `String(reflecting: item)`.
///
/// - Note: To print without a trailing newline, pass `terminator: ""`
///
/// - SeeAlso: `print`, `Streamable`, `CustomStringConvertible`,
///   `CustomDebugStringConvertible`
public func debugPrint(_ items: Swift.Any..., separator: String = default, terminator: String = default)

/// Dump an object's contents using its mirror to the specified output stream.
public func dump<T, TargetStream : OutputStream>(_ value: T, to target: inout TargetStream, name: String? = default, indent: Int = default, maxDepth: Int = default, maxItems: Int = default) -> T

/// Dump an object's contents using its mirror to standard output.
public func dump<T>(_ value: T, name: String? = default, indent: Int = default, maxDepth: Int = default, maxItems: Int = default) -> T

/// Unconditionally print a `message` and stop execution.
@noreturn public func fatalError(_ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)

/// Returns a `CVaListPointer` built from `args` that's backed by
/// autoreleased storage.
///
/// - Warning: This function is best avoided in favor of
///   `withVaList`, but occasionally (i.e. in a `class` initializer) you
///   may find that the language rules don't allow you to use
/// `withVaList` as intended.
public func getVaList(_ args: [CVarArg]) -> CVaListPointer

/// Returns `true` iff `object` is a non-`@objc` class instance with a single
/// strong reference.
///
/// * Does *not* modify `object`; the use of `inout` is an
///   implementation artifact.
/// * Weak references do not affect the result of this function.
///
/// Useful for implementing the copy-on-write optimization for the
/// deep storage of value types:
///
///     mutating func modifyMe(_ arg: X) {
///       if isUniquelyReferenced(&myStorage) {
///         myStorage.modifyInPlace(arg)
///       }
///       else {
///         myStorage = myStorage.createModified(arg)
///       }
///     }
///
/// This function is safe to use for `mutating` functions in
/// multithreaded code because a false positive would imply that there
/// is already a user-level data race on the value being mutated.
public func isUniquelyReferenced<T : NonObjectiveCBase>(_ object: inout T) -> Bool

/// Returns `true` iff `object` is a non-`@objc` class instance with
/// a single strong reference.
///
/// * Does *not* modify `object`; the use of `inout` is an
///   implementation artifact.
/// * If `object` is an Objective-C class instance, returns `false`.
/// * Weak references do not affect the result of this function.
///
/// Useful for implementing the copy-on-write optimization for the
/// deep storage of value types:
///
///     mutating func modifyMe(_ arg: X) {
///       if isUniquelyReferencedNonObjC(&myStorage) {
///         myStorage.modifyInPlace(arg)
///       }
///       else {
///         myStorage = self.createModified(myStorage, arg)
///       }
///     }
///
/// This function is safe to use for `mutating` functions in
/// multithreaded code because a false positive would imply that there
/// is already a user-level data race on the value being mutated.
public func isUniquelyReferencedNonObjC<T : AnyObject>(_ object: inout T?) -> Bool

/// Returns `true` iff `object` is a non-`@objc` class instance with
/// a single strong reference.
///
/// * Does *not* modify `object`; the use of `inout` is an
///   implementation artifact.
/// * If `object` is an Objective-C class instance, returns `false`.
/// * Weak references do not affect the result of this function.
///
/// Useful for implementing the copy-on-write optimization for the
/// deep storage of value types:
///
///     mutating func modifyMe(_ arg: X) {
///       if isUniquelyReferencedNonObjC(&myStorage) {
///         myStorage.modifyInPlace(arg)
///       }
///       else {
///         myStorage = self.createModified(myStorage, arg)
///       }
///     }
///
/// This function is safe to use for `mutating` functions in
/// multithreaded code because a false positive would imply that there
/// is already a user-level data race on the value being mutated.
public func isUniquelyReferencedNonObjC<T : AnyObject>(_ object: inout T) -> Bool

/// Returns the greater of `x` and `y`.
///
/// If `x == y`, returns `y`.
public func max<T : Comparable>(_ x: T, _ y: T) -> T

/// Returns the greatest argument passed.
///
/// If there are multiple equal greatest arguments, returns the last one.
public func max<T : Comparable>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T

/// Returns the least argument passed.
///
/// If there are multiple equal least arguments, returns the first one.
public func min<T : Comparable>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T

/// Returns the lesser of `x` and `y`.
///
/// If `x == y`, returns `x`.
public func min<T : Comparable>(_ x: T, _ y: T) -> T

/// Convert `x` to type `U`, trapping on overflow in -Onone and -O
/// builds.
///
/// Typically used to do conversion to any contextually-deduced
/// integer type:
///
///     func f(_ x: UInt32) {}
///     func g(_ x: UInt64) { f(numericCast(x)) }
public func numericCast<T : UnsignedInteger, U : UnsignedInteger>(_ x: T) -> U

/// Convert `x` to type `U`, trapping on overflow in -Onone and -O
/// builds.
///
/// Typically used to do conversion to any contextually-deduced
/// integer type:
///
///     func f(_ x: Int32) {}
///     func g(_ x: Int64) { f(numericCast(x)) }
public func numericCast<T : _SignedInteger, U : _SignedInteger>(_ x: T) -> U

/// Convert `x` to type `U`, trapping on overflow in -Onone and -O
/// builds.
///
/// Typically used to do conversion to any contextually-deduced
/// integer type:
///
///     func f(_ x: UInt32) {}
///     func g(_ x: Int64) { f(numericCast(x)) }
public func numericCast<T : _SignedInteger, U : UnsignedInteger>(_ x: T) -> U

/// Convert `x` to type `U`, trapping on overflow in -Onone and -O
/// builds.
///
/// Typically used to do conversion to any contextually-deduced
/// integer type:
///
///     func f(_ x: Int32) {}
///     func g(_ x: UInt64) { f(numericCast(x)) }
public func numericCast<T : UnsignedInteger, U : _SignedInteger>(_ x: T) -> U

/// Check a necessary condition for making forward progress.
///
/// Use this function to detect conditions that must prevent the
/// program from proceeding even in shipping code.
///
/// * In playgrounds and -Onone builds (the default for Xcode's Debug
///   configuration): if `condition` evaluates to false, stop program
///   execution in a debuggable state after printing `message`.
///
/// * In -O builds (the default for Xcode's Release configuration):
///   if `condition` evaluates to false, stop program execution.
///
/// * In -Ounchecked builds, `condition` is not evaluated, but the
///   optimizer may assume that it *would* evaluate to `true`. Failure
///   to satisfy that assumption in -Ounchecked builds is a serious
///   programming error.
public func precondition(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)

/// Indicate that a precondition was violated.
///
/// Use this function to stop the program when control flow can only
/// reach the call if your API was improperly used.
///
/// * In playgrounds and -Onone builds (the default for Xcode's Debug
///   configuration), stop program execution in a debuggable state
///   after printing `message`.
///
/// * In -O builds (the default for Xcode's Release configuration),
///   stop program execution.
///
/// * In -Ounchecked builds, the optimizer may assume that this
///   function will never be called. Failure to satisfy that assumption
///   is a serious programming error.
@noreturn public func preconditionFailure(_ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)

/// Writes the textual representations of `items`, separated by
/// `separator` and terminated by `terminator`, into `output`.
///
/// The textual representations are obtained for each `item` via
/// the expression `String(item)`.
///
/// - Note: To print without a trailing newline, pass `terminator: ""`
///
/// - SeeAlso: `debugPrint`, `Streamable`, `CustomStringConvertible`,
///   `CustomDebugStringConvertible`
public func print<Target : OutputStream>(_ items: Swift.Any..., separator: String = default, terminator: String = default, to output: inout Target)

/// Writes the textual representations of `items`, separated by
/// `separator` and terminated by `terminator`, into the standard
/// output.
///
/// The textual representations are obtained for each `item` via
/// the expression `String(item)`.
///
/// - Note: To print without a trailing newline, pass `terminator: ""`
///
/// - SeeAlso: `debugPrint`, `Streamable`, `CustomStringConvertible`,
///   `CustomDebugStringConvertible`
public func print(_ items: Swift.Any..., separator: String = default, terminator: String = default)

/// Returns `Character`s read from standard input through the end of the
/// current line or until EOF is reached, or `nil` if EOF has already been
/// reached.
///
/// If `strippingNewline` is `true`, newline characters and character
/// combinations will be stripped from the result.  This is the default.
///
/// Standard input is interpreted as `UTF-8`.  Invalid bytes
/// will be replaced by Unicode [replacement characters](http://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character).
public func readLine(strippingNewline: Bool = default) -> String?

/// Return a collection containing `n` repetitions of `elementInstance`.
public func repeatElement<T>(_ element: T, count n: Int) -> Repeated<T>

/// Returns the contiguous memory footprint of `T`.
///
/// Does not include any dynamically-allocated or "remote" storage.
/// In particular, `sizeof(X.self)`, when `X` is a class type, is the
/// same regardless of how many stored properties `X` has.
public func sizeof<T>(_: T.Type) -> Int

/// Returns the contiguous memory footprint of  `T`.
///
/// Does not include any dynamically-allocated or "remote" storage.
/// In particular, `sizeof(a)`, when `a` is a class instance, is the
/// same regardless of how many stored properties `a` has.
public func sizeofValue<T>(_: T) -> Int

/// Returns the sequence of values (`self`, `self + stride`, `self +
/// stride + stride`, ... *last*) where *last* is the last value in
/// the progression less than or equal to `end`.
///
/// - Note: There is no guarantee that `end` is an element of the sequence.
public func stride<T : Strideable>(from start: T, through end: T, by stride: T.Stride) -> StrideThrough<T>

/// Returns the sequence of values (`self`, `self + stride`, `self +
/// stride + stride`, ... *last*) where *last* is the last value in
/// the progression that is less than `end`.
public func stride<T : Strideable>(from start: T, to end: T, by stride: T.Stride) -> StrideTo<T>

/// Returns the least possible interval between distinct instances of
/// `T` in memory.  The result is always positive.
public func strideof<T>(_: T.Type) -> Int

/// Returns the least possible interval between distinct instances of
/// `T` in memory.  The result is always positive.
public func strideofValue<T>(_: T) -> Int

/// Exchange the values of `a` and `b`.
///
/// - Precondition: `a` and `b` do not alias each other.
public func swap<T>(_ a: inout T, _ b: inout T)

/// Translates the given input from one Unicode encoding to another by calling
/// the given closure.
///
/// The following example transcodes the UTF-8 representation of the string
/// `"Fermata "` into UTF-32.
///
///     let fermata = "Fermata "
///     let bytes = fermata.utf8
///     print(Array(bytes))
///     // Prints "[70, 101, 114, 109, 97, 116, 97, 32, 240, 157, 132, 144]"
///
///     var codeUnits: [UTF32.CodeUnit] = []
///     let sink = { codeUnits.append($0) }
///     transcode(bytes.makeIterator(), from: UTF8.self, to: UTF32.self,
///               stoppingOnError: false, sendingOutputTo: sink)
///     print(codeUnits)
///     // Prints "[70, 101, 114, 109, 97, 116, 97, 32, 119056]"
///
/// The `sink` closure is called with each resulting UTF-32 code unit as the
/// function iterates over its input.
///
/// - Parameters:
///   - input: An iterator of code units to be translated, encoded as
///     `inputEncoding`. If `stopOnError` is `false`, the entire iterator will
///     be exhausted. Otherwise, iteration will stop if an encoding error is
///     detected.
///   - inputEncoding: The Unicode encoding of `input`.
///   - outputEncoding: The destination Unicode encoding.
///   - stopOnError: Pass `true` to stop translation when an encoding error is
///     detected in `input`. Otherwise, a Unicode replacement character
///     (`"\u{FFFD}"`) is inserted for each detected error.
///   - processCodeUnit: A closure that processes one `outputEncoding` code
///     unit at a time.
/// - Returns: `true` if the translation detected encoding errors in `input`;
///   otherwise, `false`.
public func transcode<Input : IteratorProtocol, InputEncoding : UnicodeCodec, OutputEncoding : UnicodeCodec where InputEncoding.CodeUnit == Input.Element>(_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, sendingOutputTo processCodeUnit: @noescape (OutputEncoding.CodeUnit) -> Swift.Void) -> Bool

/// Returns an `UnsafePointer` to the storage used for `object`.  There's
/// not much you can do with this other than use it to identify the
/// object.
public func unsafeAddress(of object: AnyObject) -> UnsafePointer<Swift.Void>

/// Returns the bits of `x`, interpreted as having type `U`.
///
/// - Warning: Breaks the guarantees of Swift's type system; use
///   with extreme care.  There's almost always a better way to do
///   anything.
///
public func unsafeBitCast<T, U>(_ x: T, to: U.Type) -> U

/// - returns: `x as T`.
///
/// - Precondition: `x is T`.  In particular, in -O builds, no test is
///   performed to ensure that `x` actually has dynamic type `T`.
///
/// - Warning: Trades safety for performance.  Use `unsafeDowncast`
///   only when `x as T` has proven to be a performance problem and you
///   are confident that, always, `x is T`.  It is better than an
///   `unsafeBitCast` because it's more restrictive, and because
///   checking is still performed in debug builds.
public func unsafeDowncast<T : AnyObject>(_ x: AnyObject, to: T.Type) -> T

/// Evaluate `f(x)` and return its result, ensuring that `x` is not
/// destroyed before f returns.
public func withExtendedLifetime<T, Result>(_ x: T, _ f: @noescape (T) throws -> Result) rethrows -> Result

/// Evaluate `f()` and return its result, ensuring that `x` is not
/// destroyed before f returns.
public func withExtendedLifetime<T, Result>(_ x: T, _ f: @noescape () throws -> Result) rethrows -> Result

/// Invokes `body` with an `UnsafeMutablePointer` to `arg` and returns the
/// result. Useful for calling Objective-C APIs that take "in/out"
/// parameters (and default-constructible "out" parameters) by pointer.
public func withUnsafeMutablePointer<T, Result>(_ arg: inout T, _ body: @noescape (UnsafeMutablePointer<T>) throws -> Result) rethrows -> Result

/// Like `withUnsafeMutablePointer`, but passes pointers to `arg0` and `arg1`.
public func withUnsafeMutablePointers<A0, A1, Result>(_ arg0: inout A0, _ arg1: inout A1, _ body: @noescape (UnsafeMutablePointer<A0>, UnsafeMutablePointer<A1>) throws -> Result) rethrows -> Result

/// Like `withUnsafeMutablePointer`, but passes pointers to `arg0`, `arg1`,
/// and `arg2`.
public func withUnsafeMutablePointers<A0, A1, A2, Result>(_ arg0: inout A0, _ arg1: inout A1, _ arg2: inout A2, _ body: @noescape (UnsafeMutablePointer<A0>, UnsafeMutablePointer<A1>, UnsafeMutablePointer<A2>) throws -> Result) rethrows -> Result

/// Invokes `body` with an `UnsafePointer` to `arg` and returns the
/// result. Useful for calling Objective-C APIs that take "in/out"
/// parameters (and default-constructible "out" parameters) by pointer.
public func withUnsafePointer<T, Result>(_ arg: inout T, _ body: @noescape (UnsafePointer<T>) throws -> Result) rethrows -> Result

/// Like `withUnsafePointer`, but passes pointers to `arg0`, `arg1`,
/// and `arg2`.
public func withUnsafePointers<A0, A1, A2, Result>(_ arg0: inout A0, _ arg1: inout A1, _ arg2: inout A2, _ body: @noescape (UnsafePointer<A0>, UnsafePointer<A1>, UnsafePointer<A2>) throws -> Result) rethrows -> Result

/// Like `withUnsafePointer`, but passes pointers to `arg0` and `arg1`.
public func withUnsafePointers<A0, A1, Result>(_ arg0: inout A0, _ arg1: inout A1, _ body: @noescape (UnsafePointer<A0>, UnsafePointer<A1>) throws -> Result) rethrows -> Result

/// Invoke `body` with a C `va_list` argument derived from `args`.
public func withVaList<R>(_ args: [CVarArg], invoke body: @noescape (CVaListPointer) -> R) -> R

/// A sequence of pairs built out of two underlying sequences, where
/// the elements of the `i`th pair are the `i`th elements of each
/// underlying sequence.
public func zip<Sequence1 : Sequence, Sequence2 : Sequence>(_ sequence1: Sequence1, _ sequence2: Sequence2) -> Zip2Sequence<Sequence1, Sequence2>

/// Returns the union of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func |(lhs: UInt64, rhs: UInt64) -> UInt64

/// Returns the union of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func |(lhs: Int64, rhs: Int64) -> Int64

/// Returns the union of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func |(lhs: UInt, rhs: UInt) -> UInt

/// Returns the union of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func |(lhs: Int, rhs: Int) -> Int

/// Returns the union of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func |(lhs: UInt8, rhs: UInt8) -> UInt8

/// Returns the union of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func |(lhs: Int16, rhs: Int16) -> Int16

/// Returns the union of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func |(lhs: Int8, rhs: Int8) -> Int8

/// Returns the union of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func |(lhs: UInt16, rhs: UInt16) -> UInt16

/// Returns the union of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func |(lhs: UInt32, rhs: UInt32) -> UInt32

/// Returns the union of bits set in the two arguments.
///
/// - SeeAlso: `BitwiseOperations`
public func |(lhs: Int32, rhs: Int32) -> Int32

/// Calculates the union of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func |=(lhs: inout UInt8, rhs: UInt8)

/// Calculates the union of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func |=(lhs: inout Int8, rhs: Int8)

/// Calculates the union of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func |=(lhs: inout UInt16, rhs: UInt16)

/// Calculates the union of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func |=(lhs: inout Int16, rhs: Int16)

/// Calculates the union of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func |=(lhs: inout UInt32, rhs: UInt32)

/// Calculates the union of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func |=(lhs: inout Int32, rhs: Int32)

/// Calculates the union of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func |=(lhs: inout UInt64, rhs: UInt64)

/// Calculates the union of bits sets in the two arguments and stores the result
/// in the first argument.
///
/// - Parameters:
///   - lhs: A value to update with the union of bits set in the two arguments.
///   - rhs: Another value.
public func |=<T : BitwiseOperations>(lhs: inout T, rhs: T)

/// Calculates the union of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func |=(lhs: inout Int, rhs: Int)

/// Calculates the union of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func |=(lhs: inout UInt, rhs: UInt)

/// Calculates the union of bits set in the two arguments
/// and stores the result in the first argument.
///
/// - SeeAlso: `BitwiseOperations`
public func |=(lhs: inout Int64, rhs: Int64)

/// Performs a logical OR operation on two Boolean values.
///
/// The logical OR operator (`||`) combines two Boolean values and returns
/// `true` if at least one of the values is `true`. If both values are
/// `false`, the operator returns `false`.
///
/// This operator uses short-circuit evaluation: The left-hand side (`lhs`) is
/// evaluated first, and the right-hand side (`rhs`) is evaluated only if
/// `lhs` evaluates to `false`. For example:
///
///     let majorErrors: Set = ["No first name", "No last name", ...]
///     let error = ""
///
///     if error.isEmpty || !majorErrors.contains(error) {
///         print("No major errors detected")
///     } else {
///         print("Major error: \(error)")
///     }
///     // Prints "No major errors detected")
///
/// In this example, `lhs` tests whether `error` is an empty string. Evaluation
/// of the `||` operator is one of the following:
///
/// - When `error` is an empty string, `lhs` evaluates to `true` and `rhs` is
///   not evaluated, skipping the call to `majorErrors.contains(_:)`. The
///   result of the operation is `true`.
/// - When `error` is not an empty string, `lhs` evaluates to `false` and `rhs`
///   is evaluated. The result of evaluating `rhs` is the result of the `||`
///   operation.
///
/// - Parameters:
///   - lhs: The left-hand side of the operation.
///   - rhs: The right-hand side of the operation.
public func ||<T : Boolean>(lhs: T, rhs: @autoclosure () throws -> Bool) rethrows -> Bool

/// Performs a logical OR operation on two Boolean values.
///
/// The logical OR operator (`||`) combines two Boolean values and returns
/// `true` if at least one of the values is `true`. If both values are
/// `false`, the operator returns `false`.
///
/// This operator uses short-circuit evaluation: The left-hand side (`lhs`) is
/// evaluated first, and the right-hand side (`rhs`) is evaluated only if
/// `lhs` evaluates to `false`. For example:
///
///     let majorErrors: Set = ["No first name", "No last name", ...]
///     let error = ""
///
///     if error.isEmpty || !majorErrors.contains(error) {
///         print("No major errors detected")
///     } else {
///         print("Major error: \(error)")
///     }
///     // Prints "No major errors detected")
///
/// In this example, `lhs` tests whether `error` is an empty string. Evaluation
/// of the `||` operator is one of the following:
///
/// - When `error` is an empty string, `lhs` evaluates to `true` and `rhs` is
///   not evaluated, skipping the call to `majorErrors.contains(_:)`. The
///   result of the operation is `true`.
/// - When `error` is not an empty string, `lhs` evaluates to `false` and `rhs`
///   is evaluated. The result of evaluating `rhs` is the result of the `||`
///   operation.
///
/// - Parameters:
///   - lhs: The left-hand side of the operation.
///   - rhs: The right-hand side of the operation.
public func ||<T : Boolean, U : Boolean>(lhs: T, rhs: @autoclosure () throws -> U) rethrows -> Bool

/// Returns the inverse of the bits set in the argument.
///
/// - SeeAlso: `BitwiseOperations`
prefix public func ~(rhs: UInt32) -> UInt32

/// Returns the inverse of the bits set in the argument.
///
/// - SeeAlso: `BitwiseOperations`
prefix public func ~(rhs: Int32) -> Int32

/// Returns the inverse of the bits set in the argument.
///
/// - SeeAlso: `BitwiseOperations`
prefix public func ~(rhs: UInt64) -> UInt64

/// Returns the inverse of the bits set in the argument.
///
/// - SeeAlso: `BitwiseOperations`
prefix public func ~(rhs: Int64) -> Int64

/// Returns the inverse of the bits set in the argument.
///
/// - SeeAlso: `BitwiseOperations`
prefix public func ~(rhs: UInt) -> UInt

/// Returns the inverse of the bits set in the argument.
///
/// - SeeAlso: `BitwiseOperations`
prefix public func ~(rhs: Int) -> Int

/// Returns the inverse of the bits set in the argument.
///
/// - SeeAlso: `BitwiseOperations`
prefix public func ~(rhs: Int16) -> Int16

/// Returns the inverse of the bits set in the argument.
///
/// - SeeAlso: `BitwiseOperations`
prefix public func ~(rhs: UInt16) -> UInt16

/// Returns the inverse of the bits set in the argument.
///
/// - SeeAlso: `BitwiseOperations`
prefix public func ~(rhs: Int8) -> Int8

/// Returns the inverse of the bits set in the argument.
///
/// - SeeAlso: `BitwiseOperations`
prefix public func ~(rhs: UInt8) -> UInt8

public func ~=<T>(lhs: _OptionalNilComparisonType, rhs: T?) -> Bool

public func ~=<T : Equatable>(a: T, b: T) -> Bool

public func ~=<Bound>(pattern: Range<Bound>, value: Bound) -> Bool

public func ~=<Bound>(pattern: CountableRange<Bound>, value: Bound) -> Bool

public func ~=<Bound>(pattern: ClosedRange<Bound>, value: Bound) -> Bool

public func ~=<Bound>(pattern: CountableClosedRange<Bound>, value: Bound) -> Bool

