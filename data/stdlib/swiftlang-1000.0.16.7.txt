/// Returns a Boolean value indicating whether any corresponding components of
/// the two tuples are not equal.
///
/// For two tuples to compare as equal, each corresponding pair of components
/// must be equal. The following example compares tuples made up of 2
/// components:
///
///     let a = ("a", 1)
///     let b = ("a", 1)
///     print(a != b)
///     // Prints "false"
///
///     let c = ("a", 2)
///     print(a != c)
///     // Prints "true"
///
/// - Parameters:
///   - lhs: A tuple of `Equatable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func != <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Equatable, B : Equatable

/// Returns a Boolean value indicating whether any corresponding components of
/// the two tuples are not equal.
///
/// For two tuples to compare as equal, each corresponding pair of components
/// must be equal. The following example compares tuples made up of 6
/// components:
///
///     let a = ("a", 1, 2, 3, 4, 5)
///     let b = ("a", 1, 2, 3, 4, 5)
///     print(a != b)
///     // Prints "false"
///
///     let c = ("a", 1, 2, 3, 4, 6)
///     print(a != c)
///     // Prints "true"
///
/// - Parameters:
///   - lhs: A tuple of `Equatable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func != <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable, F : Equatable

/// Returns a Boolean value indicating whether any corresponding components of
/// the two tuples are not equal.
///
/// For two tuples to compare as equal, each corresponding pair of components
/// must be equal. The following example compares tuples made up of 5
/// components:
///
///     let a = ("a", 1, 2, 3, 4)
///     let b = ("a", 1, 2, 3, 4)
///     print(a != b)
///     // Prints "false"
///
///     let c = ("a", 1, 2, 3, 5)
///     print(a != c)
///     // Prints "true"
///
/// - Parameters:
///   - lhs: A tuple of `Equatable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func != <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable

/// Returns a Boolean value indicating whether any corresponding components of
/// the two tuples are not equal.
///
/// For two tuples to compare as equal, each corresponding pair of components
/// must be equal. The following example compares tuples made up of 4
/// components:
///
///     let a = ("a", 1, 2, 3)
///     let b = ("a", 1, 2, 3)
///     print(a != b)
///     // Prints "false"
///
///     let c = ("a", 1, 2, 4)
///     print(a != c)
///     // Prints "true"
///
/// - Parameters:
///   - lhs: A tuple of `Equatable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func != <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable

/// Returns a Boolean value indicating whether any corresponding components of
/// the two tuples are not equal.
///
/// For two tuples to compare as equal, each corresponding pair of components
/// must be equal. The following example compares tuples made up of 3
/// components:
///
///     let a = ("a", 1, 2)
///     let b = ("a", 1, 2)
///     print(a != b)
///     // Prints "false"
///
///     let c = ("a", 1, 3)
///     print(a != c)
///     // Prints "true"
///
/// - Parameters:
///   - lhs: A tuple of `Equatable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func != <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Equatable, B : Equatable, C : Equatable

/// Returns a Boolean value indicating whether any corresponding components of
/// the two tuples are not equal.
///
/// All arity zero tuples are equal.
///
/// - Parameters:
///   - lhs: An empty tuple.
///   - rhs: An empty tuple.
public func != (lhs: (), rhs: ()) -> Bool

/// Returns a Boolean value indicating whether the two arguments are not equal.
///
/// - Parameters:
///   - lhs: A raw-representable instance.
///   - rhs: A second raw-representable instance.
public func != <T>(lhs: T, rhs: T) -> Bool where T : Equatable, T : RawRepresentable, T.RawValue : Equatable

/// Returns a Boolean value indicating whether the two arguments are not equal.
///
/// - Parameters:
///   - lhs: A raw-representable instance.
///   - rhs: A second raw-representable instance.
public func != <T>(lhs: T, rhs: T) -> Bool where T : RawRepresentable, T.RawValue : Equatable

/// Returns a Boolean value indicating whether two types are not identical.
///
/// - Parameters:
///   - t0: A type to compare.
///   - t1: Another type to compare.
/// - Returns: `true` if one, but not both, of `t0` and `t1` are `nil`, or if
///   they represent different types; otherwise, `false`.
public func != (t0: Any.Type?, t1: Any.Type?) -> Bool

/// Returns a Boolean value indicating whether two references point to
/// different object instances.
///
/// This operator tests whether two instances have different identities, not
/// different values. For value inequality, see the not-equal-to operator
/// (`!=`) and the `Equatable` protocol.
///
/// - Parameters:
///   - lhs: A reference to compare.
///   - rhs: Another reference to compare.
public func !== (lhs: AnyObject?, rhs: AnyObject?) -> Bool

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is before the second tuple if and only if
/// `a1 < b1` or (`a1 == b1` and
/// `(a2, ..., aN) < (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func < <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is before the second tuple if and only if
/// `a1 < b1` or (`a1 == b1` and
/// `(a2, ..., aN) < (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func < <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Comparable, B : Comparable, C : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is before the second tuple if and only if
/// `a1 < b1` or (`a1 == b1` and
/// `(a2, ..., aN) < (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func < <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Comparable, B : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before the second in a lexicographical ordering.
///
/// An arity zero tuple is never strictly before another arity zero tuple in a
/// lexicographical ordering.
///
/// - Parameters:
///   - lhs: An empty tuple.
///   - rhs: An empty tuple.
public func < (lhs: (), rhs: ()) -> Bool

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is before the second tuple if and only if
/// `a1 < b1` or (`a1 == b1` and
/// `(a2, ..., aN) < (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func < <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is before the second tuple if and only if
/// `a1 < b1` or (`a1 == b1` and
/// `(a2, ..., aN) < (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func < <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable, F : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before or the same as the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is before or the same as the second tuple if and only if
/// `a1 < b1` or (`a1 == b1` and
/// `(a2, ..., aN) <= (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func <= <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before or the same as the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is before or the same as the second tuple if and only if
/// `a1 < b1` or (`a1 == b1` and
/// `(a2, ..., aN) <= (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func <= <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable, F : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before or the same as the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is before or the same as the second tuple if and only if
/// `a1 < b1` or (`a1 == b1` and
/// `(a2, ..., aN) <= (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func <= <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before or the same as the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is before or the same as the second tuple if and only if
/// `a1 < b1` or (`a1 == b1` and
/// `(a2, ..., aN) <= (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func <= <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Comparable, B : Comparable, C : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before or the same as the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is before or the same as the second tuple if and only if
/// `a1 < b1` or (`a1 == b1` and
/// `(a2, ..., aN) <= (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func <= <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Comparable, B : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// before or the same as the second in a lexicographical ordering.
///
/// An arity zero tuple is always before or the same as another arity zero tuple
/// in a lexicographical ordering.
///
/// - Parameters:
///   - lhs: An empty tuple.
///   - rhs: An empty tuple.
public func <= (lhs: (), rhs: ()) -> Bool

/// Returns a Boolean value indicating whether the corresponding components of
/// two tuples are equal.
///
/// For two tuples to compare as equal, each corresponding pair of components
/// must be equal. The following example compares tuples made up of 6
/// components:
///
///     let a = ("a", 1, 2, 3, 4, 5)
///     let b = ("a", 1, 2, 3, 4, 5)
///     print(a == b)
///     // Prints "true"
///
///     let c = ("a", 1, 2, 3, 4, 6)
///     print(a == c)
///     // Prints "false"
///
/// - Parameters:
///   - lhs: A tuple of `Equatable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func == <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable, F : Equatable

/// Returns a Boolean value indicating whether the corresponding components of
/// two tuples are equal.
///
/// For two tuples to compare as equal, each corresponding pair of components
/// must be equal. The following example compares tuples made up of 5
/// components:
///
///     let a = ("a", 1, 2, 3, 4)
///     let b = ("a", 1, 2, 3, 4)
///     print(a == b)
///     // Prints "true"
///
///     let c = ("a", 1, 2, 3, 5)
///     print(a == c)
///     // Prints "false"
///
/// - Parameters:
///   - lhs: A tuple of `Equatable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func == <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable, E : Equatable

/// Returns a Boolean value indicating whether the corresponding components of
/// two tuples are equal.
///
/// For two tuples to compare as equal, each corresponding pair of components
/// must be equal. The following example compares tuples made up of 4
/// components:
///
///     let a = ("a", 1, 2, 3)
///     let b = ("a", 1, 2, 3)
///     print(a == b)
///     // Prints "true"
///
///     let c = ("a", 1, 2, 4)
///     print(a == c)
///     // Prints "false"
///
/// - Parameters:
///   - lhs: A tuple of `Equatable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func == <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Equatable, B : Equatable, C : Equatable, D : Equatable

/// Returns a Boolean value indicating whether the corresponding components of
/// two tuples are equal.
///
/// For two tuples to compare as equal, each corresponding pair of components
/// must be equal. The following example compares tuples made up of 3
/// components:
///
///     let a = ("a", 1, 2)
///     let b = ("a", 1, 2)
///     print(a == b)
///     // Prints "true"
///
///     let c = ("a", 1, 3)
///     print(a == c)
///     // Prints "false"
///
/// - Parameters:
///   - lhs: A tuple of `Equatable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func == <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Equatable, B : Equatable, C : Equatable

/// Returns a Boolean value indicating whether the corresponding components of
/// two tuples are equal.
///
/// For two tuples to compare as equal, each corresponding pair of components
/// must be equal. The following example compares tuples made up of 2
/// components:
///
///     let a = ("a", 1)
///     let b = ("a", 1)
///     print(a == b)
///     // Prints "true"
///
///     let c = ("a", 2)
///     print(a == c)
///     // Prints "false"
///
/// - Parameters:
///   - lhs: A tuple of `Equatable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func == <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Equatable, B : Equatable

/// Returns a Boolean value indicating whether the corresponding components of
/// two tuples are equal.
///
/// All arity zero tuples are equal.
///
/// - Parameters:
///   - lhs: An empty tuple.
///   - rhs: An empty tuple.
public func == (lhs: (), rhs: ()) -> Bool

/// Returns a Boolean value indicating whether the two arguments are equal.
///
/// - Parameters:
///   - lhs: A raw-representable instance.
///   - rhs: A second raw-representable instance.
public func == <T>(lhs: T, rhs: T) -> Bool where T : RawRepresentable, T.RawValue : Equatable

/// Returns a Boolean value indicating whether two types are identical.
///
/// - Parameters:
///   - t0: A type to compare.
///   - t1: Another type to compare.
/// - Returns: `true` if both `t0` and `t1` are `nil` or if they represent the
///   same type; otherwise, `false`.
public func == (t0: Any.Type?, t1: Any.Type?) -> Bool

/// Returns a Boolean value indicating whether two references point to the same
/// object instance.
///
/// This operator tests whether two instances have the same identity, not the
/// same value. For value equality, see the equal-to operator (`==`) and the
/// `Equatable` protocol.
///
/// The following example defines an `IntegerRef` type, an integer type with
/// reference semantics.
///
///     class IntegerRef: Equatable {
///         let value: Int
///         init(_ value: Int) {
///             self.value = value
///         }
///     }
///
///     func ==(lhs: IntegerRef, rhs: IntegerRef) -> Bool {
///         return lhs.value == rhs.value
///     }
///
/// Because `IntegerRef` is a class, its instances can be compared using the
/// identical-to operator (`===`). In addition, because `IntegerRef` conforms
/// to the `Equatable` protocol, instances can also be compared using the
/// equal-to operator (`==`).
///
///     let a = IntegerRef(10)
///     let b = a
///     print(a == b)
///     // Prints "true"
///     print(a === b)
///     // Prints "true"
///
/// The identical-to operator (`===`) returns `false` when comparing two
/// references to different object instances, even if the two instances have
/// the same value.
///
///     let c = IntegerRef(10)
///     print(a == c)
///     // Prints "true"
///     print(a === c)
///     // Prints "false"
///
/// - Parameters:
///   - lhs: A reference to compare.
///   - rhs: Another reference to compare.
public func === (lhs: AnyObject?, rhs: AnyObject?) -> Bool

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is after the second tuple if and only if
/// `a1 > b1` or (`a1 == b1` and
/// `(a2, ..., aN) > (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func > <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is after the second tuple if and only if
/// `a1 > b1` or (`a1 == b1` and
/// `(a2, ..., aN) > (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func > <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable, F : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after the second in a lexicographical ordering.
///
/// An arity zero tuple is never strictly after another arity zero tuple in a
/// lexicographical ordering.
///
/// - Parameters:
///   - lhs: An empty tuple.
///   - rhs: An empty tuple.
public func > (lhs: (), rhs: ()) -> Bool

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is after the second tuple if and only if
/// `a1 > b1` or (`a1 == b1` and
/// `(a2, ..., aN) > (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func > <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Comparable, B : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is after the second tuple if and only if
/// `a1 > b1` or (`a1 == b1` and
/// `(a2, ..., aN) > (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func > <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Comparable, B : Comparable, C : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is after the second tuple if and only if
/// `a1 > b1` or (`a1 == b1` and
/// `(a2, ..., aN) > (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func > <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after or the same as the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is after or the same as the second tuple if and only if
/// `a1 > b1` or (`a1 == b1` and
/// `(a2, ..., aN) >= (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func >= <A, B, C, D, E, F>(lhs: (A, B, C, D, E, F), rhs: (A, B, C, D, E, F)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable, F : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after or the same as the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is after or the same as the second tuple if and only if
/// `a1 > b1` or (`a1 == b1` and
/// `(a2, ..., aN) >= (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func >= <A, B, C, D, E>(lhs: (A, B, C, D, E), rhs: (A, B, C, D, E)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable, E : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after or the same as the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is after or the same as the second tuple if and only if
/// `a1 > b1` or (`a1 == b1` and
/// `(a2, ..., aN) >= (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func >= <A, B, C, D>(lhs: (A, B, C, D), rhs: (A, B, C, D)) -> Bool where A : Comparable, B : Comparable, C : Comparable, D : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after or the same as the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is after or the same as the second tuple if and only if
/// `a1 > b1` or (`a1 == b1` and
/// `(a2, ..., aN) >= (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func >= <A, B, C>(lhs: (A, B, C), rhs: (A, B, C)) -> Bool where A : Comparable, B : Comparable, C : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after or the same as the second in a lexicographical ordering.
///
/// Given two tuples `(a1, a2, ..., aN)` and `(b1, b2, ..., bN)`, the first
/// tuple is after or the same as the second tuple if and only if
/// `a1 > b1` or (`a1 == b1` and
/// `(a2, ..., aN) >= (b2, ..., bN)`).
///
/// - Parameters:
///   - lhs: A tuple of `Comparable` elements.
///   - rhs: Another tuple of elements of the same type as `lhs`.
public func >= <A, B>(lhs: (A, B), rhs: (A, B)) -> Bool where A : Comparable, B : Comparable

/// Returns a Boolean value indicating whether the first tuple is ordered
/// after or the same as the second in a lexicographical ordering.
///
/// An arity zero tuple is always after or the same as another arity zero tuple
/// in a lexicographical ordering.
///
/// - Parameters:
///   - lhs: An empty tuple.
///   - rhs: An empty tuple.
public func >= (lhs: (), rhs: ()) -> Bool

/// Performs a nil-coalescing operation, returning the wrapped value of an
/// `Optional` instance or a default value.
///
/// A nil-coalescing operation unwraps the left-hand side if it has a value, or
/// it returns the right-hand side as a default. The result of this operation
/// will have the nonoptional type of the left-hand side's `Wrapped` type.
///
/// This operator uses short-circuit evaluation: `optional` is checked first,
/// and `defaultValue` is evaluated only if `optional` is `nil`. For example:
///
///     func getDefault() -> Int {
///         print("Calculating default...")
///         return 42
///     }
///
///     let goodNumber = Int("100") ?? getDefault()
///     // goodNumber == 100
///
///     let notSoGoodNumber = Int("invalid-input") ?? getDefault()
///     // Prints "Calculating default..."
///     // notSoGoodNumber == 42
///
/// In this example, `goodNumber` is assigned a value of `100` because
/// `Int("100")` succeeded in returning a non-`nil` result. When
/// `notSoGoodNumber` is initialized, `Int("invalid-input")` fails and returns
/// `nil`, and so the `getDefault()` method is called to supply a default
/// value.
///
/// - Parameters:
///   - optional: An optional value.
///   - defaultValue: A value to use as a default. `defaultValue` is the same
///     type as the `Wrapped` type of `optional`.
public func ?? <T>(optional: T?, defaultValue: @autoclosure () throws -> T) rethrows -> T

/// Performs a nil-coalescing operation, returning the wrapped value of an
/// `Optional` instance or a default `Optional` value.
///
/// A nil-coalescing operation unwraps the left-hand side if it has a value, or
/// returns the right-hand side as a default. The result of this operation
/// will be the same type as its arguments.
///
/// This operator uses short-circuit evaluation: `optional` is checked first,
/// and `defaultValue` is evaluated only if `optional` is `nil`. For example:
///
///     let goodNumber = Int("100") ?? Int("42")
///     print(goodNumber)
///     // Prints "Optional(100)"
///
///     let notSoGoodNumber = Int("invalid-input") ?? Int("42")
///     print(notSoGoodNumber)
///     // Prints "Optional(42)"
///
/// In this example, `goodNumber` is assigned a value of `100` because
/// `Int("100")` succeeds in returning a non-`nil` result. When
/// `notSoGoodNumber` is initialized, `Int("invalid-input")` fails and returns
/// `nil`, and so `Int("42")` is called to supply a default value.
///
/// Because the result of this nil-coalescing operation is itself an optional
/// value, you can chain default values by using `??` multiple times. The
/// first optional value that isn't `nil` stops the chain and becomes the
/// result of the whole expression. The next example tries to find the correct
/// text for a greeting in two separate dictionaries before falling back to a
/// static default.
///
///     let greeting = userPrefs[greetingKey] ??
///         defaults[greetingKey] ?? "Greetings!"
///
/// If `userPrefs[greetingKey]` has a value, that value is assigned to
/// `greeting`. If not, any value in `defaults[greetingKey]` will succeed, and
/// if not that, `greeting` will be set to the non-optional default value,
/// `"Greetings!"`.
///
/// - Parameters:
///   - optional: An optional value.
///   - defaultValue: A value to use as a default. `defaultValue` and
///     `optional` have the same type.
public func ?? <T>(optional: T?, defaultValue: @autoclosure () throws -> T?) rethrows -> T?

/// A type-erased wrapper over any collection with indices that
/// support bidirectional traversal.
///
/// An `AnyBidirectionalCollection` instance forwards its operations to a base collection having the
/// same `Element` type, hiding the specifics of the underlying
/// collection.
public struct AnyBidirectionalCollection<Element> {
}

extension AnyBidirectionalCollection {

    /// Returns an iterator over the elements of this collection.
    public func makeIterator() -> AnyBidirectionalCollection<Element>.Iterator

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    public var underestimatedCount: Int { get }

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element]

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: (Element) throws -> Void) rethrows

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element is a match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func drop(while predicate: (Element) throws -> Bool) rethrows -> AnyBidirectionalCollection<Element>

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the sequence.
    public func dropFirst(_ n: Int) -> AnyBidirectionalCollection<Element>

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence leaving off the specified number of elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> AnyBidirectionalCollection<Element>

    /// Returns a subsequence containing the initial, consecutive elements that
    /// satisfy the given predicate.
    ///
    /// The following example uses the `prefix(while:)` method to find the
    /// positive numbers at the beginning of the `numbers` array. Every element
    /// of `numbers` up to, but not including, the first negative value is
    /// included in the result.
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     let positivePrefix = numbers.prefix(while: { $0 > 0 })
    ///     // positivePrefix == [3, 7, 4]
    ///
    /// If `predicate` matches every element in the sequence, the resulting
    /// sequence contains every element of the sequence.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element should be included in the result.
    /// - Returns: A subsequence of the initial, consecutive elements that
    ///   satisfy `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func prefix(while predicate: (Element) throws -> Bool) rethrows -> AnyBidirectionalCollection<Element>

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> AnyBidirectionalCollection<Element>

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number
    /// of elements in the sequence, the result contains all the elements in
    /// the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of this sequence with
    ///   at most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> AnyBidirectionalCollection<Element>

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " })
    ///               .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(
    ///         line.split(maxSplits: 1, whereSeparator: { $0 == " " })
    ///             .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false,
    ///                      whereSeparator: { $0 == " " })
    ///          ).map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Element) throws -> Bool) rethrows -> [AnyBidirectionalCollection<Element>]
}

extension AnyBidirectionalCollection : BidirectionalCollection {

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultIndices<AnyBidirectionalCollection<Element>>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = AnyIterator<Element>

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = AnyIndex

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = AnyBidirectionalCollection<Element>

    /// Creates a type-erased collection that wraps the given collection.
    ///
    /// - Parameter base: The collection to wrap.
    ///
    /// - Complexity: O(1).
    public init<C>(_ base: C) where Element == C.Element, C : BidirectionalCollection

    /// Creates an `AnyBidirectionalCollection` having the same underlying collection as `other`.
    ///
    /// - Complexity: O(1)
    public init(_ other: AnyBidirectionalCollection<Element>)

    /// Creates a type-erased collection that wraps the given collection.
    ///
    /// - Parameter base: The collection to wrap.
    ///
    /// - Complexity: O(1).
    public init<C>(_ base: C) where Element == C.Element, C : RandomAccessCollection

    /// Creates an `AnyBidirectionalCollection` having the same underlying collection as `other`.
    ///
    /// - Complexity: O(1)
    public init(_ other: AnyRandomAccessCollection<Element>)

    /// Creates an `AnyBidirectionalCollection` having the same underlying collection as `other`.
    ///
    /// If the underlying collection stored by `other` does not satisfy
    /// `BidirectionalCollection`, the result is `nil`.
    ///
    /// - Complexity: O(1)
    public init?(_ other: AnyCollection<Element>)

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: AnyBidirectionalCollection<Element>.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: AnyBidirectionalCollection<Element>.Index { get }

    /// Accesses the element indicated by `position`.
    ///
    /// - Precondition: `position` indicates a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: AnyBidirectionalCollection<Element>.Index) -> Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<AnyBidirectionalCollection<Element>.Index>) -> AnyBidirectionalCollection<Element>.SubSequence { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: AnyBidirectionalCollection<Element>.Index) -> AnyBidirectionalCollection<Element>.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout AnyBidirectionalCollection<Element>.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyBidirectionalCollection<Element>.Index, offsetBy n: Int) -> AnyBidirectionalCollection<Element>.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyBidirectionalCollection<Element>.Index, offsetBy n: Int, limitedBy limit: AnyBidirectionalCollection<Element>.Index) -> AnyBidirectionalCollection<Element>.Index?

    public func formIndex(_ i: inout AnyBidirectionalCollection<Element>.Index, offsetBy n: Int)

    public func formIndex(_ i: inout AnyBidirectionalCollection<Element>.Index, offsetBy n: Int, limitedBy limit: AnyBidirectionalCollection<Element>.Index) -> Bool

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: AnyBidirectionalCollection<Element>.Index, to end: AnyBidirectionalCollection<Element>.Index) -> Int

    /// The number of elements.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(*n*)
    public var count: Int { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Element? { get }

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: AnyBidirectionalCollection<Element>.Index) -> AnyBidirectionalCollection<Element>.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout AnyBidirectionalCollection<Element>.Index)

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Element? { get }
}

extension AnyBidirectionalCollection {
}

/// The protocol to which all class types implicitly conform.
///
/// You can use the `AnyClass` protocol as the concrete type for an instance of
/// any class. When you do, all known `@objc` class methods and properties are
/// available as implicitly unwrapped optional methods and properties,
/// respectively. For example:
///
///     class IntegerRef {
///         @objc class func getDefaultValue() -> Int {
///             return 42
///         }
///     }
///
///     func getDefaultValue(_ c: AnyClass) -> Int? {
///         return c.getDefaultValue?()
///     }
///
/// The `getDefaultValue(_:)` function uses optional chaining to safely call
/// the implicitly unwrapped class method on `c`. Calling the function with
/// different class types shows how the `getDefaultValue()` class method is
/// only conditionally available.
///
///     print(getDefaultValue(IntegerRef.self))
///     // Prints "Optional(42)"
///
///     print(getDefaultValue(NSString.self))
///     // Prints "nil"
public typealias AnyClass = AnyObject.Type

/// A type-erased wrapper over any collection with indices that
/// support forward traversal.
///
/// An `AnyCollection` instance forwards its operations to a base collection having the
/// same `Element` type, hiding the specifics of the underlying
/// collection.
public struct AnyCollection<Element> {
}

extension AnyCollection {

    /// Returns an iterator over the elements of this collection.
    public func makeIterator() -> AnyCollection<Element>.Iterator

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    public var underestimatedCount: Int { get }

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: (AnyCollection<Element>.Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    public func filter(_ isIncluded: (AnyCollection<Element>.Element) throws -> Bool) rethrows -> [AnyCollection<Element>.Element]

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: (AnyCollection<Element>.Element) throws -> Void) rethrows

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element is a match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func drop(while predicate: (AnyCollection<Element>.Element) throws -> Bool) rethrows -> AnyCollection<AnyCollection<Element>.Element>

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the sequence.
    public func dropFirst(_ n: Int) -> AnyCollection<AnyCollection<Element>.Element>

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence leaving off the specified number of elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> AnyCollection<AnyCollection<Element>.Element>

    /// Returns a subsequence containing the initial, consecutive elements that
    /// satisfy the given predicate.
    ///
    /// The following example uses the `prefix(while:)` method to find the
    /// positive numbers at the beginning of the `numbers` array. Every element
    /// of `numbers` up to, but not including, the first negative value is
    /// included in the result.
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     let positivePrefix = numbers.prefix(while: { $0 > 0 })
    ///     // positivePrefix == [3, 7, 4]
    ///
    /// If `predicate` matches every element in the sequence, the resulting
    /// sequence contains every element of the sequence.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element should be included in the result.
    /// - Returns: A subsequence of the initial, consecutive elements that
    ///   satisfy `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func prefix(while predicate: (AnyCollection<Element>.Element) throws -> Bool) rethrows -> AnyCollection<AnyCollection<Element>.Element>

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> AnyCollection<AnyCollection<Element>.Element>

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number
    /// of elements in the sequence, the result contains all the elements in
    /// the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of this sequence with
    ///   at most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> AnyCollection<AnyCollection<Element>.Element>

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " })
    ///               .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(
    ///         line.split(maxSplits: 1, whereSeparator: { $0 == " " })
    ///             .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false,
    ///                      whereSeparator: { $0 == " " })
    ///          ).map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (AnyCollection<Element>.Element) throws -> Bool) rethrows -> [AnyCollection<AnyCollection<Element>.Element>]
}

extension AnyCollection : Collection {

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultIndices<AnyCollection<Element>>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = AnyIterator<Element>

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = AnyIndex

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = AnyCollection<Element>

    /// Creates a type-erased collection that wraps the given collection.
    ///
    /// - Parameter base: The collection to wrap.
    ///
    /// - Complexity: O(1).
    public init<C>(_ base: C) where Element == C.Element, C : Collection

    /// Creates an `AnyCollection` having the same underlying collection as `other`.
    ///
    /// - Complexity: O(1)
    public init(_ other: AnyCollection<AnyCollection<Element>.Element>)

    /// Creates a type-erased collection that wraps the given collection.
    ///
    /// - Parameter base: The collection to wrap.
    ///
    /// - Complexity: O(1).
    public init<C>(_ base: C) where Element == C.Element, C : BidirectionalCollection

    /// Creates an `AnyCollection` having the same underlying collection as `other`.
    ///
    /// - Complexity: O(1)
    public init(_ other: AnyBidirectionalCollection<AnyCollection<Element>.Element>)

    /// Creates a type-erased collection that wraps the given collection.
    ///
    /// - Parameter base: The collection to wrap.
    ///
    /// - Complexity: O(1).
    public init<C>(_ base: C) where Element == C.Element, C : RandomAccessCollection

    /// Creates an `AnyCollection` having the same underlying collection as `other`.
    ///
    /// - Complexity: O(1)
    public init(_ other: AnyRandomAccessCollection<AnyCollection<Element>.Element>)

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: AnyCollection<Element>.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: AnyCollection<Element>.Index { get }

    /// Accesses the element indicated by `position`.
    ///
    /// - Precondition: `position` indicates a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: AnyCollection<Element>.Index) -> Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// For example, using a `PartialRangeFrom` range expression with an array
    /// accesses the subrange from the start of the range expression until the
    /// end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2..<5]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. This example searches `streetsSlice` for one of the
    /// strings in the slice, and then uses that index in the original array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")!    // 4
    ///     print(streets[index])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice may result in a runtime
    /// error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<AnyCollection<Element>.Index>) -> AnyCollection<Element>.SubSequence { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: AnyCollection<Element>.Index) -> AnyCollection<Element>.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout AnyCollection<Element>.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyCollection<Element>.Index, offsetBy n: Int) -> AnyCollection<Element>.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyCollection<Element>.Index, offsetBy n: Int, limitedBy limit: AnyCollection<Element>.Index) -> AnyCollection<Element>.Index?

    public func formIndex(_ i: inout AnyCollection<Element>.Index, offsetBy n: Int)

    public func formIndex(_ i: inout AnyCollection<Element>.Index, offsetBy n: Int, limitedBy limit: AnyCollection<Element>.Index) -> Bool

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: AnyCollection<Element>.Index, to end: AnyCollection<Element>.Index) -> Int

    /// The number of elements.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(*n*)
    public var count: Int { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Element? { get }
}

extension AnyCollection {
}

/// A type-erased hashable value.
///
/// The `AnyHashable` type forwards equality comparisons and hashing operations
/// to an underlying hashable value, hiding its specific underlying type.
///
/// You can store mixed-type keys in dictionaries and other collections that
/// require `Hashable` conformance by wrapping mixed-type keys in
/// `AnyHashable` instances:
///
///     let descriptions: [AnyHashable: Any] = [
///         AnyHashable(""): "emoji",
///         AnyHashable(42): "an Int",
///         AnyHashable(Int8(43)): "an Int8",
///         AnyHashable(Set(["a", "b"])): "a set of strings"
///     ]
///     print(descriptions[AnyHashable(42)]!)      // prints "an Int"
///     print(descriptions[AnyHashable(43)])       // prints "nil"
///     print(descriptions[AnyHashable(Int8(43))]!) // prints "an Int8"
///     print(descriptions[AnyHashable(Set(["a", "b"]))]!) // prints "a set of strings"
public struct AnyHashable {

    /// Creates a type-erased hashable value that wraps the given instance.
    ///
    /// The following example creates two type-erased hashable values: `x` wraps
    /// an `Int` with the value 42, while `y` wraps a `UInt8` with the same
    /// numeric value. Because the underlying types of `x` and `y` are
    /// different, the two variables do not compare as equal despite having
    /// equal underlying values.
    ///
    ///     let x = AnyHashable(Int(42))
    ///     let y = AnyHashable(UInt8(42))
    ///
    ///     print(x == y)
    ///     // Prints "false" because `Int` and `UInt8` are different types
    ///
    ///     print(x == AnyHashable(Int(42)))
    ///     // Prints "true"
    ///
    /// - Parameter base: A hashable value to wrap.
    public init<H>(_ base: H) where H : Hashable

    /// The value wrapped by this instance.
    ///
    /// The `base` property can be cast back to its original type using one of
    /// the casting operators (`as?`, `as!`, or `as`).
    ///
    ///     let anyMessage = AnyHashable("Hello world!")
    ///     if let unwrappedMessage = anyMessage.base as? String {
    ///         print(unwrappedMessage)
    ///     }
    ///     // Prints "Hello world!"
    public var base: Any { get }
}

extension AnyHashable : Equatable {

    /// Returns a Boolean value indicating whether two type-erased hashable
    /// instances wrap the same type and value.
    ///
    /// Two instances of `AnyHashable` compare as equal if and only if the
    /// underlying types have the same conformance to the `Equatable` protocol
    /// and the underlying values compare as equal.
    ///
    /// The following example creates two type-erased hashable values: `x` wraps
    /// an `Int` with the value 42, while `y` wraps a `UInt8` with the same
    /// numeric value. Because the underlying types of `x` and `y` are
    /// different, the two variables do not compare as equal despite having
    /// equal underlying values.
    ///
    ///     let x = AnyHashable(Int(42))
    ///     let y = AnyHashable(UInt8(42))
    ///
    ///     print(x == y)
    ///     // Prints "false" because `Int` and `UInt8` are different types
    ///
    ///     print(x == AnyHashable(Int(42)))
    ///     // Prints "true"
    ///
    /// - Parameters:
    ///   - lhs: A type-erased hashable value.
    ///   - rhs: Another type-erased hashable value.
    public static func == (lhs: AnyHashable, rhs: AnyHashable) -> Bool
}

extension AnyHashable : Hashable {

    /// The hash value.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension AnyHashable : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension AnyHashable : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

extension AnyHashable : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// A wrapper over an underlying index that hides the specific underlying type.
public struct AnyIndex {

    /// Creates a new index wrapping `base`.
    public init<BaseIndex>(_ base: BaseIndex) where BaseIndex : Comparable
}

extension AnyIndex : Comparable {

    /// Returns a Boolean value indicating whether two indices wrap equal
    /// underlying indices.
    ///
    /// The types of the two underlying indices must be identical.
    ///
    /// - Parameters:
    ///   - lhs: An index to compare.
    ///   - rhs: Another index to compare.
    public static func == (lhs: AnyIndex, rhs: AnyIndex) -> Bool

    /// Returns a Boolean value indicating whether the first argument represents a
    /// position before the second argument.
    ///
    /// The types of the two underlying indices must be identical.
    ///
    /// - Parameters:
    ///   - lhs: An index to compare.
    ///   - rhs: Another index to compare.
    public static func < (lhs: AnyIndex, rhs: AnyIndex) -> Bool
}

/// A type-erased iterator of `Element`.
///
/// This iterator forwards its `next()` method to an arbitrary underlying
/// iterator having the same `Element` type, hiding the specifics of the
/// underlying `IteratorProtocol`.
public struct AnyIterator<Element> {

    /// Creates an iterator that wraps a base iterator but whose type depends
    /// only on the base iterator's element type.
    ///
    /// You can use `AnyIterator` to hide the type signature of a more complex
    /// iterator. For example, the `digits()` function in the following example
    /// creates an iterator over a collection that lazily maps the elements of a
    /// `Range<Int>` instance to strings. Instead of returning an
    /// iterator with a type that encapsulates the implementation of the
    /// collection, the `digits()` function first wraps the iterator in an
    /// `AnyIterator` instance.
    ///
    ///     func digits() -> AnyIterator<String> {
    ///         let lazyStrings = (0..<10).lazy.map { String($0) }
    ///         let iterator:
    ///             LazyMapIterator<IndexingIterator<Range<Int>>, String>
    ///             = lazyStrings.makeIterator()
    ///
    ///         return AnyIterator(iterator)
    ///     }
    ///
    /// - Parameter base: An iterator to type-erase.
    public init<I>(_ base: I) where Element == I.Element, I : IteratorProtocol

    /// Creates an iterator that wraps the given closure in its `next()` method.
    ///
    /// The following example creates an iterator that counts up from the initial
    /// value of an integer `x` to 15:
    ///
    ///     var x = 7
    ///     let iterator: AnyIterator<Int> = AnyIterator {
    ///         defer { x += 1 }
    ///         return x < 15 ? x : nil
    ///     }
    ///     let a = Array(iterator)
    ///     // a == [7, 8, 9, 10, 11, 12, 13, 14]
    ///
    /// - Parameter body: A closure that returns an optional element. `body` is
    ///   executed each time the `next()` method is called on the resulting
    ///   iterator.
    public init(_ body: @escaping () -> AnyIterator<Element>.Element?)
}

extension AnyIterator : IteratorProtocol {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    public func next() -> Element?
}

/// Every `IteratorProtocol` can also be a `Sequence`.  Note that
/// traversing the sequence consumes the iterator.
extension AnyIterator : Sequence {
}

/// A type-erased key path, from any root type to any resulting value type.
public class AnyKeyPath : Hashable, _AppendKeyPath {

    /// The root type for this key path.
    public static var rootType: Any.Type { get }

    /// The value type for this key path.
    public static var valueType: Any.Type { get }

    /// The hash value.
    final public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AnyKeyPath, b: AnyKeyPath) -> Bool
}

/// The protocol to which all classes implicitly conform.
///
/// You use `AnyObject` when you need the flexibility of an untyped object or
/// when you use bridged Objective-C methods and properties that return an
/// untyped result. `AnyObject` can be used as the concrete type for an
/// instance of any class, class type, or class-only protocol. For example:
///
///     class FloatRef {
///         let value: Float
///         init(_ value: Float) {
///             self.value = value
///         }
///     }
///
///     let x = FloatRef(2.3)
///     let y: AnyObject = x
///     let z: AnyObject = FloatRef.self
///
/// `AnyObject` can also be used as the concrete type for an instance of a type
/// that bridges to an Objective-C class. Many value types in Swift bridge to
/// Objective-C counterparts, like `String` and `Int`.
///
///     let s: AnyObject = "This is a bridged string." as NSString
///     print(s is NSString)
///     // Prints "true"
///
///     let v: AnyObject = 100 as NSNumber
///     print(type(of: v))
///     // Prints "__NSCFNumber"
///
/// The flexible behavior of the `AnyObject` protocol is similar to
/// Objective-C's `id` type. For this reason, imported Objective-C types
/// frequently use `AnyObject` as the type for properties, method parameters,
/// and return values.
///
/// Casting AnyObject Instances to a Known Type
/// ===========================================
///
/// Objects with a concrete type of `AnyObject` maintain a specific dynamic
/// type and can be cast to that type using one of the type-cast operators
/// (`as`, `as?`, or `as!`).
///
/// This example uses the conditional downcast operator (`as?`) to
/// conditionally cast the `s` constant declared above to an instance of
/// Swift's `String` type.
///
///     if let message = s as? String {
///         print("Successful cast to String: \(message)")
///     }
///     // Prints "Successful cast to String: This is a bridged string."
///
/// If you have prior knowledge that an `AnyObject` instance has a particular
/// type, you can use the unconditional downcast operator (`as!`). Performing
/// an invalid cast triggers a runtime error.
///
///     let message = s as! String
///     print("Successful cast to String: \(message)")
///     // Prints "Successful cast to String: This is a bridged string."
///
///     let badCase = v as! String
///     // Runtime error
///
/// Casting is always safe in the context of a `switch` statement.
///
///     let mixedArray: [AnyObject] = [s, v]
///     for object in mixedArray {
///         switch object {
///         case let x as String:
///             print("'\(x)' is a String")
///         default:
///             print("'\(object)' is not a String")
///         }
///     }
///     // Prints "'This is a bridged string.' is a String"
///     // Prints "'100' is not a String"
///
/// Accessing Objective-C Methods and Properties
/// ============================================
///
/// When you use `AnyObject` as a concrete type, you have at your disposal
/// every `@objc` method and property---that is, methods and properties
/// imported from Objective-C or marked with the `@objc` attribute. Because
/// Swift can't guarantee at compile time that these methods and properties
/// are actually available on an `AnyObject` instance's underlying type, these
/// `@objc` symbols are available as implicitly unwrapped optional methods and
/// properties, respectively.
///
/// This example defines an `IntegerRef` type with an `@objc` method named
/// `getIntegerValue()`.
///
///     class IntegerRef {
///         let value: Int
///         init(_ value: Int) {
///             self.value = value
///         }
///
///         @objc func getIntegerValue() -> Int {
///             return value
///         }
///     }
///
///     func getObject() -> AnyObject {
///         return IntegerRef(100)
///     }
///
///     let obj: AnyObject = getObject()
///
/// In the example, `obj` has a static type of `AnyObject` and a dynamic type
/// of `IntegerRef`. You can use optional chaining to call the `@objc` method
/// `getIntegerValue()` on `obj` safely. If you're sure of the dynamic type of
/// `obj`, you can call `getIntegerValue()` directly.
///
///     let possibleValue = obj.getIntegerValue?()
///     print(possibleValue)
///     // Prints "Optional(100)"
///
///     let certainValue = obj.getIntegerValue()
///     print(certainValue)
///     // Prints "100"
///
/// If the dynamic type of `obj` doesn't implement a `getIntegerValue()`
/// method, the system returns a runtime error when you initialize
/// `certainValue`.
///
/// Alternatively, if you need to test whether `obj.getIntegerValue()` exists,
/// use optional binding before calling the method.
///
///     if let f = obj.getIntegerValue {
///         print("The value of 'obj' is \(f())")
///     } else {
///         print("'obj' does not have a 'getIntegerValue()' method")
///     }
///     // Prints "The value of 'obj' is 100"
public typealias AnyObject

/// A type-erased wrapper over any collection with indices that
/// support random access traversal.
///
/// An `AnyRandomAccessCollection` instance forwards its operations to a base collection having the
/// same `Element` type, hiding the specifics of the underlying
/// collection.
public struct AnyRandomAccessCollection<Element> {
}

extension AnyRandomAccessCollection {

    /// Returns an iterator over the elements of this collection.
    public func makeIterator() -> AnyRandomAccessCollection<Element>.Iterator

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    public var underestimatedCount: Int { get }

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element]

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: (Element) throws -> Void) rethrows

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element is a match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func drop(while predicate: (Element) throws -> Bool) rethrows -> AnyRandomAccessCollection<Element>

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the sequence.
    public func dropFirst(_ n: Int) -> AnyRandomAccessCollection<Element>

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence leaving off the specified number of elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> AnyRandomAccessCollection<Element>

    /// Returns a subsequence containing the initial, consecutive elements that
    /// satisfy the given predicate.
    ///
    /// The following example uses the `prefix(while:)` method to find the
    /// positive numbers at the beginning of the `numbers` array. Every element
    /// of `numbers` up to, but not including, the first negative value is
    /// included in the result.
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     let positivePrefix = numbers.prefix(while: { $0 > 0 })
    ///     // positivePrefix == [3, 7, 4]
    ///
    /// If `predicate` matches every element in the sequence, the resulting
    /// sequence contains every element of the sequence.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element should be included in the result.
    /// - Returns: A subsequence of the initial, consecutive elements that
    ///   satisfy `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func prefix(while predicate: (Element) throws -> Bool) rethrows -> AnyRandomAccessCollection<Element>

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> AnyRandomAccessCollection<Element>

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number
    /// of elements in the sequence, the result contains all the elements in
    /// the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of this sequence with
    ///   at most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> AnyRandomAccessCollection<Element>

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " })
    ///               .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(
    ///         line.split(maxSplits: 1, whereSeparator: { $0 == " " })
    ///             .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false,
    ///                      whereSeparator: { $0 == " " })
    ///          ).map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Element) throws -> Bool) rethrows -> [AnyRandomAccessCollection<Element>]
}

extension AnyRandomAccessCollection : RandomAccessCollection {

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultIndices<AnyRandomAccessCollection<Element>>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = AnyIterator<Element>

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = AnyIndex

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = AnyRandomAccessCollection<Element>

    /// Creates a type-erased collection that wraps the given collection.
    ///
    /// - Parameter base: The collection to wrap.
    ///
    /// - Complexity: O(1).
    public init<C>(_ base: C) where Element == C.Element, C : RandomAccessCollection

    /// Creates an `AnyRandomAccessCollection` having the same underlying collection as `other`.
    ///
    /// - Complexity: O(1)
    public init(_ other: AnyRandomAccessCollection<Element>)

    /// Creates an `AnyRandomAccessCollection` having the same underlying collection as `other`.
    ///
    /// If the underlying collection stored by `other` does not satisfy
    /// `RandomAccessCollection`, the result is `nil`.
    ///
    /// - Complexity: O(1)
    public init?(_ other: AnyCollection<Element>)

    /// Creates an `AnyRandomAccessCollection` having the same underlying collection as `other`.
    ///
    /// If the underlying collection stored by `other` does not satisfy
    /// `RandomAccessCollection`, the result is `nil`.
    ///
    /// - Complexity: O(1)
    public init?(_ other: AnyBidirectionalCollection<Element>)

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: AnyRandomAccessCollection<Element>.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: AnyRandomAccessCollection<Element>.Index { get }

    /// Accesses the element indicated by `position`.
    ///
    /// - Precondition: `position` indicates a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: AnyRandomAccessCollection<Element>.Index) -> Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<AnyRandomAccessCollection<Element>.Index>) -> AnyRandomAccessCollection<Element>.SubSequence { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: AnyRandomAccessCollection<Element>.Index) -> AnyRandomAccessCollection<Element>.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout AnyRandomAccessCollection<Element>.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyRandomAccessCollection<Element>.Index, offsetBy n: Int) -> AnyRandomAccessCollection<Element>.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: AnyRandomAccessCollection<Element>.Index, offsetBy n: Int, limitedBy limit: AnyRandomAccessCollection<Element>.Index) -> AnyRandomAccessCollection<Element>.Index?

    public func formIndex(_ i: inout AnyRandomAccessCollection<Element>.Index, offsetBy n: Int)

    public func formIndex(_ i: inout AnyRandomAccessCollection<Element>.Index, offsetBy n: Int, limitedBy limit: AnyRandomAccessCollection<Element>.Index) -> Bool

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: AnyRandomAccessCollection<Element>.Index, to end: AnyRandomAccessCollection<Element>.Index) -> Int

    /// The number of elements.
    ///
    /// - Complexity: O(1)
    public var count: Int { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Element? { get }

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: AnyRandomAccessCollection<Element>.Index) -> AnyRandomAccessCollection<Element>.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout AnyRandomAccessCollection<Element>.Index)

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Element? { get }
}

extension AnyRandomAccessCollection {
}

public struct AnySequence<Element> {

    /// Creates a sequence whose `makeIterator()` method forwards to
    /// `makeUnderlyingIterator`.
    public init<I>(_ makeUnderlyingIterator: @escaping () -> I) where Element == I.Element, I : IteratorProtocol
}

extension AnySequence : Sequence {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = AnyIterator<Element>

    /// Creates a new sequence that wraps and forwards operations to `base`.
    public init<S>(_ base: S) where Element == S.Element, S : Sequence
}

extension AnySequence {

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> AnySequence<Element>.Iterator

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    public var underestimatedCount: Int { get }

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    public func filter(_ isIncluded: (Element) throws -> Bool) rethrows -> [Element]

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: (Element) throws -> Void) rethrows

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element is a match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func drop(while predicate: (Element) throws -> Bool) rethrows -> AnySequence<Element>

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the sequence.
    public func dropFirst(_ n: Int) -> AnySequence<Element>

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence leaving off the specified number of elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> AnySequence<Element>

    /// Returns a subsequence containing the initial, consecutive elements that
    /// satisfy the given predicate.
    ///
    /// The following example uses the `prefix(while:)` method to find the
    /// positive numbers at the beginning of the `numbers` array. Every element
    /// of `numbers` up to, but not including, the first negative value is
    /// included in the result.
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     let positivePrefix = numbers.prefix(while: { $0 > 0 })
    ///     // positivePrefix == [3, 7, 4]
    ///
    /// If `predicate` matches every element in the sequence, the resulting
    /// sequence contains every element of the sequence.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element should be included in the result.
    /// - Returns: A subsequence of the initial, consecutive elements that
    ///   satisfy `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func prefix(while predicate: (Element) throws -> Bool) rethrows -> AnySequence<Element>

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> AnySequence<Element>

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number
    /// of elements in the sequence, the result contains all the elements in
    /// the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of this sequence with
    ///   at most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> AnySequence<Element>

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " })
    ///               .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(
    ///         line.split(maxSplits: 1, whereSeparator: { $0 == " " })
    ///             .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false,
    ///                      whereSeparator: { $0 == " " })
    ///          ).map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Element) throws -> Bool) rethrows -> [AnySequence<Element>]
}

/// An ordered, random-access collection.
///
/// Arrays are one of the most commonly used data types in an app. You use
/// arrays to organize your app's data. Specifically, you use the `Array` type
/// to hold elements of a single type, the array's `Element` type. An array
/// can store any kind of elements---from integers to strings to classes.
///
/// Swift makes it easy to create arrays in your code using an array literal:
/// simply surround a comma-separated list of values with square brackets.
/// Without any other information, Swift creates an array that includes the
/// specified values, automatically inferring the array's `Element` type. For
/// example:
///
///     // An array of 'Int' elements
///     let oddNumbers = [1, 3, 5, 7, 9, 11, 13, 15]
///
///     // An array of 'String' elements
///     let streets = ["Albemarle", "Brandywine", "Chesapeake"]
///
/// You can create an empty array by specifying the `Element` type of your
/// array in the declaration. For example:
///
///     // Shortened forms are preferred
///     var emptyDoubles: [Double] = []
///
///     // The full type name is also allowed
///     var emptyFloats: Array<Float> = Array()
///
/// If you need an array that is preinitialized with a fixed number of default
/// values, use the `Array(repeating:count:)` initializer.
///
///     var digitCounts = Array(repeating: 0, count: 10)
///     print(digitCounts)
///     // Prints "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
///
/// Accessing Array Values
/// ======================
///
/// When you need to perform an operation on all of an array's elements, use a
/// `for`-`in` loop to iterate through the array's contents.
///
///     for street in streets {
///         print("I don't live on \(street).")
///     }
///     // Prints "I don't live on Albemarle."
///     // Prints "I don't live on Brandywine."
///     // Prints "I don't live on Chesapeake."
///
/// Use the `isEmpty` property to check quickly whether an array has any
/// elements, or use the `count` property to find the number of elements in
/// the array.
///
///     if oddNumbers.isEmpty {
///         print("I don't know any odd numbers.")
///     } else {
///         print("I know \(oddNumbers.count) odd numbers.")
///     }
///     // Prints "I know 8 odd numbers."
///
/// Use the `first` and `last` properties for safe access to the value of the
/// array's first and last elements. If the array is empty, these properties
/// are `nil`.
///
///     if let firstElement = oddNumbers.first, let lastElement = oddNumbers.last {
///         print(firstElement, lastElement, separator: ", ")
///     }
///     // Prints "1, 15"
///
///     print(emptyDoubles.first, emptyDoubles.last, separator: ", ")
///     // Prints "nil, nil"
///
/// You can access individual array elements through a subscript. The first
/// element of a nonempty array is always at index zero. You can subscript an
/// array with any integer from zero up to, but not including, the count of
/// the array. Using a negative number or an index equal to or greater than
/// `count` triggers a runtime error. For example:
///
///     print(oddNumbers[0], oddNumbers[3], separator: ", ")
///     // Prints "1, 7"
///
///     print(emptyDoubles[0])
///     // Triggers runtime error: Index out of range
///
/// Adding and Removing Elements
/// ============================
///
/// Suppose you need to store a list of the names of students that are signed
/// up for a class you're teaching. During the registration period, you need
/// to add and remove names as students add and drop the class.
///
///     var students = ["Ben", "Ivy", "Jordell"]
///
/// To add single elements to the end of an array, use the `append(_:)` method.
/// Add multiple elements at the same time by passing another array or a
/// sequence of any kind to the `append(contentsOf:)` method.
///
///     students.append("Maxime")
///     students.append(contentsOf: ["Shakia", "William"])
///     // ["Ben", "Ivy", "Jordell", "Maxime", "Shakia", "William"]
///
/// You can add new elements in the middle of an array by using the
/// `insert(_:at:)` method for single elements and by using
/// `insert(contentsOf:at:)` to insert multiple elements from another
/// collection or array literal. The elements at that index and later indices
/// are shifted back to make room.
///
///     students.insert("Liam", at: 3)
///     // ["Ben", "Ivy", "Jordell", "Liam", "Maxime", "Shakia", "William"]
///
/// To remove elements from an array, use the `remove(at:)`,
/// `removeSubrange(_:)`, and `removeLast()` methods.
///
///     // Ben's family is moving to another state
///     students.remove(at: 0)
///     // ["Ivy", "Jordell", "Liam", "Maxime", "Shakia", "William"]
///
///     // William is signing up for a different class
///     students.removeLast()
///     // ["Ivy", "Jordell", "Liam", "Maxime", "Shakia"]
///
/// You can replace an existing element with a new value by assigning the new
/// value to the subscript.
///
///     if let i = students.firstIndex(of: "Maxime") {
///         students[i] = "Max"
///     }
///     // ["Ivy", "Jordell", "Liam", "Max", "Shakia"]
///
/// Growing the Size of an Array
/// ----------------------------
///
/// Every array reserves a specific amount of memory to hold its contents. When
/// you add elements to an array and that array begins to exceed its reserved
/// capacity, the array allocates a larger region of memory and copies its
/// elements into the new storage. The new storage is a multiple of the old
/// storage's size. This exponential growth strategy means that appending an
/// element happens in constant time, averaging the performance of many append
/// operations. Append operations that trigger reallocation have a performance
/// cost, but they occur less and less often as the array grows larger.
///
/// If you know approximately how many elements you will need to store, use the
/// `reserveCapacity(_:)` method before appending to the array to avoid
/// intermediate reallocations. Use the `capacity` and `count` properties to
/// determine how many more elements the array can store without allocating
/// larger storage.
///
/// For arrays of most `Element` types, this storage is a contiguous block of
/// memory. For arrays with an `Element` type that is a class or `@objc`
/// protocol type, this storage can be a contiguous block of memory or an
/// instance of `NSArray`. Because any arbitrary subclass of `NSArray` can
/// become an `Array`, there are no guarantees about representation or
/// efficiency in this case.
///
/// Modifying Copies of Arrays
/// ==========================
///
/// Each array has an independent value that includes the values of all of its
/// elements. For simple types such as integers and other structures, this
/// means that when you change a value in one array, the value of that element
/// does not change in any copies of the array. For example:
///
///     var numbers = [1, 2, 3, 4, 5]
///     var numbersCopy = numbers
///     numbers[0] = 100
///     print(numbers)
///     // Prints "[100, 2, 3, 4, 5]"
///     print(numbersCopy)
///     // Prints "[1, 2, 3, 4, 5]"
///
/// If the elements in an array are instances of a class, the semantics are the
/// same, though they might appear different at first. In this case, the
/// values stored in the array are references to objects that live outside the
/// array. If you change a reference to an object in one array, only that
/// array has a reference to the new object. However, if two arrays contain
/// references to the same object, you can observe changes to that object's
/// properties from both arrays. For example:
///
///     // An integer type with reference semantics
///     class IntegerReference {
///         var value = 10
///     }
///     var firstIntegers = [IntegerReference(), IntegerReference()]
///     var secondIntegers = firstIntegers
///
///     // Modifications to an instance are visible from either array
///     firstIntegers[0].value = 100
///     print(secondIntegers[0].value)
///     // Prints "100"
///
///     // Replacements, additions, and removals are still visible
///     // only in the modified array
///     firstIntegers[0] = IntegerReference()
///     print(firstIntegers[0].value)
///     // Prints "10"
///     print(secondIntegers[0].value)
///     // Prints "100"
///
/// Arrays, like all variable-size collections in the standard library, use
/// copy-on-write optimization. Multiple copies of an array share the same
/// storage until you modify one of the copies. When that happens, the array
/// being modified replaces its storage with a uniquely owned copy of itself,
/// which is then modified in place. Optimizations are sometimes applied that
/// can reduce the amount of copying.
///
/// This means that if an array is sharing storage with other copies, the first
/// mutating operation on that array incurs the cost of copying the array. An
/// array that is the sole owner of its storage can perform mutating
/// operations in place.
///
/// In the example below, a `numbers` array is created along with two copies
/// that share the same storage. When the original `numbers` array is
/// modified, it makes a unique copy of its storage before making the
/// modification. Further modifications to `numbers` are made in place, while
/// the two copies continue to share the original storage.
///
///     var numbers = [1, 2, 3, 4, 5]
///     var firstCopy = numbers
///     var secondCopy = numbers
///
///     // The storage for 'numbers' is copied here
///     numbers[0] = 100
///     numbers[1] = 200
///     numbers[2] = 300
///     // 'numbers' is [100, 200, 300, 4, 5]
///     // 'firstCopy' and 'secondCopy' are [1, 2, 3, 4, 5]
///
/// Bridging Between Array and NSArray
/// ==================================
///
/// When you need to access APIs that require data in an `NSArray` instance
/// instead of `Array`, use the type-cast operator (`as`) to bridge your
/// instance. For bridging to be possible, the `Element` type of your array
/// must be a class, an `@objc` protocol (a protocol imported from Objective-C
/// or marked with the `@objc` attribute), or a type that bridges to a
/// Foundation type.
///
/// The following example shows how you can bridge an `Array` instance to
/// `NSArray` to use the `write(to:atomically:)` method. In this example, the
/// `colors` array can be bridged to `NSArray` because the `colors` array's
/// `String` elements bridge to `NSString`. The compiler prevents bridging the
/// `moreColors` array, on the other hand, because its `Element` type is
/// `Optional<String>`, which does *not* bridge to a Foundation type.
///
///     let colors = ["periwinkle", "rose", "moss"]
///     let moreColors: [String?] = ["ochre", "pine"]
///
///     let url = NSURL(fileURLWithPath: "names.plist")
///     (colors as NSArray).write(to: url, atomically: true)
///     // true
///
///     (moreColors as NSArray).write(to: url, atomically: true)
///     // error: cannot convert value of type '[String?]' to type 'NSArray'
///
/// Bridging from `Array` to `NSArray` takes O(1) time and O(1) space if the
/// array's elements are already instances of a class or an `@objc` protocol;
/// otherwise, it takes O(*n*) time and space.
///
/// When the destination array's element type is a class or an `@objc`
/// protocol, bridging from `NSArray` to `Array` first calls the `copy(with:)`
/// (`- copyWithZone:` in Objective-C) method on the array to get an immutable
/// copy and then performs additional Swift bookkeeping work that takes O(1)
/// time. For instances of `NSArray` that are already immutable, `copy(with:)`
/// usually returns the same array in O(1) time; otherwise, the copying
/// performance is unspecified. If `copy(with:)` returns the same array, the
/// instances of `NSArray` and `Array` share storage using the same
/// copy-on-write optimization that is used when two instances of `Array`
/// share storage.
///
/// When the destination array's element type is a nonclass type that bridges
/// to a Foundation type, bridging from `NSArray` to `Array` performs a
/// bridging copy of the elements to contiguous storage in O(*n*) time. For
/// example, bridging from `NSArray` to `Array<Int>` performs such a copy. No
/// further bridging is required when accessing elements of the `Array`
/// instance.
///
/// - Note: The `ContiguousArray` and `ArraySlice` types are not bridged;
///   instances of those types always have a contiguous block of memory as
///   their storage.
public struct Array<Element> {
}

extension Array : RandomAccessCollection, MutableCollection {

    /// The index type for arrays, `Int`.
    public typealias Index = Int

    /// The type that represents the indices that are valid for subscripting an
    /// array, in ascending order.
    public typealias Indices = Range<Int>

    /// The type that allows iteration over an array's elements.
    public typealias Iterator = IndexingIterator<[Element]>

    /// The position of the first element in a nonempty array.
    ///
    /// For an instance of `Array`, `startIndex` is always zero. If the array
    /// is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The array's "past the end" position---that is, the position one greater
    /// than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of an array, use the
    /// half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let i = numbers.firstIndex(of: 30) {
    ///         print(numbers[i ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the array is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index immediately before `i`.
    public func index(before i: Int) -> Int

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Int)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    public func index(_ i: Int, offsetBy n: Int) -> Int

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position. The
    /// operation doesn't require going beyond the limiting `numbers.endIndex`
    /// value, so it succeeds.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let i = numbers.index(numbers.startIndex,
    ///                              offsetBy: 4,
    ///                              limitedBy: numbers.endIndex) {
    ///         print(numbers[i])
    ///     }
    ///     // Prints "50"
    ///
    /// The next example attempts to retrieve an index ten positions from
    /// `numbers.startIndex`, but fails, because that distance is beyond the
    /// index passed as `limit`.
    ///
    ///     let j = numbers.index(numbers.startIndex,
    ///                           offsetBy: 10,
    ///                           limitedBy: numbers.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    public func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -> Int?

    /// Returns the distance between two indices.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`.
    public func distance(from start: Int, to end: Int) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example uses indexed subscripting to update an array's
    /// second element. After assigning the new value (`"Butler"`) at a specific
    /// position, that value is immediately available at that same position.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// - Parameter index: The position of the element to access. `index` must be
    ///   greater than or equal to `startIndex` and less than `endIndex`.
    ///
    /// - Complexity: Reading an element from an array is O(1). Writing is O(1)
    ///   unless the array's storage is shared with another array, in which case
    ///   writing is O(*n*), where *n* is the length of the array.
    ///   If the array uses a bridged `NSArray` instance as its storage, the
    ///   efficiency is unspecified.
    public subscript(index: Int) -> Element

    /// Accesses a contiguous subrange of the array's elements.
    ///
    /// The returned `ArraySlice` instance uses the same indices for the same
    /// elements as the original array. In particular, that slice, unlike an
    /// array, may have a nonzero `startIndex` and an `endIndex` that is not
    /// equal to `count`. Always use the slice's `startIndex` and `endIndex`
    /// properties instead of assuming that its indices start or end at a
    /// particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let i = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[i!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of integers. The bounds of the range must be
    ///   valid indices of the array.
    public subscript(bounds: Range<Int>) -> ArraySlice<Element>
}

extension Array : ExpressibleByArrayLiteral {

    /// Creates an array from the given array literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler
    /// when you use an array literal. Instead, create a new array by using an
    /// array literal as its value. To do this, enclose a comma-separated list of
    /// values in square brackets.
    ///
    /// Here, an array of strings is created from an array literal holding
    /// only strings.
    ///
    ///     let ingredients = ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///
    /// - Parameter elements: A variadic list of elements of the new array.
    public init(arrayLiteral elements: [Element].Element...)
}

extension Array : RangeReplaceableCollection {

    /// Creates a new, empty array.
    ///
    /// This is equivalent to initializing with an empty array literal.
    /// For example:
    ///
    ///     var emptyArray = Array<Int>()
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    ///
    ///     emptyArray = []
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    public init()

    /// Creates an array containing the elements of a sequence.
    ///
    /// You can use this initializer to create an array from any other type that
    /// conforms to the `Sequence` protocol. For example, you might want to
    /// create an array with the integers from 1 through 7. Use this initializer
    /// around a range instead of typing all those numbers in an array literal.
    ///
    ///     let numbers = Array(1...7)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7]"
    ///
    /// You can also use this initializer to convert a complex sequence or
    /// collection type back to an array. For example, the `keys` property of
    /// a dictionary isn't an array with its own storage, it's a collection
    /// that maps its elements from the dictionary only when they're
    /// accessed, saving the time and space needed to allocate an array. If
    /// you need to pass those keys to a method that takes an array, however,
    /// use this initializer to convert that list from its type of
    /// `LazyMapCollection<Dictionary<String, Int>, Int>` to a simple
    /// `[String]`.
    ///
    ///     func cacheImagesWithNames(names: [String]) {
    ///         // custom image loading and caching
    ///      }
    ///
    ///     let namedHues: [String: Int] = ["Vermillion": 18, "Magenta": 302,
    ///             "Gold": 50, "Cerise": 320]
    ///     let colorNames = Array(namedHues.keys)
    ///     cacheImagesWithNames(colorNames)
    ///
    ///     print(colorNames)
    ///     // Prints "["Gold", "Cerise", "Magenta", "Vermillion"]"
    ///
    /// - Parameter s: The sequence of elements to turn into an array.
    public init<S>(_ s: S) where Element == S.Element, S : Sequence

    /// Creates a new array containing the specified number of a single, repeated
    /// value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: [Element].Element, count: Int)

    /// The number of elements in the array.
    public var count: Int { get }

    /// The total number of elements that the array can contain without
    /// allocating new storage.
    ///
    /// Every array reserves a specific amount of memory to hold its contents.
    /// When you add elements to an array and that array begins to exceed its
    /// reserved capacity, the array allocates a larger region of memory and
    /// copies its elements into the new storage. The new storage is a multiple
    /// of the old storage's size. This exponential growth strategy means that
    /// appending an element happens in constant time, averaging the performance
    /// of many append operations. Append operations that trigger reallocation
    /// have a performance cost, but they occur less and less often as the array
    /// grows larger.
    ///
    /// The following example creates an array of integers from an array literal,
    /// then appends the elements of another collection. Before appending, the
    /// array allocates new storage that is large enough store the resulting
    /// elements.
    ///
    ///     var numbers = [10, 20, 30, 40, 50]
    ///     // numbers.count == 5
    ///     // numbers.capacity == 5
    ///
    ///     numbers.append(contentsOf: stride(from: 60, through: 100, by: 10))
    ///     // numbers.count == 10
    ///     // numbers.capacity == 12
    public var capacity: Int { get }

    /// Reserves enough space to store the specified number of elements.
    ///
    /// If you are adding a known number of elements to an array, use this method
    /// to avoid multiple reallocations. This method ensures that the array has
    /// unique, mutable, contiguous storage, with space allocated for at least
    /// the requested number of elements.
    ///
    /// Calling the `reserveCapacity(_:)` method on an array with bridged storage
    /// triggers a copy to contiguous storage even if the existing storage
    /// has room to store `minimumCapacity` elements.
    ///
    /// For performance reasons, the size of the newly allocated storage might be
    /// greater than the requested capacity. Use the array's `capacity` property
    /// to determine the size of the new storage.
    ///
    /// Preserving an Array's Geometric Growth Strategy
    /// ===============================================
    ///
    /// If you implement a custom data structure backed by an array that grows
    /// dynamically, naively calling the `reserveCapacity(_:)` method can lead
    /// to worse than expected performance. Arrays need to follow a geometric
    /// allocation pattern for appending elements to achieve amortized
    /// constant-time performance. The `Array` type's `append(_:)` and
    /// `append(contentsOf:)` methods take care of this detail for you, but
    /// `reserveCapacity(_:)` allocates only as much space as you tell it to
    /// (padded to a round value), and no more. This avoids over-allocation, but
    /// can result in insertion not having amortized constant-time performance.
    ///
    /// The following code declares `values`, an array of integers, and the
    /// `addTenQuadratic()` function, which adds ten more values to the `values`
    /// array on each call.
    ///
    ///       var values: [Int] = [0, 1, 2, 3]
    ///
    ///       // Don't use 'reserveCapacity(_:)' like this
    ///       func addTenQuadratic() {
    ///           let newCount = values.count + 10
    ///           values.reserveCapacity(newCount)
    ///           for n in values.count..<newCount {
    ///               values.append(n)
    ///           }
    ///       }
    ///
    /// The call to `reserveCapacity(_:)` increases the `values` array's capacity
    /// by exactly 10 elements on each pass through `addTenQuadratic()`, which
    /// is linear growth. Instead of having constant time when averaged over
    /// many calls, the function may decay to performance that is linear in
    /// `values.count`. This is almost certainly not what you want.
    ///
    /// In cases like this, the simplest fix is often to simply remove the call
    /// to `reserveCapacity(_:)`, and let the `append(_:)` method grow the array
    /// for you.
    ///
    ///       func addTen() {
    ///           let newCount = values.count + 10
    ///           for n in values.count..<newCount {
    ///               values.append(n)
    ///           }
    ///       }
    ///
    /// If you need more control over the capacity of your array, implement your
    /// own geometric growth strategy, passing the size you compute to
    /// `reserveCapacity(_:)`.
    ///
    /// - Parameter minimumCapacity: The requested number of elements to store.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements in the array.
    public mutating func reserveCapacity(_ minimumCapacity: Int)

    /// Adds a new element at the end of the array.
    ///
    /// Use this method to append a single element to the end of a mutable array.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(100)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 100]"
    ///
    /// Because arrays increase their allocated capacity using an exponential
    /// strategy, appending a single element to an array is an O(1) operation
    /// when averaged over many calls to the `append(_:)` method. When an array
    /// has additional capacity and is not sharing its storage with another
    /// instance, appending an element is O(1). When an array needs to
    /// reallocate storage before appending or its storage is shared with
    /// another copy, appending is O(*n*), where *n* is the length of the array.
    ///
    /// - Parameter newElement: The element to append to the array.
    ///
    /// - Complexity: Amortized O(1) over many additions. If the array uses a
    ///   bridged `NSArray` instance as its storage, the efficiency is
    ///   unspecified.
    public mutating func append(_ newElement: [Element].Element)

    /// Adds the elements of a sequence to the end of the array.
    ///
    /// Use this method to append the elements of a sequence to the end of this
    /// array. This example appends the elements of a `Range<Int>` instance
    /// to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the array.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting array.
    public mutating func append<S>(contentsOf newElements: S) where Element == S.Element, S : Sequence

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved up to
    /// close the gap.
    ///
    ///     var measurements: [Double] = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.1, 1.5, 1.2, 1.5, 1.3, 1.2]"
    ///
    /// - Parameter index: The position of the element to remove. `index` must
    ///   be a valid index of the array.
    /// - Returns: The element at the specified index.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func remove(at index: Int) -> [Element].Element

    /// Inserts a new element at the specified position.
    ///
    /// The new element is inserted before the element currently at the specified
    /// index. If you pass the array's `endIndex` property as the `index`
    /// parameter, the new element is appended to the array.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// - Parameter newElement: The new element to insert into the array.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index of the array or equal to its `endIndex`
    ///   property.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func insert(_ newElement: [Element].Element, at i: Int)

    /// Removes all elements from the array.
    ///
    /// - Parameter keepCapacity: Pass `true` to keep the existing capacity of
    ///   the array after removing its elements. The default value is
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)
}

extension Array : CustomReflectable {

    /// A mirror that reflects the array.
    public var customMirror: Mirror { get }
}

extension Array : CustomStringConvertible, CustomDebugStringConvertible {

    /// A textual representation of the array and its elements.
    public var description: String { get }

    /// A textual representation of the array and its elements, suitable for
    /// debugging.
    public var debugDescription: String { get }
}

extension Array {

    /// Calls a closure with a pointer to the array's contiguous storage.
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows how you can iterate over the contents of the
    /// buffer pointer:
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     let sum = numbers.withUnsafeBufferPointer { buffer -> Int in
    ///         var result = 0
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {
    ///             result += buffer[i]
    ///         }
    ///         return result
    ///     }
    ///     // 'sum' == 9
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withUnsafeBufferPointer(_:)`. Do not store or return the
    /// pointer for later use.
    ///
    /// - Parameter body: A closure with an `UnsafeBufferPointer` parameter that
    ///   points to the contiguous storage for the array.  If no such storage exists, it is created. If
    ///   `body` has a return value, that value is also used as the return value
    ///   for the `withUnsafeBufferPointer(_:)` method. The pointer argument is
    ///   valid only for the duration of the method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<[Element].Element>) throws -> R) rethrows -> R

    /// Calls the given closure with a pointer to the array's mutable contiguous
    /// storage.
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows how modifying the contents of the
    /// `UnsafeMutableBufferPointer` argument to `body` alters the contents of
    /// the array:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.withUnsafeMutableBufferPointer { buffer in
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {
    ///             buffer.swapAt(i, i + 1)
    ///         }
    ///     }
    ///     print(numbers)
    ///     // Prints "[2, 1, 4, 3, 5]"
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withUnsafeMutableBufferPointer(_:)`. Do not store or
    /// return the pointer for later use.
    ///
    /// - Warning: Do not rely on anything about the array that is the target of
    ///   this method during execution of the `body` closure; it might not
    ///   appear to have its correct value. Instead, use only the
    ///   `UnsafeMutableBufferPointer` argument to `body`.
    ///
    /// - Parameter body: A closure with an `UnsafeMutableBufferPointer`
    ///   parameter that points to the contiguous storage for the array.
    ///    If no such storage exists, it is created. If `body` has a return value, that value is also
    ///   used as the return value for the `withUnsafeMutableBufferPointer(_:)`
    ///   method. The pointer argument is valid only for the duration of the
    ///   method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout UnsafeMutableBufferPointer<[Element].Element>) throws -> R) rethrows -> R
}

extension Array {

    /// Replaces a range of elements with the elements in the specified
    /// collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the array and inserting the new elements at the same location. The
    /// number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the array to replace. The start and end of
    ///     a subrange must be valid indices of the array.
    ///   - newElements: The new elements to add to the array.
    ///
    /// - Complexity: O(`subrange.count`) if you are replacing a suffix of the
    ///   array with an empty collection; otherwise, O(*n*), where *n* is the
    ///   length of the array.
    public mutating func replaceSubrange<C>(_ subrange: Range<Int>, with newElements: C) where Element == C.Element, C : Collection
}

extension Array : Equatable where Element : Equatable {

    /// Returns a Boolean value indicating whether two arrays contain the same
    /// elements in the same order.
    ///
    /// You can use the equal-to operator (`==`) to compare any two arrays
    /// that store the same, `Equatable`-conforming element type.
    ///
    /// - Parameters:
    ///   - lhs: An array to compare.
    ///   - rhs: Another array to compare.
    public static func == (lhs: [[Element].Element], rhs: [[Element].Element]) -> Bool

    /// Returns a Boolean value indicating whether two arrays are not equal.
    ///
    /// Two arrays are equal if they contain the same elements in the same order.
    /// You can use the not-equal-to operator (`!=`) to compare any two arrays
    /// that store the same, `Equatable`-conforming element type.
    ///
    /// - Parameters:
    ///   - lhs: An array to compare.
    ///   - rhs: Another array to compare.
    public static func != (lhs: [[Element].Element], rhs: [[Element].Element]) -> Bool
}

extension Array : Hashable where Element : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Array {

    /// Calls the given closure with a pointer to the underlying bytes of the
    /// array's mutable contiguous storage.
    ///
    /// The array's `Element` type must be a *trivial type*, which can be copied
    /// with just a bit-for-bit copy without any indirection or
    /// reference-counting operations. Generally, native Swift types that do not
    /// contain strong or weak references are trivial, as are imported C structs
    /// and enums.
    ///
    /// The following example copies bytes from the `byteValues` array into
    /// `numbers`, an array of `Int`:
    ///
    ///     var numbers: [Int32] = [0, 0]
    ///     var byteValues: [UInt8] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00]
    ///
    ///     numbers.withUnsafeMutableBytes { destBytes in
    ///         byteValues.withUnsafeBytes { srcBytes in
    ///             destBytes.copyBytes(from: srcBytes)
    ///         }
    ///     }
    ///     // numbers == [1, 2]
    ///
    /// The pointer passed as an argument to `body` is valid only for the
    /// lifetime of the closure. Do not escape it from the closure for later
    /// use.
    ///
    /// - Warning: Do not rely on anything about the array that is the target of
    ///   this method during execution of the `body` closure; it might not
    ///   appear to have its correct value. Instead, use only the
    ///   `UnsafeMutableRawBufferPointer` argument to `body`.
    ///
    /// - Parameter body: A closure with an `UnsafeMutableRawBufferPointer`
    ///   parameter that points to the contiguous storage for the array.
    ///    If no such storage exists, it is created. If `body` has a return value, that value is also
    ///   used as the return value for the `withUnsafeMutableBytes(_:)` method.
    ///   The argument is valid only for the duration of the closure's
    ///   execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public mutating func withUnsafeMutableBytes<R>(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R

    /// Calls the given closure with a pointer to the underlying bytes of the
    /// array's contiguous storage.
    ///
    /// The array's `Element` type must be a *trivial type*, which can be copied
    /// with just a bit-for-bit copy without any indirection or
    /// reference-counting operations. Generally, native Swift types that do not
    /// contain strong or weak references are trivial, as are imported C structs
    /// and enums.
    ///
    /// The following example copies the bytes of the `numbers` array into a
    /// buffer of `UInt8`:
    ///
    ///     var numbers = [1, 2, 3]
    ///     var byteBuffer: [UInt8] = []
    ///     numbers.withUnsafeBytes {
    ///         byteBuffer.append(contentsOf: $0)
    ///     }
    ///     // byteBuffer == [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, ...]
    ///
    /// - Parameter body: A closure with an `UnsafeRawBufferPointer` parameter
    ///   that points to the contiguous storage for the array.
    ///    If no such storage exists, it is created. If `body` has a return value, that value is also
    ///   used as the return value for the `withUnsafeBytes(_:)` method. The
    ///   argument is valid only for the duration of the closure's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

extension Array : Encodable where Element : Encodable {

    /// Encodes the elements of this array into the given encoder in an unkeyed
    /// container.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Array : Decodable where Element : Decodable {

    /// Creates a new array by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws
}

@available(*, deprecated, renamed: "ExpressibleByArrayLiteral")
public typealias ArrayLiteralConvertible = ExpressibleByArrayLiteral

/// A slice of an `Array`, `ContiguousArray`, or `ArraySlice` instance.
///
/// The `ArraySlice` type makes it fast and efficient for you to perform
/// operations on sections of a larger array. Instead of copying over the
/// elements of a slice to new storage, an `ArraySlice` instance presents a
/// view onto the storage of a larger array. And because `ArraySlice`
/// presents the same interface as `Array`, you can generally perform the
/// same operations on a slice as you could on the original array.
///
/// For more information about using arrays, see `Array` and `ContiguousArray`,
/// with which `ArraySlice` shares most properties and methods.
///
/// Slices Are Views onto Arrays
/// ============================
///
/// For example, suppose you have an array holding the number of absences
/// from each class during a session.
///
///     let absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You want to compare the absences in the first half of the session with
/// those in the second half. To do so, start by creating two slices of the
/// `absences` array.
///
///     let midpoint = absences.count / 2
///
///     let firstHalf = absences[..<midpoint]
///     let secondHalf = absences[midpoint...]
///
/// Neither the `firstHalf` nor `secondHalf` slices allocate any new storage
/// of their own. Instead, each presents a view onto the storage of the
/// `absences` array.
///
/// You can call any method on the slices that you might have called on the
/// `absences` array. To learn which half had more absences, use the
/// `reduce(_:_:)` method to calculate each sum.
///
///     let firstHalfSum = firstHalf.reduce(0, +)
///     let secondHalfSum = secondHalf.reduce(0, +)
///
///     if firstHalfSum > secondHalfSum {
///         print("More absences in the first half.")
///     } else {
///         print("More absences in the second half.")
///     }
///     // Prints "More absences in the first half."
///
/// - Important: Long-term storage of `ArraySlice` instances is discouraged. A
///   slice holds a reference to the entire storage of a larger array, not
///   just to the portion it presents, even after the original array's lifetime
///   ends. Long-term storage of a slice may therefore prolong the lifetime of
///   elements that are no longer otherwise accessible, which can appear to be
///   memory and object leakage.
///
/// Slices Maintain Indices
/// =======================
///
/// Unlike `Array` and `ContiguousArray`, the starting index for an
/// `ArraySlice` instance isn't always zero. Slices maintain the same
/// indices of the larger array for the same elements, so the starting
/// index of a slice depends on how it was created, letting you perform
/// index-based operations on either a full array or a slice.
///
/// Sharing indices between collections and their subsequences is an important
/// part of the design of Swift's collection algorithms. Suppose you are
/// tasked with finding the first two days with absences in the session. To
/// find the indices of the two days in question, follow these steps:
///
/// 1) Call `firstIndex(where:)` to find the index of the first element in the
///    `absences` array that is greater than zero.
/// 2) Create a slice of the `absences` array starting after the index found in
///    step 1.
/// 3) Call `firstIndex(where:)` again, this time on the slice created in step
///    2. Where in some languages you might pass a starting index into an
///    `indexOf` method to find the second day, in Swift you perform the same
///    operation on a slice of the original array.
/// 4) Print the results using the indices found in steps 1 and 3 on the
///    original `absences` array.
///
/// Here's an implementation of those steps:
///
///     if let i = absences.firstIndex(where: { $0 > 0 }) {                 // 1
///         let absencesAfterFirst = absences[(i + 1)...]                   // 2
///         if let j = absencesAfterFirst.firstIndex(where: { $0 > 0 }) {   // 3
///             print("The first day with absences had \(absences[i]).")    // 4
///             print("The second day with absences had \(absences[j]).")
///         }
///     }
///     // Prints "The first day with absences had 2."
///     // Prints "The second day with absences had 4."
///
/// In particular, note that `j`, the index of the second day with absences,
/// was found in a slice of the original array and then used to access a value
/// in the original `absences` array itself.
///
/// - Note: To safely reference the starting and ending indices of a slice,
///   always use the `startIndex` and `endIndex` properties instead of
///   specific values.
public struct ArraySlice<Element> {
}

extension ArraySlice : RandomAccessCollection, MutableCollection {

    /// The index type for arrays, `Int`.
    ///
    /// `ArraySlice` instances are not always indexed from zero. Use `startIndex`
    /// and `endIndex` as the bounds for any element access, instead of `0` and
    /// `count`.
    public typealias Index = Int

    /// The type that represents the indices that are valid for subscripting an
    /// array, in ascending order.
    public typealias Indices = Range<Int>

    /// The type that allows iteration over an array's elements.
    public typealias Iterator = IndexingIterator<ArraySlice<Element>>

    /// The position of the first element in a nonempty array.
    ///
    /// If the array is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The array's "past the end" position---that is, the position one greater
    /// than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of an array, use the
    /// half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let i = numbers.firstIndex(of: 30) {
    ///         print(numbers[i ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the array is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index immediately before `i`.
    public func index(before i: Int) -> Int

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Int)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    public func index(_ i: Int, offsetBy n: Int) -> Int

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position. The
    /// operation doesn't require going beyond the limiting `numbers.endIndex`
    /// value, so it succeeds.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let i = numbers.index(numbers.startIndex,
    ///                              offsetBy: 4,
    ///                              limitedBy: numbers.endIndex) {
    ///         print(numbers[i])
    ///     }
    ///     // Prints "50"
    ///
    /// The next example attempts to retrieve an index ten positions from
    /// `numbers.startIndex`, but fails, because that distance is beyond the
    /// index passed as `limit`.
    ///
    ///     let j = numbers.index(numbers.startIndex,
    ///                           offsetBy: 10,
    ///                           limitedBy: numbers.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    public func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -> Int?

    /// Returns the distance between two indices.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`.
    public func distance(from start: Int, to end: Int) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example uses indexed subscripting to update an array's
    /// second element. After assigning the new value (`"Butler"`) at a specific
    /// position, that value is immediately available at that same position.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// - Parameter index: The position of the element to access. `index` must be
    ///   greater than or equal to `startIndex` and less than `endIndex`.
    ///
    /// - Complexity: Reading an element from an array is O(1). Writing is O(1)
    ///   unless the array's storage is shared with another array, in which case
    ///   writing is O(*n*), where *n* is the length of the array.
    public subscript(index: Int) -> Element

    /// Accesses a contiguous subrange of the array's elements.
    ///
    /// The returned `ArraySlice` instance uses the same indices for the same
    /// elements as the original array. In particular, that slice, unlike an
    /// array, may have a nonzero `startIndex` and an `endIndex` that is not
    /// equal to `count`. Always use the slice's `startIndex` and `endIndex`
    /// properties instead of assuming that its indices start or end at a
    /// particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let i = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[i!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of integers. The bounds of the range must be
    ///   valid indices of the array.
    public subscript(bounds: Range<Int>) -> ArraySlice<Element>
}

extension ArraySlice : ExpressibleByArrayLiteral {

    /// Creates an array from the given array literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use an array literal. Instead, create a new array by using an array
    /// literal as its value. To do this, enclose a comma-separated list of
    /// values in square brackets.
    ///
    /// Here, an array of strings is created from an array literal holding only
    /// strings:
    ///
    ///     let ingredients: ArraySlice =
    ///           ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///
    /// - Parameter elements: A variadic list of elements of the new array.
    public init(arrayLiteral elements: ArraySlice<Element>.Element...)
}

extension ArraySlice : RangeReplaceableCollection {

    /// Creates a new, empty array.
    ///
    /// This is equivalent to initializing with an empty array literal.
    /// For example:
    ///
    ///     var emptyArray = Array<Int>()
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    ///
    ///     emptyArray = []
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    public init()

    /// Creates an array containing the elements of a sequence.
    ///
    /// You can use this initializer to create an array from any other type that
    /// conforms to the `Sequence` protocol. For example, you might want to
    /// create an array with the integers from 1 through 7. Use this initializer
    /// around a range instead of typing all those numbers in an array literal.
    ///
    ///     let numbers = Array(1...7)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7]"
    ///
    /// You can also use this initializer to convert a complex sequence or
    /// collection type back to an array. For example, the `keys` property of
    /// a dictionary isn't an array with its own storage, it's a collection
    /// that maps its elements from the dictionary only when they're
    /// accessed, saving the time and space needed to allocate an array. If
    /// you need to pass those keys to a method that takes an array, however,
    /// use this initializer to convert that list from its type of
    /// `LazyMapCollection<Dictionary<String, Int>, Int>` to a simple
    /// `[String]`.
    ///
    ///     func cacheImagesWithNames(names: [String]) {
    ///         // custom image loading and caching
    ///      }
    ///
    ///     let namedHues: [String: Int] = ["Vermillion": 18, "Magenta": 302,
    ///             "Gold": 50, "Cerise": 320]
    ///     let colorNames = Array(namedHues.keys)
    ///     cacheImagesWithNames(colorNames)
    ///
    ///     print(colorNames)
    ///     // Prints "["Gold", "Cerise", "Magenta", "Vermillion"]"
    ///
    /// - Parameter s: The sequence of elements to turn into an array.
    public init<S>(_ s: S) where Element == S.Element, S : Sequence

    /// Creates a new array containing the specified number of a single, repeated
    /// value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: ArraySlice<Element>.Element, count: Int)

    /// The number of elements in the array.
    public var count: Int { get }

    /// The total number of elements that the array can contain without
    /// allocating new storage.
    ///
    /// Every array reserves a specific amount of memory to hold its contents.
    /// When you add elements to an array and that array begins to exceed its
    /// reserved capacity, the array allocates a larger region of memory and
    /// copies its elements into the new storage. The new storage is a multiple
    /// of the old storage's size. This exponential growth strategy means that
    /// appending an element happens in constant time, averaging the performance
    /// of many append operations. Append operations that trigger reallocation
    /// have a performance cost, but they occur less and less often as the array
    /// grows larger.
    ///
    /// The following example creates an array of integers from an array literal,
    /// then appends the elements of another collection. Before appending, the
    /// array allocates new storage that is large enough store the resulting
    /// elements.
    ///
    ///     var numbers = [10, 20, 30, 40, 50]
    ///     // numbers.count == 5
    ///     // numbers.capacity == 5
    ///
    ///     numbers.append(contentsOf: stride(from: 60, through: 100, by: 10))
    ///     // numbers.count == 10
    ///     // numbers.capacity == 12
    public var capacity: Int { get }

    /// Reserves enough space to store the specified number of elements.
    ///
    /// If you are adding a known number of elements to an array, use this method
    /// to avoid multiple reallocations. This method ensures that the array has
    /// unique, mutable, contiguous storage, with space allocated for at least
    /// the requested number of elements.
    ///
    /// Calling the `reserveCapacity(_:)` method on an array with bridged storage
    /// triggers a copy to contiguous storage even if the existing storage
    /// has room to store `minimumCapacity` elements.
    ///
    /// For performance reasons, the size of the newly allocated storage might be
    /// greater than the requested capacity. Use the array's `capacity` property
    /// to determine the size of the new storage.
    ///
    /// Preserving an Array's Geometric Growth Strategy
    /// ===============================================
    ///
    /// If you implement a custom data structure backed by an array that grows
    /// dynamically, naively calling the `reserveCapacity(_:)` method can lead
    /// to worse than expected performance. Arrays need to follow a geometric
    /// allocation pattern for appending elements to achieve amortized
    /// constant-time performance. The `Array` type's `append(_:)` and
    /// `append(contentsOf:)` methods take care of this detail for you, but
    /// `reserveCapacity(_:)` allocates only as much space as you tell it to
    /// (padded to a round value), and no more. This avoids over-allocation, but
    /// can result in insertion not having amortized constant-time performance.
    ///
    /// The following code declares `values`, an array of integers, and the
    /// `addTenQuadratic()` function, which adds ten more values to the `values`
    /// array on each call.
    ///
    ///       var values: [Int] = [0, 1, 2, 3]
    ///
    ///       // Don't use 'reserveCapacity(_:)' like this
    ///       func addTenQuadratic() {
    ///           let newCount = values.count + 10
    ///           values.reserveCapacity(newCount)
    ///           for n in values.count..<newCount {
    ///               values.append(n)
    ///           }
    ///       }
    ///
    /// The call to `reserveCapacity(_:)` increases the `values` array's capacity
    /// by exactly 10 elements on each pass through `addTenQuadratic()`, which
    /// is linear growth. Instead of having constant time when averaged over
    /// many calls, the function may decay to performance that is linear in
    /// `values.count`. This is almost certainly not what you want.
    ///
    /// In cases like this, the simplest fix is often to simply remove the call
    /// to `reserveCapacity(_:)`, and let the `append(_:)` method grow the array
    /// for you.
    ///
    ///       func addTen() {
    ///           let newCount = values.count + 10
    ///           for n in values.count..<newCount {
    ///               values.append(n)
    ///           }
    ///       }
    ///
    /// If you need more control over the capacity of your array, implement your
    /// own geometric growth strategy, passing the size you compute to
    /// `reserveCapacity(_:)`.
    ///
    /// - Parameter minimumCapacity: The requested number of elements to store.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements in the array.
    public mutating func reserveCapacity(_ minimumCapacity: Int)

    /// Adds a new element at the end of the array.
    ///
    /// Use this method to append a single element to the end of a mutable array.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(100)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 100]"
    ///
    /// Because arrays increase their allocated capacity using an exponential
    /// strategy, appending a single element to an array is an O(1) operation
    /// when averaged over many calls to the `append(_:)` method. When an array
    /// has additional capacity and is not sharing its storage with another
    /// instance, appending an element is O(1). When an array needs to
    /// reallocate storage before appending or its storage is shared with
    /// another copy, appending is O(*n*), where *n* is the length of the array.
    ///
    /// - Parameter newElement: The element to append to the array.
    ///
    /// - Complexity: Amortized O(1) over many additions. If the array uses a
    ///   bridged `NSArray` instance as its storage, the efficiency is
    ///   unspecified.
    public mutating func append(_ newElement: ArraySlice<Element>.Element)

    /// Adds the elements of a sequence to the end of the array.
    ///
    /// Use this method to append the elements of a sequence to the end of this
    /// array. This example appends the elements of a `Range<Int>` instance
    /// to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the array.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting array.
    public mutating func append<S>(contentsOf newElements: S) where Element == S.Element, S : Sequence

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved up to
    /// close the gap.
    ///
    ///     var measurements: [Double] = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.1, 1.5, 1.2, 1.5, 1.3, 1.2]"
    ///
    /// - Parameter index: The position of the element to remove. `index` must
    ///   be a valid index of the array.
    /// - Returns: The element at the specified index.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func remove(at index: Int) -> ArraySlice<Element>.Element

    /// Inserts a new element at the specified position.
    ///
    /// The new element is inserted before the element currently at the specified
    /// index. If you pass the array's `endIndex` property as the `index`
    /// parameter, the new element is appended to the array.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// - Parameter newElement: The new element to insert into the array.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index of the array or equal to its `endIndex`
    ///   property.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func insert(_ newElement: ArraySlice<Element>.Element, at i: Int)

    /// Removes all elements from the array.
    ///
    /// - Parameter keepCapacity: Pass `true` to keep the existing capacity of
    ///   the array after removing its elements. The default value is
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)
}

extension ArraySlice : CustomReflectable {

    /// A mirror that reflects the array.
    public var customMirror: Mirror { get }
}

extension ArraySlice : CustomStringConvertible, CustomDebugStringConvertible {

    /// A textual representation of the array and its elements.
    public var description: String { get }

    /// A textual representation of the array and its elements, suitable for
    /// debugging.
    public var debugDescription: String { get }
}

extension ArraySlice {

    /// Calls a closure with a pointer to the array's contiguous storage.
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows how you can iterate over the contents of the
    /// buffer pointer:
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     let sum = numbers.withUnsafeBufferPointer { buffer -> Int in
    ///         var result = 0
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {
    ///             result += buffer[i]
    ///         }
    ///         return result
    ///     }
    ///     // 'sum' == 9
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withUnsafeBufferPointer(_:)`. Do not store or return the
    /// pointer for later use.
    ///
    /// - Parameter body: A closure with an `UnsafeBufferPointer` parameter that
    ///   points to the contiguous storage for the array.  If
    ///   `body` has a return value, that value is also used as the return value
    ///   for the `withUnsafeBufferPointer(_:)` method. The pointer argument is
    ///   valid only for the duration of the method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<ArraySlice<Element>.Element>) throws -> R) rethrows -> R

    /// Calls the given closure with a pointer to the array's mutable contiguous
    /// storage.
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows how modifying the contents of the
    /// `UnsafeMutableBufferPointer` argument to `body` alters the contents of
    /// the array:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.withUnsafeMutableBufferPointer { buffer in
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {
    ///             buffer.swapAt(i, i + 1)
    ///         }
    ///     }
    ///     print(numbers)
    ///     // Prints "[2, 1, 4, 3, 5]"
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withUnsafeMutableBufferPointer(_:)`. Do not store or
    /// return the pointer for later use.
    ///
    /// - Warning: Do not rely on anything about the array that is the target of
    ///   this method during execution of the `body` closure; it might not
    ///   appear to have its correct value. Instead, use only the
    ///   `UnsafeMutableBufferPointer` argument to `body`.
    ///
    /// - Parameter body: A closure with an `UnsafeMutableBufferPointer`
    ///   parameter that points to the contiguous storage for the array.
    ///    If `body` has a return value, that value is also
    ///   used as the return value for the `withUnsafeMutableBufferPointer(_:)`
    ///   method. The pointer argument is valid only for the duration of the
    ///   method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout UnsafeMutableBufferPointer<ArraySlice<Element>.Element>) throws -> R) rethrows -> R
}

extension ArraySlice {

    /// Replaces a range of elements with the elements in the specified
    /// collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the array and inserting the new elements at the same location. The
    /// number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the array to replace. The start and end of
    ///     a subrange must be valid indices of the array.
    ///   - newElements: The new elements to add to the array.
    ///
    /// - Complexity: O(`subrange.count`) if you are replacing a suffix of the
    ///   array with an empty collection; otherwise, O(*n*), where *n* is the
    ///   length of the array.
    public mutating func replaceSubrange<C>(_ subrange: Range<Int>, with newElements: C) where Element == C.Element, C : Collection
}

extension ArraySlice : Equatable where Element : Equatable {

    /// Returns a Boolean value indicating whether two arrays contain the same
    /// elements in the same order.
    ///
    /// You can use the equal-to operator (`==`) to compare any two arrays
    /// that store the same, `Equatable`-conforming element type.
    ///
    /// - Parameters:
    ///   - lhs: An array to compare.
    ///   - rhs: Another array to compare.
    public static func == (lhs: ArraySlice<ArraySlice<Element>.Element>, rhs: ArraySlice<ArraySlice<Element>.Element>) -> Bool

    /// Returns a Boolean value indicating whether two arrays are not equal.
    ///
    /// Two arrays are equal if they contain the same elements in the same order.
    /// You can use the not-equal-to operator (`!=`) to compare any two arrays
    /// that store the same, `Equatable`-conforming element type.
    ///
    /// - Parameters:
    ///   - lhs: An array to compare.
    ///   - rhs: Another array to compare.
    public static func != (lhs: ArraySlice<ArraySlice<Element>.Element>, rhs: ArraySlice<ArraySlice<Element>.Element>) -> Bool
}

extension ArraySlice : Hashable where Element : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension ArraySlice {

    /// Calls the given closure with a pointer to the underlying bytes of the
    /// array's mutable contiguous storage.
    ///
    /// The array's `Element` type must be a *trivial type*, which can be copied
    /// with just a bit-for-bit copy without any indirection or
    /// reference-counting operations. Generally, native Swift types that do not
    /// contain strong or weak references are trivial, as are imported C structs
    /// and enums.
    ///
    /// The following example copies bytes from the `byteValues` array into
    /// `numbers`, an array of `Int`:
    ///
    ///     var numbers: [Int32] = [0, 0]
    ///     var byteValues: [UInt8] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00]
    ///
    ///     numbers.withUnsafeMutableBytes { destBytes in
    ///         byteValues.withUnsafeBytes { srcBytes in
    ///             destBytes.copyBytes(from: srcBytes)
    ///         }
    ///     }
    ///     // numbers == [1, 2]
    ///
    /// The pointer passed as an argument to `body` is valid only for the
    /// lifetime of the closure. Do not escape it from the closure for later
    /// use.
    ///
    /// - Warning: Do not rely on anything about the array that is the target of
    ///   this method during execution of the `body` closure; it might not
    ///   appear to have its correct value. Instead, use only the
    ///   `UnsafeMutableRawBufferPointer` argument to `body`.
    ///
    /// - Parameter body: A closure with an `UnsafeMutableRawBufferPointer`
    ///   parameter that points to the contiguous storage for the array.
    ///    If no such storage exists, it is created. If `body` has a return value, that value is also
    ///   used as the return value for the `withUnsafeMutableBytes(_:)` method.
    ///   The argument is valid only for the duration of the closure's
    ///   execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public mutating func withUnsafeMutableBytes<R>(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R

    /// Calls the given closure with a pointer to the underlying bytes of the
    /// array's contiguous storage.
    ///
    /// The array's `Element` type must be a *trivial type*, which can be copied
    /// with just a bit-for-bit copy without any indirection or
    /// reference-counting operations. Generally, native Swift types that do not
    /// contain strong or weak references are trivial, as are imported C structs
    /// and enums.
    ///
    /// The following example copies the bytes of the `numbers` array into a
    /// buffer of `UInt8`:
    ///
    ///     var numbers = [1, 2, 3]
    ///     var byteBuffer: [UInt8] = []
    ///     numbers.withUnsafeBytes {
    ///         byteBuffer.append(contentsOf: $0)
    ///     }
    ///     // byteBuffer == [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, ...]
    ///
    /// - Parameter body: A closure with an `UnsafeRawBufferPointer` parameter
    ///   that points to the contiguous storage for the array.
    ///    If no such storage exists, it is created. If `body` has a return value, that value is also
    ///   used as the return value for the `withUnsafeBytes(_:)` method. The
    ///   argument is valid only for the duration of the closure's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

/// A mutable pointer-to-ObjC-pointer argument.
///
/// This type has implicit conversions to allow passing any of the following
/// to a C or ObjC API:
///
/// - `nil`, which gets passed as a null pointer,
/// - an inout argument of the referenced type, which gets passed as a pointer
///   to a writeback temporary with autoreleasing ownership semantics,
/// - an `UnsafeMutablePointer<Pointee>`, which is passed as-is.
///
/// Passing pointers to mutable arrays of ObjC class pointers is not
/// directly supported. Unlike `UnsafeMutablePointer<Pointee>`,
/// `AutoreleasingUnsafeMutablePointer<Pointee>` must reference storage that
/// does not own a reference count to the referenced
/// value. UnsafeMutablePointer's operations, by contrast, assume that
/// the referenced storage owns values loaded from or stored to it.
///
/// This type does not carry an owner pointer unlike the other C*Pointer types
/// because it only needs to reference the results of inout conversions, which
/// already have writeback-scoped lifetime.
public struct AutoreleasingUnsafeMutablePointer<Pointee> {

    /// Access the `Pointee` instance referenced by `self`.
    ///
    /// - Precondition: the pointee has been initialized with an instance of type
    ///   `Pointee`.
    public var pointee: Pointee { get nonmutating set }

    /// Access the `i`th element of the raw array pointed to by
    /// `self`.
    ///
    /// - Precondition: `self != nil`.
    public subscript(i: Int) -> Pointee { get }

    /// Explicit construction from an UnsafeMutablePointer.
    ///
    /// This is inherently unsafe; UnsafeMutablePointer assumes the
    /// referenced memory has +1 strong ownership semantics, whereas
    /// AutoreleasingUnsafeMutablePointer implies +0 semantics.
    ///
    /// - Warning: Accessing `pointee` as a type that is unrelated to
    ///   the underlying memory's bound type is undefined.
    public init<U>(_ from: UnsafeMutablePointer<U>)

    /// Explicit construction from an UnsafeMutablePointer.
    ///
    /// Returns nil if `from` is nil.
    ///
    /// This is inherently unsafe; UnsafeMutablePointer assumes the
    /// referenced memory has +1 strong ownership semantics, whereas
    /// AutoreleasingUnsafeMutablePointer implies +0 semantics.
    ///
    /// - Warning: Accessing `pointee` as a type that is unrelated to
    ///   the underlying memory's bound type is undefined.
    public init?<U>(_ from: UnsafeMutablePointer<U>?)
}

extension AutoreleasingUnsafeMutablePointer : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: AutoreleasingUnsafeMutablePointer<Pointee>, rhs: AutoreleasingUnsafeMutablePointer<Pointee>) -> Bool
}

extension AutoreleasingUnsafeMutablePointer : CustomDebugStringConvertible {

    /// A textual representation of `self`, suitable for debugging.
    public var debugDescription: String { get }
}

extension AutoreleasingUnsafeMutablePointer : CVarArg {
}

/// A collection that supports backward as well as forward traversal.
///
/// Bidirectional collections offer traversal backward from any valid index,
/// not including a collection's `startIndex`. Bidirectional collections can
/// therefore offer additional operations, such as a `last` property that
/// provides efficient access to the last element and a `reversed()` method
/// that presents the elements in reverse order. In addition, bidirectional
/// collections have more efficient implementations of some sequence and
/// collection methods, such as `suffix(_:)`.
///
/// Conforming to the BidirectionalCollection Protocol
/// ==================================================
///
/// To add `BidirectionalProtocol` conformance to your custom types, implement
/// the `index(before:)` method in addition to the requirements of the
/// `Collection` protocol.
///
/// Indices that are moved forward and backward in a bidirectional collection
/// move by the same amount in each direction. That is, for any index `i` into
/// a bidirectional collection `c`:
///
/// - If `i >= c.startIndex && i < c.endIndex`,
///   `c.index(before: c.index(after: i)) == i`.
/// - If `i > c.startIndex && i <= c.endIndex`
///   `c.index(after: c.index(before: i)) == i`.
public protocol BidirectionalCollection : Collection where Self.Indices : BidirectionalCollection, Self.SubSequence : BidirectionalCollection {

    associatedtype Element

    associatedtype Index

    associatedtype SubSequence

    associatedtype Indices

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Self.Index) -> Self.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Self.Index)

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Self.Indices { get }

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Self.Element? { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Self.Index>) -> Self.SubSequence { get }

    public subscript(position: Self.Index) -> Self.Element { get }

    public var startIndex: Self.Index { get }

    public var endIndex: Self.Index { get }
}

/// Default implementation for bidirectional collections.
extension BidirectionalCollection {

    public func formIndex(before i: inout Self.Index)

    public func index(_ i: Self.Index, offsetBy n: Int) -> Self.Index

    public func index(_ i: Self.Index, offsetBy n: Int, limitedBy limit: Self.Index) -> Self.Index?

    public func distance(from start: Self.Index, to end: Self.Index) -> Int
}

extension BidirectionalCollection {

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    public var last: Self.Element? { get }
}

extension BidirectionalCollection where Self == Self.SubSequence {

    /// Removes and returns the last element of the collection.
    ///
    /// You can use `popLast()` to remove the last element of a collection that
    /// might be empty. The `removeLast()` method must be used only on a
    /// nonempty collection.
    ///
    /// - Returns: The last element of the collection if the collection has one
    ///   or more elements; otherwise, `nil`.
    ///
    /// - Complexity: O(1).
    public mutating func popLast() -> Self.Element?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty. To remove the last element of a
    /// collection that might be empty, use the `popLast()` method instead.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    public mutating func removeLast() -> Self.Element

    /// Removes the given number of elements from the end of the collection.
    ///
    /// - Parameter n: The number of elements to remove. `n` must be greater
    ///   than or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public mutating func removeLast(_ n: Int)
}

extension BidirectionalCollection {

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   collection. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off `n` elements from the end.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop.
    public func dropLast(_ n: Int) -> Self.SubSequence

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains the entire collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is equal to `maxLength`.
    public func suffix(_ maxLength: Int) -> Self.SubSequence
}

extension BidirectionalCollection {

    /// Returns the last element of the sequence that satisfies the given
    /// predicate.
    ///
    /// This example uses the `last(where:)` method to find the last
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let lastNegative = numbers.last(where: { $0 < 0 }) {
    ///         print("The last negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The last negative number is -6."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The last element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    public func last(where predicate: (Self.Element) throws -> Bool) rethrows -> Self.Element?

    /// Returns the index of the last element in the collection that matches the
    /// given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. This example finds the index of the last name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.lastIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Akosua starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the last element in the collection that matches
    ///   `predicate`, or `nil` if no elements match.
    public func lastIndex(where predicate: (Self.Element) throws -> Bool) rethrows -> Self.Index?
}

extension BidirectionalCollection where Self.Element : Equatable {

    /// Returns the last index where the specified value appears in the
    /// collection.
    ///
    /// After using `lastIndex(of:)` to find the position of the last instance of
    /// a particular element in a collection, you can use it to access the
    /// element by subscripting. This example shows how you can modify one of
    /// the names in an array of students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Ben", "Maxime"]
    ///     if let i = students.lastIndex(of: "Ben") {
    ///         students[i] = "Benjamin"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Benjamin", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The last index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    public func lastIndex(of element: Self.Element) -> Self.Index?
}

extension BidirectionalCollection {

    /// Returns a view presenting the elements of the collection in reverse
    /// order.
    ///
    /// You can reverse a collection without allocating new space for its
    /// elements by calling this `reversed()` method. A `ReversedCollection`
    /// instance wraps an underlying collection and provides access to its
    /// elements in reverse order. This example prints the characters of a
    /// string in reverse order:
    ///
    ///     let word = "Backwards"
    ///     for char in word.reversed() {
    ///         print(char, terminator: "")
    ///     }
    ///     // Prints "sdrawkcaB"
    ///
    /// If you need a reversed collection of the same type, you may be able to
    /// use the collection's sequence-based or collection-based initializer. For
    /// example, to get the reversed version of a string, reverse its
    /// characters and initialize a new `String` instance from the result.
    ///
    ///     let reversedWord = String(word.reversed())
    ///     print(reversedWord)
    ///     // Prints "sdrawkcaB"
    ///
    /// - Complexity: O(1)
    public func reversed() -> ReversedCollection<Self>
}

extension BidirectionalCollection where Self.Element == String {

    /// Returns a new string by concatenating the elements of the sequence,
    /// adding the given separator between each element.
    ///
    /// The following example shows how an array of strings can be joined to a
    /// single, comma-separated string:
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let list = cast.joined(separator: ", ")
    ///     print(list)
    ///     // Prints "Vivien, Marlon, Kim, Karl"
    ///
    /// - Parameter separator: A string to insert between each of the elements
    ///   in this sequence. The default separator is an empty string.
    /// - Returns: A single, concatenated string.
    public func joined(separator: String = default) -> String
}

/// A type that provides subscript access to its elements, with bidirectional
/// index traversal.
///
/// In most cases, it's best to ignore this protocol and use the
/// `BidirectionalCollection` protocol instead, because it has a more complete
/// interface.
@available(*, deprecated, message: "it will be removed in Swift 4.0.  Please use 'BidirectionalCollection' instead")
public typealias BidirectionalIndexable = BidirectionalCollection

@available(*, deprecated, renamed: "Slice")
public typealias BidirectionalSlice<T> = Slice<T>

/// A radix-2 (binary) floating-point type.
///
/// The `BinaryFloatingPoint` protocol extends the `FloatingPoint` protocol
/// with operations specific to floating-point binary types, as defined by the
/// [IEEE 754 specification][spec]. `BinaryFloatingPoint` is implemented in
/// the standard library by `Float`, `Double`, and `Float80` where available.
///
/// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
public protocol BinaryFloatingPoint : ExpressibleByFloatLiteral, FloatingPoint {

    /// A type that represents the encoded significand of a value.
    associatedtype RawSignificand : UnsignedInteger

    /// A type that represents the encoded exponent of a value.
    associatedtype RawExponent : UnsignedInteger

    /// Creates a new instance from the specified sign and bit patterns.
    ///
    /// The values passed as `exponentBitPattern` and `significandBitPattern` are
    /// interpreted in the binary interchange format defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - sign: The sign of the new value.
    ///   - exponentBitPattern: The bit pattern to use for the exponent field of
    ///     the new value.
    ///   - significandBitPattern: The bit pattern to use for the significand
    ///     field of the new value.
    public init(sign: FloatingPointSign, exponentBitPattern: Self.RawExponent, significandBitPattern: Self.RawSignificand)

    /// Creates a new instance from the given value, rounded to the closest
    /// possible representation.
    ///
    /// - Parameter value: A floating-point value to be converted.
    public init(_ value: Float)

    /// Creates a new instance from the given value, rounded to the closest
    /// possible representation.
    ///
    /// - Parameter value: A floating-point value to be converted.
    public init(_ value: Double)

    /// Creates a new instance from the given value, rounded to the closest
    /// possible representation.
    ///
    /// - Parameter value: A floating-point value to be converted.
    public init(_ value: Float80)

    /// Creates a new instance from the given value, rounded to the closest
    /// possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: A floating-point value to be converted.
    public init<Source>(_ value: Source) where Source : BinaryFloatingPoint

    /// Creates a new instance from the given value, if it can be represented
    /// exactly.
    ///
    /// If the given floating-point value cannot be represented exactly, the
    /// result is `nil`. A value that is NaN ("not a number") cannot be
    /// represented exactly if its payload cannot be encoded exactly.
    ///
    /// - Parameter value: A floating-point value to be converted.
    public init?<Source>(exactly value: Source) where Source : BinaryFloatingPoint

    /// The number of bits used to represent the type's exponent.
    ///
    /// A binary floating-point type's `exponentBitCount` imposes a limit on the
    /// range of the exponent for normal, finite values. The *exponent bias* of
    /// a type `F` can be calculated as the following, where `**` is
    /// exponentiation:
    ///
    ///     let bias = 2 ** (F.exponentBitCount - 1) - 1
    ///
    /// The least normal exponent for values of the type `F` is `1 - bias`, and
    /// the largest finite exponent is `bias`. An all-zeros exponent is reserved
    /// for subnormals and zeros, and an all-ones exponent is reserved for
    /// infinity and NaN.
    ///
    /// For example, the `Float` type has an `exponentBitCount` of 8, which gives
    /// an exponent bias of `127` by the calculation above.
    ///
    ///     let bias = 2 ** (Float.exponentBitCount - 1) - 1
    ///     // bias == 127
    ///     print(Float.greatestFiniteMagnitude.exponent)
    ///     // Prints "127"
    ///     print(Float.leastNormalMagnitude.exponent)
    ///     // Prints "-126"
    public static var exponentBitCount: Int { get }

    /// The available number of fractional significand bits.
    ///
    /// For fixed-width floating-point types, this is the actual number of
    /// fractional significand bits.
    ///
    /// For extensible floating-point types, `significandBitCount` should be the
    /// maximum allowed significand width (without counting any leading integral
    /// bit of the significand). If there is no upper limit, then
    /// `significandBitCount` should be `Int.max`.
    ///
    /// Note that `Float80.significandBitCount` is 63, even though 64 bits are
    /// used to store the significand in the memory representation of a
    /// `Float80` (unlike other floating-point types, `Float80` explicitly
    /// stores the leading integral significand bit, but the
    /// `BinaryFloatingPoint` APIs provide an abstraction so that users don't
    /// need to be aware of this detail).
    public static var significandBitCount: Int { get }

    /// The raw encoding of the value's exponent field.
    ///
    /// This value is unadjusted by the type's exponent bias.
    public var exponentBitPattern: Self.RawExponent { get }

    /// The raw encoding of the value's significand field.
    ///
    /// The `significandBitPattern` property does not include the leading
    /// integral bit of the significand, even for types like `Float80` that
    /// store it explicitly.
    public var significandBitPattern: Self.RawSignificand { get }

    /// The floating-point value with the same sign and exponent as this value,
    /// but with a significand of 1.0.
    ///
    /// A *binade* is a set of binary floating-point values that all have the
    /// same sign and exponent. The `binade` property is a member of the same
    /// binade as this value, but with a unit significand.
    ///
    /// In this example, `x` has a value of `21.5`, which is stored as
    /// `1.34375 * 2**4`, where `**` is exponentiation. Therefore, `x.binade` is
    /// equal to `1.0 * 2**4`, or `16.0`.
    ///
    ///     let x = 21.5
    ///     // x.significand == 1.34375
    ///     // x.exponent == 4
    ///
    ///     let y = x.binade
    ///     // y == 16.0
    ///     // y.significand == 1.0
    ///     // y.exponent == 4
    public var binade: Self { get }

    /// The number of bits required to represent the value's significand.
    ///
    /// If this value is a finite nonzero number, `significandWidth` is the
    /// number of fractional bits required to represent the value of
    /// `significand`; otherwise, `significandWidth` is -1. The value of
    /// `significandWidth` is always -1 or between zero and
    /// `significandBitCount`. For example:
    ///
    /// - For any representable power of two, `significandWidth` is zero, because
    ///   `significand` is `1.0`.
    /// - If `x` is 10, `x.significand` is `1.01` in binary, so
    ///   `x.significandWidth` is 2.
    /// - If `x` is Float.pi, `x.significand` is `1.10010010000111111011011` in
    ///   binary, and `x.significandWidth` is 23.
    public var significandWidth: Int { get }
}

extension BinaryFloatingPoint {

    /// The radix, or base of exponentiation, for this floating-point type.
    ///
    /// All binary floating-point types have a radix of 2. The magnitude of a
    /// floating-point value `x` of type `F` can be calculated by using the
    /// following formula, where `**` is exponentiation:
    ///
    ///     let magnitude = x.significand * F.radix ** x.exponent
    public static var radix: Int { get }

    /// Creates a new floating-point value using the sign of one value and the
    /// magnitude of another.
    ///
    /// The following example uses this initializer to create a new `Double`
    /// instance with the sign of `a` and the magnitude of `b`:
    ///
    ///     let a = -21.5
    ///     let b = 305.15
    ///     let c = Double(signOf: a, magnitudeOf: b)
    ///     print(c)
    ///     // Prints "-305.15"
    ///
    /// This initializer implements the IEEE 754 `copysign` operation.
    ///
    /// - Parameters:
    ///   - signOf: A value from which to use the sign. The result of the
    ///     initializer has the same sign as `signOf`.
    ///   - magnitudeOf: A value from which to use the magnitude. The result of
    ///     the initializer has the same magnitude as `magnitudeOf`.
    public convenience init(signOf: Self, magnitudeOf: Self)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public convenience init<Source>(_ value: Source) where Source : BinaryInteger

    /// Creates a new value, if the given integer can be represented exactly.
    ///
    /// If the given integer cannot be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public convenience init?<Source>(exactly value: Source) where Source : BinaryInteger

    /// Creates a new instance from the given value, rounded to the closest
    /// possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: A floating-point value to be converted.
    public convenience init<Source>(_ value: Source) where Source : BinaryFloatingPoint

    /// Creates a new instance from the given value, if it can be represented
    /// exactly.
    ///
    /// If the given floating-point value cannot be represented exactly, the
    /// result is `nil`. A value that is NaN ("not a number") cannot be
    /// represented exactly if its payload cannot be encoded exactly.
    ///
    /// - Parameter value: A floating-point value to be converted.
    public convenience init?<Source>(exactly value: Source) where Source : BinaryFloatingPoint

    /// Returns a Boolean value indicating whether this instance should precede
    /// or tie positions with the given value in an ascending sort.
    ///
    /// This relation is a refinement of the less-than-or-equal-to operator
    /// (`<=`) that provides a total order on all values of the type, including
    /// signed zeros and NaNs.
    ///
    /// The following example uses `isTotallyOrdered(belowOrEqualTo:)` to sort an
    /// array of floating-point values, including some that are NaN:
    ///
    ///     var numbers = [2.5, 21.25, 3.0, .nan, -9.5]
    ///     numbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }
    ///     // numbers == [-9.5, 2.5, 3.0, 21.25, NaN]
    ///
    /// The `isTotallyOrdered(belowOrEqualTo:)` method implements the total order
    /// relation as defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: A floating-point value to compare to this value.
    /// - Returns: `true` if this value is ordered below or the same as `other`
    ///   in a total ordering of the floating-point type; otherwise, `false`.
    public func isTotallyOrdered(belowOrEqualTo other: Self) -> Bool
}

extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger, Self.RawSignificand.Magnitude : UnsignedInteger, Self.RawSignificand.Stride : SignedInteger {

    /// Returns a random value within the specified range, using the given
    /// generator as a source for randomness.
    ///
    /// Use this method to generate a floating-point value within a specific
    /// range when you are using a custom random number generator. This example
    /// creates three new values in the range `10.0..<20.0`.
    ///
    ///     for _ in 1...3 {
    ///         print(Double.random(in: 10.0..<20.0, using: &myGenerator))
    ///     }
    ///     // Prints "18.1900709259179"
    ///     // Prints "14.2286325689993"
    ///     // Prints "13.1485686260762"
    ///
    /// The `random(in:using:)` static method chooses a random value from a
    /// continuous uniform distribution in `range`, and then converts that value
    /// to the nearest representable value in this type. Depending on the size and
    /// span of `range`, some concrete values may be represented more frequently
    /// than others.
    ///
    /// - Parameters:
    ///   - range: The range in which to create a random value.
    ///     `range` must not be empty.
    ///   - generator: The random number generator to use when creating the
    ///     new random value.
    /// - Returns: A random value within the bounds of `range`.
    public static func random<T>(in range: Range<Self>, using generator: inout T) -> Self where T : RandomNumberGenerator

    /// Returns a random value within the specified range.
    ///
    /// Use this method to generate a floating-point value within a specific
    /// range. This example creates three new values in the range
    /// `10.0..<20.0`.
    ///
    ///     for _ in 1...3 {
    ///         print(Double.random(in: 10.0..<20.0))
    ///     }
    ///     // Prints "18.1900709259179"
    ///     // Prints "14.2286325689993"
    ///     // Prints "13.1485686260762"
    ///
    /// The `random()` static method chooses a random value from a continuous
    /// uniform distribution in `range`, and then converts that value to the
    /// nearest representable value in this type. Depending on the size and span
    /// of `range`, some concrete values may be represented more frequently than
    /// others.
    ///
    /// This method uses the default random generator, `Random.default`. The call
    /// to `Double.random(in: 10.0..<20.0)` above is equivalent to calling
    /// `Double.random(in: 10.0..<20.0, using: &Random.default)`.
    ///
    /// - Parameter range: The range in which to create a random value.
    ///   `range` must not be empty.
    /// - Returns: A random value within the bounds of `range`.
    public static func random(in range: Range<Self>) -> Self
}

extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger, Self.RawSignificand.Magnitude : UnsignedInteger, Self.RawSignificand.Stride : SignedInteger {

    /// Returns a random value within the specified range, using the given
    /// generator as a source for randomness.
    ///
    /// Use this method to generate a floating-point value within a specific
    /// range when you are using a custom random number generator. This example
    /// creates three new values in the range `10.0...20.0`.
    ///
    ///     for _ in 1...3 {
    ///         print(Double.random(in: 10.0...20.0, using: &myGenerator))
    ///     }
    ///     // Prints "18.1900709259179"
    ///     // Prints "14.2286325689993"
    ///     // Prints "13.1485686260762"
    ///
    /// The `random(in:using:)` static method chooses a random value from a
    /// continuous uniform distribution in `range`, and then converts that value
    /// to the nearest representable value in this type. Depending on the size and
    /// span of `range`, some concrete values may be represented more frequently
    /// than others.
    ///
    /// - Parameters:
    ///   - range: The range in which to create a random value.
    ///   - generator: The random number generator to use when creating the
    ///     new random value.
    /// - Returns: A random value within the bounds of `range`.
    public static func random<T>(in range: ClosedRange<Self>, using generator: inout T) -> Self where T : RandomNumberGenerator

    /// Returns a random value within the specified range.
    ///
    /// Use this method to generate a floating-point value within a specific
    /// range. This example creates three new values in the range
    /// `10.0...20.0`.
    ///
    ///     for _ in 1...3 {
    ///         print(Double.random(in: 10.0...20.0))
    ///     }
    ///     // Prints "18.1900709259179"
    ///     // Prints "14.2286325689993"
    ///     // Prints "13.1485686260762"
    ///
    /// The `random()` static method chooses a random value from a continuous
    /// uniform distribution in `range`, and then converts that value to the
    /// nearest representable value in this type. Depending on the size and span
    /// of `range`, some concrete values may be represented more frequently than
    /// others.
    ///
    /// This method uses the default random generator, `Random.default`. The call
    /// to `Double.random(in: 10.0...20.0)` above is equivalent to calling
    /// `Double.random(in: 10.0...20.0, using: &Random.default)`.
    ///
    /// - Parameter range: The range in which to create a random value.
    /// - Returns: A random value within the bounds of `range`.
    public static func random(in range: ClosedRange<Self>) -> Self
}

extension BinaryFloatingPoint {
}

/// An integer type with a binary representation.
///
/// The `BinaryInteger` protocol is the basis for all the integer types
/// provided by the standard library. All of the standard library's integer
/// types, such as `Int` and `UInt32`, conform to `BinaryInteger`.
///
/// Converting Between Numeric Types
/// ================================
///
/// You can create new instances of a type that conforms to the `BinaryInteger`
/// protocol from a floating-point number or another binary integer of any
/// type. The `BinaryInteger` protocol provides initializers for four
/// different kinds of conversion.
///
/// Range-Checked Conversion
/// ------------------------
///
/// You use the default `init(_:)` initializer to create a new instance when
/// you're sure that the value passed is representable in the new type. For
/// example, an instance of `Int16` can represent the value `500`, so the
/// first conversion in the code sample below succeeds. That same value is too
/// large to represent as an `Int8` instance, so the second conversion fails,
/// triggering a runtime error.
///
///     let x: Int = 500
///     let y = Int16(x)
///     // y == 500
///
///     let z = Int8(x)
///     // Error: Not enough bits to represent...
///
/// When you create a binary integer from a floating-point value using the
/// default initializer, the value is rounded toward zero before the range is
/// checked. In the following example, the value `127.75` is rounded to `127`,
/// which is representable by the `Int8` type.  `128.25` is rounded to `128`,
/// which is not representable as an `Int8` instance, triggering a runtime
/// error.
///
///     let e = Int8(127.75)
///     // e == 127
///
///     let f = Int8(128.25)
///     // Error: Double value cannot be converted...
///
///
/// Exact Conversion
/// ----------------
///
/// Use the `init?(exactly:)` initializer to create a new instance after
/// checking whether the passed value is representable. Instead of trapping on
/// out-of-range values, using the failable `exact` initializer results in
/// `nil`.
///
///     let x = Int16(exactly: 500)
///     // x == Optional(500)
///
///     let y = Int8(exactly: 500)
///     // y == nil
///
/// When converting floating-point values, the `init?(exact:)` initializer
/// checks both that the passed value has no fractional part and that the
/// value is representable in the resulting type.
///
///     let e = Int8(exactly: 23.0)       // integral value, representable
///     // e == Optional(23)
///
///     let f = Int8(exactly: 23.75)      // fractional value, representable
///     // f == nil
///
///     let g = Int8(exactly: 500.0)      // integral value, nonrepresentable
///     // g == nil
///
/// Clamping Conversion
/// -------------------
///
/// Use the `init(clamping:)` initializer to create a new instance of a binary
/// integer type where out-of-range values are clamped to the representable
/// range of the type. For a type `T`, the resulting value is in the range
/// `T.min...T.max`.
///
///     let x = Int16(clamping: 500)
///     // x == 500
///
///     let y = Int8(clamping: 500)
///     // y == 127
///
///     let z = UInt8(clamping: -500)
///     // z == 0
///
/// Bit Pattern Conversion
/// ----------------------
///
/// Use the `init(truncatingIfNeeded:)` initializer to create a new instance
/// with the same bit pattern as the passed value, extending or truncating the
/// value's representation as necessary. Note that the value may not be
/// preserved, particularly when converting between signed to unsigned integer
/// types or when the destination type has a smaller bit width than the source
/// type. The following example shows how extending and truncating work for
/// nonnegative integers:
///
///     let q: Int16 = 850
///     // q == 0b00000011_01010010
///
///     let r = Int8(truncatingIfNeeded: q)      // truncate 'q' to fit in 8 bits
///     // r == 82
///     //   == 0b01010010
///
///     let s = Int16(truncatingIfNeeded: r)     // extend 'r' to fill 16 bits
///     // s == 82
///     //   == 0b00000000_01010010
///
/// Any padding is performed by *sign-extending* the passed value. When
/// nonnegative integers are extended, the result is padded with zeroes. When
/// negative integers are extended, the result is padded with ones. This
/// example shows several extending conversions of a negative value---note
/// that negative values are sign-extended even when converting to an unsigned
/// type.
///
///     let t: Int8 = -100
///     // t == -100
///     // t's binary representation == 0b10011100
///
///     let u = UInt8(truncatingIfNeeded: t)
///     // u == 156
///     // u's binary representation == 0b10011100
///
///     let v = Int16(truncatingIfNeeded: t)
///     // v == -100
///     // v's binary representation == 0b11111111_10011100
///
///     let w = UInt16(truncatingIfNeeded: t)
///     // w == 65436
///     // w's binary representation == 0b11111111_10011100
///
///
/// Comparing Across Integer Types
/// ==============================
///
/// You can use relational operators, such as the less-than and equal-to
/// operators (`<` and `==`), to compare instances of different binary integer
/// types. The following example compares instances of the `Int`, `UInt`, and
/// `UInt8` types:
///
///     let x: Int = -23
///     let y: UInt = 1_000
///     let z: UInt8 = 23
///
///     if x < y {
///         print("\(x) is less than \(y).")
///     }
///     // Prints "-23 is less than 1000."
///
///     if z > x {
///         print("\(z) is greater than \(x).")
///     }
///     // Prints "23 is greater than -23."
public protocol BinaryInteger : CustomStringConvertible, Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude == Self.Magnitude.Magnitude {

    /// A Boolean value indicating whether this type is a signed integer type.
    ///
    /// *Signed* integer types can represent both positive and negative values.
    /// *Unsigned* integer types can represent only nonnegative values.
    public static var isSigned: Bool { get }

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?<T>(exactly source: T) where T : BinaryFloatingPoint

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init<T>(_ source: T) where T : BinaryFloatingPoint

    /// Creates a new instance from the given integer.
    ///
    /// If the value passed as `source` is not representable in this type, a
    /// runtime error may occur.
    ///
    ///     let x = -500 as Int
    ///     let y = Int32(x)
    ///     // y == -500
    ///
    ///     // -500 is not representable as a 'UInt32' instance
    ///     let z = UInt32(x)
    ///     // Error
    ///
    /// - Parameter source: An integer to convert. `source` must be representable
    ///   in this type.
    public init<T>(_ source: T) where T : BinaryInteger

    /// Creates a new instance from the bit pattern of the given instance by
    /// sign-extending or truncating to fit this type.
    ///
    /// When the bit width of `T` (the type of `source`) is equal to or greater
    /// than this type's bit width, the result is the truncated
    /// least-significant bits of `source`. For example, when converting a
    /// 16-bit value to an 8-bit type, only the lower 8 bits of `source` are
    /// used.
    ///
    ///     let p: Int16 = -500
    ///     // 'p' has a binary representation of 11111110_00001100
    ///     let q = Int8(truncatingIfNeeded: p)
    ///     // q == 12
    ///     // 'q' has a binary representation of 00001100
    ///
    /// When the bit width of `T` is less than this type's bit width, the result
    /// is *sign-extended* to fill the remaining bits. That is, if `source` is
    /// negative, the result is padded with ones; otherwise, the result is
    /// padded with zeros.
    ///
    ///     let u: Int8 = 21
    ///     // 'u' has a binary representation of 00010101
    ///     let v = Int16(truncatingIfNeeded: u)
    ///     // v == 21
    ///     // 'v' has a binary representation of 00000000_00010101
    ///
    ///     let w: Int8 = -21
    ///     // 'w' has a binary representation of 11101011
    ///     let x = Int16(truncatingIfNeeded: w)
    ///     // x == -21
    ///     // 'x' has a binary representation of 11111111_11101011
    ///     let y = UInt16(truncatingIfNeeded: w)
    ///     // y == 65515
    ///     // 'y' has a binary representation of 11111111_11101011
    ///
    /// - Parameter source: An integer to convert to this type.
    public init<T>(truncatingIfNeeded source: T) where T : BinaryInteger

    /// Creates a new instance with the representable value that's closest to the
    /// given integer.
    ///
    /// If the value passed as `source` is greater than the maximum representable
    /// value in this type, the result is the type's `max` value. If `source` is
    /// less than the smallest representable value in this type, the result is
    /// the type's `min` value.
    ///
    /// In this example, `x` is initialized as an `Int8` instance by clamping
    /// `500` to the range `-128...127`, and `y` is initialized as a `UInt`
    /// instance by clamping `-500` to the range `0...UInt.max`.
    ///
    ///     let x = Int8(clamping: 500)
    ///     // x == 127
    ///     // x == Int8.max
    ///
    ///     let y = UInt(clamping: -500)
    ///     // y == 0
    ///
    /// - Parameter source: An integer to convert to this type.
    public init<T>(clamping source: T) where T : BinaryInteger

    /// A type that represents the words of a binary integer.
    ///
    /// The `Words` type must conform to the `Collection` protocol with an
    /// `Element` type of `UInt`.
    associatedtype Words : Sequence where Self.Words.Element == UInt

    /// A collection containing the words of this value's binary
    /// representation, in order from the least significant to most significant.
    ///
    /// Negative values are returned in two's complement representation,
    /// regardless of the type's underlying implementation.
    public var words: Self.Words { get }

    /// The number of bits in the current binary representation of this value.
    ///
    /// This property is a constant for instances of fixed-width integer
    /// types.
    public var bitWidth: Int { get }

    /// The number of trailing zeros in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number -8 has three trailing zeros.
    ///
    ///     let x = Int8(bitPattern: 0b1111_1000)
    ///     // x == -8
    ///     // x.trailingZeroBitCount == 3
    public var trailingZeroBitCount: Int { get }

    /// Returns the quotient of dividing the first value by the second.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     let x = 21 / 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func / (lhs: Self, rhs: Self) -> Self

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     var x = 21
    ///     x /= 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func /= (lhs: inout Self, rhs: Self)

    /// Returns the remainder of dividing the first value by the second.
    ///
    /// The result of the modulo operator (`%`) has the same sign as `lhs` and is
    /// less than `rhs.magnitude`.
    ///
    ///     let x = 22 % 5
    ///     // x == 2
    ///     let y = 22 % -5
    ///     // y == 2
    ///     let z = -22 % -5
    ///     // z == -2
    ///
    /// For any two integers `a` and `b`, their quotient `q`, and their remainder
    /// `r`, `a == b * q + r`.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func % (lhs: Self, rhs: Self) -> Self

    /// Divides the first value by the second and stores the remainder in the
    /// left-hand-side variable.
    ///
    /// The result has the same sign as `lhs` and is less than `rhs.magnitude`.
    ///
    ///     var x = 22
    ///     x %= 5
    ///     // x == 2
    ///
    ///     var y = 22
    ///     y %= -5
    ///     // y == 2
    ///
    ///     var z = -22
    ///     z %= -5
    ///     // z == -2
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func %= (lhs: inout Self, rhs: Self)

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Self, rhs: Self) -> Self

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Self, rhs: Self)

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Self, rhs: Self) -> Self

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Self, rhs: Self)

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Self, rhs: Self) -> Self

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Self, rhs: Self)

    /// Returns the inverse of the bits set in the argument.
    ///
    /// The bitwise NOT operator (`~`) is a prefix operator that returns a value
    /// in which all the bits of its argument are flipped: Bits that are `1` in
    /// the argument are `0` in the result, and bits that are `0` in the argument
    /// are `1` in the result. This is equivalent to the inverse of a set. For
    /// example:
    ///
    ///     let x: UInt8 = 5        // 0b00000101
    ///     let notX = ~x           // 0b11111010
    ///
    /// Performing a bitwise NOT operation on 0 returns a value with every bit
    /// set to `1`.
    ///
    ///     let allOnes = ~UInt8.min   // 0b11111111
    ///
    /// - Complexity: O(1).
    prefix public static func ~ (x: Self) -> Self

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: Self, rhs: Self) -> Self

    /// Stores the result of performing a bitwise AND operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x &= y                    // 0b00000100
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func &= (lhs: inout Self, rhs: Self)

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: Self, rhs: Self) -> Self

    /// Stores the result of performing a bitwise OR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x |= y                    // 0b00001111
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func |= (lhs: inout Self, rhs: Self)

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: Self, rhs: Self) -> Self

    /// Stores the result of performing a bitwise XOR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x ^= y                    // 0b00001011
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^= (lhs: inout Self, rhs: Self)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right.
    ///
    /// The `>>` operator performs a *smart shift*, which defines a result for a
    /// shift of any value.
    ///
    /// - Using a negative value for `rhs` performs a left shift using
    ///   `abs(rhs)`.
    /// - Using a value for `rhs` that is greater than or equal to the bit width
    ///   of `lhs` is an *overshift*. An overshift results in `-1` for a
    ///   negative value of `lhs` or `0` for a nonnegative value.
    /// - Using any other value for `rhs` performs a right shift on `lhs` by that
    ///   amount.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the value is shifted right by two bits.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x >> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// If you use `11` as `rhs`, `x` is overshifted such that all of its bits
    /// are set to zero.
    ///
    ///     let z = x >> 11
    ///     // z == 0                         // 0b00000000
    ///
    /// Using a negative value as `rhs` is the same as performing a left shift
    /// using `abs(rhs)`.
    ///
    ///     let a = x >> -3
    ///     // a == 240                       // 0b11110000
    ///     let b = x << 3
    ///     // b == 240                       // 0b11110000
    ///
    /// Right shift operations on negative values "fill in" the high bits with
    /// ones instead of zeros.
    ///
    ///     let q: Int8 = -30                 // 0b11100010
    ///     let r = q >> 2
    ///     // r == -8                        // 0b11111000
    ///
    ///     let s = q >> 11
    ///     // s == -1                        // 0b11111111
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right.
    public static func >> <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : BinaryInteger

    /// Stores the result of shifting a value's binary representation the
    /// specified number of digits to the right in the left-hand-side variable.
    ///
    /// The `>>=` operator performs a *smart shift*, which defines a result for a
    /// shift of any value.
    ///
    /// - Using a negative value for `rhs` performs a left shift using
    ///   `abs(rhs)`.
    /// - Using a value for `rhs` that is greater than or equal to the bit width
    ///   of `lhs` is an *overshift*. An overshift results in `-1` for a
    ///   negative value of `lhs` or `0` for a nonnegative value.
    /// - Using any other value for `rhs` performs a right shift on `lhs` by that
    ///   amount.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the value is shifted right by two bits.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x >>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// If you use `11` as `rhs`, `x` is overshifted such that all of its bits
    /// are set to zero.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y >>= 11
    ///     // y == 0                         // 0b00000000
    ///
    /// Using a negative value as `rhs` is the same as performing a left shift
    /// using `abs(rhs)`.
    ///
    ///     var a: UInt8 = 30                 // 0b00011110
    ///     a >>= -3
    ///     // a == 240                       // 0b11110000
    ///
    ///     var b: UInt8 = 30                 // 0b00011110
    ///     b <<= 3
    ///     // b == 240                       // 0b11110000
    ///
    /// Right shift operations on negative values "fill in" the high bits with
    /// ones instead of zeros.
    ///
    ///     var q: Int8 = -30                 // 0b11100010
    ///     q >>= 2
    ///     // q == -8                        // 0b11111000
    ///
    ///     var r: Int8 = -30                 // 0b11100010
    ///     r >>= 11
    ///     // r == -1                        // 0b11111111
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right.
    public static func >>= <RHS>(lhs: inout Self, rhs: RHS) where RHS : BinaryInteger

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left.
    ///
    /// The `<<` operator performs a *smart shift*, which defines a result for a
    /// shift of any value.
    ///
    /// - Using a negative value for `rhs` performs a right shift using
    ///   `abs(rhs)`.
    /// - Using a value for `rhs` that is greater than or equal to the bit width
    ///   of `lhs` is an *overshift*, resulting in zero.
    /// - Using any other value for `rhs` performs a left shift on `lhs` by that
    ///   amount.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the value is shifted left by two bits.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x << 2
    ///     // y == 120                       // 0b01111000
    ///
    /// If you use `11` as `rhs`, `x` is overshifted such that all of its bits
    /// are set to zero.
    ///
    ///     let z = x << 11
    ///     // z == 0                         // 0b00000000
    ///
    /// Using a negative value as `rhs` is the same as performing a right shift
    /// with `abs(rhs)`.
    ///
    ///     let a = x << -3
    ///     // a == 3                         // 0b00000011
    ///     let b = x >> 3
    ///     // b == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left.
    public static func << <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : BinaryInteger

    /// Stores the result of shifting a value's binary representation the
    /// specified number of digits to the left in the left-hand-side variable.
    ///
    /// The `<<` operator performs a *smart shift*, which defines a result for a
    /// shift of any value.
    ///
    /// - Using a negative value for `rhs` performs a right shift using
    ///   `abs(rhs)`.
    /// - Using a value for `rhs` that is greater than or equal to the bit width
    ///   of `lhs` is an *overshift*, resulting in zero.
    /// - Using any other value for `rhs` performs a left shift on `lhs` by that
    ///   amount.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the value is shifted left by two bits.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x <<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// If you use `11` as `rhs`, `x` is overshifted such that all of its bits
    /// are set to zero.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y <<= 11
    ///     // y == 0                         // 0b00000000
    ///
    /// Using a negative value as `rhs` is the same as performing a right shift
    /// with `abs(rhs)`.
    ///
    ///     var a: UInt8 = 30                 // 0b00011110
    ///     a <<= -3
    ///     // a == 3                         // 0b00000011
    ///
    ///     var b: UInt8 = 30                 // 0b00011110
    ///     b >>= 3
    ///     // b == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left.
    public static func <<= <RHS>(lhs: inout Self, rhs: RHS) where RHS : BinaryInteger

    /// Returns the quotient and remainder of this value divided by the given
    /// value.
    ///
    /// Use this method to calculate the quotient and remainder of a division at
    /// the same time.
    ///
    ///     let x = 1_000_000
    ///     let (q, r) = x.quotientAndRemainder(dividingBy: 933)
    ///     // q == 1071
    ///     // r == 757
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the quotient and remainder of this value
    ///   divided by `rhs`.
    public func quotientAndRemainder(dividingBy rhs: Self) -> (quotient: Self, remainder: Self)

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> Self
}

extension BinaryInteger {

    /// Creates a new value equal to zero.
    public convenience init()

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> Self

    /// Returns the quotient and remainder of this value divided by the given
    /// value.
    ///
    /// Use this method to calculate the quotient and remainder of a division at
    /// the same time.
    ///
    ///     let x = 1_000_000
    ///     let (q, r) = x.quotientAndRemainder(dividingBy: 933)
    ///     // q == 1071
    ///     // r == 757
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the quotient and remainder of this value
    ///   divided by `rhs`.
    public func quotientAndRemainder(dividingBy rhs: Self) -> (quotient: Self, remainder: Self)

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: Self, rhs: Self) -> Self

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: Self, rhs: Self) -> Self

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: Self, rhs: Self) -> Self

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right.
    ///
    /// The `>>` operator performs a *smart shift*, which defines a result for a
    /// shift of any value.
    ///
    /// - Using a negative value for `rhs` performs a left shift using
    ///   `abs(rhs)`.
    /// - Using a value for `rhs` that is greater than or equal to the bit width
    ///   of `lhs` is an *overshift*. An overshift results in `-1` for a
    ///   negative value of `lhs` or `0` for a nonnegative value.
    /// - Using any other value for `rhs` performs a right shift on `lhs` by that
    ///   amount.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the value is shifted right by two bits.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x >> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// If you use `11` as `rhs`, `x` is overshifted such that all of its bits
    /// are set to zero.
    ///
    ///     let z = x >> 11
    ///     // z == 0                         // 0b00000000
    ///
    /// Using a negative value as `rhs` is the same as performing a left shift
    /// using `abs(rhs)`.
    ///
    ///     let a = x >> -3
    ///     // a == 240                       // 0b11110000
    ///     let b = x << 3
    ///     // b == 240                       // 0b11110000
    ///
    /// Right shift operations on negative values "fill in" the high bits with
    /// ones instead of zeros.
    ///
    ///     let q: Int8 = -30                 // 0b11100010
    ///     let r = q >> 2
    ///     // r == -8                        // 0b11111000
    ///
    ///     let s = q >> 11
    ///     // s == -1                        // 0b11111111
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right.
    public static func >> <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : BinaryInteger

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left.
    ///
    /// The `<<` operator performs a *smart shift*, which defines a result for a
    /// shift of any value.
    ///
    /// - Using a negative value for `rhs` performs a right shift using
    ///   `abs(rhs)`.
    /// - Using a value for `rhs` that is greater than or equal to the bit width
    ///   of `lhs` is an *overshift*, resulting in zero.
    /// - Using any other value for `rhs` performs a left shift on `lhs` by that
    ///   amount.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the value is shifted left by two bits.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x << 2
    ///     // y == 120                       // 0b01111000
    ///
    /// If you use `11` as `rhs`, `x` is overshifted such that all of its bits
    /// are set to zero.
    ///
    ///     let z = x << 11
    ///     // z == 0                         // 0b00000000
    ///
    /// Using a negative value as `rhs` is the same as performing a right shift
    /// with `abs(rhs)`.
    ///
    ///     let a = x << -3
    ///     // a == 3                         // 0b00000011
    ///     let b = x >> 3
    ///     // b == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left.
    public static func << <RHS>(lhs: Self, rhs: RHS) -> Self where RHS : BinaryInteger
}

extension BinaryInteger {

    /// A textual representation of this value.
    public var description: String { get }
}

extension BinaryInteger {

    /// Returns the distance from this value to the given value, expressed as a
    /// stride.
    ///
    /// For two values `x` and `y`, and a distance `n = x.distance(to: y)`,
    /// `x.advanced(by: n) == y`.
    ///
    /// - Parameter other: The value to calculate the distance to.
    /// - Returns: The distance from this value to `other`.
    public func distance(to other: Self) -> Int

    /// Returns a value that is offset the specified distance from this value.
    ///
    /// Use the `advanced(by:)` method in generic code to offset a value by a
    /// specified distance. If you're working directly with numeric values, use
    /// the addition operator (`+`) instead of this method.
    ///
    /// For a value `x`, a distance `n`, and a value `y = x.advanced(by: n)`,
    /// `x.distance(to: y) == n`.
    ///
    /// - Parameter n: The distance to advance this value.
    /// - Returns: A value that is offset from this value by `n`.
    public func advanced(by n: Int) -> Self
}

extension BinaryInteger {

    /// Returns a Boolean value indicating whether the two given values are
    /// equal.
    ///
    /// You can check the equality of instances of any `BinaryInteger` types
    /// using the equal-to operator (`==`). For example, you can test whether
    /// the first `UInt8` value in a string's UTF-8 encoding is equal to the
    /// first `UInt32` value in its Unicode scalar view:
    ///
    ///     let gameName = "Red Light, Green Light"
    ///     if let firstUTF8 = gameName.utf8.first,
    ///         let firstScalar = gameName.unicodeScalars.first?.value {
    ///         print("First code values are equal: \(firstUTF8 == firstScalar)")
    ///     }
    ///     // Prints "First code values are equal: true"
    ///
    /// - Parameters:
    ///   - lhs: An integer to compare.
    ///   - rhs: Another integer to compare.
    public static func == <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger

    /// Returns a Boolean value indicating whether the two given values are not
    /// equal.
    ///
    /// You can check the inequality of instances of any `BinaryInteger` types
    /// using the not-equal-to operator (`!=`). For example, you can test
    /// whether the first `UInt8` value in a string's UTF-8 encoding is not
    /// equal to the first `UInt32` value in its Unicode scalar view:
    ///
    ///     let gameName = "Red Light, Green Light"
    ///     if let firstUTF8 = gameName.utf8.first,
    ///         let firstScalar = gameName.unicodeScalars.first?.value {
    ///         print("First code values are different: \(firstUTF8 != firstScalar)")
    ///     }
    ///     // Prints "First code values are different: false"
    ///
    /// - Parameters:
    ///   - lhs: An integer to compare.
    ///   - rhs: Another integer to compare.
    public static func != <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// You can compare instances of any `BinaryInteger` types using the
    /// less-than operator (`<`), even if the two instances are of different
    /// types.
    ///
    /// - Parameters:
    ///   - lhs: An integer to compare.
    ///   - rhs: Another integer to compare.
    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// You can compare instances of any `BinaryInteger` types using the
    /// less-than-or-equal-to operator (`<=`), even if the two instances are of
    /// different types.
    ///
    /// - Parameters:
    ///   - lhs: An integer to compare.
    ///   - rhs: Another integer to compare.
    public static func <= <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// You can compare instances of any `BinaryInteger` types using the
    /// greater-than-or-equal-to operator (`>=`), even if the two instances are
    /// of different types.
    ///
    /// - Parameters:
    ///   - lhs: An integer to compare.
    ///   - rhs: Another integer to compare.
    public static func >= <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// You can compare instances of any `BinaryInteger` types using the
    /// greater-than operator (`>`), even if the two instances are of different
    /// types.
    ///
    /// - Parameters:
    ///   - lhs: An integer to compare.
    ///   - rhs: Another integer to compare.
    public static func > <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger
}

extension BinaryInteger {

    public static func != (lhs: Self, rhs: Self) -> Bool

    public static func <= (lhs: Self, rhs: Self) -> Bool

    public static func >= (lhs: Self, rhs: Self) -> Bool

    public static func > (lhs: Self, rhs: Self) -> Bool
}

/// A value type whose instances are either `true` or `false`.
///
/// `Bool` represents Boolean values in Swift. Create instances of `Bool` by
/// using one of the Boolean literals `true` or `false`, or by assigning the
/// result of a Boolean method or operation to a variable or constant.
///
///     var godotHasArrived = false
///
///     let numbers = 1...5
///     let containsTen = numbers.contains(10)
///     print(containsTen)
///     // Prints "false"
///
///     let (a, b) = (100, 101)
///     let aFirst = a < b
///     print(aFirst)
///     // Prints "true"
///
/// Swift uses only simple Boolean values in conditional contexts to help avoid
/// accidental programming errors and to help maintain the clarity of each
/// control statement. Unlike in other programming languages, in Swift, integers
/// and strings cannot be used where a Boolean value is required.
///
/// For example, the following code sample does not compile, because it
/// attempts to use the integer `i` in a logical context:
///
///     var i = 5
///     while i {
///         print(i)
///         i -= 1
///     }
///
/// The correct approach in Swift is to compare the `i` value with zero in the
/// `while` statement.
///
///     while i != 0 {
///         print(i)
///         i -= 1
///     }
///
/// Using Imported Boolean values
/// =============================
///
/// The C `bool` and `Boolean` types and the Objective-C `BOOL` type are all
/// bridged into Swift as `Bool`. The single `Bool` type in Swift guarantees
/// that functions, methods, and properties imported from C and Objective-C
/// have a consistent type interface.
public struct Bool {

    /// Creates an instance initialized to `false`.
    ///
    /// Do not call this initializer directly. Instead, use the Boolean literal
    /// `false` to create a new `Bool` instance.
    public init()

    /// Creates an instance equal to the given Boolean value.
    ///
    /// - Parameter value: The Boolean value to copy.
    public init(_ value: Bool)

    /// Returns a random Boolean value, using the given generator as a source for
    /// randomness.
    ///
    /// This method returns `true` and `false` with equal probability. Use this
    /// method to generate a random Boolean value when you are using a custom
    /// random number generator.
    ///
    ///     let flippedHeads = Boolean.random(using: &myGenerator)
    ///     if flippedHeads {
    ///         print("Heads, you win!")
    ///     } else {
    ///         print("Maybe another try?")
    ///     }
    ///
    /// - Parameter generator: The random number generator to use when creating
    ///   the new random value.
    /// - Returns: Either `true` or `false`, randomly chosen with equal
    ///   probability.
    public static func random<T>(using generator: inout T) -> Bool where T : RandomNumberGenerator

    /// Returns a random Boolean value.
    ///
    /// This method returns `true` and `false` with equal probability.
    ///
    ///     let flippedHeads = Boolean.random()
    ///     if flippedHeads {
    ///         print("Heads, you win!")
    ///     } else {
    ///         print("Maybe another try?")
    ///     }
    ///
    /// `Bool.random()` uses the default random generator, `Random.default`. The
    /// call in the example above is equivalent to
    /// `Bool.random(using: &Random.default)`.
    ///
    /// - Returns: Either `true` or `false`, randomly chosen with equal
    ///   probability.
    public static func random() -> Bool
}

extension Bool : ExpressibleByBooleanLiteral {

    /// Creates an instance initialized to the specified Boolean literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use a Boolean literal. Instead, create a new `Bool` instance by
    /// using one of the Boolean literals `true` or `false`.
    ///
    ///     var printedMessage = false
    ///
    ///     if !printedMessage {
    ///         print("You look nice today!")
    ///         printedMessage = true
    ///     }
    ///     // Prints "You look nice today!"
    ///
    /// In this example, both assignments to the `printedMessage` variable call
    /// this Boolean literal initializer behind the scenes.
    ///
    /// - Parameter value: The value of the new instance.
    public init(booleanLiteral value: Bool)
}

extension Bool : CustomStringConvertible {

    /// A textual representation of the Boolean value.
    public var description: String { get }
}

extension Bool : Equatable, Hashable {

    /// The hash value for the Boolean value.
    ///
    /// Two values that are equal always have equal hash values.
    ///
    /// - Note: The hash value is not guaranteed to be stable across different
    ///   invocations of the same program. Do not persist the hash value across
    ///   program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Bool, rhs: Bool) -> Bool
}

extension Bool : LosslessStringConvertible {

    /// Creates a new Boolean value from the given string.
    ///
    /// If the `description` value is any string other than `"true"` or
    /// `"false"`, the result is `nil`. This initializer is case sensitive.
    ///
    /// - Parameter description: A string representation of the Boolean value.
    public init?(_ description: String)
}

extension Bool {

    /// Performs a logical NOT operation on a Boolean value.
    ///
    /// The logical NOT operator (`!`) inverts a Boolean value. If the value is
    /// `true`, the result of the operation is `false`; if the value is `false`,
    /// the result is `true`.
    ///
    ///     var printedMessage = false
    ///
    ///     if !printedMessage {
    ///         print("You look nice today!")
    ///         printedMessage = true
    ///     }
    ///     // Prints "You look nice today!"
    ///
    /// - Parameter a: The Boolean value to negate.
    prefix public static func ! (a: Bool) -> Bool
}

extension Bool {

    /// Performs a logical AND operation on two Boolean values.
    ///
    /// The logical AND operator (`&&`) combines two Boolean values and returns
    /// `true` if both of the values are `true`. If either of the values is
    /// `false`, the operator returns `false`.
    ///
    /// This operator uses short-circuit evaluation: The left-hand side (`lhs`) is
    /// evaluated first, and the right-hand side (`rhs`) is evaluated only if
    /// `lhs` evaluates to `true`. For example:
    ///
    ///     let measurements = [7.44, 6.51, 4.74, 5.88, 6.27, 6.12, 7.76]
    ///     let sum = measurements.reduce(0, combine: +)
    ///
    ///     if measurements.count > 0 && sum / Double(measurements.count) < 6.5 {
    ///         print("Average measurement is less than 6.5")
    ///     }
    ///     // Prints "Average measurement is less than 6.5"
    ///
    /// In this example, `lhs` tests whether `measurements.count` is greater than
    /// zero. Evaluation of the `&&` operator is one of the following:
    ///
    /// - When `measurements.count` is equal to zero, `lhs` evaluates to `false`
    ///   and `rhs` is not evaluated, preventing a divide-by-zero error in the
    ///   expression `sum / Double(measurements.count)`. The result of the
    ///   operation is `false`.
    /// - When `measurements.count` is greater than zero, `lhs` evaluates to
    ///   `true` and `rhs` is evaluated. The result of evaluating `rhs` is the
    ///   result of the `&&` operation.
    ///
    /// - Parameters:
    ///   - lhs: The left-hand side of the operation.
    ///   - rhs: The right-hand side of the operation.
    public static func && (lhs: Bool, rhs: @autoclosure () throws -> Bool) rethrows -> Bool

    /// Performs a logical OR operation on two Boolean values.
    ///
    /// The logical OR operator (`||`) combines two Boolean values and returns
    /// `true` if at least one of the values is `true`. If both values are
    /// `false`, the operator returns `false`.
    ///
    /// This operator uses short-circuit evaluation: The left-hand side (`lhs`) is
    /// evaluated first, and the right-hand side (`rhs`) is evaluated only if
    /// `lhs` evaluates to `false`. For example:
    ///
    ///     let majorErrors: Set = ["No first name", "No last name", ...]
    ///     let error = ""
    ///
    ///     if error.isEmpty || !majorErrors.contains(error) {
    ///         print("No major errors detected")
    ///     } else {
    ///         print("Major error: \(error)")
    ///     }
    ///     // Prints "No major errors detected"
    ///
    /// In this example, `lhs` tests whether `error` is an empty string.
    /// Evaluation of the `||` operator is one of the following:
    ///
    /// - When `error` is an empty string, `lhs` evaluates to `true` and `rhs` is
    ///   not evaluated, skipping the call to `majorErrors.contains(_:)`. The
    ///   result of the operation is `true`.
    /// - When `error` is not an empty string, `lhs` evaluates to `false` and
    ///   `rhs` is evaluated. The result of evaluating `rhs` is the result of the
    ///   `||` operation.
    ///
    /// - Parameters:
    ///   - lhs: The left-hand side of the operation.
    ///   - rhs: The right-hand side of the operation.
    public static func || (lhs: Bool, rhs: @autoclosure () throws -> Bool) rethrows -> Bool
}

extension Bool {

    public mutating func toggle()
}

extension Bool : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Bool : CustomReflectable {

    /// A mirror that reflects the `Bool` instance.
    public var customMirror: Mirror { get }
}

extension Bool : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `Bool` instance.
    @available(*, deprecated, message: "Bool.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Bool : CVarArg {
}

@available(*, deprecated, renamed: "ExpressibleByBooleanLiteral")
public typealias BooleanLiteralConvertible = ExpressibleByBooleanLiteral

/// The default type for an otherwise-unconstrained Boolean literal.
///
/// When you create a constant or variable using one of the Boolean literals
/// `true` or `false`, the resulting type is determined by the
/// `BooleanLiteralType` alias. For example:
///
///     let isBool = true
///     print("isBool is a '\(type(of: isBool))'")
///     // Prints "isBool is a 'Bool'"
///
/// The type aliased by `BooleanLiteralType` must conform to the
/// `ExpressibleByBooleanLiteral` protocol.
public typealias BooleanLiteralType = Bool

/// The C '_Bool' and C++ 'bool' type.
public typealias CBool = Bool

/// The C 'char' type.
///
/// This will be the same as either `CSignedChar` (in the common
/// case) or `CUnsignedChar`, depending on the platform.
public typealias CChar = Int8

/// The C++11 'char16_t' type, which has UTF-16 encoding.
public typealias CChar16 = UInt16

/// The C++11 'char32_t' type, which has UTF-32 encoding.
public typealias CChar32 = Unicode.Scalar

/// The C 'double' type.
public typealias CDouble = Double

/// The C 'float' type.
public typealias CFloat = Float

/// The C 'int' type.
public typealias CInt = Int32

public typealias CLong = Int

public typealias CLongDouble = Float80

/// The C 'long long' type.
public typealias CLongLong = Int64

/// The C 'short' type.
public typealias CShort = Int16

/// The C 'signed char' type.
public typealias CSignedChar = Int8

/// The C 'unsigned char' type.
public typealias CUnsignedChar = UInt8

/// The C 'unsigned int' type.
public typealias CUnsignedInt = UInt32

public typealias CUnsignedLong = UInt

/// The C 'unsigned long long' type.
public typealias CUnsignedLongLong = UInt64

/// The C 'unsigned short' type.
public typealias CUnsignedShort = UInt16

/// A wrapper around a C `va_list` pointer.
public struct CVaListPointer {
}

extension CVaListPointer : CustomDebugStringConvertible {

    /// A textual representation of the pointer, suitable for debugging.
    public var debugDescription: String { get }
}

/// A type whose instances can be encoded, and appropriately passed, as
/// elements of a C `va_list`.
///
/// You use this protocol to present a native Swift interface to a C "varargs"
/// API. For example, a program can import a C API like the one defined here:
///
/// ~~~c
/// int c_api(int, va_list arguments)
/// ~~~
///
/// To create a wrapper for the `c_api` function, write a function that takes
/// `CVarArg` arguments, and then call the imported C function using the
/// `withVaList(_:_:)` function:
///
///     func swiftAPI(_ x: Int, arguments: CVarArg...) -> Int {
///         return withVaList(arguments) { c_api(x, $0) }
///     }
///
/// Swift only imports C variadic functions that use a `va_list` for their
/// arguments. C functions that use the `...` syntax for variadic arguments
/// are not imported, and therefore can't be called using `CVarArg` arguments.
///
/// If you need to pass an optional pointer as a `CVarArg` argument, use the
/// `Int(bitPattern:)` initializer to interpret the optional pointer as an
/// `Int` value, which has the same C variadic calling conventions as a pointer
/// on all supported platforms.
///
/// - Note: Declaring conformance to the `CVarArg` protocol for types defined
///   outside the standard library is not supported.
public protocol CVarArg {
}

/// The C++ 'wchar_t' type.
public typealias CWideChar = Unicode.Scalar

/// A type that provides a collection of all of its values.
///
/// Types that conform to the `CaseIterable` protocol are typically
/// enumerations without associated values. When using a `CaseIterable` type,
/// you can access a collection of all of the type's cases by using the type's
/// `allCases` property.
///
/// For example, the `CompassDirection` enumeration declared in this example
/// conforms to `CaseIterable`. You access the number of cases and the cases
/// themselves through `CompassDirection.allCases`.
///
///     enum CompassDirection: CaseIterable {
///         case north, south, east, west
///     }
///
///     print("There are \(CompassDirection.allCases.count) directions.")
///     // Prints "There are 4 directions."
///     let caseList = CompassDirection.allCases
///                                    .map({ "\($0)" })
///                                    .joined(separator: ", ")
///     // caseList == "north, south, east, west"
///
/// Conforming to the CaseIterable Protocol
/// =======================================
///
/// The compiler can automatically provide an implementation of the
/// `CaseIterable` requirements for any enumeration without associated values
/// or `@available` attributes on its cases. The synthesized `allCases`
/// collection provides the cases in order of their declaration.
///
/// You can take advantage of this compiler support when defining your own
/// custom enumeration by declaring conformance to `CaseIterable` in the
/// enumeration's original declaration. The `CompassDirection` example above
/// demonstrates this automatic implementation.
public protocol CaseIterable {

    /// A type that can represent a collection of all values of this type.
    associatedtype AllCases : Collection where Self.AllCases.Element == Self

    /// A collection of all values of this type.
    public static var allCases: Self.AllCases { get }
}

/// A single extended grapheme cluster that approximates a user-perceived
/// character.
///
/// The `Character` type represents a character made up of one or more Unicode
/// scalar values, grouped by a Unicode boundary algorithm. Generally, a
/// `Character` instance matches what the reader of a string will perceive as
/// a single character. Strings are collections of `Character` instances, so
/// the number of visible characters is generally the most natural way to
/// count the length of a string.
///
///     let greeting = "Hello! "
///     print("Length: \(greeting.count)")
///     // Prints "Length: 8"
///
/// Because each character in a string can be made up of one or more Unicode
/// scalar values, the number of characters in a string may not match the
/// length of the Unicode scalar value representation or the length of the
/// string in a particular binary representation.
///
///     print("Unicode scalar value count: \(greeting.unicodeScalars.count)")
///     // Prints "Unicode scalar value count: 15"
///
///     print("UTF-8 representation count: \(greeting.utf8.count)")
///     // Prints "UTF-8 representation count: 18"
///
/// Every `Character` instance is composed of one or more Unicode scalar values
/// that are grouped together as an *extended grapheme cluster*. The way these
/// scalar values are grouped is defined by a canonical, localized, or
/// otherwise tailored Unicode segmentation algorithm.
///
/// For example, a country's Unicode flag character is made up of two regional
/// indicator scalar values that correspond to that country's ISO 3166-1
/// alpha-2 code. The alpha-2 code for The United States is "US", so its flag
/// character is made up of the Unicode scalar values `"\u{1F1FA}"` (REGIONAL
/// INDICATOR SYMBOL LETTER U) and `"\u{1F1F8}"` (REGIONAL INDICATOR SYMBOL
/// LETTER S). When placed next to each other in a string literal, these two
/// scalar values are combined into a single grapheme cluster, represented by
/// a `Character` instance in Swift.
///
///     let usFlag: Character = "\u{1F1FA}\u{1F1F8}"
///     print(usFlag)
///     // Prints ""
///
/// For more information about the Unicode terms used in this discussion, see
/// the [Unicode.org glossary][glossary]. In particular, this discussion
/// mentions [extended grapheme clusters][clusters] and [Unicode scalar
/// values][scalars].
///
/// [glossary]: http://www.unicode.org/glossary/
/// [clusters]: http://www.unicode.org/glossary/#extended_grapheme_cluster
/// [scalars]: http://www.unicode.org/glossary/#unicode_scalar_value
public struct Character {
}

extension Character {

    public struct UnicodeScalarView {
    }

    public var unicodeScalars: Character.UnicodeScalarView { get }
}

extension Character : ExpressibleByExtendedGraphemeClusterLiteral {

    /// Creates a character containing the given Unicode scalar value.
    ///
    /// - Parameter content: The Unicode scalar value to convert into a character.
    public init(_ content: Unicode.Scalar)

    /// Creates a character with the specified value.
    ///
    /// Do not call this initalizer directly. It is used by the compiler when
    /// you use a string literal to initialize a `Character` instance. For
    /// example:
    ///
    ///     let oBreve: Character = "o\u{306}"
    ///     print(oBreve)
    ///     // Prints ""
    ///
    /// The assignment to the `oBreve` constant calls this initializer behind the
    /// scenes.
    public init(extendedGraphemeClusterLiteral value: Character)

    /// Creates a character from a single-character string.
    ///
    /// The following example creates a new character from the uppercase version
    /// of a string that only holds one character.
    ///
    ///     let a = "a"
    ///     let capitalA = Character(a.uppercased())
    ///
    /// - Parameter s: The single-character string to convert to a `Character`
    ///   instance. `s` must contain exactly one extended grapheme cluster.
    public init(_ s: String)
}

extension Character : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension Character : LosslessStringConvertible {
}

extension Character : CustomDebugStringConvertible {

    /// A textual representation of the character, suitable for debugging.
    public var debugDescription: String { get }
}

extension Character : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Character, rhs: Character) -> Bool
}

extension Character : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Character, rhs: Character) -> Bool
}

extension Character : Hashable {

    /// The character's hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }
}

extension Character : CustomReflectable {

    /// A mirror that reflects the `Character` instance.
    public var customMirror: Mirror { get }
}

extension Character : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `Character` instance.
    @available(*, deprecated, message: "Character.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Character : TextOutputStreamable {

    /// Writes the character into the given output stream.
    ///
    /// - Parameter target: An output stream.
    public func write<Target>(to target: inout Target) where Target : TextOutputStream
}

extension Character.UnicodeScalarView {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public struct Index {
    }
}

extension Character.UnicodeScalarView {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator {
    }
}

extension Character.UnicodeScalarView : Sequence {

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> Character.UnicodeScalarView.Iterator
}

extension Character.UnicodeScalarView : Collection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Character.UnicodeScalarView.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Character.UnicodeScalarView.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Character.UnicodeScalarView.Index) -> Character.UnicodeScalarView.Index

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(i: Character.UnicodeScalarView.Index) -> UnicodeScalar { get }
}

extension Character.UnicodeScalarView : BidirectionalCollection {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Character.UnicodeScalarView.Index) -> Character.UnicodeScalarView.Index
}

extension Character.UnicodeScalarView.Index : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Character.UnicodeScalarView.Index, rhs: Character.UnicodeScalarView.Index) -> Bool
}

extension Character.UnicodeScalarView.Index : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Character.UnicodeScalarView.Index, rhs: Character.UnicodeScalarView.Index) -> Bool
}

extension Character.UnicodeScalarView.Iterator : IteratorProtocol {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> UnicodeScalar?
}

/// An interval from a lower bound up to, and including, an upper bound.
///
/// You create a `ClosedRange` instance by using the closed range
/// operator (`...`).
///
///     let throughFive = 0...5
///
/// A `ClosedRange` instance contains both its lower bound and its
/// upper bound.
///
///     throughFive.contains(3)
///     // true
///     throughFive.contains(10)
///     // false
///     throughFive.contains(5)
///     // true
///
/// Because a closed range includes its upper bound, a closed range whose lower
/// bound is equal to the upper bound contains that value. Therefore, a
/// `ClosedRange` instance cannot represent an empty range.
///
///     let zeroInclusive = 0...0
///     zeroInclusive.contains(0)
///     // true
///     zeroInclusive.isEmpty
///     // false
///
/// Using a Closed Range as a Collection of Consecutive Values
/// ----------------------------------------------------------
///
/// When a closed range uses integers as its lower and upper bounds, or any
/// other type that conforms to the `Strideable` protocol with an integer
/// stride, you can use that range in a `for`-`in` loop or with any sequence or
/// collection method. The elements of the range are the consecutive values
/// from its lower bound up to, and including, its upper bound.
///
///     for n in 3...5 {
///         print(n)
///     }
///     // Prints "3"
///     // Prints "4"
///     // Prints "5"
///
/// Because floating-point types such as `Float` and `Double` are their own
/// `Stride` types, they cannot be used as the bounds of a countable range. If
/// you need to iterate over consecutive floating-point values, see the
/// `stride(from:through:by:)` function.
public struct ClosedRange<Bound> where Bound : Comparable {

    /// The range's lower bound.
    public let lowerBound: Bound

    /// The range's upper bound.
    public let upperBound: Bound

    /// Creates an instance with the given bounds.
    ///
    /// Because this initializer does not perform any checks, it should be used
    /// as an optimization only when you are absolutely certain that `lower` is
    /// less than or equal to `upper`. Using the closed range operator (`...`)
    /// to form `ClosedRange` instances is preferred.
    ///
    /// - Parameter bounds: A tuple of the lower and upper bounds of the range.
    public init(uncheckedBounds bounds: (lower: ClosedRange<Bound>.Bound, upper: ClosedRange<Bound>.Bound))
}

extension ClosedRange where Bound : Strideable, Bound.Stride : SignedInteger {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public enum Index {

        case pastEnd

        case inRange(Bound)
    }
}

extension ClosedRange where Bound : Comparable {

    /// A Boolean value indicating whether the range contains no elements.
    ///
    /// Because a closed range cannot represent an empty range, this property is
    /// always `false`.
    public var isEmpty: Bool { get }
}

extension ClosedRange : RangeExpression where Bound : Comparable {

    /// Returns the range of indices described by this range expression within
    /// the given collection.
    ///
    /// You can use the `relative(to:)` method to convert a range expression,
    /// which could be missing one or both of its endpoints, into a concrete
    /// range that is bounded on both sides. The following example uses this
    /// method to convert a partial range up to `4` into a half-open range,
    /// using an array instance to add the range's lower bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     let upToFour = ..<4
    ///
    ///     let r1 = upToFour.relative(to: numbers)
    ///     // r1 == 0..<4
    ///
    /// The `r1` range is bounded on the lower end by `0` because that is the
    /// starting index of the `numbers` array. When the collection passed to
    /// `relative(to:)` starts with a different index, that index is used as the
    /// lower bound instead. The next example creates a slice of `numbers`
    /// starting at index `2`, and then uses the slice with `relative(to:)` to
    /// convert `upToFour` to a concrete range.
    ///
    ///     let numbersSuffix = numbers[2...]
    ///     // numbersSuffix == [30, 40, 50, 60, 70]
    ///
    ///     let r2 = upToFour.relative(to: numbersSuffix)
    ///     // r2 == 2..<4
    ///
    /// Use this method only if you need the concrete range it produces. To
    /// access a slice of a collection using a range expression, use the
    /// collection's generic subscript that uses a range expression as its
    /// parameter.
    ///
    ///     let numbersPrefix = numbers[upToFour]
    ///     // numbersPrefix == [10, 20, 30, 40]
    ///
    /// - Parameter collection: The collection to evaluate this range expression
    ///   in relation to.
    /// - Returns: A range suitable for slicing `collection`. The returned range
    ///   is *not* guaranteed to be inside the bounds of `collection`. Callers
    ///   should apply the same preconditions to the return value as they would
    ///   to a range provided directly by the user.
    public func relative<C>(to collection: C) -> Range<Bound> where Bound == C.Index, C : Collection

    /// Returns a Boolean value indicating whether the given element is contained
    /// within the range.
    ///
    /// A `ClosedRange` instance contains both its lower and upper bound.
    /// `element` is contained in the range if it is between the two bounds or
    /// equal to either bound.
    ///
    /// - Parameter element: The element to check for containment.
    /// - Returns: `true` if `element` is contained in the range; otherwise,
    ///   `false`.
    public func contains(_ element: Bound) -> Bool
}

extension ClosedRange : Sequence where Bound : Strideable, Bound.Stride : SignedInteger {

    /// A type representing the sequence's elements.
    public typealias Element = Bound

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = IndexingIterator<ClosedRange<Bound>>
}

extension ClosedRange : Collection, BidirectionalCollection, RandomAccessCollection where Bound : Strideable, Bound.Stride : SignedInteger {

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = Slice<ClosedRange<Bound>>

    /// The position of the first element in the range.
    public var startIndex: ClosedRange<Bound>.Index { get }

    /// The range's "past the end" position---that is, the position one greater
    /// than the last valid subscript argument.
    public var endIndex: ClosedRange<Bound>.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: ClosedRange<Bound>.Index) -> ClosedRange<Bound>.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: ClosedRange<Bound>.Index) -> ClosedRange<Bound>.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: ClosedRange<Bound>.Index, offsetBy n: Int) -> ClosedRange<Bound>.Index

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: ClosedRange<Bound>.Index, to end: ClosedRange<Bound>.Index) -> Int

    /// Accesses the element at specified position.
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the range, and must not equal the range's end
    ///   index.
    public subscript(position: ClosedRange<Bound>.Index) -> ClosedRange<Bound>.Bound { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// For example, using a `PartialRangeFrom` range expression with an array
    /// accesses the subrange from the start of the range expression until the
    /// end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2..<5]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. This example searches `streetsSlice` for one of the
    /// strings in the slice, and then uses that index in the original array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")!    // 4
    ///     print(streets[index])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice may result in a runtime
    /// error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<ClosedRange<Bound>.Index>) -> Slice<ClosedRange<ClosedRange<Bound>.Bound>> { get }
}

extension ClosedRange : Equatable where Bound : Comparable {

    /// Returns a Boolean value indicating whether two ranges are equal.
    ///
    /// Two ranges are equal when they have the same lower and upper bounds.
    ///
    ///     let x: ClosedRange = 5...15
    ///     print(x == 5...15)
    ///     // Prints "true"
    ///     print(x == 10...20)
    ///     // Prints "false"
    ///
    /// - Parameters:
    ///   - lhs: A range to compare.
    ///   - rhs: Another range to compare.
    public static func == (lhs: ClosedRange<Bound>, rhs: ClosedRange<Bound>) -> Bool
}

extension ClosedRange : Hashable where Bound : Comparable, Bound : Hashable {

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension ClosedRange : CustomStringConvertible where Bound : Comparable {

    /// A textual representation of the range.
    public var description: String { get }
}

extension ClosedRange : CustomDebugStringConvertible where Bound : Comparable {

    /// A textual representation of the range, suitable for debugging.
    public var debugDescription: String { get }
}

extension ClosedRange : CustomReflectable where Bound : Comparable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension ClosedRange where Bound : Comparable {

    /// Returns a copy of this range clamped to the given limiting range.
    ///
    /// The bounds of the result are always limited to the bounds of `limits`.
    /// For example:
    ///
    ///     let x: ClosedRange = 0...20
    ///     print(x.clamped(to: 10...1000))
    ///     // Prints "10...20"
    ///
    /// If the two ranges do not overlap, the result is a single-element range at
    /// the upper or lower bound of `limits`.
    ///
    ///     let y: ClosedRange = 0...5
    ///     print(y.clamped(to: 10...1000))
    ///     // Prints "10...10"
    ///
    /// - Parameter limits: The range to clamp the bounds of this range.
    /// - Returns: A new range clamped to the bounds of `limits`.
    public func clamped(to limits: ClosedRange<Bound>) -> ClosedRange<Bound>
}

extension ClosedRange where Bound : Strideable, Bound.Stride : SignedInteger {

    /// Now that Range is conditionally a collection when Bound: Strideable,
    /// CountableRange is no longer needed. This is a deprecated initializer
    /// for any remaining uses of Range(countableRange).
    @available(swift, deprecated: 4.2, message: "CountableRange is now Range. No need to convert any more.")
    public init(_ other: ClosedRange<ClosedRange<Bound>.Bound>)

    /// Creates an instance equivalent to the given `Range`.
    ///
    /// - Parameter other: A `Range` to convert to a `ClosedRange` instance.
    ///
    /// An equivalent range must be representable as a closed range.
    /// For example, passing an empty range as `other` triggers a runtime error,
    /// because an empty range cannot be represented by a closed range instance.
    public init(_ other: Range<ClosedRange<Bound>.Bound>)
}

extension ClosedRange where Bound : Comparable {

    public func overlaps(_ other: ClosedRange<ClosedRange<Bound>.Bound>) -> Bool

    public func overlaps(_ other: Range<ClosedRange<Bound>.Bound>) -> Bool
}

extension ClosedRange where Bound : FixedWidthInteger, Bound.Magnitude : UnsignedInteger, Bound.Stride : SignedInteger {

    /// Returns a random element of the range, using the given generator as
    /// a source for randomness.
    ///
    /// You can use this method to select a random element of a range when you
    /// are using a custom random number generator. If you're generating a random
    /// number, in most cases, you should prefer using the `random(in:using:)`
    /// static method of the desired numeric type. That static method is available
    /// for both integer and floating point types, and returns a non-optional
    /// value.
    ///
    /// - Parameter generator: The random number generator to use when choosing
    ///   a random element.
    /// - Returns: A random element of the range.
    ///   This method never returns `nil`.
    public func randomElement<T>(using generator: inout T) -> ClosedRange<Bound>.Element? where T : RandomNumberGenerator

    /// Returns a random element of the range, using the given generator as
    /// a source for randomness.
    ///
    /// You can use this method to select a random element of a range when you
    /// are using a custom random number generator. If you're generating a random
    /// number, in most cases, you should prefer using the `random(in:)`
    /// static method of the desired numeric type. That static method is available
    /// for both integer and floating point types, and returns a non-optional
    /// value.
    ///
    /// This method uses the default random generator, `Random.default`. Calling
    /// `(1...100).randomElement()` is equivalent to calling
    /// `(1...100).randomElement(using: &Random.default)`.
    ///
    /// - Returns: A random element of the range.
    ///   This method never returns `nil`.
    public func randomElement() -> ClosedRange<Bound>.Element?
}

extension ClosedRange.Index : Comparable where Bound : Strideable, Bound.Stride : SignedInteger {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ClosedRange<Bound>.Index, rhs: ClosedRange<Bound>.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: ClosedRange<Bound>.Index, rhs: ClosedRange<Bound>.Index) -> Bool
}

extension ClosedRange.Index : Hashable where Bound : Hashable, Bound : Strideable, Bound.Stride : SignedInteger {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

@available(*, deprecated, renamed: "ClosedRange.Index")
public typealias ClosedRangeIndex<T> = ClosedRange<T>.Index

/// A type that can convert itself into and out of an external representation.
///
/// `Codable` is a type alias for the `Encodable` and `Decodable` protocols.
/// When you use `Codable` as a type or a generic constraint, it matches
/// any type that conforms to both protocols.
public typealias Codable = Decodable & Encodable

/// A type that can be used as a key for encoding and decoding.
public protocol CodingKey : CustomDebugStringConvertible, CustomStringConvertible {

    /// The string to use in a named collection (e.g. a string-keyed dictionary).
    public var stringValue: String { get }

    /// Creates a new instance from the given string.
    ///
    /// If the string passed as `stringValue` does not correspond to any instance
    /// of this type, the result is `nil`.
    ///
    /// - parameter stringValue: The string value of the desired key.
    public init?(stringValue: String)

    /// The value to use in an integer-indexed collection (e.g. an int-keyed
    /// dictionary).
    public var intValue: Int? { get }

    /// Creates a new instance from the specified integer.
    ///
    /// If the value passed as `intValue` does not correspond to any instance of
    /// this type, the result is `nil`.
    ///
    /// - parameter intValue: The integer value of the desired key.
    public init?(intValue: Int)
}

extension CodingKey {

    /// A textual representation of this key.
    public var description: String { get }

    /// A textual representation of this key, suitable for debugging.
    public var debugDescription: String { get }
}

/// A user-defined key for providing context during encoding and decoding.
public struct CodingUserInfoKey : RawRepresentable, Equatable, Hashable {

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    public typealias RawValue = String

    /// The key's string value.
    public let rawValue: String

    /// Creates a new instance with the given raw value.
    ///
    /// - parameter rawValue: The value of the key.
    public init?(rawValue: String)

    /// Returns a Boolean value indicating whether the given keys are equal.
    ///
    /// - parameter lhs: The key to compare against.
    /// - parameter rhs: The key to compare with.
    public static func == (lhs: CodingUserInfoKey, rhs: CodingUserInfoKey) -> Bool

    /// The key's hash value.
    public var hashValue: Int { get }
}

/// A sequence whose elements can be traversed multiple times,
/// nondestructively, and accessed by an indexed subscript.
///
/// Collections are used extensively throughout the standard library. When you
/// use arrays, dictionaries, and other collections, you benefit from the
/// operations that the `Collection` protocol declares and implements. In
/// addition to the operations that collections inherit from the `Sequence`
/// protocol, you gain access to methods that depend on accessing an element
/// at a specific position in a collection.
///
/// For example, if you want to print only the first word in a string, you can
/// search for the index of the first space, and then create a substring up to
/// that position.
///
///     let text = "Buffalo buffalo buffalo buffalo."
///     if let firstSpace = text.firstIndex(of: " ") {
///         print(text[..<firstSpace])
///     }
///     // Prints "Buffalo"
///
/// The `firstSpace` constant is an index into the `text` string---the position
/// of the first space in the string. You can store indices in variables, and
/// pass them to collection algorithms or use them later to access the
/// corresponding element. In the example above, `firstSpace` is used to
/// extract the prefix that contains elements up to that index.
///
/// Accessing Individual Elements
/// =============================
///
/// You can access an element of a collection through its subscript by using
/// any valid index except the collection's `endIndex` property. This property
/// is a "past the end" index that does not correspond with any element of the
/// collection.
///
/// Here's an example of accessing the first character in a string through its
/// subscript:
///
///     let firstChar = text[text.startIndex]
///     print(firstChar)
///     // Prints "B"
///
/// The `Collection` protocol declares and provides default implementations for
/// many operations that depend on elements being accessible by their
/// subscript. For example, you can also access the first character of `text`
/// using the `first` property, which has the value of the first element of
/// the collection, or `nil` if the collection is empty.
///
///     print(text.first)
///     // Prints "Optional("B")"
///
/// You can pass only valid indices to collection operations. You can find a
/// complete set of a collection's valid indices by starting with the
/// collection's `startIndex` property and finding every successor up to, and
/// including, the `endIndex` property. All other values of the `Index` type,
/// such as the `startIndex` property of a different collection, are invalid
/// indices for this collection.
///
/// Saved indices may become invalid as a result of mutating operations. For
/// more information about index invalidation in mutable collections, see the
/// reference for the `MutableCollection` and `RangeReplaceableCollection`
/// protocols, as well as for the specific type you're using.
///
/// Accessing Slices of a Collection
/// ================================
///
/// You can access a slice of a collection through its ranged subscript or by
/// calling methods like `prefix(while:)` or `suffix(_:)`. A slice of a
/// collection can contain zero or more of the original collection's elements
/// and shares the original collection's semantics.
///
/// The following example creates a `firstWord` constant by using the
/// `prefix(while:)` method to get a slice of the `text` string.
///
///     let firstWord = text.prefix(while: { $0 != " " })
///     print(firstWord)
///     // Prints "Buffalo"
///
/// You can retrieve the same slice using the string's ranged subscript, which
/// takes a range expression.
///
///     if let firstSpace = text.firstIndex(of: " ") {
///         print(text[..<firstSpace]
///         // Prints "Buffalo"
///     }
///
/// The retrieved slice of `text` is equivalent in each of these cases.
///
/// Slices Share Indices
/// --------------------
///
/// A collection and its slices share the same indices. An element of a
/// collection is located under the same index in a slice as in the base
/// collection, as long as neither the collection nor the slice has been
/// mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these steps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(by:)` method to determine the index of the day with the
///    most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(by: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Collection Semantics
/// -----------------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, when working with a slice of a mutable collection that has value
/// semantics, such as an array, mutating the original collection triggers a
/// copy of that collection and does not affect the contents of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// Traversing a Collection
/// =======================
///
/// Although a sequence can be consumed as it is traversed, a collection is
/// guaranteed to be *multipass*: Any element can be repeatedly accessed by
/// saving its index. Moreover, a collection's indices form a finite range of
/// the positions of the collection's elements. The fact that all collections
/// are finite guarantees the safety of many sequence operations, such as
/// using the `contains(_:)` method to test whether a collection includes an
/// element.
///
/// Iterating over the elements of a collection by their positions yields the
/// same elements in the same order as iterating over that collection using
/// its iterator. This example demonstrates that the `characters` view of a
/// string returns the same characters in the same order whether the view's
/// indices or the view itself is being iterated.
///
///     let word = "Swift"
///     for character in word {
///         print(character)
///     }
///     // Prints "S"
///     // Prints "w"
///     // Prints "i"
///     // Prints "f"
///     // Prints "t"
///
///     for i in word.indices {
///         print(word[i])
///     }
///     // Prints "S"
///     // Prints "w"
///     // Prints "i"
///     // Prints "f"
///     // Prints "t"
///
/// Conforming to the Collection Protocol
/// =====================================
///
/// If you create a custom sequence that can provide repeated access to its
/// elements, make sure that its type conforms to the `Collection` protocol in
/// order to give a more useful and more efficient interface for sequence and
/// collection operations. To add `Collection` conformance to your type, you
/// must declare at least the following requirements:
///
/// - The `startIndex` and `endIndex` properties
/// - A subscript that provides at least read-only access to your type's
///   elements
/// - The `index(after:)` method for advancing an index into your collection
///
/// Expected Performance
/// ====================
///
/// Types that conform to `Collection` are expected to provide the `startIndex`
/// and `endIndex` properties and subscript access to elements as O(1)
/// operations. Types that are not able to guarantee this performance must
/// document the departure, because many collection operations depend on O(1)
/// subscripting performance for their own performance guarantees.
///
/// The performance of some collection operations depends on the type of index
/// that the collection provides. For example, a random-access collection,
/// which can measure the distance between two indices in O(1) time, can
/// calculate its `count` property in O(1) time. Conversely, because a forward
/// or bidirectional collection must traverse the entire collection to count
/// the number of contained elements, accessing its `count` property is an
/// O(*n*) operation.
public protocol Collection : Sequence where Self.SubSequence : Collection {

    associatedtype Element

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    associatedtype Index : Comparable where Self.Index == Self.Indices.Element, Self.Indices.Element == Self.Indices.Index, Self.Indices.Index == Self.SubSequence.Index, Self.SubSequence.Index == Self.Indices.Indices.Element, Self.Indices.Indices.Element == Self.Indices.Indices.Index, Self.Indices.Indices.Index == Self.SubSequence.Indices.Element, Self.SubSequence.Indices.Element == Self.SubSequence.Indices.Index, Self.SubSequence.Indices.Index == Self.SubSequence.Indices.Indices.Element, Self.SubSequence.Indices.Indices.Element == Self.SubSequence.Indices.Indices.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Self.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Self.Index { get }

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    associatedtype Iterator = IndexingIterator<Self>

    /// Returns an iterator over the elements of the collection.
    public func makeIterator() -> Self.Iterator

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    associatedtype SubSequence = Slice<Self>

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Self.Index) -> Self.Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// For example, using a `PartialRangeFrom` range expression with an array
    /// accesses the subrange from the start of the range expression until the
    /// end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2..<5]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. This example searches `streetsSlice` for one of the
    /// strings in the slice, and then uses that index in the original array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")!    // 4
    ///     print(streets[index])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice may result in a runtime
    /// error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<Self.Index>) -> Self.SubSequence { get }

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    associatedtype Indices : Collection = DefaultIndices<Self> where Self.Indices == Self.Indices.SubSequence

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Self.Indices { get }

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    public func prefix(upTo end: Self.Index) -> Self.SubSequence

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    public func suffix(from start: Self.Index) -> Self.SubSequence

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position `end`. 
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter end: The index of the last element to include in the
    ///   resulting subsequence. `end` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the `end` position.
    ///
    /// - Complexity: O(1)
    public func prefix(through position: Self.Index) -> Self.SubSequence

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("I've been through the desert on a horse with no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!"
    ///
    /// - Complexity: O(1)
    public var isEmpty: Bool { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Self.Element? { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Self.Index, offsetBy n: Int) -> Self.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Self.Index, offsetBy n: Int, limitedBy limit: Self.Index) -> Self.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Self.Index, to end: Self.Index) -> Int

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Self.Index) -> Self.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Self.Index)

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// You use this method to select a random element from a collection when you
    /// are using a custom random number generator. For example, call
    /// `randomElement(using:)` to select a random element from an array of names.
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing
    ///   a random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    public func randomElement<T>(using generator: inout T) -> Self.Element? where T : RandomNumberGenerator

    @available(*, deprecated, message: "all index distances are now of type Int")
    public typealias IndexDistance = Int
}

extension Collection {

    /// Accesses the contiguous subrange of the collection's elements specified
    /// by a range expression.
    ///
    /// The range expression is converted to a concrete subrange relative to this
    /// collection. For example, using a `PartialRangeFrom` range expression
    /// with an array accesses the subrange from the start of the range
    /// expression until the end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2...]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. This example searches `streetsSlice` for one
    /// of the strings in the slice, and then uses that index in the original
    /// array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice's indices may result in a
    /// runtime error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }

    public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }
}

extension Collection {

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the collection. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the collection.
    public func dropFirst(_ n: Int) -> Self.SubSequence

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in the
    /// collection, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   collection. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence that leaves off the specified number of elements
    ///   at the end.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func dropLast(_ n: Int) -> Self.SubSequence

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be skipped or `false` if it should be included. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func drop(while predicate: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this collection
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> Self.SubSequence

    /// Returns a subsequence containing the initial elements until `predicate`
    /// returns `false` and skipping the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns `true` if the element should
    ///   be included or `false` if it should be excluded. Once the predicate
    ///   returns `false` it will not be called again.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func prefix(while predicate: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the collection.
    ///
    /// If the maximum length exceeds the number of elements in the collection,
    /// the result contains all the elements in the collection.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of the collection with at
    ///   most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func suffix(_ maxLength: Int) -> Self.SubSequence

    /// Returns a subsequence from the start of the collection up to, but not
    /// including, the specified position.
    ///
    /// The resulting subsequence *does not include* the element at the position
    /// `end`. The following example searches for the index of the number `40`
    /// in an array of integers, and then prints the prefix of the array up to,
    /// but not including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(upTo: i))
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// Passing the collection's starting index as the `end` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.prefix(upTo: numbers.startIndex))
    ///     // Prints "[]"
    ///
    /// Using the `prefix(upTo:)` method is equivalent to using a partial
    /// half-open range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(upTo:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[..<i])
    ///     }
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter end: The "past the end" index of the resulting subsequence.
    ///   `end` must be a valid index of the collection.
    /// - Returns: A subsequence up to, but not including, the `end` position.
    ///
    /// - Complexity: O(1)
    public func prefix(upTo end: Self.Index) -> Self.SubSequence

    /// Returns a subsequence from the specified position to the end of the
    /// collection.
    ///
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the suffix of the array starting at
    /// that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.suffix(from: i))
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// Passing the collection's `endIndex` as the `start` parameter results in
    /// an empty subsequence.
    ///
    ///     print(numbers.suffix(from: numbers.endIndex))
    ///     // Prints "[]"
    ///
    /// Using the `suffix(from:)` method is equivalent to using a partial range
    /// from the index as the collection's subscript. The subscript notation is
    /// preferred over `suffix(from:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[i...])
    ///     }
    ///     // Prints "[40, 50, 60]"
    ///
    /// - Parameter start: The index at which to start the resulting subsequence.
    ///   `start` must be a valid index of the collection.
    /// - Returns: A subsequence starting at the `start` position.
    ///
    /// - Complexity: O(1)
    public func suffix(from start: Self.Index) -> Self.SubSequence

    /// Returns a subsequence from the start of the collection through the
    /// specified position.
    ///
    /// The resulting subsequence *includes* the element at the position `end`. 
    /// The following example searches for the index of the number `40` in an
    /// array of integers, and then prints the prefix of the array up to, and
    /// including, that index:
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60]
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers.prefix(through: i))
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// Using the `prefix(through:)` method is equivalent to using a partial
    /// closed range as the collection's subscript. The subscript notation is
    /// preferred over `prefix(through:)`.
    ///
    ///     if let i = numbers.firstIndex(of: 40) {
    ///         print(numbers[...i])
    ///     }
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter end: The index of the last element to include in the
    ///   resulting subsequence. `end` must be a valid index of the collection
    ///   that is not equal to the `endIndex` property.
    /// - Returns: A subsequence up to, and including, the `end` position.
    ///
    /// - Complexity: O(1)
    public func prefix(through position: Self.Index) -> Self.SubSequence

    /// Returns the longest possible subsequences of the collection, in order,
    /// that don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(maxSplits: 1, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false, whereSeparator: { $0 == " " }))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the collection satisfying the `isSeparator`
    ///     predicate. The default value is `true`.
    ///   - isSeparator: A closure that takes an element as an argument and
    ///     returns a Boolean value indicating whether the collection should be
    ///     split at that element.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Self.Element) throws -> Bool) rethrows -> [Self.SubSequence]
}

/// Default implementations of core requirements
extension Collection {

    /// A Boolean value indicating whether the collection is empty.
    ///
    /// When you need to check whether your collection is empty, use the
    /// `isEmpty` property instead of checking that the `count` property is
    /// equal to zero. For collections that don't conform to
    /// `RandomAccessCollection`, accessing the `count` property iterates
    /// through the elements of the collection.
    ///
    ///     let horseName = "Silver"
    ///     if horseName.isEmpty {
    ///         print("I've been through the desert on a horse with no name.")
    ///     } else {
    ///         print("Hi ho, \(horseName)!")
    ///     }
    ///     // Prints "Hi ho, Silver!")
    ///
    /// - Complexity: O(1)
    public var isEmpty: Bool { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Self.Element? { get }

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var underestimatedCount: Int { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }
}

/// Default implementation for forward collections.
extension Collection {

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Self.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Self.Index, offsetBy n: Int) -> Self.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Self.Index, offsetBy n: Int, limitedBy limit: Self.Index) -> Self.Index?

    /// Offsets the given index by the specified distance.
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout Self.Index, offsetBy n: Int)

    /// Offsets the given index by the specified distance, or so that it equals
    /// the given limiting index.
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: `true` if `i` has been offset by exactly `n` steps without
    ///   going beyond `limit`; otherwise, `false`. When the return value is
    ///   `false`, the value of `i` is equal to `limit`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func formIndex(_ i: inout Self.Index, offsetBy n: Int, limitedBy limit: Self.Index) -> Bool

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Self.Index, to end: Self.Index) -> Int

    /// Returns a random element of the collection, using the given generator as
    /// a source for randomness.
    ///
    /// Call `randomElement(using:)` to select a random element from an array or
    /// another collection when you are using a custom random number generator.
    /// This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement(using: &myGenerator)!
    ///     // randomName == "Amani"
    ///
    /// - Parameter generator: The random number generator to use when choosing
    ///   a random element.
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    public func randomElement<T>(using generator: inout T) -> Self.Element? where T : RandomNumberGenerator

    /// Returns a random element of the collection.
    ///
    /// Call `randomElement()` to select a random element from an array or
    /// another collection. This example picks a name at random from an array:
    ///
    ///     let names = ["Zoey", "Chloe", "Amani", "Amaia"]
    ///     let randomName = names.randomElement()!
    ///     // randomName == "Amani"
    ///
    /// This method uses the default random generator, `Random.default`. The call
    /// to `names.randomElement()` above is equivalent to calling
    /// `names.randomElement(using: &Random.default)`.
    ///
    /// - Returns: A random element from the collection. If the collection is
    ///   empty, the method returns `nil`.
    public func randomElement() -> Self.Element?
}

/// Supply the default `makeIterator()` method for `Collection` models
/// that accept the default associated `Iterator`,
/// `IndexingIterator<Self>`.
extension Collection where Self.Iterator == IndexingIterator<Self> {

    /// Returns an iterator over the elements of the collection.
    public func makeIterator() -> IndexingIterator<Self>
}

/// Supply the default "slicing" `subscript` for `Collection` models
/// that accept the default associated `SubSequence`, `Slice<Self>`.
extension Collection where Self.SubSequence == Slice<Self> {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<Self.Index>) -> Slice<Self> { get }
}

extension Collection where Self == Self.SubSequence {

    /// Removes and returns the first element of the collection.
    ///
    /// - Returns: The first element of the collection if the collection is
    ///   not empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    public mutating func popFirst() -> Self.Element?
}

extension Collection where Self.Element : Equatable {

    /// Returns the longest possible subsequences of the collection, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the collection are not returned as part
    /// of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " "))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the collection, or
    ///     one less than the number of subsequences to return. If
    ///     `maxSplits + 1` subsequences are returned, the last one is a suffix
    ///     of the original collection containing the remaining elements.
    ///     `maxSplits` must be greater than or equal to zero. The default value
    ///     is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the collection and for each instance of `separator` at
    ///     the start or end of the collection. If `true`, only nonempty
    ///     subsequences are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this collection's
    ///   elements.
    public func split(separator: Self.Element, maxSplits: Int = default, omittingEmptySubsequences: Bool = default) -> [Self.SubSequence]
}

extension Collection where Self == Self.SubSequence {

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// - Returns: The first element of the collection.
    ///
    /// - Complexity: O(1)
    public mutating func removeFirst() -> Self.Element

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    /// - Parameter n: The number of elements to remove. `n` must be greater than
    ///   or equal to zero, and must be less than or equal to the number of
    ///   elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*).
    public mutating func removeFirst(_ n: Int)
}

extension Collection {

    @available(*, deprecated, message: "all index distances are now of type Int")
    public func index<T>(_ i: Self.Index, offsetBy n: T) -> Self.Index where T : BinaryInteger

    @available(*, deprecated, message: "all index distances are now of type Int")
    public func formIndex<T>(_ i: inout Self.Index, offsetBy n: T) where T : BinaryInteger

    @available(*, deprecated, message: "all index distances are now of type Int")
    public func index<T>(_ i: Self.Index, offsetBy n: T, limitedBy limit: Self.Index) -> Self.Index? where T : BinaryInteger

    @available(*, deprecated, message: "all index distances are now of type Int")
    public func formIndex<T>(_ i: inout Self.Index, offsetBy n: T, limitedBy limit: Self.Index) -> Bool where T : BinaryInteger

    @available(*, deprecated, message: "all index distances are now of type Int")
    public func distance<T>(from start: Self.Index, to end: Self.Index) -> T where T : BinaryInteger
}

extension Collection where Self.Element : Equatable {

    /// Returns the first index where the specified value appears in the
    /// collection.
    ///
    /// After using `firstIndex(of:)` to find the position of a particular element
    /// in a collection, you can use it to access the element by subscripting.
    /// This example shows how you can modify one of the names in an array of
    /// students.
    ///
    ///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
    ///     if let i = students.firstIndex(of: "Maxime") {
    ///         students[i] = "Max"
    ///     }
    ///     print(students)
    ///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
    ///
    /// - Parameter element: An element to search for in the collection.
    /// - Returns: The first index where `element` is found. If `element` is not
    ///   found in the collection, returns `nil`.
    public func firstIndex(of element: Self.Element) -> Self.Index?
}

extension Collection {

    /// Returns the first index in which an element of the collection satisfies
    /// the given predicate.
    ///
    /// You can use the predicate to find an element of a type that doesn't
    /// conform to the `Equatable` protocol or to find an element that matches
    /// particular criteria. Here's an example that finds a student name that
    /// begins with the letter "A":
    ///
    ///     let students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     if let i = students.firstIndex(where: { $0.hasPrefix("A") }) {
    ///         print("\(students[i]) starts with 'A'!")
    ///     }
    ///     // Prints "Abena starts with 'A'!"
    ///
    /// - Parameter predicate: A closure that takes an element as its argument
    ///   and returns a Boolean value that indicates whether the passed element
    ///   represents a match.
    /// - Returns: The index of the first element for which `predicate` returns
    ///   `true`. If no elements in the collection satisfy the given predicate,
    ///   returns `nil`.
    public func firstIndex(where predicate: (Self.Element) throws -> Bool) rethrows -> Self.Index?
}

extension Collection where Self.Element : Collection {

    /// Returns the elements of this collection of collections, concatenated.
    ///
    /// In this example, an array of three ranges is flattened so that the
    /// elements of each range can be iterated in turn.
    ///
    ///     let ranges = [0..<3, 8..<10, 15..<17]
    ///
    ///     // A for-in loop over 'ranges' accesses each range:
    ///     for range in ranges {
    ///       print(range)
    ///     }
    ///     // Prints "0..<3"
    ///     // Prints "8..<10"
    ///     // Prints "15..<17"
    ///
    ///     // Use 'joined()' to access each element of each range:
    ///     for index in ranges.joined() {
    ///         print(index, terminator: " ")
    ///     }
    ///     // Prints: "0 1 2 8 9 15 16"
    ///
    /// - Returns: A flattened view of the elements of this
    ///   collection of collections.
    public func joined() -> FlattenCollection<Self>
}

extension Collection where Self.Indices == DefaultIndices<Self> {

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: DefaultIndices<Self> { get }
}

/// Augment `self` with lazy methods such as `map`, `filter`, etc.
extension Collection {

    /// A view onto this collection that provides lazy implementations of
    /// normally eager operations, such as `map` and `filter`.
    ///
    /// Use the `lazy` property when chaining operations to prevent
    /// intermediate operations from allocating storage, or when you only
    /// need a part of the final collection to avoid unnecessary computation.
    public var lazy: LazyCollection<Self> { get }
}

extension Collection {

    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap(_ transform: (Self.Element) throws -> String?) rethrows -> [String]
}

/// A collection containing a single element.
///
/// You can use a `CollectionOfOne` instance when you need to efficiently
/// represent a single value as a collection. For example, you can add a
/// single element to an array by using a `CollectionOfOne` instance with the
/// concatenation operator (`+`):
///
///     let a = [1, 2, 3, 4]
///     let toAdd = 100
///     let b = a + CollectionOfOne(toAdd)
///     // b == [1, 2, 3, 4, 100]
public struct CollectionOfOne<Element> {

    /// Creates an instance containing just the given element.
    ///
    /// - Parameter element: The element to store in the collection.
    public init(_ element: Element)
}

extension CollectionOfOne : RandomAccessCollection, MutableCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// The position of the first element.
    ///
    /// In a `CollectionOfOne` instance, `startIndex` is always `0`.
    public var startIndex: Int { get }

    /// The "past the end" position---that is, the position one greater than the
    /// last valid subscript argument.
    ///
    /// In a `CollectionOfOne` instance, `endIndex` is always `1`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be `0`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be `1`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Int) -> Int

    /// Returns an iterator over the elements of this collection.
    ///
    /// - Complexity: O(1)
    public func makeIterator() -> IteratorOverOne<Element>

    /// Accesses the element at the specified position.
    ///
    /// - Parameter position: The position of the element to access. The only
    ///   valid position in a `CollectionOfOne` instance is `0`.
    public subscript(position: Int) -> Element

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Int>) -> Slice<CollectionOfOne<Element>>

    /// The number of elements in the collection, which is always one.
    public var count: Int { get }
}

extension CollectionOfOne : CustomDebugStringConvertible {

    /// A textual representation of the collection, suitable for debugging.
    public var debugDescription: String { get }
}

extension CollectionOfOne : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// Command-line arguments for the current process.
public enum CommandLine {

    /// Access to the raw argc value from C.
    public static var argc: Int32 { get }

    /// Access to the raw argv value from C. Accessing the argument vector
    /// through this pointer is unsafe.
    public static var unsafeArgv: UnsafeMutablePointer<UnsafeMutablePointer<Int8>?> { get }

    /// Access to the swift arguments, also use lazy initialization of static
    /// properties to safely initialize the swift arguments.
    public static var arguments: [String]
}

/// A type that can be compared using the relational operators `<`, `<=`, `>=`,
/// and `>`.
///
/// The `Comparable` protocol is used for types that have an inherent order,
/// such as numbers and strings. Many types in the standard library already
/// conform to the `Comparable` protocol. Add `Comparable` conformance to your
/// own custom types when you want to be able to compare instances using
/// relational operators or use standard library methods that are designed for
/// `Comparable` types.
///
/// The most familiar use of relational operators is to compare numbers, as in
/// the following example:
///
///     let currentTemp = 73
///
///     if currentTemp >= 90 {
///         print("It's a scorcher!")
///     } else if currentTemp < 65 {
///         print("Might need a sweater today.")
///     } else {
///         print("Seems like picnic weather!")
///     }
///     // Prints "Seems like picnic weather!"
///
/// You can use special versions of some sequence and collection operations
/// when working with a `Comparable` type. For example, if your array's
/// elements conform to `Comparable`, you can call the `sort()` method without
/// using arguments to sort the elements of your array in ascending order.
///
///     var measurements = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]
///     measurements.sort()
///     print(measurements)
///     // Prints "[1.1, 1.2, 1.2, 1.3, 1.5, 1.5, 2.9]"
///
/// Conforming to the Comparable Protocol
/// =====================================
///
/// Types with Comparable conformance implement the less-than operator (`<`)
/// and the equal-to operator (`==`). These two operations impose a strict
/// total order on the values of a type, in which exactly one of the following
/// must be true for any two values `a` and `b`:
///
/// - `a == b`
/// - `a < b`
/// - `b < a`
///
/// In addition, the following conditions must hold:
///
/// - `a < a` is always `false` (Irreflexivity)
/// - `a < b` implies `!(b < a)` (Asymmetry)
/// - `a < b` and `b < c` implies `a < c` (Transitivity)
///
/// To add `Comparable` conformance to your custom types, define the `<` and
/// `==` operators as static methods of your types. The `==` operator is a
/// requirement of the `Equatable` protocol, which `Comparable` extends---see
/// that protocol's documentation for more information about equality in
/// Swift. Because default implementations of the remainder of the relational
/// operators are provided by the standard library, you'll be able to use
/// `!=`, `>`, `<=`, and `>=` with instances of your type without any further
/// code.
///
/// As an example, here's an implementation of a `Date` structure that stores
/// the year, month, and day of a date:
///
///     struct Date {
///         let year: Int
///         let month: Int
///         let day: Int
///     }
///
/// To add `Comparable` conformance to `Date`, first declare conformance to
/// `Comparable` and implement the `<` operator function.
///
///     extension Date: Comparable {
///         static func < (lhs: Date, rhs: Date) -> Bool {
///             if lhs.year != rhs.year {
///                 return lhs.year < rhs.year
///             } else if lhs.month != rhs.month {
///                 return lhs.month < rhs.month
///             } else {
///                 return lhs.day < rhs.day
///             }
///         }
///
/// This function uses the least specific nonmatching property of the date to
/// determine the result of the comparison. For example, if the two `year`
/// properties are equal but the two `month` properties are not, the date with
/// the lesser value for `month` is the lesser of the two dates.
///
/// Next, implement the `==` operator function, the requirement inherited from
/// the `Equatable` protocol.
///
///         static func == (lhs: Date, rhs: Date) -> Bool {
///             return lhs.year == rhs.year && lhs.month == rhs.month
///                 && lhs.day == rhs.day
///         }
///     }
///
/// Two `Date` instances are equal if each of their corresponding properties is
/// equal.
///
/// Now that `Date` conforms to `Comparable`, you can compare instances of the
/// type with any of the relational operators. The following example compares
/// the date of the first moon landing with the release of David Bowie's song
/// "Space Oddity":
///
///     let spaceOddity = Date(year: 1969, month: 7, day: 11)   // July 11, 1969
///     let moonLanding = Date(year: 1969, month: 7, day: 20)   // July 20, 1969
///     if moonLanding > spaceOddity {
///         print("Major Tom stepped through the door first.")
///     } else {
///         print("David Bowie was following in Neil Armstrong's footsteps.")
///     }
///     // Prints "Major Tom stepped through the door first."
///
/// Note that the `>` operator provided by the standard library is used in this
/// example, not the `<` operator implemented above.
///
/// - Note: A conforming type may contain a subset of values which are treated
///   as exceptional---that is, values that are outside the domain of
///   meaningful arguments for the purposes of the `Comparable` protocol. For
///   example, the special "not a number" value for floating-point types
///   (`FloatingPoint.nan`) compares as neither less than, greater than, nor
///   equal to any normal floating-point value. Exceptional values need not
///   take part in the strict total order.
public protocol Comparable : Equatable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Self, rhs: Self) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: Self, rhs: Self) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: Self, rhs: Self) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: Self, rhs: Self) -> Bool
}

extension Comparable {

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than that of the second argument.
    ///
    /// This is the default implementation of the greater-than operator (`>`) for
    /// any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: Self, rhs: Self) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is less than or equal to that of the second argument.
    ///
    /// This is the default implementation of the less-than-or-equal-to
    /// operator (`<=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: Self, rhs: Self) -> Bool

    /// Returns a Boolean value indicating whether the value of the first argument
    /// is greater than or equal to that of the second argument.
    ///
    /// This is the default implementation of the greater-than-or-equal-to operator
    /// (`>=`) for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    /// - Returns: `true` if `lhs` is greater than or equal to `rhs`; otherwise,
    ///   `false`.
    public static func >= (lhs: Self, rhs: Self) -> Bool
}

extension Comparable {

    /// Returns a closed range that contains both of its bounds.
    ///
    /// Use the closed range operator (`...`) to create a closed range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `ClosedRange<Character>` from "a" up to, and including, "z".
    ///
    ///     let lowercase = "a"..."z"
    ///     print(lowercase.contains("z"))
    ///     // Prints "true"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    public static func ... (minimum: Self, maximum: Self) -> ClosedRange<Self>
}

extension Comparable {

    /// Returns a half-open range that contains its lower bound but not its upper
    /// bound.
    ///
    /// Use the half-open range operator (`..<`) to create a range of any type
    /// that conforms to the `Comparable` protocol. This example creates a
    /// `Range<Double>` from zero up to, but not including, 5.0.
    ///
    ///     let lessThanFive = 0.0..<5.0
    ///     print(lessThanFive.contains(3.14))  // Prints "true"
    ///     print(lessThanFive.contains(5.0))   // Prints "false"
    ///
    /// - Parameters:
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    public static func ..< (minimum: Self, maximum: Self) -> Range<Self>

    /// Returns a partial range up to, but not including, its upper bound.
    ///
    /// Use the prefix half-open range operator (prefix `..<`) to create a
    /// partial range of any type that conforms to the `Comparable` protocol.
    /// This example creates a `PartialRangeUpTo<Double>` instance that includes
    /// any value less than `5.0`.
    ///
    ///     let upToFive = ..<5.0
    ///
    ///     upToFive.contains(3.14)       // true
    ///     upToFive.contains(6.28)       // false
    ///     upToFive.contains(5.0)        // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, but not
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[..<3])
    ///     // Prints "[10, 20, 30]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    prefix public static func ..< (maximum: Self) -> PartialRangeUpTo<Self>

    /// Returns a partial range up to, and including, its upper bound.
    ///
    /// Use the prefix closed range operator (prefix `...`) to create a partial
    /// range of any type that conforms to the `Comparable` protocol. This
    /// example creates a `PartialRangeThrough<Double>` instance that includes
    /// any value less than or equal to `5.0`.
    ///
    ///     let throughFive = ...5.0
    ///
    ///     throughFive.contains(4.0)     // true
    ///     throughFive.contains(5.0)     // true
    ///     throughFive.contains(6.0)     // false
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the start of the collection up to, and
    /// including, the partial range's upper bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[...3])
    ///     // Prints "[10, 20, 30, 40]"
    ///
    /// - Parameter maximum: The upper bound for the range.
    prefix public static func ... (maximum: Self) -> PartialRangeThrough<Self>

    /// Returns a partial range extending upward from a lower bound.
    ///
    /// Use the postfix range operator (postfix `...`) to create a partial range
    /// of any type that conforms to the `Comparable` protocol. This example
    /// creates a `PartialRangeFrom<Double>` instance that includes any value
    /// greater than or equal to `5.0`.
    ///
    ///     let atLeastFive = 5.0...
    ///
    ///     atLeastFive.contains(4.0)     // false
    ///     atLeastFive.contains(5.0)     // true
    ///     atLeastFive.contains(6.0)     // true
    ///
    /// You can use this type of partial range of a collection's indices to
    /// represent the range from the partial range's lower bound up to the end
    /// of the collection.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     print(numbers[3...])
    ///     // Prints "[40, 50, 60, 70]"
    ///
    /// - Parameter minimum: The lower bound for the range.
    postfix public static func ... (minimum: Self) -> PartialRangeFrom<Self>
}

/// A contiguously stored array.
///
/// The `ContiguousArray` type is a specialized array that always stores its
/// elements in a contiguous region of memory. This contrasts with `Array`,
/// which can store its elements in either a contiguous region of memory or an
/// `NSArray` instance if its `Element` type is a class or `@objc` protocol.
///
/// If your array's `Element` type is a class or `@objc` protocol and you do
/// not need to bridge the array to `NSArray` or pass the array to Objective-C
/// APIs, using `ContiguousArray` may be more efficient and have more
/// predictable performance than `Array`. If the array's `Element` type is a
/// struct or enumeration, `Array` and `ContiguousArray` should have similar
/// efficiency.
///
/// For more information about using arrays, see `Array` and `ArraySlice`, with
/// which `ContiguousArray` shares most properties and methods.
public struct ContiguousArray<Element> {
}

extension ContiguousArray : RandomAccessCollection, MutableCollection {

    /// The index type for arrays, `Int`.
    public typealias Index = Int

    /// The type that represents the indices that are valid for subscripting an
    /// array, in ascending order.
    public typealias Indices = Range<Int>

    /// The type that allows iteration over an array's elements.
    public typealias Iterator = IndexingIterator<ContiguousArray<Element>>

    /// The position of the first element in a nonempty array.
    ///
    /// For an instance of `ContiguousArray`, `startIndex` is always zero. If the array
    /// is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The array's "past the end" position---that is, the position one greater
    /// than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of an array, use the
    /// half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let i = numbers.firstIndex(of: 30) {
    ///         print(numbers[i ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the array is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index immediately before `i`.
    public func index(before i: Int) -> Int

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Int)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    public func index(_ i: Int, offsetBy n: Int) -> Int

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position. The
    /// operation doesn't require going beyond the limiting `numbers.endIndex`
    /// value, so it succeeds.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let i = numbers.index(numbers.startIndex,
    ///                              offsetBy: 4,
    ///                              limitedBy: numbers.endIndex) {
    ///         print(numbers[i])
    ///     }
    ///     // Prints "50"
    ///
    /// The next example attempts to retrieve an index ten positions from
    /// `numbers.startIndex`, but fails, because that distance is beyond the
    /// index passed as `limit`.
    ///
    ///     let j = numbers.index(numbers.startIndex,
    ///                           offsetBy: 10,
    ///                           limitedBy: numbers.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` has no effect if it is less than `i`. Likewise, if `n < 0`,
    ///     `limit` has no effect if it is greater than `i`.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    public func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -> Int?

    /// Returns the distance between two indices.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`.
    public func distance(from start: Int, to end: Int) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example uses indexed subscripting to update an array's
    /// second element. After assigning the new value (`"Butler"`) at a specific
    /// position, that value is immediately available at that same position.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// - Parameter index: The position of the element to access. `index` must be
    ///   greater than or equal to `startIndex` and less than `endIndex`.
    ///
    /// - Complexity: Reading an element from an array is O(1). Writing is O(1)
    ///   unless the array's storage is shared with another array, in which case
    ///   writing is O(*n*), where *n* is the length of the array.
    public subscript(index: Int) -> Element

    /// Accesses a contiguous subrange of the array's elements.
    ///
    /// The returned `ArraySlice` instance uses the same indices for the same
    /// elements as the original array. In particular, that slice, unlike an
    /// array, may have a nonzero `startIndex` and an `endIndex` that is not
    /// equal to `count`. Always use the slice's `startIndex` and `endIndex`
    /// properties instead of assuming that its indices start or end at a
    /// particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let i = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[i!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of integers. The bounds of the range must be
    ///   valid indices of the array.
    public subscript(bounds: Range<Int>) -> ArraySlice<Element>
}

extension ContiguousArray : ExpressibleByArrayLiteral {

    /// Creates an array from the given array literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use an array literal. Instead, create a new array by using an array
    /// literal as its value. To do this, enclose a comma-separated list of
    /// values in square brackets.
    ///
    /// Here, an array of strings is created from an array literal holding only
    /// strings:
    ///
    ///     let ingredients: ContiguousArray =
    ///           ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///
    /// - Parameter elements: A variadic list of elements of the new array.
    public init(arrayLiteral elements: ContiguousArray<Element>.Element...)
}

extension ContiguousArray : RangeReplaceableCollection {

    /// Creates a new, empty array.
    ///
    /// This is equivalent to initializing with an empty array literal.
    /// For example:
    ///
    ///     var emptyArray = Array<Int>()
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    ///
    ///     emptyArray = []
    ///     print(emptyArray.isEmpty)
    ///     // Prints "true"
    public init()

    /// Creates an array containing the elements of a sequence.
    ///
    /// You can use this initializer to create an array from any other type that
    /// conforms to the `Sequence` protocol. For example, you might want to
    /// create an array with the integers from 1 through 7. Use this initializer
    /// around a range instead of typing all those numbers in an array literal.
    ///
    ///     let numbers = Array(1...7)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7]"
    ///
    /// You can also use this initializer to convert a complex sequence or
    /// collection type back to an array. For example, the `keys` property of
    /// a dictionary isn't an array with its own storage, it's a collection
    /// that maps its elements from the dictionary only when they're
    /// accessed, saving the time and space needed to allocate an array. If
    /// you need to pass those keys to a method that takes an array, however,
    /// use this initializer to convert that list from its type of
    /// `LazyMapCollection<Dictionary<String, Int>, Int>` to a simple
    /// `[String]`.
    ///
    ///     func cacheImagesWithNames(names: [String]) {
    ///         // custom image loading and caching
    ///      }
    ///
    ///     let namedHues: [String: Int] = ["Vermillion": 18, "Magenta": 302,
    ///             "Gold": 50, "Cerise": 320]
    ///     let colorNames = Array(namedHues.keys)
    ///     cacheImagesWithNames(colorNames)
    ///
    ///     print(colorNames)
    ///     // Prints "["Gold", "Cerise", "Magenta", "Vermillion"]"
    ///
    /// - Parameter s: The sequence of elements to turn into an array.
    public init<S>(_ s: S) where Element == S.Element, S : Sequence

    /// Creates a new array containing the specified number of a single, repeated
    /// value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: ContiguousArray<Element>.Element, count: Int)

    /// The number of elements in the array.
    public var count: Int { get }

    /// The total number of elements that the array can contain without
    /// allocating new storage.
    ///
    /// Every array reserves a specific amount of memory to hold its contents.
    /// When you add elements to an array and that array begins to exceed its
    /// reserved capacity, the array allocates a larger region of memory and
    /// copies its elements into the new storage. The new storage is a multiple
    /// of the old storage's size. This exponential growth strategy means that
    /// appending an element happens in constant time, averaging the performance
    /// of many append operations. Append operations that trigger reallocation
    /// have a performance cost, but they occur less and less often as the array
    /// grows larger.
    ///
    /// The following example creates an array of integers from an array literal,
    /// then appends the elements of another collection. Before appending, the
    /// array allocates new storage that is large enough store the resulting
    /// elements.
    ///
    ///     var numbers = [10, 20, 30, 40, 50]
    ///     // numbers.count == 5
    ///     // numbers.capacity == 5
    ///
    ///     numbers.append(contentsOf: stride(from: 60, through: 100, by: 10))
    ///     // numbers.count == 10
    ///     // numbers.capacity == 12
    public var capacity: Int { get }

    /// Reserves enough space to store the specified number of elements.
    ///
    /// If you are adding a known number of elements to an array, use this method
    /// to avoid multiple reallocations. This method ensures that the array has
    /// unique, mutable, contiguous storage, with space allocated for at least
    /// the requested number of elements.
    ///
    /// For performance reasons, the size of the newly allocated storage might be
    /// greater than the requested capacity. Use the array's `capacity` property
    /// to determine the size of the new storage.
    ///
    /// Preserving an Array's Geometric Growth Strategy
    /// ===============================================
    ///
    /// If you implement a custom data structure backed by an array that grows
    /// dynamically, naively calling the `reserveCapacity(_:)` method can lead
    /// to worse than expected performance. Arrays need to follow a geometric
    /// allocation pattern for appending elements to achieve amortized
    /// constant-time performance. The `Array` type's `append(_:)` and
    /// `append(contentsOf:)` methods take care of this detail for you, but
    /// `reserveCapacity(_:)` allocates only as much space as you tell it to
    /// (padded to a round value), and no more. This avoids over-allocation, but
    /// can result in insertion not having amortized constant-time performance.
    ///
    /// The following code declares `values`, an array of integers, and the
    /// `addTenQuadratic()` function, which adds ten more values to the `values`
    /// array on each call.
    ///
    ///       var values: [Int] = [0, 1, 2, 3]
    ///
    ///       // Don't use 'reserveCapacity(_:)' like this
    ///       func addTenQuadratic() {
    ///           let newCount = values.count + 10
    ///           values.reserveCapacity(newCount)
    ///           for n in values.count..<newCount {
    ///               values.append(n)
    ///           }
    ///       }
    ///
    /// The call to `reserveCapacity(_:)` increases the `values` array's capacity
    /// by exactly 10 elements on each pass through `addTenQuadratic()`, which
    /// is linear growth. Instead of having constant time when averaged over
    /// many calls, the function may decay to performance that is linear in
    /// `values.count`. This is almost certainly not what you want.
    ///
    /// In cases like this, the simplest fix is often to simply remove the call
    /// to `reserveCapacity(_:)`, and let the `append(_:)` method grow the array
    /// for you.
    ///
    ///       func addTen() {
    ///           let newCount = values.count + 10
    ///           for n in values.count..<newCount {
    ///               values.append(n)
    ///           }
    ///       }
    ///
    /// If you need more control over the capacity of your array, implement your
    /// own geometric growth strategy, passing the size you compute to
    /// `reserveCapacity(_:)`.
    ///
    /// - Parameter minimumCapacity: The requested number of elements to store.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements in the array.
    public mutating func reserveCapacity(_ minimumCapacity: Int)

    /// Adds a new element at the end of the array.
    ///
    /// Use this method to append a single element to the end of a mutable array.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(100)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 100]"
    ///
    /// Because arrays increase their allocated capacity using an exponential
    /// strategy, appending a single element to an array is an O(1) operation
    /// when averaged over many calls to the `append(_:)` method. When an array
    /// has additional capacity and is not sharing its storage with another
    /// instance, appending an element is O(1). When an array needs to
    /// reallocate storage before appending or its storage is shared with
    /// another copy, appending is O(*n*), where *n* is the length of the array.
    ///
    /// - Parameter newElement: The element to append to the array.
    ///
    /// - Complexity: Amortized O(1) over many additions. If the array uses a
    ///   bridged `NSArray` instance as its storage, the efficiency is
    ///   unspecified.
    public mutating func append(_ newElement: ContiguousArray<Element>.Element)

    /// Adds the elements of a sequence to the end of the array.
    ///
    /// Use this method to append the elements of a sequence to the end of this
    /// array. This example appends the elements of a `Range<Int>` instance
    /// to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the array.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting array.
    public mutating func append<S>(contentsOf newElements: S) where Element == S.Element, S : Sequence

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved up to
    /// close the gap.
    ///
    ///     var measurements: [Double] = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.1, 1.5, 1.2, 1.5, 1.3, 1.2]"
    ///
    /// - Parameter index: The position of the element to remove. `index` must
    ///   be a valid index of the array.
    /// - Returns: The element at the specified index.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func remove(at index: Int) -> ContiguousArray<Element>.Element

    /// Inserts a new element at the specified position.
    ///
    /// The new element is inserted before the element currently at the specified
    /// index. If you pass the array's `endIndex` property as the `index`
    /// parameter, the new element is appended to the array.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// - Parameter newElement: The new element to insert into the array.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index of the array or equal to its `endIndex`
    ///   property.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func insert(_ newElement: ContiguousArray<Element>.Element, at i: Int)

    /// Removes all elements from the array.
    ///
    /// - Parameter keepCapacity: Pass `true` to keep the existing capacity of
    ///   the array after removing its elements. The default value is
    ///   `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the array.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)
}

extension ContiguousArray : CustomReflectable {

    /// A mirror that reflects the array.
    public var customMirror: Mirror { get }
}

extension ContiguousArray : CustomStringConvertible, CustomDebugStringConvertible {

    /// A textual representation of the array and its elements.
    public var description: String { get }

    /// A textual representation of the array and its elements, suitable for
    /// debugging.
    public var debugDescription: String { get }
}

extension ContiguousArray {

    /// Calls a closure with a pointer to the array's contiguous storage.
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows how you can iterate over the contents of the
    /// buffer pointer:
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     let sum = numbers.withUnsafeBufferPointer { buffer -> Int in
    ///         var result = 0
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {
    ///             result += buffer[i]
    ///         }
    ///         return result
    ///     }
    ///     // 'sum' == 9
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withUnsafeBufferPointer(_:)`. Do not store or return the
    /// pointer for later use.
    ///
    /// - Parameter body: A closure with an `UnsafeBufferPointer` parameter that
    ///   points to the contiguous storage for the array.  If
    ///   `body` has a return value, that value is also used as the return value
    ///   for the `withUnsafeBufferPointer(_:)` method. The pointer argument is
    ///   valid only for the duration of the method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withUnsafeBufferPointer<R>(_ body: (UnsafeBufferPointer<ContiguousArray<Element>.Element>) throws -> R) rethrows -> R

    /// Calls the given closure with a pointer to the array's mutable contiguous
    /// storage.
    ///
    /// Often, the optimizer can eliminate bounds checks within an array
    /// algorithm, but when that fails, invoking the same algorithm on the
    /// buffer pointer passed into your closure lets you trade safety for speed.
    ///
    /// The following example shows how modifying the contents of the
    /// `UnsafeMutableBufferPointer` argument to `body` alters the contents of
    /// the array:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.withUnsafeMutableBufferPointer { buffer in
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {
    ///             buffer.swapAt(i, i + 1)
    ///         }
    ///     }
    ///     print(numbers)
    ///     // Prints "[2, 1, 4, 3, 5]"
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withUnsafeMutableBufferPointer(_:)`. Do not store or
    /// return the pointer for later use.
    ///
    /// - Warning: Do not rely on anything about the array that is the target of
    ///   this method during execution of the `body` closure; it might not
    ///   appear to have its correct value. Instead, use only the
    ///   `UnsafeMutableBufferPointer` argument to `body`.
    ///
    /// - Parameter body: A closure with an `UnsafeMutableBufferPointer`
    ///   parameter that points to the contiguous storage for the array.
    ///    If `body` has a return value, that value is also
    ///   used as the return value for the `withUnsafeMutableBufferPointer(_:)`
    ///   method. The pointer argument is valid only for the duration of the
    ///   method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout UnsafeMutableBufferPointer<ContiguousArray<Element>.Element>) throws -> R) rethrows -> R
}

extension ContiguousArray {

    /// Replaces a range of elements with the elements in the specified
    /// collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the array and inserting the new elements at the same location. The
    /// number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the array to replace. The start and end of
    ///     a subrange must be valid indices of the array.
    ///   - newElements: The new elements to add to the array.
    ///
    /// - Complexity: O(`subrange.count`) if you are replacing a suffix of the
    ///   array with an empty collection; otherwise, O(*n*), where *n* is the
    ///   length of the array.
    public mutating func replaceSubrange<C>(_ subrange: Range<Int>, with newElements: C) where Element == C.Element, C : Collection
}

extension ContiguousArray : Equatable where Element : Equatable {

    /// Returns a Boolean value indicating whether two arrays contain the same
    /// elements in the same order.
    ///
    /// You can use the equal-to operator (`==`) to compare any two arrays
    /// that store the same, `Equatable`-conforming element type.
    ///
    /// - Parameters:
    ///   - lhs: An array to compare.
    ///   - rhs: Another array to compare.
    public static func == (lhs: ContiguousArray<ContiguousArray<Element>.Element>, rhs: ContiguousArray<ContiguousArray<Element>.Element>) -> Bool

    /// Returns a Boolean value indicating whether two arrays are not equal.
    ///
    /// Two arrays are equal if they contain the same elements in the same order.
    /// You can use the not-equal-to operator (`!=`) to compare any two arrays
    /// that store the same, `Equatable`-conforming element type.
    ///
    /// - Parameters:
    ///   - lhs: An array to compare.
    ///   - rhs: Another array to compare.
    public static func != (lhs: ContiguousArray<ContiguousArray<Element>.Element>, rhs: ContiguousArray<ContiguousArray<Element>.Element>) -> Bool
}

extension ContiguousArray : Hashable where Element : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension ContiguousArray {

    /// Calls the given closure with a pointer to the underlying bytes of the
    /// array's mutable contiguous storage.
    ///
    /// The array's `Element` type must be a *trivial type*, which can be copied
    /// with just a bit-for-bit copy without any indirection or
    /// reference-counting operations. Generally, native Swift types that do not
    /// contain strong or weak references are trivial, as are imported C structs
    /// and enums.
    ///
    /// The following example copies bytes from the `byteValues` array into
    /// `numbers`, an array of `Int`:
    ///
    ///     var numbers: [Int32] = [0, 0]
    ///     var byteValues: [UInt8] = [0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00]
    ///
    ///     numbers.withUnsafeMutableBytes { destBytes in
    ///         byteValues.withUnsafeBytes { srcBytes in
    ///             destBytes.copyBytes(from: srcBytes)
    ///         }
    ///     }
    ///     // numbers == [1, 2]
    ///
    /// The pointer passed as an argument to `body` is valid only for the
    /// lifetime of the closure. Do not escape it from the closure for later
    /// use.
    ///
    /// - Warning: Do not rely on anything about the array that is the target of
    ///   this method during execution of the `body` closure; it might not
    ///   appear to have its correct value. Instead, use only the
    ///   `UnsafeMutableRawBufferPointer` argument to `body`.
    ///
    /// - Parameter body: A closure with an `UnsafeMutableRawBufferPointer`
    ///   parameter that points to the contiguous storage for the array.
    ///    If no such storage exists, it is created. If `body` has a return value, that value is also
    ///   used as the return value for the `withUnsafeMutableBytes(_:)` method.
    ///   The argument is valid only for the duration of the closure's
    ///   execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public mutating func withUnsafeMutableBytes<R>(_ body: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R

    /// Calls the given closure with a pointer to the underlying bytes of the
    /// array's contiguous storage.
    ///
    /// The array's `Element` type must be a *trivial type*, which can be copied
    /// with just a bit-for-bit copy without any indirection or
    /// reference-counting operations. Generally, native Swift types that do not
    /// contain strong or weak references are trivial, as are imported C structs
    /// and enums.
    ///
    /// The following example copies the bytes of the `numbers` array into a
    /// buffer of `UInt8`:
    ///
    ///     var numbers = [1, 2, 3]
    ///     var byteBuffer: [UInt8] = []
    ///     numbers.withUnsafeBytes {
    ///         byteBuffer.append(contentsOf: $0)
    ///     }
    ///     // byteBuffer == [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, ...]
    ///
    /// - Parameter body: A closure with an `UnsafeRawBufferPointer` parameter
    ///   that points to the contiguous storage for the array.
    ///    If no such storage exists, it is created. If `body` has a return value, that value is also
    ///   used as the return value for the `withUnsafeBytes(_:)` method. The
    ///   argument is valid only for the duration of the closure's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

public typealias CountableClosedRange<Bound> = ClosedRange<Bound>

public typealias CountablePartialRangeFrom<Bound> = PartialRangeFrom<Bound>

public typealias CountableRange<Bound> = Range<Bound>

/// A type with a customized textual representation suitable for debugging
/// purposes.
///
/// Swift provides a default debugging textual representation for any type.
/// That default representation is used by the `String(reflecting:)`
/// initializer and the `debugPrint(_:)` function for types that don't provide
/// their own. To customize that representation, make your type conform to the
/// `CustomDebugStringConvertible` protocol.
///
/// Because the `String(reflecting:)` initializer works for instances of *any*
/// type, returning an instance's `debugDescription` if the value passed
/// conforms to `CustomDebugStringConvertible`, accessing a type's
/// `debugDescription` property directly or using
/// `CustomDebugStringConvertible` as a generic constraint is discouraged.
///
/// - Note: Calling the `dump(_:_:_:_:)` function and printing in the debugger
///   uses both `String(reflecting:)` and `Mirror(reflecting:)` to collect
///   information about an instance. If you implement
///   `CustomDebugStringConvertible` conformance for your custom type, you may
///   want to consider providing a custom mirror by implementing
///   `CustomReflectable` conformance, as well.
///
/// Conforming to the CustomDebugStringConvertible Protocol
/// =======================================================
///
/// Add `CustomDebugStringConvertible` conformance to your custom types by
/// defining a `debugDescription` property.
///
/// For example, this custom `Point` struct uses the default representation
/// supplied by the standard library:
///
///     struct Point {
///         let x: Int, y: Int
///     }
///
///     let p = Point(x: 21, y: 30)
///     print(String(reflecting: p))
///     // Prints "p: Point = {
///     //           x = 21
///     //           y = 30
///     //         }"
///
/// After adding `CustomDebugStringConvertible` conformance by implementing the
/// `debugDescription` property, `Point` provides its own custom debugging
/// representation.
///
///     extension Point: CustomDebugStringConvertible {
///         var debugDescription: String {
///             return "Point(x: \(x), y: \(y))"
///         }
///     }
///
///     print(String(reflecting: p))
///     // Prints "Point(x: 21, y: 30)"
public protocol CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

/// A type that explicitly supplies its own mirror, but whose
/// descendant classes are not represented in the mirror unless they
/// also override `customMirror`.
public protocol CustomLeafReflectable : CustomReflectable {
}

/// A type that supplies a custom description for playground logging.
///
/// Playground logging can generate, at a minimum, a structured description
/// of any type. If you want to provide a custom description of your type to be
/// logged in place of the default description, conform to the
/// `CustomPlaygroundDisplayConvertible` protocol.
///
/// Playground logging generates a richer, more specialized description of core
/// types. For example, the contents of a `String` are logged, as are the
/// components of an `NSColor` or `UIColor`. The current playground logging
/// implementation logs specialized descriptions of at least the following
/// types:
///
/// - `String` and `NSString`
/// - `Int`, `UInt`, and the other standard library integer types
/// - `Float` and `Double`
/// - `Bool`
/// - `Date` and `NSDate`
/// - `NSAttributedString`
/// - `NSNumber`
/// - `NSRange`
/// - `URL` and `NSURL`
/// - `CGPoint`, `CGSize`, and `CGRect`
/// - `NSColor`, `UIColor`, `CGColor`, and `CIColor`
/// - `NSImage`, `UIImage`, `CGImage`, and `CIImage`
/// - `NSBezierPath` and `UIBezierPath`
/// - `NSView` and `UIView`
///
/// Playground logging may also be able to support specialized descriptions
/// of other types.
///
/// Conforming to the CustomPlaygroundDisplayConvertible Protocol
/// -------------------------------------------------------------
///
/// To add `CustomPlaygroundDisplayConvertible` conformance to your custom type,
/// implement the `playgroundDescription` property. If your implementation
/// returns an instance of one of the types above, that type's specialized
/// description is used. If you return any other type, a structured description
/// is generated.
///
/// If your type has value semantics, the `playgroundDescription` should be
/// unaffected by subsequent mutations, if possible.
///
/// If your type's `playgroundDescription` returns an instance which itself
/// conforms to `CustomPlaygroundDisplayConvertible`, then that type's
/// `playgroundDescription` will be used, and so on. To prevent infinite loops,
/// playground logging implementations can place a reasonable limit on this
/// kind of chaining.
public protocol CustomPlaygroundDisplayConvertible {

    /// A custom playground description for this instance.
    public var playgroundDescription: Any { get }
}

/// A type that explicitly supplies its own playground Quick Look.
///
/// The `CustomPlaygroundQuickLookable` protocol is deprecated, and will be
/// removed from the standard library in a future Swift release. To customize
/// the logging of your type in a playground, conform to the
/// `CustomPlaygroundDisplayConvertible` protocol.
///
/// If you need to provide a customized playground representation in Swift 4.0
/// or Swift 3.2 or earlier, use a conditional compilation block:
///
///     #if swift(>=4.1) || (swift(>=3.3) && !swift(>=4.0))
///         // With Swift 4.1 and later (including Swift 3.3 and later),
///         // conform to CustomPlaygroundDisplayConvertible.
///         extension MyType: CustomPlaygroundDisplayConvertible { /*...*/ }
///     #else
///         // Otherwise, on Swift 4.0 and Swift 3.2 and earlier,
///         // conform to CustomPlaygroundQuickLookable.
///         extension MyType: CustomPlaygroundQuickLookable { /*...*/ }
///     #endif
@available(*, deprecated, message: "CustomPlaygroundQuickLookable will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
public protocol CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

/// A type that explicitly supplies its own mirror.
///
/// You can create a mirror for any type using the `Mirror(reflecting:)`
/// initializer, but if you are not satisfied with the mirror supplied for
/// your type by default, you can make it conform to `CustomReflectable` and
/// return a custom `Mirror` instance.
public protocol CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// A type with a customized textual representation.
///
/// Types that conform to the `CustomStringConvertible` protocol can provide
/// their own representation to be used when converting an instance to a
/// string. The `String(describing:)` initializer is the preferred way to
/// convert an instance of *any* type to a string. If the passed instance
/// conforms to `CustomStringConvertible`, the `String(describing:)`
/// initializer and the `print(_:)` function use the instance's custom
/// `description` property.
///
/// Accessing a type's `description` property directly or using
/// `CustomStringConvertible` as a generic constraint is discouraged.
///
/// Conforming to the CustomStringConvertible Protocol
/// ==================================================
///
/// Add `CustomStringConvertible` conformance to your custom types by defining
/// a `description` property.
///
/// For example, this custom `Point` struct uses the default representation
/// supplied by the standard library:
///
///     struct Point {
///         let x: Int, y: Int
///     }
///
///     let p = Point(x: 21, y: 30)
///     print(p)
///     // Prints "Point(x: 21, y: 30)"
///
/// After implementing the `description` property and declaring
/// `CustomStringConvertible` conformance, the `Point` type provides its own
/// custom representation.
///
///     extension Point: CustomStringConvertible {
///         var description: String {
///             return "(\(x), \(y))"
///         }
///     }
///
///     print(p)
///     // Prints "(21, 30)"
public protocol CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

/// A type that can decode itself from an external representation.
public protocol Decodable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws
}

/// A type that can decode values from a native format into in-memory
/// representations.
public protocol Decoder {

    /// The path of coding keys taken to get to this point in decoding.
    public var codingPath: [CodingKey] { get }

    /// Any contextual information set by the user for decoding.
    public var userInfo: [CodingUserInfoKey : Any] { get }

    /// Returns the data stored in this decoder as represented in a container
    /// keyed by the given key type.
    ///
    /// - parameter type: The key type to use for the container.
    /// - returns: A keyed decoding container view into this decoder.
    /// - throws: `DecodingError.typeMismatch` if the encountered stored value is
    ///   not a keyed container.
    public func container<Key>(keyedBy type: Key.Type) throws -> KeyedDecodingContainer<Key> where Key : CodingKey

    /// Returns the data stored in this decoder as represented in a container
    /// appropriate for holding values with no keys.
    ///
    /// - returns: An unkeyed container view into this decoder.
    /// - throws: `DecodingError.typeMismatch` if the encountered stored value is
    ///   not an unkeyed container.
    public func unkeyedContainer() throws -> UnkeyedDecodingContainer

    /// Returns the data stored in this decoder as represented in a container
    /// appropriate for holding a single primitive value.
    ///
    /// - returns: A single value container view into this decoder.
    /// - throws: `DecodingError.typeMismatch` if the encountered stored value is
    ///   not a single value container.
    public func singleValueContainer() throws -> SingleValueDecodingContainer
}

/// An error that occurs during the decoding of a value.
public enum DecodingError : Error {

    /// The context in which the error occurred.
    public struct Context {

        /// The path of coding keys taken to get to the point of the failing decode
        /// call.
        public let codingPath: [CodingKey]

        /// A description of what went wrong, for debugging purposes.
        public let debugDescription: String

        /// The underlying error which caused this error, if any.
        public let underlyingError: Error?

        /// Creates a new context with the given path of coding keys and a
        /// description of what went wrong.
        ///
        /// - parameter codingPath: The path of coding keys taken to get to the
        ///   point of the failing decode call.
        /// - parameter debugDescription: A description of what went wrong, for
        ///   debugging purposes.
        /// - parameter underlyingError: The underlying error which caused this
        ///   error, if any.
        public init(codingPath: [CodingKey], debugDescription: String, underlyingError: Error? = default)
    }

    /// An indication that a value of the given type could not be decoded because
    /// it did not match the type of what was found in the encoded payload.
    ///
    /// As associated values, this case contains the attempted type and context
    /// for debugging.
    case typeMismatch(Any.Type, DecodingError.Context)

    /// An indication that a non-optional value of the given type was expected,
    /// but a null value was found.
    ///
    /// As associated values, this case contains the attempted type and context
    /// for debugging.
    case valueNotFound(Any.Type, DecodingError.Context)

    ///  An indication that a keyed decoding container was asked for an entry for
    ///  the given key, but did not contain one.
    ///
    /// As associated values, this case contains the attempted key and context
    /// for debugging.
    case keyNotFound(CodingKey, DecodingError.Context)

    /// An indication that the data is corrupted or otherwise invalid.
    ///
    /// As an associated value, this case contains the context for debugging.
    case dataCorrupted(DecodingError.Context)
}

extension DecodingError {

    /// Returns a new `.dataCorrupted` error using a constructed coding path and
    /// the given debug description.
    ///
    /// The coding path for the returned error is constructed by appending the
    /// given key to the given container's coding path.
    ///
    /// - param key: The key which caused the failure.
    /// - param container: The container in which the corrupted data was
    ///   accessed.
    /// - param debugDescription: A description of the error to aid in debugging.
    ///
    /// - Returns: A new `.dataCorrupted` error with the given information.
    public static func dataCorruptedError<C>(forKey key: C.Key, in container: C, debugDescription: String) -> DecodingError where C : KeyedDecodingContainerProtocol

    /// Returns a new `.dataCorrupted` error using a constructed coding path and
    /// the given debug description.
    ///
    /// The coding path for the returned error is constructed by appending the
    /// given container's current index to its coding path.
    ///
    /// - param container: The container in which the corrupted data was
    ///   accessed.
    /// - param debugDescription: A description of the error to aid in debugging.
    ///
    /// - Returns: A new `.dataCorrupted` error with the given information.
    public static func dataCorruptedError(in container: UnkeyedDecodingContainer, debugDescription: String) -> DecodingError

    /// Returns a new `.dataCorrupted` error using a constructed coding path and
    /// the given debug description.
    ///
    /// The coding path for the returned error is the given container's coding
    /// path.
    ///
    /// - param container: The container in which the corrupted data was
    ///   accessed.
    /// - param debugDescription: A description of the error to aid in debugging.
    ///
    /// - Returns: A new `.dataCorrupted` error with the given information.
    public static func dataCorruptedError(in container: SingleValueDecodingContainer, debugDescription: String) -> DecodingError
}

@available(*, deprecated, renamed: "DefaultIndices")
public typealias DefaultBidirectionalIndices<T> = DefaultIndices<T>

/// A collection of indices for an arbitrary collection
public struct DefaultIndices<Elements> where Elements : Collection {
}

extension DefaultIndices : Collection where Elements : Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Elements.Index

    /// A type representing the sequence's elements.
    public typealias Element = Elements.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultIndices<Elements>

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = DefaultIndices<Elements>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<DefaultIndices<Elements>>

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Elements.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Elements.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(i: DefaultIndices<Elements>.Index) -> Elements.Index { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<DefaultIndices<Elements>.Index>) -> DefaultIndices<Elements> { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: DefaultIndices<Elements>.Index) -> DefaultIndices<Elements>.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout DefaultIndices<Elements>.Index)

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: DefaultIndices<Elements> { get }
}

extension DefaultIndices : BidirectionalCollection where Elements : BidirectionalCollection {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: DefaultIndices<Elements>.Index) -> DefaultIndices<Elements>.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout DefaultIndices<Elements>.Index)
}

extension DefaultIndices : RandomAccessCollection where Elements : RandomAccessCollection {
}

@available(*, deprecated, renamed: "DefaultIndices")
public typealias DefaultRandomAccessIndices<T> = DefaultIndices<T>

/// A collection whose elements are key-value pairs.
///
/// A dictionary is a type of hash table, providing fast access to the entries
/// it contains. Each entry in the table is identified using its key, which is
/// a hashable type such as a string or number. You use that key to retrieve
/// the corresponding value, which can be any object. In other languages,
/// similar data types are known as hashes or associated arrays.
///
/// Create a new dictionary by using a dictionary literal. A dictionary literal
/// is a comma-separated list of key-value pairs, in which a colon separates
/// each key from its associated value, surrounded by square brackets. You can
/// assign a dictionary literal to a variable or constant or pass it to a
/// function that expects a dictionary.
///
/// Here's how you would create a dictionary of HTTP response codes and their
/// related messages:
///
///     var responseMessages = [200: "OK",
///                             403: "Access forbidden",
///                             404: "File not found",
///                             500: "Internal server error"]
///
/// The `responseMessages` variable is inferred to have type `[Int: String]`.
/// The `Key` type of the dictionary is `Int`, and the `Value` type of the
/// dictionary is `String`.
///
/// To create a dictionary with no key-value pairs, use an empty dictionary
/// literal (`[:]`).
///
///     var emptyDict: [String: String] = [:]
///
/// Any type that conforms to the `Hashable` protocol can be used as a
/// dictionary's `Key` type, including all of Swift's basic types. You can use
/// your own custom types as dictionary keys by making them conform to the
/// `Hashable` protocol.
///
/// Getting and Setting Dictionary Values
/// =====================================
///
/// The most common way to access values in a dictionary is to use a key as a
/// subscript. Subscripting with a key takes the following form:
///
///     print(responseMessages[200])
///     // Prints "Optional("OK")"
///
/// Subscripting a dictionary with a key returns an optional value, because a
/// dictionary might not hold a value for the key that you use in the
/// subscript.
///
/// The next example uses key-based subscripting of the `responseMessages`
/// dictionary with two keys that exist in the dictionary and one that does
/// not.
///
///     let httpResponseCodes = [200, 403, 301]
///     for code in httpResponseCodes {
///         if let message = responseMessages[code] {
///             print("Response \(code): \(message)")
///         } else {
///             print("Unknown response \(code)")
///         }
///     }
///     // Prints "Response 200: OK"
///     // Prints "Response 403: Access Forbidden"
///     // Prints "Unknown response 301"
///
/// You can also update, modify, or remove keys and values from a dictionary
/// using the key-based subscript. To add a new key-value pair, assign a value
/// to a key that isn't yet a part of the dictionary.
///
///     responseMessages[301] = "Moved permanently"
///     print(responseMessages[301])
///     // Prints "Optional("Moved permanently")"
///
/// Update an existing value by assigning a new value to a key that already
/// exists in the dictionary. If you assign `nil` to an existing key, the key
/// and its associated value are removed. The following example updates the
/// value for the `404` code to be simply "Not found" and removes the
/// key-value pair for the `500` code entirely.
///
///     responseMessages[404] = "Not found"
///     responseMessages[500] = nil
///     print(responseMessages)
///     // Prints "[301: "Moved permanently", 200: "OK", 403: "Access forbidden", 404: "Not found"]"
///
/// In a mutable `Dictionary` instance, you can modify in place a value that
/// you've accessed through a keyed subscript. The code sample below declares a
/// dictionary called `interestingNumbers` with string keys and values that
/// are integer arrays, then sorts each array in-place in descending order.
///
///     var interestingNumbers = ["primes": [2, 3, 5, 7, 11, 13, 15],
///                               "triangular": [1, 3, 6, 10, 15, 21, 28],
///                               "hexagonal": [1, 6, 15, 28, 45, 66, 91]]
///     for key in interestingNumbers.keys {
///         interestingNumbers[key]?.sort(by: >)
///     }
///
///     print(interestingNumbers["primes"]!)
///     // Prints "[15, 13, 11, 7, 5, 3, 2]"
///
/// Iterating Over the Contents of a Dictionary
/// ===========================================
///
/// Every dictionary is an unordered collection of key-value pairs. You can
/// iterate over a dictionary using a `for`-`in` loop, decomposing each
/// key-value pair into the elements of a tuple.
///
///     let imagePaths = ["star": "/glyphs/star.png",
///                       "portrait": "/images/content/portrait.jpg",
///                       "spacer": "/images/shared/spacer.gif"]
///
///     for (name, path) in imagePaths {
///         print("The path to '\(name)' is '\(path)'.")
///     }
///     // Prints "The path to 'star' is '/glyphs/star.png'."
///     // Prints "The path to 'portrait' is '/images/content/portrait.jpg'."
///     // Prints "The path to 'spacer' is '/images/shared/spacer.gif'."
///
/// The order of key-value pairs in a dictionary is stable between mutations
/// but is otherwise unpredictable. If you need an ordered collection of
/// key-value pairs and don't need the fast key lookup that `Dictionary`
/// provides, see the `DictionaryLiteral` type for an alternative.
///
/// You can search a dictionary's contents for a particular value using the
/// `contains(where:)` or `firstIndex(where:)` methods supplied by default
/// implementation. The following example checks to see if `imagePaths` contains
/// any paths in the `"/glyphs"` directory:
///
///     let glyphIndex = imagePaths.firstIndex(where: { $0.value.hasPrefix("/glyphs") })
///     if let index = glyphIndex {
///         print("The '\(imagesPaths[index].key)' image is a glyph.")
///     } else {
///         print("No glyphs found!")
///     }
///     // Prints "The 'star' image is a glyph.")
///
/// Note that in this example, `imagePaths` is subscripted using a dictionary
/// index. Unlike the key-based subscript, the index-based subscript returns
/// the corresponding key-value pair as a non-optional tuple.
///
///     print(imagePaths[glyphIndex!])
///     // Prints "("star", "/glyphs/star.png")"
///
/// A dictionary's indices stay valid across additions to the dictionary as
/// long as the dictionary has enough capacity to store the added values
/// without allocating more buffer. When a dictionary outgrows its buffer,
/// existing indices may be invalidated without any notification.
///
/// When you know how many new values you're adding to a dictionary, use the
/// `init(minimumCapacity:)` initializer to allocate the correct amount of
/// buffer.
///
/// Bridging Between Dictionary and NSDictionary
/// ============================================
///
/// You can bridge between `Dictionary` and `NSDictionary` using the `as`
/// operator. For bridging to be possible, the `Key` and `Value` types of a
/// dictionary must be classes, `@objc` protocols, or types that bridge to
/// Foundation types.
///
/// Bridging from `Dictionary` to `NSDictionary` always takes O(1) time and
/// space. When the dictionary's `Key` and `Value` types are neither classes
/// nor `@objc` protocols, any required bridging of elements occurs at the
/// first access of each element. For this reason, the first operation that
/// uses the contents of the dictionary may take O(*n*).
///
/// Bridging from `NSDictionary` to `Dictionary` first calls the `copy(with:)`
/// method (`- copyWithZone:` in Objective-C) on the dictionary to get an
/// immutable copy and then performs additional Swift bookkeeping work that
/// takes O(1) time. For instances of `NSDictionary` that are already
/// immutable, `copy(with:)` usually returns the same dictionary in O(1) time;
/// otherwise, the copying performance is unspecified. The instances of
/// `NSDictionary` and `Dictionary` share buffer using the same copy-on-write
/// optimization that is used when two instances of `Dictionary` share
/// buffer.
public struct Dictionary<Key, Value> where Key : Hashable {

    /// The element type of a dictionary: a tuple containing an individual
    /// key-value pair.
    public typealias Element = (key: Key, value: Value)

    /// Creates an empty dictionary.
    public init()

    public init(minimumCapacity: Int)

    /// Creates a new dictionary from the key-value pairs in the given sequence.
    ///
    /// You use this initializer to create a dictionary when you have a sequence
    /// of key-value tuples with unique keys. Passing a sequence with duplicate
    /// keys to this initializer results in a runtime error. If your
    /// sequence might have duplicate keys, use the
    /// `Dictionary(_:uniquingKeysWith:)` initializer instead.
    ///
    /// The following example creates a new dictionary using an array of strings
    /// as the keys and the integers in a countable range as the values:
    ///
    ///     let digitWords = ["one", "two", "three", "four", "five"]
    ///     let wordToValue = Dictionary(uniqueKeysWithValues: zip(digitWords, 1...5))
    ///     print(wordToValue["three"]!)
    ///     // Prints "3"
    ///     print(wordToValue)
    ///     // Prints "["three": 3, "four": 4, "five": 5, "one": 1, "two": 2]"
    ///
    /// - Parameter keysAndValues: A sequence of key-value pairs to use for
    ///   the new dictionary. Every key in `keysAndValues` must be unique.
    /// - Returns: A new dictionary initialized with the elements of
    ///   `keysAndValues`.
    /// - Precondition: The sequence must not have duplicate keys.
    public init<S>(uniqueKeysWithValues keysAndValues: S) where S : Sequence, S.Element == (Key, Value)

    /// Creates a new dictionary from the key-value pairs in the given sequence,
    /// using a combining closure to determine the value for any duplicate keys.
    ///
    /// You use this initializer to create a dictionary when you have a sequence
    /// of key-value tuples that might have duplicate keys. As the dictionary is
    /// built, the initializer calls the `combine` closure with the current and
    /// new values for any duplicate keys. Pass a closure as `combine` that
    /// returns the value to use in the resulting dictionary: The closure can
    /// choose between the two values, combine them to produce a new value, or
    /// even throw an error.
    ///
    /// The following example shows how to choose the first and last values for
    /// any duplicate keys:
    ///
    ///     let pairsWithDuplicateKeys = [("a", 1), ("b", 2), ("a", 3), ("b", 4)]
    ///
    ///     let firstValues = Dictionary(pairsWithDuplicateKeys,
    ///                                  uniquingKeysWith: { (first, _) in first })
    ///     // ["b": 2, "a": 1]
    ///
    ///     let lastValues = Dictionary(pairsWithDuplicateKeys,
    ///                                 uniquingKeysWith: { (_, last) in last })
    ///     // ["b": 4, "a": 3]
    ///
    /// - Parameters:
    ///   - keysAndValues: A sequence of key-value pairs to use for the new
    ///     dictionary.
    ///   - combine: A closure that is called with the values for any duplicate
    ///     keys that are encountered. The closure returns the desired value for
    ///     the final dictionary.
    public init<S>(_ keysAndValues: S, uniquingKeysWith combine: ([Key : Value].Value, [Key : Value].Value) throws -> [Key : Value].Value) rethrows where S : Sequence, S.Element == (Key, Value)

    /// Creates a new dictionary whose keys are the groupings returned by the
    /// given closure and whose values are arrays of the elements that returned
    /// each key.
    ///
    /// The arrays in the "values" position of the new dictionary each contain at
    /// least one element, with the elements in the same order as the source
    /// sequence.
    ///
    /// The following example declares an array of names, and then creates a
    /// dictionary from that array by grouping the names by first letter:
    ///
    ///     let students = ["Kofi", "Abena", "Efua", "Kweku", "Akosua"]
    ///     let studentsByLetter = Dictionary(grouping: students, by: { $0.first! })
    ///     // ["E": ["Efua"], "K": ["Kofi", "Kweku"], "A": ["Abena", "Akosua"]]
    ///
    /// The new `studentsByLetter` dictionary has three entries, with students'
    /// names grouped by the keys `"E"`, `"K"`, and `"A"`.
    ///
    /// - Parameters:
    ///   - values: A sequence of values to group into a dictionary.
    ///   - keyForValue: A closure that returns a key for each element in
    ///     `values`.
    public init<S>(grouping values: S, by keyForValue: (S.Element) throws -> [Key : Value].Key) rethrows where Value == [S.Element], S : Sequence
}

extension Dictionary where Key : Hashable {

    /// The position of a key-value pair in a dictionary.
    ///
    /// Dictionary has two subscripting interfaces:
    ///
    /// 1. Subscripting with a key, yielding an optional value:
    ///
    ///        v = d[k]!
    ///
    /// 2. Subscripting with an index, yielding a key-value pair:
    ///
    ///        (k, v) = d[i]
    public struct Index : Comparable, Hashable {
    }
}

extension Dictionary : Encodable where Key : Encodable, Key : Hashable, Value : Encodable {

    /// Encodes the contents of this dictionary into the given encoder.
    ///
    /// If the dictionary uses `String` or `Int` keys, the contents are encoded
    /// in a keyed container. Otherwise, the contents are encoded as alternating
    /// key-value pairs in an unkeyed container.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Dictionary : Decodable where Key : Decodable, Key : Hashable, Value : Decodable {

    /// Creates a new dictionary by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws
}

extension Dictionary : Sequence where Key : Hashable {

    /// Returns an iterator over the dictionary's key-value pairs.
    ///
    /// Iterating over a dictionary yields the key-value pairs as two-element
    /// tuples. You can decompose the tuple in a `for`-`in` loop, which calls
    /// `makeIterator()` behind the scenes, or when calling the iterator's
    /// `next()` method directly.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     for (name, hueValue) in hues {
    ///         print("The hue of \(name) is \(hueValue).")
    ///     }
    ///     // Prints "The hue of Heliotrope is 296."
    ///     // Prints "The hue of Coral is 16."
    ///     // Prints "The hue of Aquamarine is 156."
    ///
    /// - Returns: An iterator over the dictionary with elements of type
    ///   `(key: Key, value: Value)`.
    public func makeIterator() -> DictionaryIterator<[Key : Value].Key, [Key : Value].Value>
}

extension Dictionary where Key : Hashable {

    /// Returns a new dictionary containing the key-value pairs of the dictionary
    /// that satisfy the given predicate.
    ///
    /// - Parameter isIncluded: A closure that takes a key-value pair as its
    ///   argument and returns a Boolean value indicating whether the pair
    ///   should be included in the returned dictionary.
    /// - Returns: A dictionary of the key-value pairs that `isIncluded` allows.
    @available(swift 4.0)
    public func filter(_ isIncluded: ([Key : Value].Element) throws -> Bool) rethrows -> [[Key : Value].Key : [Key : Value].Value]
}

extension Dictionary : Collection where Key : Hashable {

    /// The position of the first element in a nonempty dictionary.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    ///
    /// - Complexity: Amortized O(1) if the dictionary does not wrap a bridged
    ///   `NSDictionary`. If the dictionary wraps a bridged `NSDictionary`, the
    ///   performance is unspecified.
    public var startIndex: Dictionary<Key, Value>.Index { get }

    /// The dictionary's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    ///
    /// - Complexity: Amortized O(1) if the dictionary does not wrap a bridged
    ///   `NSDictionary`; otherwise, the performance is unspecified.
    public var endIndex: Dictionary<Key, Value>.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Index

    /// Returns the index for the given key.
    ///
    /// If the given key is found in the dictionary, this method returns an index
    /// into the dictionary that corresponds with the key-value pair.
    ///
    ///     let countryCodes = ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"]
    ///     let index = countryCodes.index(forKey: "JP")
    ///
    ///     print("Country code for \(countryCodes[index!].value): '\(countryCodes[index!].key)'.")
    ///     // Prints "Country code for Japan: 'JP'."
    ///
    /// - Parameter key: The key to find in the dictionary.
    /// - Returns: The index for `key` and its associated value if `key` is in
    ///   the dictionary; otherwise, `nil`.
    public func index(forKey key: [Key : Value].Key) -> Dictionary<Key, Value>.Index?

    /// Accesses the key-value pair at the specified position.
    ///
    /// This subscript takes an index into the dictionary, instead of a key, and
    /// returns the corresponding key-value pair as a tuple. When performing
    /// collection-based operations that return an index into a dictionary, use
    /// this subscript with the resulting value.
    ///
    /// For example, to find the key for a particular value in a dictionary, use
    /// the `firstIndex(where:)` method.
    ///
    ///     let countryCodes = ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"]
    ///     if let index = countryCodes.firstIndex(where: { $0.value == "Japan" }) {
    ///         print(countryCodes[index])
    ///         print("Japan's country code is '\(countryCodes[index].key)'.")
    ///     } else {
    ///         print("Didn't find 'Japan' as a value in the dictionary.")
    ///     }
    ///     // Prints "("JP", "Japan")"
    ///     // Prints "Japan's country code is 'JP'."
    ///
    /// - Parameter position: The position of the key-value pair to access.
    ///   `position` must be a valid index of the dictionary and not equal to
    ///   `endIndex`.
    /// - Returns: A two-element tuple with the key and value corresponding to
    ///   `position`.
    public subscript(position: Dictionary<Key, Value>.Index) -> [Key : Value].Element { get }

    /// The number of key-value pairs in the dictionary.
    ///
    /// - Complexity: O(1).
    public var count: Int { get }

    /// A Boolean value that indicates whether the dictionary is empty.
    ///
    /// Dictionaries are empty when created with an initializer or an empty
    /// dictionary literal.
    ///
    ///     var frequencies: [String: Int] = [:]
    ///     print(frequencies.isEmpty)
    ///     // Prints "true"
    public var isEmpty: Bool { get }
}

extension Dictionary where Key : Hashable {

    /// Accesses the value associated with the given key for reading and writing.
    ///
    /// This *key-based* subscript returns the value for the given key if the key
    /// is found in the dictionary, or `nil` if the key is not found.
    ///
    /// The following example creates a new dictionary and prints the value of a
    /// key found in the dictionary (`"Coral"`) and a key not found in the
    /// dictionary (`"Cerise"`).
    ///
    ///     var hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     print(hues["Coral"])
    ///     // Prints "Optional(16)"
    ///     print(hues["Cerise"])
    ///     // Prints "nil"
    ///
    /// When you assign a value for a key and that key already exists, the
    /// dictionary overwrites the existing value. If the dictionary doesn't
    /// contain the key, the key and value are added as a new key-value pair.
    ///
    /// Here, the value for the key `"Coral"` is updated from `16` to `18` and a
    /// new key-value pair is added for the key `"Cerise"`.
    ///
    ///     hues["Coral"] = 18
    ///     print(hues["Coral"])
    ///     // Prints "Optional(18)"
    ///
    ///     hues["Cerise"] = 330
    ///     print(hues["Cerise"])
    ///     // Prints "Optional(330)"
    ///
    /// If you assign `nil` as the value for the given key, the dictionary
    /// removes that key and its associated value.
    ///
    /// In the following example, the key-value pair for the key `"Aquamarine"`
    /// is removed from the dictionary by assigning `nil` to the key-based
    /// subscript.
    ///
    ///     hues["Aquamarine"] = nil
    ///     print(hues)
    ///     // Prints "["Coral": 18, "Heliotrope": 296, "Cerise": 330]"
    ///
    /// - Parameter key: The key to find in the dictionary.
    /// - Returns: The value associated with `key` if `key` is in the dictionary;
    ///   otherwise, `nil`.
    public subscript(key: [Key : Value].Key) -> [Key : Value].Value?
}

extension Dictionary : ExpressibleByDictionaryLiteral where Key : Hashable {

    /// Creates a dictionary initialized with a dictionary literal.
    ///
    /// Do not call this initializer directly. It is called by the compiler to
    /// handle dictionary literals. To use a dictionary literal as the initial
    /// value of a dictionary, enclose a comma-separated list of key-value pairs
    /// in square brackets.
    ///
    /// For example, the code sample below creates a dictionary with string keys
    /// and values.
    ///
    ///     let countryCodes = ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"]
    ///     print(countryCodes)
    ///     // Prints "["BR": "Brazil", "JP": "Japan", "GH": "Ghana"]"
    ///
    /// - Parameter elements: The key-value pairs that will make up the new
    ///   dictionary. Each key in `elements` must be unique.
    public init(dictionaryLiteral elements: (Key, Value)...)
}

extension Dictionary where Key : Hashable {

    /// Accesses the element with the given key, or the specified default value,
    /// if the dictionary doesn't contain the given key.
    public subscript(key: [Key : Value].Key, default defaultValue: @autoclosure () -> [Key : Value].Value) -> [Key : Value].Value

    /// Returns a new dictionary containing the keys of this dictionary with the
    /// values transformed by the given closure.
    ///
    /// - Parameter transform: A closure that transforms a value. `transform`
    ///   accepts each value of the dictionary as its parameter and returns a
    ///   transformed value of the same or of a different type.
    /// - Returns: A dictionary containing the keys and transformed values of
    ///   this dictionary.
    public func mapValues<T>(_ transform: ([Key : Value].Value) throws -> T) rethrows -> [[Key : Value].Key : T]

    /// Updates the value stored in the dictionary for the given key, or adds a
    /// new key-value pair if the key does not exist.
    ///
    /// Use this method instead of key-based subscripting when you need to know
    /// whether the new value supplants the value of an existing key. If the
    /// value of an existing key is updated, `updateValue(_:forKey:)` returns
    /// the original value.
    ///
    ///     var hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///
    ///     if let oldValue = hues.updateValue(18, forKey: "Coral") {
    ///         print("The old value of \(oldValue) was replaced with a new one.")
    ///     }
    ///     // Prints "The old value of 16 was replaced with a new one."
    ///
    /// If the given key is not present in the dictionary, this method adds the
    /// key-value pair and returns `nil`.
    ///
    ///     if let oldValue = hues.updateValue(330, forKey: "Cerise") {
    ///         print("The old value of \(oldValue) was replaced with a new one.")
    ///     } else {
    ///         print("No value was found in the dictionary for that key.")
    ///     }
    ///     // Prints "No value was found in the dictionary for that key."
    ///
    /// - Parameters:
    ///   - value: The new value to add to the dictionary.
    ///   - key: The key to associate with `value`. If `key` already exists in
    ///     the dictionary, `value` replaces the existing associated value. If
    ///     `key` isn't already a key of the dictionary, the `(key, value)` pair
    ///     is added.
    /// - Returns: The value that was replaced, or `nil` if a new key-value pair
    ///   was added.
    public mutating func updateValue(_ value: [Key : Value].Value, forKey key: [Key : Value].Key) -> [Key : Value].Value?

    /// Merges the key-value pairs in the given sequence into the dictionary,
    /// using a combining closure to determine the value for any duplicate keys.
    ///
    /// Use the `combine` closure to select a value to use in the updated
    /// dictionary, or to combine existing and new values. As the key-value
    /// pairs are merged with the dictionary, the `combine` closure is called
    /// with the current and new values for any duplicate keys that are
    /// encountered.
    ///
    /// This example shows how to choose the current or new values for any
    /// duplicate keys:
    ///
    ///     var dictionary = ["a": 1, "b": 2]
    ///
    ///     // Keeping existing value for key "a":
    ///     dictionary.merge(zip(["a", "c"], [3, 4])) { (current, _) in current }
    ///     // ["b": 2, "a": 1, "c": 4]
    ///
    ///     // Taking the new value for key "a":
    ///     dictionary.merge(zip(["a", "d"], [5, 6])) { (_, new) in new }
    ///     // ["b": 2, "a": 5, "c": 4, "d": 6]
    ///
    /// - Parameters:
    ///   - other:  A sequence of key-value pairs.
    ///   - combine: A closure that takes the current and new values for any
    ///     duplicate keys. The closure returns the desired value for the final
    ///     dictionary.
    public mutating func merge<S>(_ other: S, uniquingKeysWith combine: ([Key : Value].Value, [Key : Value].Value) throws -> [Key : Value].Value) rethrows where S : Sequence, S.Element == (Key, Value)

    /// Merges the given dictionary into this dictionary, using a combining
    /// closure to determine the value for any duplicate keys.
    ///
    /// Use the `combine` closure to select a value to use in the updated
    /// dictionary, or to combine existing and new values. As the key-values
    /// pairs in `other` are merged with this dictionary, the `combine` closure
    /// is called with the current and new values for any duplicate keys that
    /// are encountered.
    ///
    /// This example shows how to choose the current or new values for any
    /// duplicate keys:
    ///
    ///     var dictionary = ["a": 1, "b": 2]
    ///
    ///     // Keeping existing value for key "a":
    ///     dictionary.merge(["a": 3, "c": 4]) { (current, _) in current }
    ///     // ["b": 2, "a": 1, "c": 4]
    ///
    ///     // Taking the new value for key "a":
    ///     dictionary.merge(["a": 5, "d": 6]) { (_, new) in new }
    ///     // ["b": 2, "a": 5, "c": 4, "d": 6]
    ///
    /// - Parameters:
    ///   - other:  A dictionary to merge.
    ///   - combine: A closure that takes the current and new values for any
    ///     duplicate keys. The closure returns the desired value for the final
    ///     dictionary.
    public mutating func merge(_ other: [[Key : Value].Key : [Key : Value].Value], uniquingKeysWith combine: ([Key : Value].Value, [Key : Value].Value) throws -> [Key : Value].Value) rethrows

    /// Creates a dictionary by merging key-value pairs in a sequence into the
    /// dictionary, using a combining closure to determine the value for
    /// duplicate keys.
    ///
    /// Use the `combine` closure to select a value to use in the returned
    /// dictionary, or to combine existing and new values. As the key-value
    /// pairs are merged with the dictionary, the `combine` closure is called
    /// with the current and new values for any duplicate keys that are
    /// encountered.
    ///
    /// This example shows how to choose the current or new values for any
    /// duplicate keys:
    ///
    ///     let dictionary = ["a": 1, "b": 2]
    ///     let newKeyValues = zip(["a", "b"], [3, 4])
    ///
    ///     let keepingCurrent = dictionary.merging(newKeyValues) { (current, _) in current }
    ///     // ["b": 2, "a": 1]
    ///     let replacingCurrent = dictionary.merging(newKeyValues) { (_, new) in new }
    ///     // ["b": 4, "a": 3]
    ///
    /// - Parameters:
    ///   - other:  A sequence of key-value pairs.
    ///   - combine: A closure that takes the current and new values for any
    ///     duplicate keys. The closure returns the desired value for the final
    ///     dictionary.
    /// - Returns: A new dictionary with the combined keys and values of this
    ///   dictionary and `other`.
    public func merging<S>(_ other: S, uniquingKeysWith combine: ([Key : Value].Value, [Key : Value].Value) throws -> [Key : Value].Value) rethrows -> [[Key : Value].Key : [Key : Value].Value] where S : Sequence, S.Element == (Key, Value)

    /// Creates a dictionary by merging the given dictionary into this
    /// dictionary, using a combining closure to determine the value for
    /// duplicate keys.
    ///
    /// Use the `combine` closure to select a value to use in the returned
    /// dictionary, or to combine existing and new values. As the key-value
    /// pairs in `other` are merged with this dictionary, the `combine` closure
    /// is called with the current and new values for any duplicate keys that
    /// are encountered.
    ///
    /// This example shows how to choose the current or new values for any
    /// duplicate keys:
    ///
    ///     let dictionary = ["a": 1, "b": 2]
    ///     let otherDictionary = ["a": 3, "b": 4]
    ///
    ///     let keepingCurrent = dictionary.merging(otherDictionary)
    ///           { (current, _) in current }
    ///     // ["b": 2, "a": 1]
    ///     let replacingCurrent = dictionary.merging(otherDictionary)
    ///           { (_, new) in new }
    ///     // ["b": 4, "a": 3]
    ///
    /// - Parameters:
    ///   - other:  A dictionary to merge.
    ///   - combine: A closure that takes the current and new values for any
    ///     duplicate keys. The closure returns the desired value for the final
    ///     dictionary.
    /// - Returns: A new dictionary with the combined keys and values of this
    ///   dictionary and `other`.
    public func merging(_ other: [[Key : Value].Key : [Key : Value].Value], uniquingKeysWith combine: ([Key : Value].Value, [Key : Value].Value) throws -> [Key : Value].Value) rethrows -> [[Key : Value].Key : [Key : Value].Value]

    /// Removes and returns the key-value pair at the specified index.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// dictionary.
    ///
    /// - Parameter index: The position of the key-value pair to remove. `index`
    ///   must be a valid index of the dictionary, and must not equal the
    ///   dictionary's end index.
    /// - Returns: The key-value pair that correspond to `index`.
    ///
    /// - Complexity: O(*n*), where *n* is the number of key-value pairs in the
    ///   dictionary.
    public mutating func remove(at index: Dictionary<Key, Value>.Index) -> [Key : Value].Element

    /// Removes the given key and its associated value from the dictionary.
    ///
    /// If the key is found in the dictionary, this method returns the key's
    /// associated value. On removal, this method invalidates all indices with
    /// respect to the dictionary.
    ///
    ///     var hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     if let value = hues.removeValue(forKey: "Coral") {
    ///         print("The value \(value) was removed.")
    ///     }
    ///     // Prints "The value 16 was removed."
    ///
    /// If the key isn't found in the dictionary, `removeValue(forKey:)` returns
    /// `nil`.
    ///
    ///     if let value = hues.removeValueForKey("Cerise") {
    ///         print("The value \(value) was removed.")
    ///     } else {
    ///         print("No value found for that key.")
    ///     }
    ///     // Prints "No value found for that key.""
    ///
    /// - Parameter key: The key to remove along with its associated value.
    /// - Returns: The value that was removed, or `nil` if the key was not
    ///   present in the dictionary.
    ///
    /// - Complexity: O(*n*), where *n* is the number of key-value pairs in the
    ///   dictionary.
    public mutating func removeValue(forKey key: [Key : Value].Key) -> [Key : Value].Value?

    /// Removes all key-value pairs from the dictionary.
    ///
    /// Calling this method invalidates all indices with respect to the
    /// dictionary.
    ///
    /// - Parameter keepCapacity: Whether the dictionary should keep its
    ///   underlying buffer. If you pass `true`, the operation preserves the
    ///   buffer capacity that the collection has, otherwise the underlying
    ///   buffer is released.  The default is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the number of key-value pairs in the
    ///   dictionary.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)
}

extension Dictionary where Key : Hashable {
}

extension Dictionary where Key : Hashable {

    /// A collection containing just the keys of the dictionary.
    ///
    /// When iterated over, keys appear in this collection in the same order as
    /// they occur in the dictionary's key-value pairs. Each key in the keys
    /// collection has a unique value.
    ///
    ///     let countryCodes = ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"]
    ///     print(countryCodes)
    ///     // Prints "["BR": "Brazil", "JP": "Japan", "GH": "Ghana"]"
    ///
    ///     for k in countryCodes.keys {
    ///         print(k)
    ///     }
    ///     // Prints "BR"
    ///     // Prints "JP"
    ///     // Prints "GH"
    @available(swift 4.0)
    public var keys: Dictionary<Key, Value>.Keys { get }

    /// A collection containing just the values of the dictionary.
    ///
    /// When iterated over, values appear in this collection in the same order as
    /// they occur in the dictionary's key-value pairs.
    ///
    ///     let countryCodes = ["BR": "Brazil", "GH": "Ghana", "JP": "Japan"]
    ///     print(countryCodes)
    ///     // Prints "["BR": "Brazil", "JP": "Japan", "GH": "Ghana"]"
    ///
    ///     for v in countryCodes.values {
    ///         print(v)
    ///     }
    ///     // Prints "Brazil"
    ///     // Prints "Japan"
    ///     // Prints "Ghana"
    @available(swift 4.0)
    public var values: Dictionary<Key, Value>.Values

    /// A view of a dictionary's keys.
    public struct Keys : Collection, Equatable, CustomStringConvertible, CustomDebugStringConvertible {

        /// A type representing the sequence's elements.
        public typealias Element = Key

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Dictionary<Key, Value>.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Dictionary<Key, Value>.Index { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Index

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Keys.Element { get }

        /// The number of keys in the dictionary.
        ///
        /// - Complexity: O(1).
        public var count: Int { get }

        /// A Boolean value indicating whether the collection is empty.
        ///
        /// When you need to check whether your collection is empty, use the
        /// `isEmpty` property instead of checking that the `count` property is
        /// equal to zero. For collections that don't conform to
        /// `RandomAccessCollection`, accessing the `count` property iterates
        /// through the elements of the collection.
        ///
        ///     let horseName = "Silver"
        ///     if horseName.isEmpty {
        ///         print("I've been through the desert on a horse with no name.")
        ///     } else {
        ///         print("Hi ho, \(horseName)!")
        ///     }
        ///     // Prints "Hi ho, Silver!"
        ///
        /// - Complexity: O(1)
        public var isEmpty: Bool { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Dictionary<Key, Value>.Keys, rhs: Dictionary<Key, Value>.Keys) -> Bool

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        public var debugDescription: String { get }
    }

    /// A view of a dictionary's values.
    public struct Values : MutableCollection, CustomStringConvertible, CustomDebugStringConvertible {

        /// A type representing the sequence's elements.
        public typealias Element = Value

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Dictionary<Key, Value>.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Dictionary<Key, Value>.Index { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Index

        /// Accesses the element at the specified position.
        ///
        /// For example, you can replace an element of an array by using its
        /// subscript.
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     streets[1] = "Butler"
        ///     print(streets[1])
        ///     // Prints "Butler"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one
        /// past the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        public subscript(position: Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Values.Element

        /// The number of values in the dictionary.
        ///
        /// - Complexity: O(1).
        public var count: Int { get }

        /// A Boolean value indicating whether the collection is empty.
        ///
        /// When you need to check whether your collection is empty, use the
        /// `isEmpty` property instead of checking that the `count` property is
        /// equal to zero. For collections that don't conform to
        /// `RandomAccessCollection`, accessing the `count` property iterates
        /// through the elements of the collection.
        ///
        ///     let horseName = "Silver"
        ///     if horseName.isEmpty {
        ///         print("I've been through the desert on a horse with no name.")
        ///     } else {
        ///         print("Hi ho, \(horseName)!")
        ///     }
        ///     // Prints "Hi ho, Silver!"
        ///
        /// - Complexity: O(1)
        public var isEmpty: Bool { get }

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        public var debugDescription: String { get }
    }
}

extension Dictionary : Equatable where Key : Hashable, Value : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: [Key : Value], rhs: [Key : Value]) -> Bool

    public static func != (lhs: [Key : Value], rhs: [Key : Value]) -> Bool
}

extension Dictionary : Hashable where Key : Hashable, Value : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Dictionary : CustomStringConvertible, CustomDebugStringConvertible where Key : Hashable {

    /// A string that represents the contents of the dictionary.
    public var description: String { get }

    /// A string that represents the contents of the dictionary, suitable for
    /// debugging.
    public var debugDescription: String { get }
}

extension Dictionary : CustomReflectable where Key : Hashable {

    /// A mirror that reflects the dictionary.
    public var customMirror: Mirror { get }
}

extension Dictionary where Key : Hashable {

    /// Removes and returns the first key-value pair of the dictionary if the
    /// dictionary isn't empty.
    ///
    /// The first element of the dictionary is not necessarily the first element
    /// added. Don't expect any particular ordering of key-value pairs.
    ///
    /// - Returns: The first key-value pair of the dictionary if the dictionary
    ///   is not empty; otherwise, `nil`.
    ///
    /// - Complexity: Averages to O(1) over many calls to `popFirst()`.
    public mutating func popFirst() -> [Key : Value].Element?

    /// The total number of key-value pairs that the dictionary can contain without
    /// allocating new storage.
    public var capacity: Int { get }

    /// Reserves enough space to store the specified number of key-value pairs.
    ///
    /// If you are adding a known number of key-value pairs to a dictionary, use this
    /// method to avoid multiple reallocations. This method ensures that the
    /// dictionary has unique, mutable, contiguous storage, with space allocated
    /// for at least the requested number of key-value pairs.
    ///
    /// Calling the `reserveCapacity(_:)` method on a dictionary with bridged
    /// storage triggers a copy to contiguous storage even if the existing
    /// storage has room to store `minimumCapacity` key-value pairs.
    ///
    /// - Parameter minimumCapacity: The requested number of key-value pairs to
    ///   store.
    public mutating func reserveCapacity(_ minimumCapacity: Int)
}

extension Dictionary.Index where Key : Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Dictionary<Key, Value>.Index, rhs: Dictionary<Key, Value>.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Dictionary<Key, Value>.Index, rhs: Dictionary<Key, Value>.Index) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }
}

public typealias DictionaryIndex<Key, Value> = Dictionary<Key, Value>.Index

/// An iterator over the members of a `Dictionary<Key, Value>`.
public struct DictionaryIterator<Key, Value> : IteratorProtocol where Key : Hashable {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    public mutating func next() -> (key: Key, value: Value)?
}

extension DictionaryIterator : CustomReflectable where Key : Hashable {

    /// A mirror that reflects the iterator.
    public var customMirror: Mirror { get }
}

/// A lightweight collection of key-value pairs.
///
/// Use a `DictionaryLiteral` instance when you need an ordered collection of
/// key-value pairs and don't require the fast key lookup that the
/// `Dictionary` type provides. Unlike key-value pairs in a true dictionary,
/// neither the key nor the value of a `DictionaryLiteral` instance must
/// conform to the `Hashable` protocol.
///
/// You initialize a `DictionaryLiteral` instance using a Swift dictionary
/// literal. Besides maintaining the order of the original dictionary literal,
/// `DictionaryLiteral` also allows duplicates keys. For example:
///
///     let recordTimes: DictionaryLiteral = ["Florence Griffith-Joyner": 10.49,
///                                           "Evelyn Ashford": 10.76,
///                                           "Evelyn Ashford": 10.79,
///                                           "Marlies Gohr": 10.81]
///     print(recordTimes.first!)
///     // Prints "("Florence Griffith-Joyner", 10.49)"
///
/// Some operations that are efficient on a dictionary are slower when using
/// `DictionaryLiteral`. In particular, to find the value matching a key, you
/// must search through every element of the collection. The call to
/// `firstIndex(where:)` in the following example must traverse the whole
/// collection to find the element that matches the predicate:
///
///     let runner = "Marlies Gohr"
///     if let index = recordTimes.firstIndex(where: { $0.0 == runner }) {
///         let time = recordTimes[index].1
///         print("\(runner) set a 100m record of \(time) seconds.")
///     } else {
///         print("\(runner) couldn't be found in the records.")
///     }
///     // Prints "Marlies Gohr set a 100m record of 10.81 seconds."
///
/// Dictionary Literals as Function Parameters
/// ------------------------------------------
///
/// When calling a function with a `DictionaryLiteral` parameter, you can pass
/// a Swift dictionary literal without causing a `Dictionary` to be created.
/// This capability can be especially important when the order of elements in
/// the literal is significant.
///
/// For example, you could create an `IntPairs` structure that holds a list of
/// two-integer tuples and use an initializer that accepts a
/// `DictionaryLiteral` instance.
///
///     struct IntPairs {
///         var elements: [(Int, Int)]
///
///         init(_ elements: DictionaryLiteral<Int, Int>) {
///             self.elements = Array(elements)
///         }
///     }
///
/// When you're ready to create a new `IntPairs` instance, use a dictionary
/// literal as the parameter to the `IntPairs` initializer. The
/// `DictionaryLiteral` instance preserves the order of the elements as
/// passed.
///
///     let pairs = IntPairs([1: 2, 1: 1, 3: 4, 2: 1])
///     print(pairs.elements)
///     // Prints "[(1, 2), (1, 1), (3, 4), (2, 1)]"
public struct DictionaryLiteral<Key, Value> : ExpressibleByDictionaryLiteral {

    /// Creates a new `DictionaryLiteral` instance from the given dictionary
    /// literal.
    ///
    /// The order of the key-value pairs is kept intact in the resulting
    /// `DictionaryLiteral` instance.
    public init(dictionaryLiteral elements: (Key, Value)...)
}

/// `Collection` conformance that allows `DictionaryLiteral` to
/// interoperate with the rest of the standard library.
extension DictionaryLiteral : RandomAccessCollection {

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// The position of the first element in a nonempty collection.
    ///
    /// If the `DictionaryLiteral` instance is empty, `startIndex` is equal to
    /// `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// If the `DictionaryLiteral` instance is empty, `endIndex` is equal to
    /// `startIndex`.
    public var endIndex: Int { get }

    /// The element type of a `DictionaryLiteral`: a tuple containing an
    /// individual key-value pair.
    public typealias Element = (key: Key, value: Value)

    /// Accesses the element at the specified position.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    /// - Returns: The key-value pair at position `position`.
    public subscript(position: Int) -> DictionaryLiteral<Key, Value>.Element { get }
}

@available(*, deprecated, renamed: "ExpressibleByDictionaryLiteral")
public typealias DictionaryLiteralConvertible = ExpressibleByDictionaryLiteral

/// A double-precision, floating-point value type.
public struct Double {

    /// Creates a value initialized to zero.
    public init()
}

extension Double : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Double : LosslessStringConvertible {

    /// Creates a new instance from the given string.
    ///
    /// The string passed as `text` can represent a real number in decimal or
    /// hexadecimal format or special floating-point values for infinity and NaN
    /// ("not a number").
    ///
    /// The given string may begin with a plus or minus sign character (`+` or
    /// `-`). The allowed formats for each of these representations is then as
    /// follows:
    ///
    /// - A *decimal value* contains the significand, a sequence of decimal
    ///   digits that may include a decimal point.
    ///
    ///       let c = Double("-1.0")
    ///       // c == -1.0
    ///
    ///       let d = Double("28.375")
    ///       // d == 28.375
    ///
    ///   A decimal value may also include an exponent following the significand,
    ///   indicating the power of 10 by which the significand should be
    ///   multiplied. If included, the exponent is separated by a single
    ///   character, `e` or `E`, and consists of an optional plus or minus sign
    ///   character and a sequence of decimal digits.
    ///
    ///       let e = Double("2837.5e-2")
    ///       // e == 28.375
    ///
    /// - A *hexadecimal value* contains the significand, either `0X` or `0x`,
    ///   followed by a sequence of hexadecimal digits. The significand may
    ///   include a decimal point.
    ///
    ///       let f = Double("0x1c.6")
    ///       // f == 28.375
    ///
    ///   A hexadecimal value may also include an exponent following the
    ///   significand, indicating the power of 2 by which the significand should
    ///   be multiplied. If included, the exponent is separated by a single
    ///   character, `p` or `P`, and consists of an optional plus or minus sign
    ///   character and a sequence of decimal digits.
    ///
    ///       let g = Double("0x1.c6p4")
    ///       // g == 28.375
    ///
    /// - A value of *infinity* contains one of the strings `"inf"` or
    ///   `"infinity"`, case insensitive.
    ///
    ///       let i = Double("inf")
    ///       // i == Double.infinity
    ///
    ///       let j = Double("-Infinity")
    ///       // j == -Double.infinity
    ///
    /// - A value of *NaN* contains the string `"nan"`, case insensitive.
    ///
    ///       let n = Double("-nan")
    ///       // n?.isNaN == true
    ///       // n?.sign == .minus
    ///
    ///   A NaN value may also include a payload in parentheses following the
    ///   `"nan"` keyword. The payload consists of a sequence of decimal digits,
    ///   or the characters `0X` or `0x` followed by a sequence of hexadecimal
    ///   digits. If the payload contains any other characters, it is ignored.
    ///   If the value of the payload is larger than can be stored as the
    ///   payload of a `Double.nan`, the least significant bits are used.
    ///
    ///       let p = Double("nan(0x10)")
    ///       // p?.isNaN == true
    ///       // String(p!) == "nan(0x10)"
    ///
    /// Passing any other format or any additional characters as `text` results
    /// in `nil`. For example, the following conversions result in `nil`:
    ///
    ///     Double(" 5.0")      // Includes whitespace
    ///     Double("2.0")      // Invalid character
    ///     Double("0x1.25e4")  // Incorrect exponent format
    ///
    /// - Parameter text: The input string to convert to a `Double` instance. If
    ///   `text` has invalid characters or is in an invalid format, the result
    ///   is `nil`.
    public init?<S>(_ text: S) where S : StringProtocol
}

extension Double : CustomStringConvertible {

    /// A textual representation of the value.
    public var description: String { get }
}

extension Double : CustomDebugStringConvertible {

    /// A textual representation of the value, suitable for debugging.
    public var debugDescription: String { get }
}

extension Double : BinaryFloatingPoint {

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = Double

    /// A type that can represent any written exponent.
    public typealias Exponent = Int

    /// A type that represents the encoded significand of a value.
    public typealias RawSignificand = UInt64

    /// The number of bits used to represent the type's exponent.
    ///
    /// A binary floating-point type's `exponentBitCount` imposes a limit on the
    /// range of the exponent for normal, finite values. The *exponent bias* of
    /// a type `F` can be calculated as the following, where `**` is
    /// exponentiation:
    ///
    ///     let bias = 2 ** (F.exponentBitCount - 1) - 1
    ///
    /// The least normal exponent for values of the type `F` is `1 - bias`, and
    /// the largest finite exponent is `bias`. An all-zeros exponent is reserved
    /// for subnormals and zeros, and an all-ones exponent is reserved for
    /// infinity and NaN.
    ///
    /// For example, the `Float` type has an `exponentBitCount` of 8, which gives
    /// an exponent bias of `127` by the calculation above.
    ///
    ///     let bias = 2 ** (Float.exponentBitCount - 1) - 1
    ///     // bias == 127
    ///     print(Float.greatestFiniteMagnitude.exponent)
    ///     // Prints "127"
    ///     print(Float.leastNormalMagnitude.exponent)
    ///     // Prints "-126"
    public static var exponentBitCount: Int { get }

    /// The available number of fractional significand bits.
    ///
    /// For fixed-width floating-point types, this is the actual number of
    /// fractional significand bits.
    ///
    /// For extensible floating-point types, `significandBitCount` should be the
    /// maximum allowed significand width (without counting any leading integral
    /// bit of the significand). If there is no upper limit, then
    /// `significandBitCount` should be `Int.max`.
    public static var significandBitCount: Int { get }

    /// The bit pattern of the value's encoding.
    ///
    /// The bit pattern matches the binary interchange format defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var bitPattern: UInt64 { get }

    /// Creates a new value with the given bit pattern.
    ///
    /// The value passed as `bitPattern` is interpreted in the binary interchange
    /// format defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter bitPattern: The integer encoding of a `Double` instance.
    public init(bitPattern: UInt64)

    /// The sign of the floating-point value.
    ///
    /// The `sign` property is `.minus` if the value's signbit is set, and
    /// `.plus` otherwise. For example:
    ///
    ///     let x = -33.375
    ///     // x.sign == .minus
    ///
    /// Do not use this property to check whether a floating point value is
    /// negative. For a value `x`, the comparison `x.sign == .minus` is not
    /// necessarily the same as `x < 0`. In particular, `x.sign == .minus` if
    /// `x` is -0, and while `x < 0` is always `false` if `x` is NaN, `x.sign`
    /// could be either `.plus` or `.minus`.
    public var sign: FloatingPointSign { get }

    /// The raw encoding of the value's exponent field.
    ///
    /// This value is unadjusted by the type's exponent bias.
    public var exponentBitPattern: UInt { get }

    /// The raw encoding of the value's significand field.
    ///
    /// The `significandBitPattern` property does not include the leading
    /// integral bit of the significand, even for types like `Float80` that
    /// store it explicitly.
    public var significandBitPattern: UInt64 { get }

    /// Creates a new instance from the specified sign and bit patterns.
    ///
    /// The values passed as `exponentBitPattern` and `significandBitPattern` are
    /// interpreted in the binary interchange format defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - sign: The sign of the new value.
    ///   - exponentBitPattern: The bit pattern to use for the exponent field of
    ///     the new value.
    ///   - significandBitPattern: The bit pattern to use for the significand
    ///     field of the new value.
    public init(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)

    /// A Boolean value indicating whether the instance's representation is in
    /// the canonical form.
    ///
    /// The [IEEE 754 specification][spec] defines a *canonical*, or preferred,
    /// encoding of a floating-point value's representation. Every `Float` or
    /// `Double` value is canonical, but noncanonical values of the `Float80`
    /// type exist, and noncanonical values may exist for other types that
    /// conform to the `FloatingPoint` protocol.
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var isCanonical: Bool { get }

    /// Positive infinity.
    ///
    /// Infinity compares greater than all finite numbers and equal to other
    /// infinite values.
    ///
    ///     let x = Double.greatestFiniteMagnitude
    ///     let y = x * 2
    ///     // y == Double.infinity
    ///     // y > x
    public static var infinity: Double { get }

    /// A quiet NaN ("not a number").
    ///
    /// A NaN compares not equal, not greater than, and not less than every
    /// value, including itself. Passing a NaN to an operation generally results
    /// in NaN.
    ///
    ///     let x = 1.21
    ///     // x > Double.nan == false
    ///     // x < Double.nan == false
    ///     // x == Double.nan == false
    ///
    /// Because a NaN always compares not equal to itself, to test whether a
    /// floating-point value is NaN, use its `isNaN` property instead of the
    /// equal-to operator (`==`). In the following example, `y` is NaN.
    ///
    ///     let y = x + Double.nan
    ///     print(y == Double.nan)
    ///     // Prints "false"
    ///     print(y.isNaN)
    ///     // Prints "true"
    public static var nan: Double { get }

    /// A signaling NaN ("not a number").
    ///
    /// The default IEEE 754 behavior of operations involving a signaling NaN is
    /// to raise the Invalid flag in the floating-point environment and return a
    /// quiet NaN.
    ///
    /// Operations on types conforming to the `FloatingPoint` protocol should
    /// support this behavior, but they might also support other options. For
    /// example, it would be reasonable to implement alternative operations in
    /// which operating on a signaling NaN triggers a runtime error or results
    /// in a diagnostic for debugging purposes. Types that implement alternative
    /// behaviors for a signaling NaN must document the departure.
    ///
    /// Other than these signaling operations, a signaling NaN behaves in the
    /// same manner as a quiet NaN.
    public static var signalingNaN: Double { get }

    /// The greatest finite number representable by this type.
    ///
    /// This value compares greater than or equal to all finite numbers, but less
    /// than `infinity`.
    ///
    /// This value corresponds to type-specific C macros such as `FLT_MAX` and
    /// `DBL_MAX`. The naming of those macros is slightly misleading, because
    /// `infinity` is greater than this value.
    public static var greatestFiniteMagnitude: Double { get }

    /// The mathematical constant pi.
    ///
    /// This value should be rounded toward zero to keep user computations with
    /// angles from inadvertently ending up in the wrong quadrant. A type that
    /// conforms to the `FloatingPoint` protocol provides the value for `pi` at
    /// its best possible precision.
    ///
    ///     print(Double.pi)
    ///     // Prints "3.14159265358979"
    public static var pi: Double { get }

    /// The unit in the last place of this value.
    ///
    /// This is the unit of the least significant digit in this value's
    /// significand. For most numbers `x`, this is the difference between `x`
    /// and the next greater (in magnitude) representable number. There are some
    /// edge cases to be aware of:
    ///
    /// - If `x` is not a finite number, then `x.ulp` is NaN.
    /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal
    ///   number. If a type does not support subnormals, `x.ulp` may be rounded
    ///   to zero.
    /// - `greatestFiniteMagnitude.ulp` is a finite number, even though the next
    ///   greater representable value is `infinity`.
    ///
    /// This quantity, or a related quantity, is sometimes called *epsilon* or
    /// *machine epsilon.* Avoid that name because it has different meanings in
    /// different languages, which can lead to confusion, and because it
    /// suggests that it is a good tolerance to use for comparisons, which it
    /// almost never is.
    public var ulp: Double { get }

    /// The least positive normal number.
    ///
    /// This value compares less than or equal to all positive normal numbers.
    /// There may be smaller positive numbers, but they are *subnormal*, meaning
    /// that they are represented with less precision than normal numbers.
    ///
    /// This value corresponds to type-specific C macros such as `FLT_MIN` and
    /// `DBL_MIN`. The naming of those macros is slightly misleading, because
    /// subnormals, zeros, and negative numbers are smaller than this value.
    public static var leastNormalMagnitude: Double { get }

    /// The least positive number.
    ///
    /// This value compares less than or equal to all positive numbers, but
    /// greater than zero. If the type supports subnormal values,
    /// `leastNonzeroMagnitude` is smaller than `leastNormalMagnitude`;
    /// otherwise they are equal.
    public static var leastNonzeroMagnitude: Double { get }

    /// The unit in the last place of 1.0.
    ///
    /// The positive difference between 1.0 and the next greater representable
    /// number. The `ulpOfOne` constant corresponds to the C macros
    /// `FLT_EPSILON`, `DBL_EPSILON`, and others with a similar purpose.
    public static var ulpOfOne: Double { get }

    /// The exponent of the floating-point value.
    ///
    /// The *exponent* of a floating-point value is the integer part of the
    /// logarithm of the value's magnitude. For a value `x` of a floating-point
    /// type `F`, the magnitude can be calculated as the following, where `**`
    /// is exponentiation:
    ///
    ///     let magnitude = x.significand * F.radix ** x.exponent
    ///
    /// In the next example, `y` has a value of `21.5`, which is encoded as
    /// `1.34375 * 2 ** 4`. The significand of `y` is therefore 1.34375.
    ///
    ///     let y: Double = 21.5
    ///     // y.significand == 1.34375
    ///     // y.exponent == 4
    ///     // Double.radix == 2
    ///
    /// The `exponent` property has the following edge cases:
    ///
    /// - If `x` is zero, then `x.exponent` is `Int.min`.
    /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`
    ///
    /// This property implements the `logB` operation defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var exponent: Int { get }

    /// The significand of the floating-point value.
    ///
    /// The magnitude of a floating-point value `x` of type `F` can be calculated
    /// by using the following formula, where `**` is exponentiation:
    ///
    ///     let magnitude = x.significand * F.radix ** x.exponent
    ///
    /// In the next example, `y` has a value of `21.5`, which is encoded as
    /// `1.34375 * 2 ** 4`. The significand of `y` is therefore 1.34375.
    ///
    ///     let y: Double = 21.5
    ///     // y.significand == 1.34375
    ///     // y.exponent == 4
    ///     // Double.radix == 2
    ///
    /// If a type's radix is 2, then for finite nonzero numbers, the significand
    /// is in the range `1.0 ..< 2.0`. For other values of `x`, `x.significand`
    /// is defined as follows:
    ///
    /// - If `x` is zero, then `x.significand` is 0.0.
    /// - If `x` is infinity, then `x.significand` is 1.0.
    /// - If `x` is NaN, then `x.significand` is NaN.
    /// - Note: The significand is frequently also called the *mantissa*, but
    ///   significand is the preferred terminology in the [IEEE 754
    ///   specification][spec], to allay confusion with the use of mantissa for
    ///   the fractional part of a logarithm.
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var significand: Double { get }

    /// Creates a new value from the given sign, exponent, and significand.
    ///
    /// The following example uses this initializer to create a new `Double`
    /// instance. `Double` is a binary floating-point type that has a radix of
    /// `2`.
    ///
    ///     let x = Double(sign: .plus, exponent: -2, significand: 1.5)
    ///     // x == 0.375
    ///
    /// This initializer is equivalent to the following calculation, where `**`
    /// is exponentiation, computed as if by a single, correctly rounded,
    /// floating-point operation:
    ///
    ///     let sign: FloatingPointSign = .plus
    ///     let exponent = -2
    ///     let significand = 1.5
    ///     let y = (sign == .minus ? -1 : 1) * significand * Double.radix ** exponent
    ///     // y == 0.375
    ///
    /// As with any basic operation, if this value is outside the representable
    /// range of the type, overflow or underflow occurs, and zero, a subnormal
    /// value, or infinity may result. In addition, there are two other edge
    /// cases:
    ///
    /// - If the value you pass to `significand` is zero or infinite, the result
    ///   is zero or infinite, regardless of the value of `exponent`.
    /// - If the value you pass to `significand` is NaN, the result is NaN.
    ///
    /// For any floating-point value `x` of type `F`, the result of the following
    /// is equal to `x`, with the distinction that the result is canonicalized
    /// if `x` is in a noncanonical encoding:
    ///
    ///     let x0 = F(sign: x.sign, exponent: x.exponent, significand: x.significand)
    ///
    /// This initializer implements the `scaleB` operation defined by the [IEEE
    /// 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - sign: The sign to use for the new value.
    ///   - exponent: The new value's exponent.
    ///   - significand: The new value's significand.
    public init(sign: FloatingPointSign, exponent: Int, significand: Double)

    /// Creates a NaN ("not a number") value with the specified payload.
    ///
    /// NaN values compare not equal to every value, including themselves. Most
    /// operations with a NaN operand produce a NaN result. Don't use the
    /// equal-to operator (`==`) to test whether a value is NaN. Instead, use
    /// the value's `isNaN` property.
    ///
    ///     let x = Double(nan: 0, signaling: false)
    ///     print(x == .nan)
    ///     // Prints "false"
    ///     print(x.isNaN)
    ///     // Prints "true"
    ///
    /// - Parameters:
    ///   - payload: The payload to use for the new NaN value.
    ///   - signaling: Pass `true` to create a signaling NaN or `false` to create
    ///     a quiet NaN.
    public init(nan payload: Double.RawSignificand, signaling: Bool)

    /// The least representable value that compares greater than this value.
    ///
    /// For any finite value `x`, `x.nextUp` is greater than `x`. For `nan` or
    /// `infinity`, `x.nextUp` is `x` itself. The following special cases also
    /// apply:
    ///
    /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestFiniteMagnitude`.
    /// - If `x` is `-leastNonzeroMagnitude`, then `x.nextUp` is `-0.0`.
    /// - If `x` is zero, then `x.nextUp` is `leastNonzeroMagnitude`.
    /// - If `x` is `greatestFiniteMagnitude`, then `x.nextUp` is `infinity`.
    public var nextUp: Double { get }

    /// Rounds the value to an integral value using the specified rounding rule.
    ///
    /// The following example rounds a value using four different rounding rules:
    ///
    ///     // Equivalent to the C 'round' function:
    ///     var w = 6.5
    ///     w.round(.toNearestOrAwayFromZero)
    ///     // w == 7.0
    ///
    ///     // Equivalent to the C 'trunc' function:
    ///     var x = 6.5
    ///     x.round(.towardZero)
    ///     // x == 6.0
    ///
    ///     // Equivalent to the C 'ceil' function:
    ///     var y = 6.5
    ///     y.round(.up)
    ///     // y == 7.0
    ///
    ///     // Equivalent to the C 'floor' function:
    ///     var z = 6.5
    ///     z.round(.down)
    ///     // z == 6.0
    ///
    /// For more information about the available rounding rules, see the
    /// `FloatingPointRoundingRule` enumeration. To round a value using the
    /// default "schoolbook rounding", you can use the shorter `round()` method
    /// instead.
    ///
    ///     var w1 = 6.5
    ///     w1.round()
    ///     // w1 == 7.0
    ///
    /// - Parameter rule: The rounding rule to use.
    public mutating func round(_ rule: FloatingPointRoundingRule)

    /// Replaces this value with its additive inverse.
    ///
    /// The result is always exact. This example uses the `negate()` method to
    /// negate the value of the variable `x`:
    ///
    ///     var x = 21.5
    ///     x.negate()
    ///     // x == -21.5
    public mutating func negate()

    /// Adds two values and stores the result in the left-hand-side variable,
    /// rounded to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Double, rhs: Double)

    /// Subtracts the second value from the first and stores the difference in
    /// the left-hand-side variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Double, rhs: Double)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Double, rhs: Double)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by.
    public static func /= (lhs: inout Double, rhs: Double)

    /// Replaces this value with the remainder of itself divided by the given
    /// value.
    ///
    /// For two finite values `x` and `y`, the remainder `r` of dividing `x` by
    /// `y` satisfies `x == y * q + r`, where `q` is the integer nearest to
    /// `x / y`. If `x / y` is exactly halfway between two integers, `q` is
    /// chosen to be even. Note that `q` is *not* `x / y` computed in
    /// floating-point arithmetic, and that `q` may not be representable in any
    /// available integer type.
    ///
    /// The following example calculates the remainder of dividing 8.625 by 0.75:
    ///
    ///     var x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.toNearestOrEven)
    ///     // q == 12.0
    ///     x.formRemainder(dividingBy: 0.75)
    ///     // x == -0.375
    ///
    ///     let x1 = 0.75 * q + x
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are finite numbers, the remainder is in the
    /// closed range `-abs(other / 2)...abs(other / 2)`. The
    /// `formRemainder(dividingBy:)` method is always exact.
    ///
    /// - Parameter other: The value to use when dividing this value.
    public mutating func formRemainder(dividingBy other: Double)

    /// Replaces this value with the remainder of itself divided by the given
    /// value using truncating division.
    ///
    /// Performing truncating division with floating-point values results in a
    /// truncated integer quotient and a remainder. For values `x` and `y` and
    /// their truncated integer quotient `q`, the remainder `r` satisfies
    /// `x == y * q + r`.
    ///
    /// The following example calculates the truncating remainder of dividing
    /// 8.625 by 0.75:
    ///
    ///     var x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.towardZero)
    ///     // q == 11.0
    ///     x.formTruncatingRemainder(dividingBy: 0.75)
    ///     // x == 0.375
    ///
    ///     let x1 = 0.75 * q + x
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are both finite numbers, the truncating
    /// remainder has the same sign as this value and is strictly smaller in
    /// magnitude than `other`. The `formTruncatingRemainder(dividingBy:)`
    /// method is always exact.
    ///
    /// - Parameter other: The value to use when dividing this value.
    public mutating func formTruncatingRemainder(dividingBy other: Double)

    /// Replaces this value with its square root, rounded to a representable
    /// value.
    public mutating func formSquareRoot()

    /// Adds the product of the two given values to this value in place, computed
    /// without intermediate rounding.
    ///
    /// - Parameters:
    ///   - lhs: One of the values to multiply before adding to this value.
    ///   - rhs: The other value to multiply.
    public mutating func addProduct(_ lhs: Double, _ rhs: Double)

    /// Returns a Boolean value indicating whether this instance is equal to the
    /// given value.
    ///
    /// This method serves as the basis for the equal-to operator (`==`) for
    /// floating-point values. When comparing two values with this method, `-0`
    /// is equal to `+0`. NaN is not equal to any value, including itself. For
    /// example:
    ///
    ///     let x = 15.0
    ///     x.isEqual(to: 15.0)
    ///     // true
    ///     x.isEqual(to: .nan)
    ///     // false
    ///     Double.nan.isEqual(to: .nan)
    ///     // false
    ///
    /// The `isEqual(to:)` method implements the equality predicate defined by
    /// the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if `other` has the same value as this instance;
    ///   otherwise, `false`.
    public func isEqual(to other: Double) -> Bool

    /// Returns a Boolean value indicating whether this instance is less than the
    /// given value.
    ///
    /// This method serves as the basis for the less-than operator (`<`) for
    /// floating-point values. Some special cases apply:
    ///
    /// - Because NaN compares not less than nor greater than any value, this
    ///   method returns `false` when called on NaN or when NaN is passed as
    ///   `other`.
    /// - `-infinity` compares less than all values except for itself and NaN.
    /// - Every value except for NaN and `+infinity` compares less than
    ///   `+infinity`.
    ///
    ///     let x = 15.0
    ///     x.isLess(than: 20.0)
    ///     // true
    ///     x.isLess(than: .nan)
    ///     // false
    ///     Double.nan.isLess(than: x)
    ///     // false
    ///
    /// The `isLess(than:)` method implements the less-than predicate defined by
    /// the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if `other` is less than this value; otherwise, `false`.
    public func isLess(than other: Double) -> Bool

    /// Returns a Boolean value indicating whether this instance is less than or
    /// equal to the given value.
    ///
    /// This method serves as the basis for the less-than-or-equal-to operator
    /// (`<=`) for floating-point values. Some special cases apply:
    ///
    /// - Because NaN is incomparable with any value, this method returns `false`
    ///   when called on NaN or when NaN is passed as `other`.
    /// - `-infinity` compares less than or equal to all values except NaN.
    /// - Every value except NaN compares less than or equal to `+infinity`.
    ///
    ///     let x = 15.0
    ///     x.isLessThanOrEqualTo(20.0)
    ///     // true
    ///     x.isLessThanOrEqualTo(.nan)
    ///     // false
    ///     Double.nan.isLessThanOrEqualTo(x)
    ///     // false
    ///
    /// The `isLessThanOrEqualTo(_:)` method implements the less-than-or-equal
    /// predicate defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if `other` is less than this value; otherwise, `false`.
    public func isLessThanOrEqualTo(_ other: Double) -> Bool

    /// A Boolean value indicating whether this instance is normal.
    ///
    /// A *normal* value is a finite number that uses the full precision
    /// available to values of a type. Zero is neither a normal nor a subnormal
    /// number.
    public var isNormal: Bool { get }

    /// A Boolean value indicating whether this instance is finite.
    ///
    /// All values other than NaN and infinity are considered finite, whether
    /// normal or subnormal.
    public var isFinite: Bool { get }

    /// A Boolean value indicating whether the instance is equal to zero.
    ///
    /// The `isZero` property of a value `x` is `true` when `x` represents either
    /// `-0.0` or `+0.0`. `x.isZero` is equivalent to the following comparison:
    /// `x == 0.0`.
    ///
    ///     let x = -0.0
    ///     x.isZero        // true
    ///     x == 0.0        // true
    public var isZero: Bool { get }

    /// A Boolean value indicating whether the instance is subnormal.
    ///
    /// A *subnormal* value is a nonzero number that has a lesser magnitude than
    /// the smallest normal number. Subnormal values do not use the full
    /// precision available to values of a type.
    ///
    /// Zero is neither a normal nor a subnormal number. Subnormal numbers are
    /// often called *denormal* or *denormalized*---these are different names
    /// for the same concept.
    public var isSubnormal: Bool { get }

    /// A Boolean value indicating whether the instance is infinite.
    ///
    /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because
    /// they are not total: If `x` is `NaN`, then both properties are `false`.
    public var isInfinite: Bool { get }

    /// A Boolean value indicating whether the instance is NaN ("not a number").
    ///
    /// Because NaN is not equal to any value, including NaN, use this property
    /// instead of the equal-to operator (`==`) or not-equal-to operator (`!=`)
    /// to test whether a value is or is not NaN. For example:
    ///
    ///     let x = 0.0
    ///     let y = x * .infinity
    ///     // y is a NaN
    ///
    ///     // Comparing with the equal-to operator never returns 'true'
    ///     print(x == Double.nan)
    ///     // Prints "false"
    ///     print(y == Double.nan)
    ///     // Prints "false"
    ///
    ///     // Test with the 'isNaN' property instead
    ///     print(x.isNaN)
    ///     // Prints "false"
    ///     print(y.isNaN)
    ///     // Prints "true"
    ///
    /// This property is `true` for both quiet and signaling NaNs.
    public var isNaN: Bool { get }

    /// A Boolean value indicating whether the instance is a signaling NaN.
    ///
    /// Signaling NaNs typically raise the Invalid flag when used in general
    /// computing operations.
    public var isSignalingNaN: Bool { get }

    /// The floating-point value with the same sign and exponent as this value,
    /// but with a significand of 1.0.
    ///
    /// A *binade* is a set of binary floating-point values that all have the
    /// same sign and exponent. The `binade` property is a member of the same
    /// binade as this value, but with a unit significand.
    ///
    /// In this example, `x` has a value of `21.5`, which is stored as
    /// `1.34375 * 2**4`, where `**` is exponentiation. Therefore, `x.binade` is
    /// equal to `1.0 * 2**4`, or `16.0`.
    ///
    ///     let x = 21.5
    ///     // x.significand == 1.34375
    ///     // x.exponent == 4
    ///
    ///     let y = x.binade
    ///     // y == 16.0
    ///     // y.significand == 1.0
    ///     // y.exponent == 4
    public var binade: Double { get }

    /// The number of bits required to represent the value's significand.
    ///
    /// If this value is a finite nonzero number, `significandWidth` is the
    /// number of fractional bits required to represent the value of
    /// `significand`; otherwise, `significandWidth` is -1. The value of
    /// `significandWidth` is always -1 or between zero and
    /// `significandBitCount`. For example:
    ///
    /// - For any representable power of two, `significandWidth` is zero, because
    ///   `significand` is `1.0`.
    /// - If `x` is 10, `x.significand` is `1.01` in binary, so
    ///   `x.significandWidth` is 2.
    /// - If `x` is Float.pi, `x.significand` is `1.10010010000111111011011` in
    ///   binary, and `x.significandWidth` is 23.
    public var significandWidth: Int { get }

    /// Creates a new value from the given floating-point literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you create a new `Double` instance by using a floating-point literal.
    /// Instead, create a new value by using a literal.
    ///
    /// In this example, the assignment to the `x` constant calls this
    /// initializer behind the scenes.
    ///
    ///     let x: Double = 21.25
    ///     // x == 21.25
    ///
    /// - Parameter value: The new floating-point value.
    public init(floatLiteral value: Double)
}

extension Double : ExpressibleByIntegerLiteral {

    /// Creates a new value from the given integer literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you create a new `Double` instance by using an integer literal.
    /// Instead, create a new value by using a literal.
    ///
    /// In this example, the assignment to the `x` constant calls this
    /// initializer behind the scenes.
    ///
    ///     let x: Double = 100
    ///     // x == 100.0
    ///
    /// - Parameter value: The new value.
    public init(integerLiteral value: Int64)
}

extension Double {
}

extension Double : Hashable {

    /// The number's hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Double {

    /// The magnitude of this value.
    ///
    /// For any value `x`, `x.magnitude.sign` is `.plus`. If `x` is not NaN,
    /// `x.magnitude` is the absolute value of `x`.
    ///
    /// The global `abs(_:)` function provides more familiar syntax when you need
    /// to find an absolute value. In addition, because `abs(_:)` always returns
    /// a value of the same type, even in a generic context, using the function
    /// instead of the `magnitude` property is encouraged.
    ///
    ///     let targetDistance: Double = 5.25
    ///     let throwDistance: Double = 5.5
    ///
    ///     let margin = targetDistance - throwDistance
    ///     // margin == -0.25
    ///     // margin.magnitude == 0.25
    ///
    ///     // Use 'abs(_:)' instead of 'magnitude'
    ///     print("Missed the target by \(abs(margin)) meters.")
    ///     // Prints "Missed the target by 0.25 meters."
    public var magnitude: Double { get }
}

extension Double {

    /// Calculates the additive inverse of a value.
    ///
    /// The unary minus operator (prefix `-`) calculates the negation of its
    /// operand. The result is always exact.
    ///
    ///     let x = 21.5
    ///     let y = -x
    ///     // y == -21.5
    ///
    /// - Parameter operand: The value to negate.
    prefix public static func - (x: Double) -> Double
}

extension Double {

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt8)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting UInt8 to Double will always succeed.")
    public init?(exactly value: UInt8)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int8)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting Int8 to Double will always succeed.")
    public init?(exactly value: Int8)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt16)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting UInt16 to Double will always succeed.")
    public init?(exactly value: UInt16)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int16)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting Int16 to Double will always succeed.")
    public init?(exactly value: Int16)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt32)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting UInt32 to Double will always succeed.")
    public init?(exactly value: UInt32)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int32)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting Int32 to Double will always succeed.")
    public init?(exactly value: Int32)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt64)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: UInt64)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int64)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: Int64)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: UInt)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: Int)
}

extension Double {

    /// Creates a new instance that approximates the given value.
    ///
    /// The value of `other` is rounded to a representable value, if necessary.
    /// A NaN passed as `other` results in another NaN, with a signaling NaN
    /// value converted to quiet NaN.
    ///
    ///     let x: Float = 21.25
    ///     let y = Double(x)
    ///     // y == 21.25
    ///
    ///     let z = Double(Float.nan)
    ///     // z.isNaN == true
    ///
    /// - Parameter other: The value to use for the new instance.
    public init(_ other: Float)

    /// Creates a new instance initialized to the given value, if it can be
    /// represented without rounding.
    ///
    /// If `other` can't be represented as an instance of `Double` without
    /// rounding, the result of this initializer is `nil`. In particular,
    /// passing NaN as `other` always results in `nil`.
    ///
    ///     let x: Float = 21.25
    ///     let y = Double(exactly: x)
    ///     // y == Optional.some(21.25)
    ///
    ///     let z = Double(exactly: Float.nan)
    ///     // z == nil
    ///
    /// - Parameter other: The value to use for the new instance.
    public init?(exactly other: Float)

    /// Creates a new instance initialized to the given value.
    ///
    /// The value of `other` is represented exactly by the new instance. A NaN
    /// passed as `other` results in another NaN, with a signaling NaN value
    /// converted to quiet NaN.
    ///
    ///     let x: Double = 21.25
    ///     let y = Double(x)
    ///     // y == 21.25
    ///
    ///     let z = Double(Double.nan)
    ///     // z.isNaN == true
    ///
    /// - Parameter other: The value to use for the new instance.
    public init(_ other: Double)

    /// Creates a new instance initialized to the given value, if it can be
    /// represented without rounding.
    ///
    /// If `other` can't be represented as an instance of `Double` without
    /// rounding, the result of this initializer is `nil`. In particular,
    /// passing NaN as `other` always results in `nil`.
    ///
    ///     let x: Double = 21.25
    ///     let y = Double(exactly: x)
    ///     // y == Optional.some(21.25)
    ///
    ///     let z = Double(exactly: Double.nan)
    ///     // z == nil
    ///
    /// - Parameter other: The value to use for the new instance.
    public init?(exactly other: Double)

    /// Creates a new instance that approximates the given value.
    ///
    /// The value of `other` is rounded to a representable value, if necessary.
    /// A NaN passed as `other` results in another NaN, with a signaling NaN
    /// value converted to quiet NaN.
    ///
    ///     let x: Float80 = 21.25
    ///     let y = Double(x)
    ///     // y == 21.25
    ///
    ///     let z = Double(Float80.nan)
    ///     // z.isNaN == true
    ///
    /// - Parameter other: The value to use for the new instance.
    public init(_ other: Float80)

    /// Creates a new instance initialized to the given value, if it can be
    /// represented without rounding.
    ///
    /// If `other` can't be represented as an instance of `Double` without
    /// rounding, the result of this initializer is `nil`. In particular,
    /// passing NaN as `other` always results in `nil`.
    ///
    ///     let x: Float80 = 21.25
    ///     let y = Double(exactly: x)
    ///     // y == Optional.some(21.25)
    ///
    ///     let z = Double(exactly: Float80.nan)
    ///     // z == nil
    ///
    /// - Parameter other: The value to use for the new instance.
    public init?(exactly other: Float80)
}

extension Double {

    /// Adds two values and produces their sum, rounded to a
    /// representable value.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     let x = 1.5
    ///     let y = x + 2.25
    ///     // y == 3.75
    ///
    /// The `+` operator implements the addition operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Double, rhs: Double) -> Double

    /// Subtracts one value from another and produces their difference, rounded
    /// to a representable value.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     let x = 7.5
    ///     let y = x - 2.25
    ///     // y == 5.25
    ///
    /// The `-` operator implements the subtraction operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Double, rhs: Double) -> Double

    /// Multiplies two values and produces their product, rounding to a
    /// representable value.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     let x = 7.5
    ///     let y = x * 2.25
    ///     // y == 16.875
    ///
    /// The `*` operator implements the multiplication operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Double, rhs: Double) -> Double

    /// Returns the quotient of dividing the first value by the second, rounded
    /// to a representable value.
    ///
    /// The division operator (`/`) calculates the quotient of the division if
    /// `rhs` is nonzero. If `rhs` is zero, the result of the division is
    /// infinity, with the sign of the result matching the sign of `lhs`.
    ///
    ///     let x = 16.875
    ///     let y = x / 2.25
    ///     // y == 7.5
    ///
    ///     let z = x / 0
    ///     // z.isInfinite == true
    ///
    /// The `/` operator implements the division operation defined by the [IEEE
    /// 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by.
    public static func / (lhs: Double, rhs: Double) -> Double
}

extension Double : Strideable {

    /// Returns the distance from this value to the specified value.
    ///
    /// For two values `x` and `y`, the result of `x.distance(to: y)` is equal to
    /// `y - x`---a distance `d` such that `x.advanced(by: d)` approximates `y`.
    /// For example:
    ///
    ///     let x = 21.5
    ///     let d = x.distance(to: 15.0)
    ///     // d == -6.5
    ///
    ///     print(x.advanced(by: d))
    ///     // Prints "15.0"
    ///
    /// - Parameter other: A value to calculate the distance to.
    /// - Returns: The distance between this value and `other`.
    public func distance(to other: Double) -> Double

    /// Returns a new value advanced by the given distance.
    ///
    /// For two values `x` and `d`, the result of a `x.advanced(by: d)` is equal
    /// to `x + d`---a new value `y` such that `x.distance(to: y)` approximates
    /// `d`. For example:
    ///
    ///     let x = 21.5
    ///     let y = x.advanced(by: -6.5)
    ///     // y == 15.0
    ///
    ///     print(x.distance(to: y))
    ///     // Prints "-6.5"
    ///
    /// - Parameter amount: The distance to advance this value.
    /// - Returns: A new value that is `amount` added to this value.
    public func advanced(by amount: Double) -> Double
}

extension Double : CustomReflectable {

    /// A mirror that reflects the `Double` instance.
    public var customMirror: Mirror { get }
}

extension Double : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `Double` instance.
    @available(*, deprecated, message: "Double.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Double {
}

/// A collection whose element type is `Element` but that is always empty.
public struct EmptyCollection<Element> {

    /// Creates an instance.
    public init()
}

extension EmptyCollection {

    /// An iterator that never produces an element.
    public struct Iterator {

        /// Creates an instance.
        public init()
    }
}

extension EmptyCollection : Sequence {

    /// Returns an empty iterator.
    public func makeIterator() -> EmptyCollection<Element>.Iterator
}

extension EmptyCollection : RandomAccessCollection, MutableCollection {

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = EmptyCollection<Element>

    /// Always zero, just like `endIndex`.
    public var startIndex: EmptyCollection<Element>.Index { get }

    /// Always zero, just like `startIndex`.
    public var endIndex: EmptyCollection<Element>.Index { get }

    /// Always traps.
    ///
    /// `EmptyCollection` does not have any element indices, so it is not
    /// possible to advance indices.
    public func index(after i: EmptyCollection<Element>.Index) -> EmptyCollection<Element>.Index

    /// Always traps.
    ///
    /// `EmptyCollection` does not have any element indices, so it is not
    /// possible to advance indices.
    public func index(before i: EmptyCollection<Element>.Index) -> EmptyCollection<Element>.Index

    /// Accesses the element at the given position.
    ///
    /// Must never be called, since this collection is always empty.
    public subscript(position: EmptyCollection<Element>.Index) -> Element

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<EmptyCollection<Element>.Index>) -> EmptyCollection<Element>.SubSequence

    /// The number of elements (always zero).
    public var count: Int { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: EmptyCollection<Element>.Index, offsetBy n: Int) -> EmptyCollection<Element>.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: EmptyCollection<Element>.Index, offsetBy n: Int, limitedBy limit: EmptyCollection<Element>.Index) -> EmptyCollection<Element>.Index?

    /// The distance between two indexes (always zero).
    public func distance(from start: EmptyCollection<Element>.Index, to end: EmptyCollection<Element>.Index) -> Int
}

extension EmptyCollection : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: EmptyCollection<Element>, rhs: EmptyCollection<Element>) -> Bool
}

extension EmptyCollection.Iterator : IteratorProtocol, Sequence {

    /// Returns `nil`, indicating that there are no more elements.
    public mutating func next() -> Element?
}

public typealias EmptyIterator<T> = EmptyCollection<T>.Iterator

/// A type that can encode itself to an external representation.
public protocol Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

/// A type that can encode values into a native format for external
/// representation.
public protocol Encoder {

    /// The path of coding keys taken to get to this point in encoding.
    public var codingPath: [CodingKey] { get }

    /// Any contextual information set by the user for encoding.
    public var userInfo: [CodingUserInfoKey : Any] { get }

    /// Returns an encoding container appropriate for holding multiple values
    /// keyed by the given key type.
    ///
    /// You must use only one kind of top-level encoding container. This method
    /// must not be called after a call to `unkeyedContainer()` or after
    /// encoding a value through a call to `singleValueContainer()`
    ///
    /// - parameter type: The key type to use for the container.
    /// - returns: A new keyed encoding container.
    public func container<Key>(keyedBy type: Key.Type) -> KeyedEncodingContainer<Key> where Key : CodingKey

    /// Returns an encoding container appropriate for holding multiple unkeyed
    /// values.
    ///
    /// You must use only one kind of top-level encoding container. This method
    /// must not be called after a call to `container(keyedBy:)` or after
    /// encoding a value through a call to `singleValueContainer()`
    ///
    /// - returns: A new empty unkeyed container.
    public func unkeyedContainer() -> UnkeyedEncodingContainer

    /// Returns an encoding container appropriate for holding a single primitive
    /// value.
    ///
    /// You must use only one kind of top-level encoding container. This method
    /// must not be called after a call to `unkeyedContainer()` or
    /// `container(keyedBy:)`, or after encoding a value through a call to
    /// `singleValueContainer()`
    ///
    /// - returns: A new empty single value container.
    public func singleValueContainer() -> SingleValueEncodingContainer
}

/// An error that occurs during the encoding of a value.
public enum EncodingError : Error {

    /// The context in which the error occurred.
    public struct Context {

        /// The path of coding keys taken to get to the point of the failing encode
        /// call.
        public let codingPath: [CodingKey]

        /// A description of what went wrong, for debugging purposes.
        public let debugDescription: String

        /// The underlying error which caused this error, if any.
        public let underlyingError: Error?

        /// Creates a new context with the given path of coding keys and a
        /// description of what went wrong.
        ///
        /// - parameter codingPath: The path of coding keys taken to get to the
        ///   point of the failing encode call.
        /// - parameter debugDescription: A description of what went wrong, for
        ///   debugging purposes.
        /// - parameter underlyingError: The underlying error which caused this
        ///   error, if any.
        public init(codingPath: [CodingKey], debugDescription: String, underlyingError: Error? = default)
    }

    /// An indication that an encoder or its containers could not encode the
    /// given value.
    ///
    /// As associated values, this case contains the attempted value and context
    /// for debugging.
    case invalidValue(Any, EncodingError.Context)
}

/// The iterator for `EnumeratedSequence`.
///
/// An instance of `EnumeratedIterator` wraps a base iterator and yields
/// successive `Int` values, starting at zero, along with the elements of the
/// underlying base iterator. The following example enumerates the elements of
/// an array:
///
///     var iterator = ["foo", "bar"].enumerated().makeIterator()
///     iterator.next() // (0, "foo")
///     iterator.next() // (1, "bar")
///     iterator.next() // nil
///
/// To create an instance of `EnumeratedIterator`, call
/// `enumerated().makeIterator()` on a sequence or collection.
public struct EnumeratedIterator<Base> where Base : IteratorProtocol {
}

extension EnumeratedIterator : IteratorProtocol, Sequence where Base : IteratorProtocol {

    /// The type of element returned by `next()`.
    public typealias Element = (offset: Int, element: Base.Element)

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    public mutating func next() -> EnumeratedIterator<Base>.Element?
}

/// An enumeration of the elements of a sequence or collection.
///
/// `EnumeratedSequence` is a sequence of pairs (*n*, *x*), where *n*s are
/// consecutive `Int` values starting at zero, and *x*s are the elements of a
/// base sequence.
///
/// To create an instance of `EnumeratedSequence`, call `enumerated()` on a
/// sequence or collection. The following example enumerates the elements of
/// an array.
///
///     var s = ["foo", "bar"].enumerated()
///     for (n, x) in s {
///         print("\(n): \(x)")
///     }
///     // Prints "0: foo"
///     // Prints "1: bar"
public struct EnumeratedSequence<Base> where Base : Sequence {
}

extension EnumeratedSequence : Sequence where Base : Sequence {

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> EnumeratedIterator<Base.Iterator>
}

/// A type that can be compared for value equality.
///
/// Types that conform to the `Equatable` protocol can be compared for equality
/// using the equal-to operator (`==`) or inequality using the not-equal-to
/// operator (`!=`). Most basic types in the Swift standard library conform to
/// `Equatable`.
///
/// Some sequence and collection operations can be used more simply when the
/// elements conform to `Equatable`. For example, to check whether an array
/// contains a particular value, you can pass the value itself to the
/// `contains(_:)` method when the array's element conforms to `Equatable`
/// instead of providing a closure that determines equivalence. The following
/// example shows how the `contains(_:)` method can be used with an array of
/// strings.
///
///     let students = ["Nora", "Fern", "Ryan", "Rainer"]
///
///     let nameToCheck = "Ryan"
///     if students.contains(nameToCheck) {
///         print("\(nameToCheck) is signed up!")
///     } else {
///         print("No record of \(nameToCheck).")
///     }
///     // Prints "Ryan is signed up!"
///
/// Conforming to the Equatable Protocol
/// ====================================
///
/// Adding `Equatable` conformance to your custom types means that you can use
/// more convenient APIs when searching for particular instances in a
/// collection. `Equatable` is also the base protocol for the `Hashable` and
/// `Comparable` protocols, which allow more uses of your custom type, such as
/// constructing sets or sorting the elements of a collection.
///
/// You can rely on automatic synthesis of the `Equatable` protocol's
/// requirements for a custom type when you declare `Equatable` conformance in
/// the type's original declaration and your type meets these criteria:
///
/// - For a `struct`, all its stored properties must conform to `Equatable`.
/// - For an `enum`, all its associated values must conform to `Equatable`. (An
///   `enum` without associated values has `Equatable` conformance even
///   without the declaration.)
///
/// To customize your type's `Equatable` conformance, to adopt `Equatable` in a
/// type that doesn't meet the criteria listed above, or to extend an existing
/// type to conform to `Equatable`, implement the equal-to operator (`==`) as
/// a static method of your type. The standard library provides an
/// implementation for the not-equal-to operator (`!=`) for any `Equatable`
/// type, which calls the custom `==` function and negates its result.
///
/// As an example, consider a `StreetAddress` class that holds the parts of a
/// street address: a house or building number, the street name, and an
/// optional unit number. Here's the initial declaration of the
/// `StreetAddress` type:
///
///     class StreetAddress {
///         let number: String
///         let street: String
///         let unit: String?
///
///         init(_ number: String, _ street: String, unit: String? = nil) {
///             self.number = number
///             self.street = street
///             self.unit = unit
///         }
///     }
///
/// Now suppose you have an array of addresses that you need to check for a
/// particular address. To use the `contains(_:)` method without including a
/// closure in each call, extend the `StreetAddress` type to conform to
/// `Equatable`.
///
///     extension StreetAddress: Equatable {
///         static func == (lhs: StreetAddress, rhs: StreetAddress) -> Bool {
///             return
///                 lhs.number == rhs.number &&
///                 lhs.street == rhs.street &&
///                 lhs.unit == rhs.unit
///         }
///     }
///
/// The `StreetAddress` type now conforms to `Equatable`. You can use `==` to
/// check for equality between any two instances or call the
/// `Equatable`-constrained `contains(_:)` method.
///
///     let addresses = [StreetAddress("1490", "Grove Street"),
///                      StreetAddress("2119", "Maple Avenue"),
///                      StreetAddress("1400", "16th Street")]
///     let home = StreetAddress("1400", "16th Street")
///
///     print(addresses[0] == home)
///     // Prints "false"
///     print(addresses.contains(home))
///     // Prints "true"
///
/// Equality implies substitutability---any two instances that compare equally
/// can be used interchangeably in any code that depends on their values. To
/// maintain substitutability, the `==` operator should take into account all
/// visible aspects of an `Equatable` type. Exposing nonvalue aspects of
/// `Equatable` types other than class identity is discouraged, and any that
/// *are* exposed should be explicitly pointed out in documentation.
///
/// Since equality between instances of `Equatable` types is an equivalence
/// relation, any of your custom types that conform to `Equatable` must
/// satisfy three conditions, for any values `a`, `b`, and `c`:
///
/// - `a == a` is always `true` (Reflexivity)
/// - `a == b` implies `b == a` (Symmetry)
/// - `a == b` and `b == c` implies `a == c` (Transitivity)
///
/// Moreover, inequality is the inverse of equality, so any custom
/// implementation of the `!=` operator must guarantee that `a != b` implies
/// `!(a == b)`. The default implementation of the `!=` operator function
/// satisfies this requirement.
///
/// Equality is Separate From Identity
/// ----------------------------------
///
/// The identity of a class instance is not part of an instance's value.
/// Consider a class called `IntegerRef` that wraps an integer value. Here's
/// the definition for `IntegerRef` and the `==` function that makes it
/// conform to `Equatable`:
///
///     class IntegerRef: Equatable {
///         let value: Int
///         init(_ value: Int) {
///             self.value = value
///         }
///
///         static func == (lhs: IntegerRef, rhs: IntegerRef) -> Bool {
///             return lhs.value == rhs.value
///         }
///     }
///
/// The implementation of the `==` function returns the same value whether its
/// two arguments are the same instance or are two different instances with
/// the same integer stored in their `value` properties. For example:
///
///     let a = IntegerRef(100)
///     let b = IntegerRef(100)
///
///     print(a == a, a == b, separator: ", ")
///     // Prints "true, true"
///
/// Class instance identity, on the other hand, is compared using the
/// triple-equals identical-to operator (`===`). For example:
///
///     let c = a
///     print(c === a, c === b, separator: ", ")
///     // Prints "true, false"
public protocol Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Self, rhs: Self) -> Bool
}

extension Equatable {

    /// Returns a Boolean value indicating whether two values are not equal.
    ///
    /// Inequality is the inverse of equality. For any values `a` and `b`, `a != b`
    /// implies that `a == b` is `false`.
    ///
    /// This is the default implementation of the not-equal-to operator (`!=`)
    /// for any type that conforms to `Equatable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func != (lhs: Self, rhs: Self) -> Bool
}

/// A type representing an error value that can be thrown.
///
/// Any type that declares conformance to the `Error` protocol can be used to
/// represent an error in Swift's error handling system. Because the `Error`
/// protocol has no requirements of its own, you can declare conformance on
/// any custom type you create.
///
/// Using Enumerations as Errors
/// ============================
///
/// Swift's enumerations are well suited to represent simple errors. Create an
/// enumeration that conforms to the `Error` protocol with a case for each
/// possible error. If there are additional details about the error that could
/// be helpful for recovery, use associated values to include that
/// information.
///
/// The following example shows an `IntParsingError` enumeration that captures
/// two different kinds of errors that can occur when parsing an integer from
/// a string: overflow, where the value represented by the string is too large
/// for the integer data type, and invalid input, where nonnumeric characters
/// are found within the input.
///
///     enum IntParsingError: Error {
///         case overflow
///         case invalidInput(String)
///     }
///
/// The `invalidInput` case includes the invalid character as an associated
/// value.
///
/// The next code sample shows a possible extension to the `Int` type that
/// parses the integer value of a `String` instance, throwing an error when
/// there is a problem during parsing.
///
///     extension Int {
///         init(validating input: String) throws {
///             // ...
///             if !_isValid(s) {
///                 throw IntParsingError.invalidInput(s)
///             }
///             // ...
///         }
///     }
///
/// When calling the new `Int` initializer within a `do` statement, you can use
/// pattern matching to match specific cases of your custom error type and
/// access their associated values, as in the example below.
///
///     do {
///         let price = try Int(validating: "$100")
///     } catch IntParsingError.invalidInput(let invalid) {
///         print("Invalid character: '\(invalid)'")
///     } catch IntParsingError.overflow {
///         print("Overflow error")
///     } catch {
///         print("Other error")
///     }
///     // Prints "Invalid character: '$'"
///
/// Including More Data in Errors
/// =============================
///
/// Sometimes you may want different error states to include the same common
/// data, such as the position in a file or some of your application's state.
/// When you do, use a structure to represent errors. The following example
/// uses a structure to represent an error when parsing an XML document,
/// including the line and column numbers where the error occurred:
///
///     struct XMLParsingError: Error {
///         enum ErrorKind {
///             case invalidCharacter
///             case mismatchedTag
///             case internalError
///         }
///
///         let line: Int
///         let column: Int
///         let kind: ErrorKind
///     }
///
///     func parse(_ source: String) throws -> XMLDoc {
///         // ...
///         throw XMLParsingError(line: 19, column: 5, kind: .mismatchedTag)
///         // ...
///     }
///
/// Once again, use pattern matching to conditionally catch errors. Here's how
/// you can catch any `XMLParsingError` errors thrown by the `parse(_:)`
/// function:
///
///     do {
///         let xmlDoc = try parse(myXMLData)
///     } catch let e as XMLParsingError {
///         print("Parsing error: \(e.kind) [\(e.line):\(e.column)]")
///     } catch {
///         print("Other error: \(error)")
///     }
///     // Prints "Parsing error: mismatchedTag [19:5]"
public protocol Error {
}

extension Error {
}

extension Error where Self.RawValue : SignedInteger {
}

extension Error where Self.RawValue : UnsignedInteger {
}

/// A type that can be initialized using an array literal.
///
/// An array literal is a simple way of expressing a list of values. Simply
/// surround a comma-separated list of values, instances, or literals with
/// square brackets to create an array literal. You can use an array literal
/// anywhere an instance of an `ExpressibleByArrayLiteral` type is expected: as
/// a value assigned to a variable or constant, as a parameter to a method or
/// initializer, or even as the subject of a nonmutating operation like
/// `map(_:)` or `filter(_:)`.
///
/// Arrays, sets, and option sets all conform to `ExpressibleByArrayLiteral`, 
/// and your own custom types can as well. Here's an example of creating a set 
/// and an array using array literals:
///
///     let employeesSet: Set<String> = ["Amir", "Jihye", "Dave", "Alessia", "Dave"]
///     print(employeesSet)
///     // Prints "["Amir", "Dave", "Jihye", "Alessia"]"
///
///     let employeesArray: [String] = ["Amir", "Jihye", "Dave", "Alessia", "Dave"]
///     print(employeesArray)
///     // Prints "["Amir", "Jihye", "Dave", "Alessia", "Dave"]"
///
/// The `Set` and `Array` types each handle array literals in their own way to
/// create new instances. In this case, the newly created set drops the
/// duplicate value ("Dave") and doesn't maintain the order of the array
/// literal's elements. The new array, on the other hand, matches the order
/// and number of elements provided.
///
/// - Note: An array literal is not the same as an `Array` instance. You can't
///   initialize a type that conforms to `ExpressibleByArrayLiteral` simply by
///   assigning an existing array.
///
///       let anotherSet: Set = employeesArray
///       // error: cannot convert value of type '[String]' to specified type 'Set'
///
/// Type Inference of Array Literals
/// ================================
///
/// Whenever possible, Swift's compiler infers the full intended type of your
/// array literal. Because `Array` is the default type for an array literal,
/// without writing any other code, you can declare an array with a particular
/// element type by providing one or more values.
///
/// In this example, the compiler infers the full type of each array literal.
///
///     let integers = [1, 2, 3]
///     // 'integers' has type '[Int]'
///
///     let strings = ["a", "b", "c"]
///     // 'strings' has type '[String]'
///
/// An empty array literal alone doesn't provide enough information for the
/// compiler to infer the intended type of the `Array` instance. When using an
/// empty array literal, specify the type of the variable or constant.
///
///     var emptyArray: [Bool] = []
///     // 'emptyArray' has type '[Bool]'
///
/// Because many functions and initializers fully specify the types of their
/// parameters, you can often use an array literal with or without elements as
/// a parameter. For example, the `sum(_:)` function shown here takes an `Int`
/// array as a parameter:
///
///     func sum(values: [Int]) -> Int {
///         return values.reduce(0, +)
///     }
///
///     let sumOfFour = sum([5, 10, 15, 20])
///     // 'sumOfFour' == 50
///
///     let sumOfNone = sum([])
///     // 'sumOfNone' == 0
///
/// When you call a function that does not fully specify its parameters' types,
/// use the type-cast operator (`as`) to specify the type of an array literal.
/// For example, the `log(name:value:)` function shown here has an
/// unconstrained generic `value` parameter.
///
///     func log<T>(name name: String, value: T) {
///         print("\(name): \(value)")
///     }
///
///     log(name: "Four integers", value: [5, 10, 15, 20])
///     // Prints "Four integers: [5, 10, 15, 20]"
///
///     log(name: "Zero integers", value: [] as [Int])
///     // Prints "Zero integers: []"
///
/// Conforming to ExpressibleByArrayLiteral
/// =======================================
///
/// Add the capability to be initialized with an array literal to your own
/// custom types by declaring an `init(arrayLiteral:)` initializer. The
/// following example shows the array literal initializer for a hypothetical
/// `OrderedSet` type, which has setlike semantics but maintains the order of
/// its elements.
///
///     struct OrderedSet<Element: Hashable>: Collection, SetAlgebra {
///         // implementation details
///     }
///
///     extension OrderedSet: ExpressibleByArrayLiteral {
///         init(arrayLiteral: Element...) {
///             self.init()
///             for element in arrayLiteral {
///                 self.append(element)
///             }
///         }
///     }
public protocol ExpressibleByArrayLiteral {

    /// The type of the elements of an array literal.
    associatedtype ArrayLiteralElement

    /// Creates an instance initialized with the given elements.
    public init(arrayLiteral elements: Self.ArrayLiteralElement...)
}

/// A type that can be initialized with the Boolean literals `true` and
/// `false`.
///
/// Only three types provided by Swift---`Bool`, `DarwinBoolean`, and
/// `ObjCBool`---are treated as Boolean values. Expanding this set to include
/// types that represent more than simple Boolean values is discouraged.
///
/// To add `ExpressibleByBooleanLiteral` conformance to your custom type,
/// implement the `init(booleanLiteral:)` initializer that creates an instance
/// of your type with the given Boolean value.
public protocol ExpressibleByBooleanLiteral {

    /// A type that represents a Boolean literal, such as `Bool`.
    associatedtype BooleanLiteralType : _ExpressibleByBuiltinBooleanLiteral

    /// Creates an instance initialized to the given Boolean value.
    ///
    /// Do not call this initializer directly. Instead, initialize a variable or
    /// constant using one of the Boolean literals `true` and `false`. For
    /// example:
    ///
    ///     let twasBrillig = true
    ///
    /// In this example, the assignment to the `twasBrillig` constant calls this
    /// Boolean literal initializer behind the scenes.
    ///
    /// - Parameter value: The value of the new instance.
    public init(booleanLiteral value: Self.BooleanLiteralType)
}

/// A type that can be initialized using a dictionary literal.
///
/// A dictionary literal is a simple way of writing a list of key-value pairs.
/// You write each key-value pair with a colon (`:`) separating the key and
/// the value. The dictionary literal is made up of one or more key-value
/// pairs, separated by commas and surrounded with square brackets.
///
/// To declare a dictionary, assign a dictionary literal to a variable or
/// constant:
///
///     let countryCodes = ["BR": "Brazil", "GH": "Ghana",
///                         "JP": "Japan", "US": "United States"]
///     // 'countryCodes' has type [String: String]
///
///     print(countryCodes["BR"]!)
///     // Prints "Brazil"
///
/// When the context provides enough type information, you can use a special
/// form of the dictionary literal, square brackets surrounding a single
/// colon, to initialize an empty dictionary.
///
///     var frequencies: [String: Int] = [:]
///     print(frequencies.count)
///     // Prints "0"
///
/// - Note: A dictionary literal is *not* the same as an instance of
///   `Dictionary` or the similarly named `DictionaryLiteral` type. You can't
///   initialize a type that conforms to `ExpressibleByDictionaryLiteral` simply
///   by assigning an instance of one of these types.
///
/// Conforming to the ExpressibleByDictionaryLiteral Protocol
/// =========================================================
///
/// To add the capability to be initialized with a dictionary literal to your
/// own custom types, declare an `init(dictionaryLiteral:)` initializer. The
/// following example shows the dictionary literal initializer for a
/// hypothetical `CountedSet` type, which uses setlike semantics while keeping
/// track of the count for duplicate elements:
///
///     struct CountedSet<Element: Hashable>: Collection, SetAlgebra {
///         // implementation details
///
///         /// Updates the count stored in the set for the given element,
///         /// adding the element if necessary.
///         ///
///         /// - Parameter n: The new count for `element`. `n` must be greater
///         ///   than or equal to zero.
///         /// - Parameter element: The element to set the new count on.
///         mutating func updateCount(_ n: Int, for element: Element)
///     }
///
///     extension CountedSet: ExpressibleByDictionaryLiteral {
///         init(dictionaryLiteral elements: (Element, Int)...) {
///             self.init()
///             for (element, count) in elements {
///                 self.updateCount(count, for: element)
///             }
///         }
///     }
public protocol ExpressibleByDictionaryLiteral {

    /// The key type of a dictionary literal.
    associatedtype Key

    /// The value type of a dictionary literal.
    associatedtype Value

    /// Creates an instance initialized with the given key-value pairs.
    public init(dictionaryLiteral elements: (Self.Key, Self.Value)...)
}

/// A type that can be initialized with a string literal containing a single
/// extended grapheme cluster.
///
/// An *extended grapheme cluster* is a group of one or more Unicode scalar
/// values that approximates a single user-perceived character.  Many
/// individual characters, such as "", "", and "", can be made up of
/// multiple Unicode scalar values. These code points are combined by
/// Unicode's boundary algorithms into extended grapheme clusters.
///
/// The `String`, `StaticString`, and `Character` types conform to the
/// `ExpressibleByExtendedGraphemeClusterLiteral` protocol. You can initialize
/// a variable or constant of any of these types using a string literal that
/// holds a single character.
///
///     let snowflake: Character = ""
///     print(snowflake)
///     // Prints ""
///
/// Conforming to ExpressibleByExtendedGraphemeClusterLiteral
/// =========================================================
///
/// To add `ExpressibleByExtendedGraphemeClusterLiteral` conformance to your
/// custom type, implement the required initializer.
public protocol ExpressibleByExtendedGraphemeClusterLiteral : ExpressibleByUnicodeScalarLiteral {

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    associatedtype ExtendedGraphemeClusterLiteralType : _ExpressibleByBuiltinExtendedGraphemeClusterLiteral

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(extendedGraphemeClusterLiteral value: Self.ExtendedGraphemeClusterLiteralType)
}

extension ExpressibleByExtendedGraphemeClusterLiteral where Self.ExtendedGraphemeClusterLiteralType == Self.UnicodeScalarLiteralType {

    public convenience init(unicodeScalarLiteral value: Self.ExtendedGraphemeClusterLiteralType)
}

/// A type that can be initialized with a floating-point literal.
///
/// The standard library floating-point types---`Float`, `Double`, and
/// `Float80` where available---all conform to the `ExpressibleByFloatLiteral`
/// protocol. You can initialize a variable or constant of any of these types
/// by assigning a floating-point literal.
///
///     // Type inferred as 'Double'
///     let threshold = 6.0
///
///     // An array of 'Double'
///     let measurements = [2.2, 4.1, 3.65, 4.2, 9.1]
///
/// Conforming to ExpressibleByFloatLiteral
/// =======================================
///
/// To add `ExpressibleByFloatLiteral` conformance to your custom type,
/// implement the required initializer.
public protocol ExpressibleByFloatLiteral {

    /// A type that represents a floating-point literal.
    ///
    /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
    /// where available.
    associatedtype FloatLiteralType : _ExpressibleByBuiltinFloatLiteral

    /// Creates an instance initialized to the specified floating-point value.
    ///
    /// Do not call this initializer directly. Instead, initialize a variable or
    /// constant using a floating-point literal. For example:
    ///
    ///     let x = 21.5
    ///
    /// In this example, the assignment to the `x` constant calls this
    /// floating-point literal initializer behind the scenes.
    ///
    /// - Parameter value: The value to create.
    public init(floatLiteral value: Self.FloatLiteralType)
}

/// A type that can be initialized with an integer literal.
///
/// The standard library integer and floating-point types, such as `Int` and
/// `Double`, conform to the `ExpressibleByIntegerLiteral` protocol. You can
/// initialize a variable or constant of any of these types by assigning an
/// integer literal.
///
///     // Type inferred as 'Int'
///     let cookieCount = 12
///
///     // An array of 'Int'
///     let chipsPerCookie = [21, 22, 25, 23, 24, 19]
///
///     // A floating-point value initialized using an integer literal
///     let redPercentage: Double = 1
///     // redPercentage == 1.0
///
/// Conforming to ExpressibleByIntegerLiteral
/// =========================================
///
/// To add `ExpressibleByIntegerLiteral` conformance to your custom type,
/// implement the required initializer.
public protocol ExpressibleByIntegerLiteral {

    /// A type that represents an integer literal.
    ///
    /// The standard library integer and floating-point types are all valid types
    /// for `IntegerLiteralType`.
    associatedtype IntegerLiteralType : _ExpressibleByBuiltinIntegerLiteral

    /// Creates an instance initialized to the specified integer value.
    ///
    /// Do not call this initializer directly. Instead, initialize a variable or
    /// constant using an integer literal. For example:
    ///
    ///     let x = 23
    ///
    /// In this example, the assignment to the `x` constant calls this integer
    /// literal initializer behind the scenes.
    ///
    /// - Parameter value: The value to create.
    public init(integerLiteral value: Self.IntegerLiteralType)
}

extension ExpressibleByIntegerLiteral {

    public convenience init(integerLiteral value: Self)
}

/// A type that can be initialized using the nil literal, `nil`.
///
/// `nil` has a specific meaning in Swift---the absence of a value. Only the
/// `Optional` type conforms to `ExpressibleByNilLiteral`.
/// `ExpressibleByNilLiteral` conformance for types that use `nil` for other
/// purposes is discouraged.
public protocol ExpressibleByNilLiteral {

    /// Creates an instance initialized with `nil`.
    public init(nilLiteral: ())
}

/// A type that can be initialized by string interpolation with a string
/// literal that includes expressions.
///
/// Use string interpolation to include one or more expressions in a string
/// literal, wrapped in a set of parentheses and prefixed by a backslash. For
/// example:
///
///     let price = 2
///     let number = 3
///     let message = "One cookie: $\(price), \(number) cookies: $\(price * number)."
///     print(message)
///     // Prints "One cookie: $2, 3 cookies: $6."
///
/// Conforming to the ExpressibleByStringInterpolation Protocol
/// ===========================================================
///
/// The `ExpressibleByStringInterpolation` protocol is deprecated. Do not add
/// new conformances to the protocol.
@available(*, deprecated, message: "it will be replaced or redesigned in Swift 4.0.  Instead of conforming to 'ExpressibleByStringInterpolation', consider adding an 'init(_:String)'")
public typealias ExpressibleByStringInterpolation

/// A type that can be initialized with a string literal.
///
/// The `String` and `StaticString` types conform to the
/// `ExpressibleByStringLiteral` protocol. You can initialize a variable or
/// constant of either of these types using a string literal of any length.
///
///     let picnicGuest = "Deserving porcupine"
///
/// Conforming to ExpressibleByStringLiteral
/// ========================================
///
/// To add `ExpressibleByStringLiteral` conformance to your custom type,
/// implement the required initializer.
public protocol ExpressibleByStringLiteral : ExpressibleByExtendedGraphemeClusterLiteral {

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    associatedtype StringLiteralType : _ExpressibleByBuiltinStringLiteral

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral value: Self.StringLiteralType)
}

extension ExpressibleByStringLiteral where Self.ExtendedGraphemeClusterLiteralType == Self.StringLiteralType {

    public convenience init(extendedGraphemeClusterLiteral value: Self.StringLiteralType)
}

/// A type that can be initialized with a string literal containing a single
/// Unicode scalar value.
///
/// The `String`, `StaticString`, `Character`, and `Unicode.Scalar` types all
/// conform to the `ExpressibleByUnicodeScalarLiteral` protocol. You can
/// initialize a variable of any of these types using a string literal that
/// holds a single Unicode scalar.
///
///     let : Unicode.Scalar = ""
///     print()
///     // Prints ""
///
/// Conforming to ExpressibleByUnicodeScalarLiteral
/// ===============================================
///
/// To add `ExpressibleByUnicodeScalarLiteral` conformance to your custom type,
/// implement the required initializer.
public protocol ExpressibleByUnicodeScalarLiteral {

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    associatedtype UnicodeScalarLiteralType : _ExpressibleByBuiltinUnicodeScalarLiteral

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(unicodeScalarLiteral value: Self.UnicodeScalarLiteralType)
}

@available(*, deprecated, renamed: "ExpressibleByExtendedGraphemeClusterLiteral")
public typealias ExtendedGraphemeClusterLiteralConvertible = ExpressibleByExtendedGraphemeClusterLiteral

/// The default type for an otherwise-unconstrained Unicode extended
/// grapheme cluster literal.
public typealias ExtendedGraphemeClusterType = String

/// An integer type that uses a fixed size for every instance.
///
/// The `FixedWidthInteger` protocol adds binary bitwise operations, bit
/// shifts, and overflow handling to the operations supported by the
/// `BinaryInteger` protocol.
///
/// Use the `FixedWidthInteger` protocol as a constraint or extension point
/// when writing operations that depend on bit shifting, performing bitwise
/// operations, catching overflows, or having access to the maximum or minimum
/// representable value of a type. For example, the following code provides a
/// `binaryString` property on every fixed-width integer that represents the
/// number's binary representation, split into 8-bit chunks.
///
///     extension FixedWidthInteger {
///         var binaryString: String {
///             var result: [String] = []
///             for i in 0..<(Self.bitWidth / 8) {
///                 let byte = UInt8(truncatingIfNeeded: self >> (i * 8))
///                 let byteString = String(byte, radix: 2)
///                 let padding = String(repeating: "0",
///                                      count: 8 - byteString.count)
///                 result.append(padding + byteString)
///             }
///             return "0b" + result.reversed().joined(separator: "_")
///         }
///     }
///
///     print(Int16.max.binaryString)
///     // Prints "0b01111111_11111111"
///     print((101 as UInt8).binaryString)
///     // Prints "0b11001001"
///
/// The `binaryString` implementation uses the static `bitWidth` property and
/// the right shift operator (`<<`), both of which are available to any type
/// that conforms to the `FixedWidthInteger` protocol.
///
/// The next example declares a generic `squared` function, which accepts an
/// instance `x` of any fixed-width integer type. The function uses the
/// `multipliedReportingOverflow(by:)` method to multiply `x` by itself and
/// check whether the result is too large to represent in the same type.
///
///     func squared<T: FixedWidthInteger>(_ x: T) -> T? {
///         let (result, overflow) = x.multipliedReportingOverflow(by: x)
///         if overflow {
///             return nil
///         }
///         return result
///     }
///
///     let (x, y): (Int8, Int8) = (9, 123)
///     print(squared(x))
///     // Prints "Optional(81)"
///     print(squared(y))
///     // Prints "nil"
///
/// Conforming to the FixedWidthInteger Protocol
/// ============================================
///
/// To make your own custom type conform to the `FixedWidthInteger` protocol,
/// declare the required initializers, properties, and methods. The required
/// methods that are suffixed with `ReportingOverflow` serve as the
/// customization points for arithmetic operations. When you provide just those
/// methods, the standard library provides default implementations for all
/// other arithmetic methods and operators.
public protocol FixedWidthInteger : BinaryInteger, LosslessStringConvertible, _BitwiseOperations where Self.Magnitude : FixedWidthInteger {

    /// The number of bits used for the underlying binary representation of
    /// values of this type.
    ///
    /// An unsigned, fixed-width integer type can represent values from 0 through
    /// `(2 ** bitWidth) - 1`, where `**` is exponentiation. A signed,
    /// fixed-width integer type can represent values from
    /// `-(2 ** (bitWidth - 1))` through `(2 ** (bitWidth - 1)) - 1`. For example,
    /// the `Int8` type has a `bitWidth` value of 8 and can store any integer in
    /// the range `-128...127`.
    public static var bitWidth: Int { get }

    /// The maximum representable integer in this type.
    ///
    /// For unsigned integer types, this value is `(2 ** bitWidth) - 1`, where
    /// `**` is exponentiation. For signed integer types, this value is
    /// `(2 ** (bitWidth - 1)) - 1`.
    public static var max: Self { get }

    /// The minimum representable integer in this type.
    ///
    /// For unsigned integer types, this value is always `0`. For signed integer
    /// types, this value is `-(2 ** (bitWidth - 1))`, where `**` is
    /// exponentiation.
    public static var min: Self { get }

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: A tuple containing the result of the addition along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   sum. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated sum of this value
    ///   and `rhs`.
    public func addingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    /// the operation.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: A tuple containing the result of the subtraction along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   difference. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains the truncated result of `rhs`
    ///   subtracted from this value.
    public func subtractingReportingOverflow(_ rhs: Self) -> (partialValue: Self, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: A tuple containing the result of the multiplication along with
    ///   a Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   product. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated product of this
    ///   value and `rhs`.
    public func multipliedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Bool)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.dividedReportingOverflow(by: 0)` is `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the division along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   quotient. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains either the truncated quotient
    ///   or, if the quotient is undefined, the dividend.
    public func dividedReportingOverflow(by rhs: Self) -> (partialValue: Self, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.remainderReportingOverflow(dividingBy: 0)` is
    /// `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the operation along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   remainder. If the `overflow` component is `true`, an overflow occurred
    ///   during division and the `partialValue` component contains either the
    ///   entire remainder or, if the remainder is undefined, the dividend.
    public func remainderReportingOverflow(dividingBy rhs: Self) -> (partialValue: Self, overflow: Bool)

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    ///
    /// Use this method to calculate the full result of a product that would
    /// otherwise overflow. Unlike traditional truncating multiplication, the
    /// `multipliedFullWidth(by:)` method returns a tuple containing both the
    /// `high` and `low` parts of the product of this value and `other`. The
    /// following example uses this method to multiply two `Int8` values that
    /// normally overflow when multiplied:
    ///
    ///     let x: Int8 = 48
    ///     let y: Int8 = -40
    ///     let result = x.multipliedFullWidth(by: y)
    ///     // result.high == -8
    ///     // result.low  == 128
    ///
    /// The product of `x` and `y` is `-1920`, which is too large to represent in
    /// an `Int8` instance. The `high` and `low` compnents of the `result` value
    /// represent `-1920` when concatenated to form a double-width integer; that
    /// is, using `result.high` as the high byte and `result.low` as the low byte
    /// of an `Int16` instance.
    ///
    ///     let z = Int16(result.high) << 8 | Int16(result.low)
    ///     // z == -1920
    ///
    /// - Parameter other: The value to multiply this value by.
    /// - Returns: A tuple containing the high and low parts of the result of
    ///   multiplying this value and `other`.
    public func multipliedFullWidth(by other: Self) -> (high: Self, low: Self.Magnitude)

    /// Returns a tuple containing the quotient and remainder obtained by dividing
    /// the given value by this value.
    ///
    /// The resulting quotient must be representable within the bounds of the
    /// type. If the quotient is too large to represent in the type, a runtime
    /// error may occur.
    ///
    /// The following example divides a value that is too large to be represented
    /// using a single `Int` instance by another `Int` value. Because the quotient
    /// is representable as an `Int`, the division succeeds.
    ///
    ///     // 'dividend' represents the value 0x506f70652053616e74612049494949
    ///     let dividend = (22640526660490081, 7959093232766896457 as UInt)
    ///     let divisor = 2241543570477705381
    ///
    ///     let (quotient, remainder) = divisor.dividingFullWidth(dividend)
    ///     // quotient == 186319822866995413
    ///     // remainder == 0
    ///
    /// - Parameter dividend: A tuple containing the high and low parts of a
    ///   double-width integer.
    /// - Returns: A tuple containing the quotient and remainder obtained by
    ///   dividing `dividend` by this value.
    public func dividingFullWidth(_ dividend: (high: Self, low: Self.Magnitude)) -> (quotient: Self, remainder: Self)

    /// The number of bits equal to 1 in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has five bits equal to *1*.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.nonzeroBitCount == 5
    public var nonzeroBitCount: Int { get }

    /// The number of leading zeros in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has three leading zeros.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.leadingZeroBitCount == 3
    public var leadingZeroBitCount: Int { get }

    /// Creates an integer from its big-endian representation, changing the byte
    /// order if necessary.
    ///
    /// - Parameter value: A value to use as the big-endian representation of the
    ///   new integer.
    public init(bigEndian value: Self)

    /// Creates an integer from its little-endian representation, changing the
    /// byte order if necessary.
    ///
    /// - Parameter value: A value to use as the little-endian representation of
    ///   the new integer.
    public init(littleEndian value: Self)

    /// The big-endian representation of this integer.
    ///
    /// If necessary, the byte order of this value is reversed from the typical
    /// byte order of this integer type. On a big-endian platform, for any
    /// integer `x`, `x == x.bigEndian`.
    public var bigEndian: Self { get }

    /// The little-endian representation of this integer.
    ///
    /// If necessary, the byte order of this value is reversed from the typical
    /// byte order of this integer type. On a little-endian platform, for any
    /// integer `x`, `x == x.littleEndian`.
    public var littleEndian: Self { get }

    /// A representation of this integer with the byte order swapped.
    public var byteSwapped: Self { get }

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: Self, rhs: Self) -> Self

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= (lhs: inout Self, rhs: Self)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: Self, rhs: Self) -> Self

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= (lhs: inout Self, rhs: Self)
}

extension FixedWidthInteger {

    /// Creates a new integer value from the given string and radix.
    ///
    /// The string passed as `text` may begin with a plus or minus sign character
    /// (`+` or `-`), followed by one or more numeric digits (`0-9`) or letters
    /// (`a-z` or `A-Z`). Parsing of the string is case insensitive.
    ///
    ///     let x = Int("123")
    ///     // x == 123
    ///
    ///     let y = Int("-123", radix: 8)
    ///     // y == -83
    ///     let y = Int("+123", radix: 8)
    ///     // y == +83
    ///
    ///     let z = Int("07b", radix: 16)
    ///     // z == 123
    ///
    /// If `text` is in an invalid format or contains characters that are out of
    /// bounds for the given `radix`, or if the value it denotes in the given
    /// `radix` is not representable, the result is `nil`. For example, the
    /// following conversions result in `nil`:
    ///
    ///     Int(" 100")                       // Includes whitespace
    ///     Int("21-50")                      // Invalid format
    ///     Int("ff6600")                     // Characters out of bounds
    ///     Int("zzzzzzzzzzzzz", radix: 36)   // Out of range
    ///
    /// - Parameters:
    ///   - text: The ASCII representation of a number in the radix passed as
    ///     `radix`.
    ///   - radix: The radix, or base, to use for converting `text` to an integer
    ///     value. `radix` must be in the range `2...36`. The default is 10.
    public convenience init?<S>(_ text: S, radix: Int = default) where S : StringProtocol

    /// Creates a new integer value from the given string.
    ///
    /// The string passed as `description` may begin with a plus or minus sign
    /// character (`+` or `-`), followed by one or more numeric digits (`0-9`).
    ///
    ///     let x = Int("123")
    ///     // x == 123
    ///
    /// If `description` is in an invalid format, or if the value it denotes in
    /// base 10 is not representable, the result is `nil`. For example, the
    /// following conversions result in `nil`:
    ///
    ///     Int(" 100")                       // Includes whitespace
    ///     Int("21-50")                      // Invalid format
    ///     Int("ff6600")                     // Characters out of bounds
    ///     Int("10000000000000000000000000") // Out of range
    ///
    /// - Parameter description: The ASCII representation of a number.
    public convenience init?(_ description: String)
}

extension FixedWidthInteger {

    /// The number of bits in the binary representation of this value.
    public var bitWidth: Int { get }

    /// Creates an integer from its little-endian representation, changing the
    /// byte order if necessary.
    ///
    /// - Parameter value: A value to use as the little-endian representation of
    ///   the new integer.
    public convenience init(littleEndian value: Self)

    /// Creates an integer from its big-endian representation, changing the byte
    /// order if necessary.
    ///
    /// - Parameter value: A value to use as the big-endian representation of the
    ///   new integer.
    public convenience init(bigEndian value: Self)

    /// The little-endian representation of this integer.
    ///
    /// If necessary, the byte order of this value is reversed from the typical
    /// byte order of this integer type. On a little-endian platform, for any
    /// integer `x`, `x == x.littleEndian`.
    public var littleEndian: Self { get }

    /// The big-endian representation of this integer.
    ///
    /// If necessary, the byte order of this value is reversed from the typical
    /// byte order of this integer type. On a big-endian platform, for any
    /// integer `x`, `x == x.bigEndian`.
    public var bigEndian: Self { get }

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: Self, rhs: Self) -> Self

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> <Other>(lhs: Self, rhs: Other) -> Self where Other : BinaryInteger

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= <Other>(lhs: inout Self, rhs: Other) where Other : BinaryInteger

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: Self, rhs: Self) -> Self

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< <Other>(lhs: Self, rhs: Other) -> Self where Other : BinaryInteger

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= <Other>(lhs: inout Self, rhs: Other) where Other : BinaryInteger
}

extension FixedWidthInteger where Self.Magnitude : UnsignedInteger, Self.Stride : SignedInteger {

    /// Returns a random value within the specified range, using the given
    /// generator as a source for randomness.
    ///
    /// Use this method to generate an integer within a specific range when you
    /// are using a custom random number generator. This example creates three
    /// new values in the range `1..<100`.
    ///
    ///     for _ in 1...3 {
    ///         print(Int.random(in: 1..<100, using: &myGenerator))
    ///     }
    ///     // Prints "7"
    ///     // Prints "44"
    ///     // Prints "21"
    ///
    /// - Parameters:
    ///   - range: The range in which to create a random value.
    ///     `range` must not be empty.
    ///   - generator: The random number generator to use when creating the
    ///     new random value.
    /// - Returns: A random value within the bounds of `range`.
    public static func random<T>(in range: Range<Self>, using generator: inout T) -> Self where T : RandomNumberGenerator

    /// Returns a random value within the specified range.
    ///
    /// Use this method to generate an integer within a specific range. This
    /// example creates three new values in the range `1..<100`.
    ///
    ///     for _ in 1...3 {
    ///         print(Int.random(in: 1..<100))
    ///     }
    ///     // Prints "53"
    ///     // Prints "64"
    ///     // Prints "5"
    ///
    /// This method uses the default random generator, `Random.default`. The call
    /// to `Int.random(in: 1..<100)` above is equivalent to calling
    /// `Int.random(in: 1..<100, using: &Random.default)`.
    ///
    /// - Parameter range: The range in which to create a random value.
    ///   `range` must not be empty.
    /// - Returns: A random value within the bounds of `range`.
    public static func random(in range: Range<Self>) -> Self
}

extension FixedWidthInteger where Self.Magnitude : UnsignedInteger, Self.Stride : SignedInteger {

    /// Returns a random value within the specified range, using the given
    /// generator as a source for randomness.
    ///
    /// Use this method to generate an integer within a specific range when you
    /// are using a custom random number generator. This example creates three
    /// new values in the range `1...100`.
    ///
    ///     for _ in 1...3 {
    ///         print(Int.random(in: 1...100, using: &myGenerator))
    ///     }
    ///     // Prints "7"
    ///     // Prints "44"
    ///     // Prints "21"
    ///
    /// - Parameters:
    ///   - range: The range in which to create a random value.
    ///   - generator: The random number generator to use when creating the
    ///     new random value.
    /// - Returns: A random value within the bounds of `range`.
    public static func random<T>(in range: ClosedRange<Self>, using generator: inout T) -> Self where T : RandomNumberGenerator

    /// Returns a random value within the specified range.
    ///
    /// Use this method to generate an integer within a specific range. This
    /// example creates three new values in the range `1...100`.
    ///
    ///     for _ in 1...3 {
    ///         print(Int.random(in: 1...100))
    ///     }
    ///     // Prints "53"
    ///     // Prints "64"
    ///     // Prints "5"
    ///
    /// This method uses the default random generator, `Random.default`. The call
    /// to `Int.random(in: 1...100)` above is equivalent to calling
    /// `Int.random(in: 1...100, using: &Random.default)`.
    ///
    /// - Parameter range: The range in which to create a random value.
    /// - Returns: A random value within the bounds of `range`.
    public static func random(in range: ClosedRange<Self>) -> Self
}

extension FixedWidthInteger {

    /// Returns the inverse of the bits set in the argument.
    ///
    /// The bitwise NOT operator (`~`) is a prefix operator that returns a value
    /// in which all the bits of its argument are flipped: Bits that are `1` in
    /// the argument are `0` in the result, and bits that are `0` in the argument
    /// are `1` in the result. This is equivalent to the inverse of a set. For
    /// example:
    ///
    ///     let x: UInt8 = 5        // 0b00000101
    ///     let notX = ~x           // 0b11111010
    ///
    /// Performing a bitwise NOT operation on 0 returns a value with every bit
    /// set to `1`.
    ///
    ///     let allOnes = ~UInt8.min   // 0b11111111
    ///
    /// - Complexity: O(1).
    prefix public static func ~ (x: Self) -> Self

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right.
    ///
    /// The `>>` operator performs a *smart shift*, which defines a result for a
    /// shift of any value.
    ///
    /// - Using a negative value for `rhs` performs a left shift using
    ///   `abs(rhs)`.
    /// - Using a value for `rhs` that is greater than or equal to the bit width
    ///   of `lhs` is an *overshift*. An overshift results in `-1` for a
    ///   negative value of `lhs` or `0` for a nonnegative value.
    /// - Using any other value for `rhs` performs a right shift on `lhs` by that
    ///   amount.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the value is shifted right by two bits.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x >> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// If you use `11` as `rhs`, `x` is overshifted such that all of its bits
    /// are set to zero.
    ///
    ///     let z = x >> 11
    ///     // z == 0                         // 0b00000000
    ///
    /// Using a negative value as `rhs` is the same as performing a left shift
    /// using `abs(rhs)`.
    ///
    ///     let a = x >> -3
    ///     // a == 240                       // 0b11110000
    ///     let b = x << 3
    ///     // b == 240                       // 0b11110000
    ///
    /// Right shift operations on negative values "fill in" the high bits with
    /// ones instead of zeros.
    ///
    ///     let q: Int8 = -30                 // 0b11100010
    ///     let r = q >> 2
    ///     // r == -8                        // 0b11111000
    ///
    ///     let s = q >> 11
    ///     // s == -1                        // 0b11111111
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right.
    public static func >> <Other>(lhs: Self, rhs: Other) -> Self where Other : BinaryInteger

    public static func >>= <Other>(lhs: inout Self, rhs: Other) where Other : BinaryInteger

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left.
    ///
    /// The `<<` operator performs a *smart shift*, which defines a result for a
    /// shift of any value.
    ///
    /// - Using a negative value for `rhs` performs a right shift using
    ///   `abs(rhs)`.
    /// - Using a value for `rhs` that is greater than or equal to the bit width
    ///   of `lhs` is an *overshift*, resulting in zero.
    /// - Using any other value for `rhs` performs a left shift on `lhs` by that
    ///   amount.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the value is shifted left by two bits.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x << 2
    ///     // y == 120                       // 0b01111000
    ///
    /// If you use `11` as `rhs`, `x` is overshifted such that all of its bits
    /// are set to zero.
    ///
    ///     let z = x << 11
    ///     // z == 0                         // 0b00000000
    ///
    /// Using a negative value as `rhs` is the same as performing a right shift
    /// with `abs(rhs)`.
    ///
    ///     let a = x << -3
    ///     // a == 3                         // 0b00000011
    ///     let b = x >> 3
    ///     // b == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left.
    public static func << <Other>(lhs: Self, rhs: Other) -> Self where Other : BinaryInteger

    public static func <<= <Other>(lhs: inout Self, rhs: Other) where Other : BinaryInteger
}

extension FixedWidthInteger {

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero. Any fractional part of the value passed as `source` is removed.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...outside the representable range
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public convenience init<T>(_ source: T) where T : BinaryFloatingPoint

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public convenience init?<T>(exactly source: T) where T : BinaryFloatingPoint

    /// Creates a new instance with the representable value that's closest to the
    /// given integer.
    ///
    /// If the value passed as `source` is greater than the maximum representable
    /// value in this type, the result is the type's `max` value. If `source` is
    /// less than the smallest representable value in this type, the result is
    /// the type's `min` value.
    ///
    /// In this example, `x` is initialized as an `Int8` instance by clamping
    /// `500` to the range `-128...127`, and `y` is initialized as a `UInt`
    /// instance by clamping `-500` to the range `0...UInt.max`.
    ///
    ///     let x = Int8(clamping: 500)
    ///     // x == 127
    ///     // x == Int8.max
    ///
    ///     let y = UInt(clamping: -500)
    ///     // y == 0
    ///
    /// - Parameter source: An integer to convert to this type.
    public convenience init<Other>(clamping source: Other) where Other : BinaryInteger

    /// Returns the sum of this value and the given value without checking for
    /// arithmetic overflow.
    ///
    /// Use this function only to avoid the cost of overflow checking when you
    /// are certain that the operation won't overflow. In optimized builds (`-O`)
    /// the compiler is free to assume that overflow won't occur. Failure to
    /// satisfy that assumption is a serious programming error and could lead to
    /// statements being unexpectedly executed or skipped.
    ///
    /// In debug builds (`-Onone`) a runtime error is still triggered if the
    /// operation overflows.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: The sum of this value and `rhs`.
    public func unsafeAdding(_ other: Self) -> Self

    /// Returns the difference obtained by subtracting the given value from this
    /// value without checking for arithmetic overflow.
    ///
    /// Use this function only to avoid the cost of overflow checking when you
    /// are certain that the operation won't overflow. In optimized builds (`-O`)
    /// the compiler is free to assume that overflow won't occur. Failure to
    /// satisfy that assumption is a serious programming error and could lead to
    /// statements being unexpectedly executed or skipped.
    ///
    /// In debug builds (`-Onone`) a runtime error is still triggered if the
    /// operation overflows.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: The result of subtracting `rhs` from this value.
    public func unsafeSubtracting(_ other: Self) -> Self

    /// Returns the product of this value and the given value without checking
    /// for arithmetic overflow.
    ///
    /// Use this function only to avoid the cost of overflow checking when you
    /// are certain that the operation won't overflow. In optimized builds (`-O`)
    /// the compiler is free to assume that overflow won't occur. Failure to
    /// satisfy that assumption is a serious programming error and could lead to
    /// statements being unexpectedly executed or skipped.
    ///
    /// In debug builds (`-Onone`) a runtime error is still triggered if the
    /// operation overflows.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: The product of this value and `rhs`.
    public func unsafeMultiplied(by other: Self) -> Self

    /// Returns the quotient obtained by dividing this value by the given value
    /// without checking for arithmetic overflow.
    ///
    /// Use this function only to avoid the cost of overflow checking when you
    /// are certain that the operation won't overflow. In optimized builds (`-O`)
    /// the compiler is free to assume that overflow won't occur. Failure to
    /// satisfy that assumption is a serious programming error and could lead to
    /// statements being unexpectedly executed or skipped.
    ///
    /// In debug builds (`-Onone`) a runtime error is still triggered if the
    /// operation overflows.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: The result of dividing this value by `rhs`.
    public func unsafeDivided(by other: Self) -> Self

    /// Creates a new instance from the bit pattern of the given instance by
    /// truncating or sign-extending if needed to fit this type.
    ///
    /// When the bit width of `T` (the type of `source`) is equal to or greater
    /// than this type's bit width, the result is the truncated
    /// least-significant bits of `source`. For example, when converting a
    /// 16-bit value to an 8-bit type, only the lower 8 bits of `source` are
    /// used.
    ///
    ///     let p: Int16 = -500
    ///     // 'p' has a binary representation of 11111110_00001100
    ///     let q = Int8(truncatingIfNeeded: p)
    ///     // q == 12
    ///     // 'q' has a binary representation of 00001100
    ///
    /// When the bit width of `T` is less than this type's bit width, the result
    /// is *sign-extended* to fill the remaining bits. That is, if `source` is
    /// negative, the result is padded with ones; otherwise, the result is
    /// padded with zeros.
    ///
    ///     let u: Int8 = 21
    ///     // 'u' has a binary representation of 00010101
    ///     let v = Int16(truncatingIfNeeded: u)
    ///     // v == 21
    ///     // 'v' has a binary representation of 00000000_00010101
    ///
    ///     let w: Int8 = -21
    ///     // 'w' has a binary representation of 11101011
    ///     let x = Int16(truncatingIfNeeded: w)
    ///     // x == -21
    ///     // 'x' has a binary representation of 11111111_11101011
    ///     let y = UInt16(truncatingIfNeeded: w)
    ///     // y == 65515
    ///     // 'y' has a binary representation of 11111111_11101011
    ///
    /// - Parameter source: An integer to convert to this type.
    public convenience init<T>(truncatingIfNeeded source: T) where T : BinaryInteger

    /// Returns the sum of the two given values, discarding any overflow.
    ///
    /// The masking addition operator (`&+`) silently discards any overflow that
    /// occurs during the operation. In the following example, the sum of `100`
    /// and `121` is greater than the maximum representable `Int8` value, so the
    /// result is the overflowed value:
    ///
    ///     let x: Int8 = 10 &+ 21
    ///     // x == 31
    ///     let y: Int8 = 100 &+ 121
    ///     // y == -35 (after overflow)
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func &+ (lhs: Self, rhs: Self) -> Self

    /// Adds two values and stores the result in the left-hand-side variable, 
    /// discarding any overflow.
    ///
    /// The masking addition assignment operator (`&+=`) silently discards any 
    /// overflow that occurs during the operation. In the following example, the 
    /// sum of `100` and `121` is greater than the maximum representable `Int8` 
    /// value, so the result is the overflowed value:
    ///
    ///     var x: Int8 = 10
    ///     x &+= 21
    ///     // x == 31
    ///     var y: Int8 = 100
    ///     y &+= 121
    ///     // y == -35 (after overflow)
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func &+= (lhs: inout Self, rhs: Self)

    /// Returns the difference of the two given values, discarding any overflow.
    ///
    /// The masking subtraction operator (`&-`) silently discards any overflow
    /// that occurs during the operation. In the following example, the
    /// difference of `10` and `21` is less than zero, the minimum representable
    /// `UInt` value, so the result is the overflowed value:
    ///
    ///     let x: UInt8 = 21 &- 10
    ///     // x == 11
    ///     let y: UInt8 = 10 &- 21
    ///     // y == 245 (after overflow)
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func &- (lhs: Self, rhs: Self) -> Self

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable, discarding any overflow.
    ///
    /// The masking subtraction assignment operator (`&-=`) silently discards any
    /// overflow that occurs during the operation. In the following example, the
    /// difference of `10` and `21` is less than zero, the minimum representable
    /// `UInt` value, so the result is the overflowed value:
    ///
    ///     var x: Int8 = 21
    ///     x &-= 10
    ///     // x == 11
    ///     var y: UInt8 = 10
    ///     y &-= 21
    ///     // y == 245 (after overflow)
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func &-= (lhs: inout Self, rhs: Self)

    /// Returns the product of the two given values, discarding any overflow.
    ///
    /// The masking multiplication operator (`&*`) silently discards any overflow
    /// that occurs during the operation. In the following example, the product
    /// of `10` and `50` is greater than the maximum representable `Int8` value,
    /// so the result is the overflowed value:
    ///
    ///     let x: Int8 = 10 &* 5
    ///     // x == 50
    ///     let y: Int8 = 10 &* 50
    ///     // y == -12 (after overflow)
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func &* (lhs: Self, rhs: Self) -> Self

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable, discarding any overflow.
    ///
    /// The masking multiplication assignment operator (`&*=`) silently discards 
    /// any overflow that occurs during the operation. In the following example, 
    /// the product of `10` and `50` is greater than the maximum representable 
    /// `Int8` value, so the result is the overflowed value:
    ///
    ///     var x: Int8 = 10
    ///     x &*= 5
    ///     // x == 50
    ///     var y: Int8 = 10
    ///     y &*= 50
    ///     // y == -12 (after overflow)
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func &*= (lhs: inout Self, rhs: Self)
}

@available(*, deprecated, renamed: "FlattenCollection")
public typealias FlattenBidirectionalCollection<T> = FlattenCollection<T>

@available(*, deprecated, renamed: "FlattenCollection.Index")
public typealias FlattenBidirectionalCollectionIndex<T> = FlattenCollection<T>.Index

/// A flattened view of a base collection of collections.
///
/// The elements of this view are a concatenation of the elements of
/// each collection in the base.
///
/// The `joined` method is always lazy, but does not implicitly
/// confer laziness on algorithms applied to its result.  In other
/// words, for ordinary collections `c`:
///
/// * `c.joined()` does not create new storage
/// * `c.joined().map(f)` maps eagerly and returns a new array
/// * `c.lazy.joined().map(f)` maps lazily and returns a `LazyMapCollection`
///
/// - Note: The performance of accessing `startIndex`, `first`, any methods
///   that depend on `startIndex`, or of advancing an `Index`
///   depends on how many empty subcollections are found in the base
///   collection, and may not offer the usual performance given by `Collection`
///   or `Index`. Be aware, therefore, that general operation on
///   `FlattenCollection` instances may not have the documented complexity.
///
/// - See also: `FlattenSequence`
public struct FlattenCollection<Base> where Base : Collection, Base.Element : Collection {

    /// Creates a flattened view of `base`.
    public init(_ base: Base)
}

extension FlattenCollection where Base : Collection, Base.Element : Collection {

    /// A position in a FlattenCollection
    public struct Index {
    }
}

extension FlattenCollection : Sequence where Base : Collection, Base.Element : Collection {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = FlattenSequence<Base>.Iterator

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = Slice<FlattenCollection<Base>>

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> FlattenCollection<Base>.Iterator

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: (Base.Element.Element) throws -> Void) rethrows
}

extension FlattenCollection : Collection where Base : Collection, Base.Element : Collection {

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: FlattenCollection<Base>.Index { get }

    /// The collection's "past the end" position.
    ///
    /// `endIndex` is not a valid argument to `subscript`, and is always
    /// reachable from `startIndex` by zero or more applications of
    /// `index(after:)`.
    public var endIndex: FlattenCollection<Base>.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: FlattenCollection<Base>.Index) -> FlattenCollection<Base>.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout FlattenCollection<Base>.Index)

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: FlattenCollection<Base>.Index, to end: FlattenCollection<Base>.Index) -> Int

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: FlattenCollection<Base>.Index, offsetBy n: Int) -> FlattenCollection<Base>.Index

    public func formIndex(_ i: inout FlattenCollection<Base>.Index, offsetBy n: Int)

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: FlattenCollection<Base>.Index, offsetBy n: Int, limitedBy limit: FlattenCollection<Base>.Index) -> FlattenCollection<Base>.Index?

    public func formIndex(_ i: inout FlattenCollection<Base>.Index, offsetBy n: Int, limitedBy limit: FlattenCollection<Base>.Index) -> Bool

    /// Accesses the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: FlattenCollection<Base>.Index) -> Base.Element.Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// For example, using a `PartialRangeFrom` range expression with an array
    /// accesses the subrange from the start of the range expression until the
    /// end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2..<5]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. This example searches `streetsSlice` for one of the
    /// strings in the slice, and then uses that index in the original array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")!    // 4
    ///     print(streets[index])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice may result in a runtime
    /// error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<FlattenCollection<Base>.Index>) -> FlattenCollection<Base>.SubSequence { get }
}

extension FlattenCollection : BidirectionalCollection where Base : BidirectionalCollection, Base.Element : BidirectionalCollection {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: FlattenCollection<Base>.Index) -> FlattenCollection<Base>.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout FlattenCollection<Base>.Index)
}

extension FlattenCollection.Index : Equatable where Base : Collection, Base.Element : Collection {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: FlattenCollection<Base>.Index, rhs: FlattenCollection<Base>.Index) -> Bool
}

extension FlattenCollection.Index : Comparable where Base : Collection, Base.Element : Collection {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: FlattenCollection<Base>.Index, rhs: FlattenCollection<Base>.Index) -> Bool
}

extension FlattenCollection.Index : Hashable where Base : Collection, Base.Element : Collection, Base.Index : Hashable, Base.Element.Index : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

public typealias FlattenCollectionIndex<T> = FlattenCollection<T>.Index

/// A sequence consisting of all the elements contained in each segment
/// contained in some `Base` sequence.
///
/// The elements of this view are a concatenation of the elements of
/// each sequence in the base.
///
/// The `joined` method is always lazy, but does not implicitly
/// confer laziness on algorithms applied to its result.  In other
/// words, for ordinary sequences `s`:
///
/// * `s.joined()` does not create new storage
/// * `s.joined().map(f)` maps eagerly and returns a new array
/// * `s.lazy.joined().map(f)` maps lazily and returns a `LazyMapSequence`
///
/// - See also: `FlattenCollection`
public struct FlattenSequence<Base> where Base : Sequence, Base.Element : Sequence {
}

extension FlattenSequence where Base : Sequence, Base.Element : Sequence {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator {
    }
}

extension FlattenSequence : Sequence where Base : Sequence, Base.Element : Sequence {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> FlattenSequence<Base>.Iterator
}

extension FlattenSequence.Iterator : IteratorProtocol where Base : Sequence, Base.Element : Sequence {

    /// The type of element traversed by the iterator.
    public typealias Element = Base.Element.Element

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    ///
    /// - Precondition: `next()` has not been applied to a copy of `self`
    ///   since the copy was made.
    public mutating func next() -> FlattenSequence<Base>.Iterator.Element?
}

/// A single-precision, floating-point value type.
public struct Float {

    /// Creates a value initialized to zero.
    public init()
}

extension Float : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Float : LosslessStringConvertible {

    /// Creates a new instance from the given string.
    ///
    /// The string passed as `text` can represent a real number in decimal or
    /// hexadecimal format or special floating-point values for infinity and NaN
    /// ("not a number").
    ///
    /// The given string may begin with a plus or minus sign character (`+` or
    /// `-`). The allowed formats for each of these representations is then as
    /// follows:
    ///
    /// - A *decimal value* contains the significand, a sequence of decimal
    ///   digits that may include a decimal point.
    ///
    ///       let c = Float("-1.0")
    ///       // c == -1.0
    ///
    ///       let d = Float("28.375")
    ///       // d == 28.375
    ///
    ///   A decimal value may also include an exponent following the significand,
    ///   indicating the power of 10 by which the significand should be
    ///   multiplied. If included, the exponent is separated by a single
    ///   character, `e` or `E`, and consists of an optional plus or minus sign
    ///   character and a sequence of decimal digits.
    ///
    ///       let e = Float("2837.5e-2")
    ///       // e == 28.375
    ///
    /// - A *hexadecimal value* contains the significand, either `0X` or `0x`,
    ///   followed by a sequence of hexadecimal digits. The significand may
    ///   include a decimal point.
    ///
    ///       let f = Float("0x1c.6")
    ///       // f == 28.375
    ///
    ///   A hexadecimal value may also include an exponent following the
    ///   significand, indicating the power of 2 by which the significand should
    ///   be multiplied. If included, the exponent is separated by a single
    ///   character, `p` or `P`, and consists of an optional plus or minus sign
    ///   character and a sequence of decimal digits.
    ///
    ///       let g = Float("0x1.c6p4")
    ///       // g == 28.375
    ///
    /// - A value of *infinity* contains one of the strings `"inf"` or
    ///   `"infinity"`, case insensitive.
    ///
    ///       let i = Float("inf")
    ///       // i == Float.infinity
    ///
    ///       let j = Float("-Infinity")
    ///       // j == -Float.infinity
    ///
    /// - A value of *NaN* contains the string `"nan"`, case insensitive.
    ///
    ///       let n = Float("-nan")
    ///       // n?.isNaN == true
    ///       // n?.sign == .minus
    ///
    ///   A NaN value may also include a payload in parentheses following the
    ///   `"nan"` keyword. The payload consists of a sequence of decimal digits,
    ///   or the characters `0X` or `0x` followed by a sequence of hexadecimal
    ///   digits. If the payload contains any other characters, it is ignored.
    ///   If the value of the payload is larger than can be stored as the
    ///   payload of a `Float.nan`, the least significant bits are used.
    ///
    ///       let p = Float("nan(0x10)")
    ///       // p?.isNaN == true
    ///       // String(p!) == "nan(0x10)"
    ///
    /// Passing any other format or any additional characters as `text` results
    /// in `nil`. For example, the following conversions result in `nil`:
    ///
    ///     Float(" 5.0")      // Includes whitespace
    ///     Float("2.0")      // Invalid character
    ///     Float("0x1.25e4")  // Incorrect exponent format
    ///
    /// - Parameter text: The input string to convert to a `Float` instance. If
    ///   `text` has invalid characters or is in an invalid format, the result
    ///   is `nil`.
    public init?<S>(_ text: S) where S : StringProtocol
}

extension Float : CustomStringConvertible {

    /// A textual representation of the value.
    public var description: String { get }
}

extension Float : CustomDebugStringConvertible {

    /// A textual representation of the value, suitable for debugging.
    public var debugDescription: String { get }
}

extension Float : BinaryFloatingPoint {

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = Float

    /// A type that can represent any written exponent.
    public typealias Exponent = Int

    /// A type that represents the encoded significand of a value.
    public typealias RawSignificand = UInt32

    /// The number of bits used to represent the type's exponent.
    ///
    /// A binary floating-point type's `exponentBitCount` imposes a limit on the
    /// range of the exponent for normal, finite values. The *exponent bias* of
    /// a type `F` can be calculated as the following, where `**` is
    /// exponentiation:
    ///
    ///     let bias = 2 ** (F.exponentBitCount - 1) - 1
    ///
    /// The least normal exponent for values of the type `F` is `1 - bias`, and
    /// the largest finite exponent is `bias`. An all-zeros exponent is reserved
    /// for subnormals and zeros, and an all-ones exponent is reserved for
    /// infinity and NaN.
    ///
    /// For example, the `Float` type has an `exponentBitCount` of 8, which gives
    /// an exponent bias of `127` by the calculation above.
    ///
    ///     let bias = 2 ** (Float.exponentBitCount - 1) - 1
    ///     // bias == 127
    ///     print(Float.greatestFiniteMagnitude.exponent)
    ///     // Prints "127"
    ///     print(Float.leastNormalMagnitude.exponent)
    ///     // Prints "-126"
    public static var exponentBitCount: Int { get }

    /// The available number of fractional significand bits.
    ///
    /// For fixed-width floating-point types, this is the actual number of
    /// fractional significand bits.
    ///
    /// For extensible floating-point types, `significandBitCount` should be the
    /// maximum allowed significand width (without counting any leading integral
    /// bit of the significand). If there is no upper limit, then
    /// `significandBitCount` should be `Int.max`.
    public static var significandBitCount: Int { get }

    /// The bit pattern of the value's encoding.
    ///
    /// The bit pattern matches the binary interchange format defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var bitPattern: UInt32 { get }

    /// Creates a new value with the given bit pattern.
    ///
    /// The value passed as `bitPattern` is interpreted in the binary interchange
    /// format defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter bitPattern: The integer encoding of a `Float` instance.
    public init(bitPattern: UInt32)

    /// The sign of the floating-point value.
    ///
    /// The `sign` property is `.minus` if the value's signbit is set, and
    /// `.plus` otherwise. For example:
    ///
    ///     let x = -33.375
    ///     // x.sign == .minus
    ///
    /// Do not use this property to check whether a floating point value is
    /// negative. For a value `x`, the comparison `x.sign == .minus` is not
    /// necessarily the same as `x < 0`. In particular, `x.sign == .minus` if
    /// `x` is -0, and while `x < 0` is always `false` if `x` is NaN, `x.sign`
    /// could be either `.plus` or `.minus`.
    public var sign: FloatingPointSign { get }

    /// The raw encoding of the value's exponent field.
    ///
    /// This value is unadjusted by the type's exponent bias.
    public var exponentBitPattern: UInt { get }

    /// The raw encoding of the value's significand field.
    ///
    /// The `significandBitPattern` property does not include the leading
    /// integral bit of the significand, even for types like `Float80` that
    /// store it explicitly.
    public var significandBitPattern: UInt32 { get }

    /// Creates a new instance from the specified sign and bit patterns.
    ///
    /// The values passed as `exponentBitPattern` and `significandBitPattern` are
    /// interpreted in the binary interchange format defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - sign: The sign of the new value.
    ///   - exponentBitPattern: The bit pattern to use for the exponent field of
    ///     the new value.
    ///   - significandBitPattern: The bit pattern to use for the significand
    ///     field of the new value.
    public init(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt32)

    /// A Boolean value indicating whether the instance's representation is in
    /// the canonical form.
    ///
    /// The [IEEE 754 specification][spec] defines a *canonical*, or preferred,
    /// encoding of a floating-point value's representation. Every `Float` or
    /// `Double` value is canonical, but noncanonical values of the `Float80`
    /// type exist, and noncanonical values may exist for other types that
    /// conform to the `FloatingPoint` protocol.
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var isCanonical: Bool { get }

    /// Positive infinity.
    ///
    /// Infinity compares greater than all finite numbers and equal to other
    /// infinite values.
    ///
    ///     let x = Double.greatestFiniteMagnitude
    ///     let y = x * 2
    ///     // y == Double.infinity
    ///     // y > x
    public static var infinity: Float { get }

    /// A quiet NaN ("not a number").
    ///
    /// A NaN compares not equal, not greater than, and not less than every
    /// value, including itself. Passing a NaN to an operation generally results
    /// in NaN.
    ///
    ///     let x = 1.21
    ///     // x > Double.nan == false
    ///     // x < Double.nan == false
    ///     // x == Double.nan == false
    ///
    /// Because a NaN always compares not equal to itself, to test whether a
    /// floating-point value is NaN, use its `isNaN` property instead of the
    /// equal-to operator (`==`). In the following example, `y` is NaN.
    ///
    ///     let y = x + Double.nan
    ///     print(y == Double.nan)
    ///     // Prints "false"
    ///     print(y.isNaN)
    ///     // Prints "true"
    public static var nan: Float { get }

    /// A signaling NaN ("not a number").
    ///
    /// The default IEEE 754 behavior of operations involving a signaling NaN is
    /// to raise the Invalid flag in the floating-point environment and return a
    /// quiet NaN.
    ///
    /// Operations on types conforming to the `FloatingPoint` protocol should
    /// support this behavior, but they might also support other options. For
    /// example, it would be reasonable to implement alternative operations in
    /// which operating on a signaling NaN triggers a runtime error or results
    /// in a diagnostic for debugging purposes. Types that implement alternative
    /// behaviors for a signaling NaN must document the departure.
    ///
    /// Other than these signaling operations, a signaling NaN behaves in the
    /// same manner as a quiet NaN.
    public static var signalingNaN: Float { get }

    /// The greatest finite number representable by this type.
    ///
    /// This value compares greater than or equal to all finite numbers, but less
    /// than `infinity`.
    ///
    /// This value corresponds to type-specific C macros such as `FLT_MAX` and
    /// `DBL_MAX`. The naming of those macros is slightly misleading, because
    /// `infinity` is greater than this value.
    public static var greatestFiniteMagnitude: Float { get }

    /// The mathematical constant pi.
    ///
    /// This value should be rounded toward zero to keep user computations with
    /// angles from inadvertently ending up in the wrong quadrant. A type that
    /// conforms to the `FloatingPoint` protocol provides the value for `pi` at
    /// its best possible precision.
    ///
    ///     print(Double.pi)
    ///     // Prints "3.14159265358979"
    public static var pi: Float { get }

    /// The unit in the last place of this value.
    ///
    /// This is the unit of the least significant digit in this value's
    /// significand. For most numbers `x`, this is the difference between `x`
    /// and the next greater (in magnitude) representable number. There are some
    /// edge cases to be aware of:
    ///
    /// - If `x` is not a finite number, then `x.ulp` is NaN.
    /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal
    ///   number. If a type does not support subnormals, `x.ulp` may be rounded
    ///   to zero.
    /// - `greatestFiniteMagnitude.ulp` is a finite number, even though the next
    ///   greater representable value is `infinity`.
    ///
    /// This quantity, or a related quantity, is sometimes called *epsilon* or
    /// *machine epsilon.* Avoid that name because it has different meanings in
    /// different languages, which can lead to confusion, and because it
    /// suggests that it is a good tolerance to use for comparisons, which it
    /// almost never is.
    public var ulp: Float { get }

    /// The least positive normal number.
    ///
    /// This value compares less than or equal to all positive normal numbers.
    /// There may be smaller positive numbers, but they are *subnormal*, meaning
    /// that they are represented with less precision than normal numbers.
    ///
    /// This value corresponds to type-specific C macros such as `FLT_MIN` and
    /// `DBL_MIN`. The naming of those macros is slightly misleading, because
    /// subnormals, zeros, and negative numbers are smaller than this value.
    public static var leastNormalMagnitude: Float { get }

    /// The least positive number.
    ///
    /// This value compares less than or equal to all positive numbers, but
    /// greater than zero. If the type supports subnormal values,
    /// `leastNonzeroMagnitude` is smaller than `leastNormalMagnitude`;
    /// otherwise they are equal.
    public static var leastNonzeroMagnitude: Float { get }

    /// The unit in the last place of 1.0.
    ///
    /// The positive difference between 1.0 and the next greater representable
    /// number. The `ulpOfOne` constant corresponds to the C macros
    /// `FLT_EPSILON`, `DBL_EPSILON`, and others with a similar purpose.
    public static var ulpOfOne: Float { get }

    /// The exponent of the floating-point value.
    ///
    /// The *exponent* of a floating-point value is the integer part of the
    /// logarithm of the value's magnitude. For a value `x` of a floating-point
    /// type `F`, the magnitude can be calculated as the following, where `**`
    /// is exponentiation:
    ///
    ///     let magnitude = x.significand * F.radix ** x.exponent
    ///
    /// In the next example, `y` has a value of `21.5`, which is encoded as
    /// `1.34375 * 2 ** 4`. The significand of `y` is therefore 1.34375.
    ///
    ///     let y: Double = 21.5
    ///     // y.significand == 1.34375
    ///     // y.exponent == 4
    ///     // Double.radix == 2
    ///
    /// The `exponent` property has the following edge cases:
    ///
    /// - If `x` is zero, then `x.exponent` is `Int.min`.
    /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`
    ///
    /// This property implements the `logB` operation defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var exponent: Int { get }

    /// The significand of the floating-point value.
    ///
    /// The magnitude of a floating-point value `x` of type `F` can be calculated
    /// by using the following formula, where `**` is exponentiation:
    ///
    ///     let magnitude = x.significand * F.radix ** x.exponent
    ///
    /// In the next example, `y` has a value of `21.5`, which is encoded as
    /// `1.34375 * 2 ** 4`. The significand of `y` is therefore 1.34375.
    ///
    ///     let y: Double = 21.5
    ///     // y.significand == 1.34375
    ///     // y.exponent == 4
    ///     // Double.radix == 2
    ///
    /// If a type's radix is 2, then for finite nonzero numbers, the significand
    /// is in the range `1.0 ..< 2.0`. For other values of `x`, `x.significand`
    /// is defined as follows:
    ///
    /// - If `x` is zero, then `x.significand` is 0.0.
    /// - If `x` is infinity, then `x.significand` is 1.0.
    /// - If `x` is NaN, then `x.significand` is NaN.
    /// - Note: The significand is frequently also called the *mantissa*, but
    ///   significand is the preferred terminology in the [IEEE 754
    ///   specification][spec], to allay confusion with the use of mantissa for
    ///   the fractional part of a logarithm.
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var significand: Float { get }

    /// Creates a new value from the given sign, exponent, and significand.
    ///
    /// The following example uses this initializer to create a new `Double`
    /// instance. `Double` is a binary floating-point type that has a radix of
    /// `2`.
    ///
    ///     let x = Double(sign: .plus, exponent: -2, significand: 1.5)
    ///     // x == 0.375
    ///
    /// This initializer is equivalent to the following calculation, where `**`
    /// is exponentiation, computed as if by a single, correctly rounded,
    /// floating-point operation:
    ///
    ///     let sign: FloatingPointSign = .plus
    ///     let exponent = -2
    ///     let significand = 1.5
    ///     let y = (sign == .minus ? -1 : 1) * significand * Double.radix ** exponent
    ///     // y == 0.375
    ///
    /// As with any basic operation, if this value is outside the representable
    /// range of the type, overflow or underflow occurs, and zero, a subnormal
    /// value, or infinity may result. In addition, there are two other edge
    /// cases:
    ///
    /// - If the value you pass to `significand` is zero or infinite, the result
    ///   is zero or infinite, regardless of the value of `exponent`.
    /// - If the value you pass to `significand` is NaN, the result is NaN.
    ///
    /// For any floating-point value `x` of type `F`, the result of the following
    /// is equal to `x`, with the distinction that the result is canonicalized
    /// if `x` is in a noncanonical encoding:
    ///
    ///     let x0 = F(sign: x.sign, exponent: x.exponent, significand: x.significand)
    ///
    /// This initializer implements the `scaleB` operation defined by the [IEEE
    /// 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - sign: The sign to use for the new value.
    ///   - exponent: The new value's exponent.
    ///   - significand: The new value's significand.
    public init(sign: FloatingPointSign, exponent: Int, significand: Float)

    /// Creates a NaN ("not a number") value with the specified payload.
    ///
    /// NaN values compare not equal to every value, including themselves. Most
    /// operations with a NaN operand produce a NaN result. Don't use the
    /// equal-to operator (`==`) to test whether a value is NaN. Instead, use
    /// the value's `isNaN` property.
    ///
    ///     let x = Float(nan: 0, signaling: false)
    ///     print(x == .nan)
    ///     // Prints "false"
    ///     print(x.isNaN)
    ///     // Prints "true"
    ///
    /// - Parameters:
    ///   - payload: The payload to use for the new NaN value.
    ///   - signaling: Pass `true` to create a signaling NaN or `false` to create
    ///     a quiet NaN.
    public init(nan payload: Float.RawSignificand, signaling: Bool)

    /// The least representable value that compares greater than this value.
    ///
    /// For any finite value `x`, `x.nextUp` is greater than `x`. For `nan` or
    /// `infinity`, `x.nextUp` is `x` itself. The following special cases also
    /// apply:
    ///
    /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestFiniteMagnitude`.
    /// - If `x` is `-leastNonzeroMagnitude`, then `x.nextUp` is `-0.0`.
    /// - If `x` is zero, then `x.nextUp` is `leastNonzeroMagnitude`.
    /// - If `x` is `greatestFiniteMagnitude`, then `x.nextUp` is `infinity`.
    public var nextUp: Float { get }

    /// Rounds the value to an integral value using the specified rounding rule.
    ///
    /// The following example rounds a value using four different rounding rules:
    ///
    ///     // Equivalent to the C 'round' function:
    ///     var w = 6.5
    ///     w.round(.toNearestOrAwayFromZero)
    ///     // w == 7.0
    ///
    ///     // Equivalent to the C 'trunc' function:
    ///     var x = 6.5
    ///     x.round(.towardZero)
    ///     // x == 6.0
    ///
    ///     // Equivalent to the C 'ceil' function:
    ///     var y = 6.5
    ///     y.round(.up)
    ///     // y == 7.0
    ///
    ///     // Equivalent to the C 'floor' function:
    ///     var z = 6.5
    ///     z.round(.down)
    ///     // z == 6.0
    ///
    /// For more information about the available rounding rules, see the
    /// `FloatingPointRoundingRule` enumeration. To round a value using the
    /// default "schoolbook rounding", you can use the shorter `round()` method
    /// instead.
    ///
    ///     var w1 = 6.5
    ///     w1.round()
    ///     // w1 == 7.0
    ///
    /// - Parameter rule: The rounding rule to use.
    public mutating func round(_ rule: FloatingPointRoundingRule)

    /// Replaces this value with its additive inverse.
    ///
    /// The result is always exact. This example uses the `negate()` method to
    /// negate the value of the variable `x`:
    ///
    ///     var x = 21.5
    ///     x.negate()
    ///     // x == -21.5
    public mutating func negate()

    /// Adds two values and stores the result in the left-hand-side variable,
    /// rounded to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Float, rhs: Float)

    /// Subtracts the second value from the first and stores the difference in
    /// the left-hand-side variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Float, rhs: Float)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Float, rhs: Float)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by.
    public static func /= (lhs: inout Float, rhs: Float)

    /// Replaces this value with the remainder of itself divided by the given
    /// value.
    ///
    /// For two finite values `x` and `y`, the remainder `r` of dividing `x` by
    /// `y` satisfies `x == y * q + r`, where `q` is the integer nearest to
    /// `x / y`. If `x / y` is exactly halfway between two integers, `q` is
    /// chosen to be even. Note that `q` is *not* `x / y` computed in
    /// floating-point arithmetic, and that `q` may not be representable in any
    /// available integer type.
    ///
    /// The following example calculates the remainder of dividing 8.625 by 0.75:
    ///
    ///     var x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.toNearestOrEven)
    ///     // q == 12.0
    ///     x.formRemainder(dividingBy: 0.75)
    ///     // x == -0.375
    ///
    ///     let x1 = 0.75 * q + x
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are finite numbers, the remainder is in the
    /// closed range `-abs(other / 2)...abs(other / 2)`. The
    /// `formRemainder(dividingBy:)` method is always exact.
    ///
    /// - Parameter other: The value to use when dividing this value.
    public mutating func formRemainder(dividingBy other: Float)

    /// Replaces this value with the remainder of itself divided by the given
    /// value using truncating division.
    ///
    /// Performing truncating division with floating-point values results in a
    /// truncated integer quotient and a remainder. For values `x` and `y` and
    /// their truncated integer quotient `q`, the remainder `r` satisfies
    /// `x == y * q + r`.
    ///
    /// The following example calculates the truncating remainder of dividing
    /// 8.625 by 0.75:
    ///
    ///     var x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.towardZero)
    ///     // q == 11.0
    ///     x.formTruncatingRemainder(dividingBy: 0.75)
    ///     // x == 0.375
    ///
    ///     let x1 = 0.75 * q + x
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are both finite numbers, the truncating
    /// remainder has the same sign as this value and is strictly smaller in
    /// magnitude than `other`. The `formTruncatingRemainder(dividingBy:)`
    /// method is always exact.
    ///
    /// - Parameter other: The value to use when dividing this value.
    public mutating func formTruncatingRemainder(dividingBy other: Float)

    /// Replaces this value with its square root, rounded to a representable
    /// value.
    public mutating func formSquareRoot()

    /// Adds the product of the two given values to this value in place, computed
    /// without intermediate rounding.
    ///
    /// - Parameters:
    ///   - lhs: One of the values to multiply before adding to this value.
    ///   - rhs: The other value to multiply.
    public mutating func addProduct(_ lhs: Float, _ rhs: Float)

    /// Returns a Boolean value indicating whether this instance is equal to the
    /// given value.
    ///
    /// This method serves as the basis for the equal-to operator (`==`) for
    /// floating-point values. When comparing two values with this method, `-0`
    /// is equal to `+0`. NaN is not equal to any value, including itself. For
    /// example:
    ///
    ///     let x = 15.0
    ///     x.isEqual(to: 15.0)
    ///     // true
    ///     x.isEqual(to: .nan)
    ///     // false
    ///     Double.nan.isEqual(to: .nan)
    ///     // false
    ///
    /// The `isEqual(to:)` method implements the equality predicate defined by
    /// the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if `other` has the same value as this instance;
    ///   otherwise, `false`.
    public func isEqual(to other: Float) -> Bool

    /// Returns a Boolean value indicating whether this instance is less than the
    /// given value.
    ///
    /// This method serves as the basis for the less-than operator (`<`) for
    /// floating-point values. Some special cases apply:
    ///
    /// - Because NaN compares not less than nor greater than any value, this
    ///   method returns `false` when called on NaN or when NaN is passed as
    ///   `other`.
    /// - `-infinity` compares less than all values except for itself and NaN.
    /// - Every value except for NaN and `+infinity` compares less than
    ///   `+infinity`.
    ///
    ///     let x = 15.0
    ///     x.isLess(than: 20.0)
    ///     // true
    ///     x.isLess(than: .nan)
    ///     // false
    ///     Double.nan.isLess(than: x)
    ///     // false
    ///
    /// The `isLess(than:)` method implements the less-than predicate defined by
    /// the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if `other` is less than this value; otherwise, `false`.
    public func isLess(than other: Float) -> Bool

    /// Returns a Boolean value indicating whether this instance is less than or
    /// equal to the given value.
    ///
    /// This method serves as the basis for the less-than-or-equal-to operator
    /// (`<=`) for floating-point values. Some special cases apply:
    ///
    /// - Because NaN is incomparable with any value, this method returns `false`
    ///   when called on NaN or when NaN is passed as `other`.
    /// - `-infinity` compares less than or equal to all values except NaN.
    /// - Every value except NaN compares less than or equal to `+infinity`.
    ///
    ///     let x = 15.0
    ///     x.isLessThanOrEqualTo(20.0)
    ///     // true
    ///     x.isLessThanOrEqualTo(.nan)
    ///     // false
    ///     Double.nan.isLessThanOrEqualTo(x)
    ///     // false
    ///
    /// The `isLessThanOrEqualTo(_:)` method implements the less-than-or-equal
    /// predicate defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if `other` is less than this value; otherwise, `false`.
    public func isLessThanOrEqualTo(_ other: Float) -> Bool

    /// A Boolean value indicating whether this instance is normal.
    ///
    /// A *normal* value is a finite number that uses the full precision
    /// available to values of a type. Zero is neither a normal nor a subnormal
    /// number.
    public var isNormal: Bool { get }

    /// A Boolean value indicating whether this instance is finite.
    ///
    /// All values other than NaN and infinity are considered finite, whether
    /// normal or subnormal.
    public var isFinite: Bool { get }

    /// A Boolean value indicating whether the instance is equal to zero.
    ///
    /// The `isZero` property of a value `x` is `true` when `x` represents either
    /// `-0.0` or `+0.0`. `x.isZero` is equivalent to the following comparison:
    /// `x == 0.0`.
    ///
    ///     let x = -0.0
    ///     x.isZero        // true
    ///     x == 0.0        // true
    public var isZero: Bool { get }

    /// A Boolean value indicating whether the instance is subnormal.
    ///
    /// A *subnormal* value is a nonzero number that has a lesser magnitude than
    /// the smallest normal number. Subnormal values do not use the full
    /// precision available to values of a type.
    ///
    /// Zero is neither a normal nor a subnormal number. Subnormal numbers are
    /// often called *denormal* or *denormalized*---these are different names
    /// for the same concept.
    public var isSubnormal: Bool { get }

    /// A Boolean value indicating whether the instance is infinite.
    ///
    /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because
    /// they are not total: If `x` is `NaN`, then both properties are `false`.
    public var isInfinite: Bool { get }

    /// A Boolean value indicating whether the instance is NaN ("not a number").
    ///
    /// Because NaN is not equal to any value, including NaN, use this property
    /// instead of the equal-to operator (`==`) or not-equal-to operator (`!=`)
    /// to test whether a value is or is not NaN. For example:
    ///
    ///     let x = 0.0
    ///     let y = x * .infinity
    ///     // y is a NaN
    ///
    ///     // Comparing with the equal-to operator never returns 'true'
    ///     print(x == Double.nan)
    ///     // Prints "false"
    ///     print(y == Double.nan)
    ///     // Prints "false"
    ///
    ///     // Test with the 'isNaN' property instead
    ///     print(x.isNaN)
    ///     // Prints "false"
    ///     print(y.isNaN)
    ///     // Prints "true"
    ///
    /// This property is `true` for both quiet and signaling NaNs.
    public var isNaN: Bool { get }

    /// A Boolean value indicating whether the instance is a signaling NaN.
    ///
    /// Signaling NaNs typically raise the Invalid flag when used in general
    /// computing operations.
    public var isSignalingNaN: Bool { get }

    /// The floating-point value with the same sign and exponent as this value,
    /// but with a significand of 1.0.
    ///
    /// A *binade* is a set of binary floating-point values that all have the
    /// same sign and exponent. The `binade` property is a member of the same
    /// binade as this value, but with a unit significand.
    ///
    /// In this example, `x` has a value of `21.5`, which is stored as
    /// `1.34375 * 2**4`, where `**` is exponentiation. Therefore, `x.binade` is
    /// equal to `1.0 * 2**4`, or `16.0`.
    ///
    ///     let x = 21.5
    ///     // x.significand == 1.34375
    ///     // x.exponent == 4
    ///
    ///     let y = x.binade
    ///     // y == 16.0
    ///     // y.significand == 1.0
    ///     // y.exponent == 4
    public var binade: Float { get }

    /// The number of bits required to represent the value's significand.
    ///
    /// If this value is a finite nonzero number, `significandWidth` is the
    /// number of fractional bits required to represent the value of
    /// `significand`; otherwise, `significandWidth` is -1. The value of
    /// `significandWidth` is always -1 or between zero and
    /// `significandBitCount`. For example:
    ///
    /// - For any representable power of two, `significandWidth` is zero, because
    ///   `significand` is `1.0`.
    /// - If `x` is 10, `x.significand` is `1.01` in binary, so
    ///   `x.significandWidth` is 2.
    /// - If `x` is Float.pi, `x.significand` is `1.10010010000111111011011` in
    ///   binary, and `x.significandWidth` is 23.
    public var significandWidth: Int { get }

    /// Creates a new value from the given floating-point literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you create a new `Float` instance by using a floating-point literal.
    /// Instead, create a new value by using a literal.
    ///
    /// In this example, the assignment to the `x` constant calls this
    /// initializer behind the scenes.
    ///
    ///     let x: Float = 21.25
    ///     // x == 21.25
    ///
    /// - Parameter value: The new floating-point value.
    public init(floatLiteral value: Float)
}

extension Float : ExpressibleByIntegerLiteral {

    /// Creates a new value from the given integer literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you create a new `Float` instance by using an integer literal.
    /// Instead, create a new value by using a literal.
    ///
    /// In this example, the assignment to the `x` constant calls this
    /// initializer behind the scenes.
    ///
    ///     let x: Float = 100
    ///     // x == 100.0
    ///
    /// - Parameter value: The new value.
    public init(integerLiteral value: Int64)
}

extension Float {
}

extension Float : Hashable {

    /// The number's hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Float {

    /// The magnitude of this value.
    ///
    /// For any value `x`, `x.magnitude.sign` is `.plus`. If `x` is not NaN,
    /// `x.magnitude` is the absolute value of `x`.
    ///
    /// The global `abs(_:)` function provides more familiar syntax when you need
    /// to find an absolute value. In addition, because `abs(_:)` always returns
    /// a value of the same type, even in a generic context, using the function
    /// instead of the `magnitude` property is encouraged.
    ///
    ///     let targetDistance: Float = 5.25
    ///     let throwDistance: Float = 5.5
    ///
    ///     let margin = targetDistance - throwDistance
    ///     // margin == -0.25
    ///     // margin.magnitude == 0.25
    ///
    ///     // Use 'abs(_:)' instead of 'magnitude'
    ///     print("Missed the target by \(abs(margin)) meters.")
    ///     // Prints "Missed the target by 0.25 meters."
    public var magnitude: Float { get }
}

extension Float {

    /// Calculates the additive inverse of a value.
    ///
    /// The unary minus operator (prefix `-`) calculates the negation of its
    /// operand. The result is always exact.
    ///
    ///     let x = 21.5
    ///     let y = -x
    ///     // y == -21.5
    ///
    /// - Parameter operand: The value to negate.
    prefix public static func - (x: Float) -> Float
}

extension Float {

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt8)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting UInt8 to Float will always succeed.")
    public init?(exactly value: UInt8)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int8)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting Int8 to Float will always succeed.")
    public init?(exactly value: Int8)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt16)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting UInt16 to Float will always succeed.")
    public init?(exactly value: UInt16)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int16)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting Int16 to Float will always succeed.")
    public init?(exactly value: Int16)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt32)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: UInt32)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int32)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: Int32)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt64)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: UInt64)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int64)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: Int64)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: UInt)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: Int)
}

extension Float {

    /// Creates a new instance initialized to the given value.
    ///
    /// The value of `other` is represented exactly by the new instance. A NaN
    /// passed as `other` results in another NaN, with a signaling NaN value
    /// converted to quiet NaN.
    ///
    ///     let x: Float = 21.25
    ///     let y = Float(x)
    ///     // y == 21.25
    ///
    ///     let z = Float(Float.nan)
    ///     // z.isNaN == true
    ///
    /// - Parameter other: The value to use for the new instance.
    public init(_ other: Float)

    /// Creates a new instance initialized to the given value, if it can be
    /// represented without rounding.
    ///
    /// If `other` can't be represented as an instance of `Float` without
    /// rounding, the result of this initializer is `nil`. In particular,
    /// passing NaN as `other` always results in `nil`.
    ///
    ///     let x: Float = 21.25
    ///     let y = Float(exactly: x)
    ///     // y == Optional.some(21.25)
    ///
    ///     let z = Float(exactly: Float.nan)
    ///     // z == nil
    ///
    /// - Parameter other: The value to use for the new instance.
    public init?(exactly other: Float)

    /// Creates a new instance that approximates the given value.
    ///
    /// The value of `other` is rounded to a representable value, if necessary.
    /// A NaN passed as `other` results in another NaN, with a signaling NaN
    /// value converted to quiet NaN.
    ///
    ///     let x: Double = 21.25
    ///     let y = Float(x)
    ///     // y == 21.25
    ///
    ///     let z = Float(Double.nan)
    ///     // z.isNaN == true
    ///
    /// - Parameter other: The value to use for the new instance.
    public init(_ other: Double)

    /// Creates a new instance initialized to the given value, if it can be
    /// represented without rounding.
    ///
    /// If `other` can't be represented as an instance of `Float` without
    /// rounding, the result of this initializer is `nil`. In particular,
    /// passing NaN as `other` always results in `nil`.
    ///
    ///     let x: Double = 21.25
    ///     let y = Float(exactly: x)
    ///     // y == Optional.some(21.25)
    ///
    ///     let z = Float(exactly: Double.nan)
    ///     // z == nil
    ///
    /// - Parameter other: The value to use for the new instance.
    public init?(exactly other: Double)

    /// Creates a new instance that approximates the given value.
    ///
    /// The value of `other` is rounded to a representable value, if necessary.
    /// A NaN passed as `other` results in another NaN, with a signaling NaN
    /// value converted to quiet NaN.
    ///
    ///     let x: Float80 = 21.25
    ///     let y = Float(x)
    ///     // y == 21.25
    ///
    ///     let z = Float(Float80.nan)
    ///     // z.isNaN == true
    ///
    /// - Parameter other: The value to use for the new instance.
    public init(_ other: Float80)

    /// Creates a new instance initialized to the given value, if it can be
    /// represented without rounding.
    ///
    /// If `other` can't be represented as an instance of `Float` without
    /// rounding, the result of this initializer is `nil`. In particular,
    /// passing NaN as `other` always results in `nil`.
    ///
    ///     let x: Float80 = 21.25
    ///     let y = Float(exactly: x)
    ///     // y == Optional.some(21.25)
    ///
    ///     let z = Float(exactly: Float80.nan)
    ///     // z == nil
    ///
    /// - Parameter other: The value to use for the new instance.
    public init?(exactly other: Float80)
}

extension Float {

    /// Adds two values and produces their sum, rounded to a
    /// representable value.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     let x = 1.5
    ///     let y = x + 2.25
    ///     // y == 3.75
    ///
    /// The `+` operator implements the addition operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Float, rhs: Float) -> Float

    /// Subtracts one value from another and produces their difference, rounded
    /// to a representable value.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     let x = 7.5
    ///     let y = x - 2.25
    ///     // y == 5.25
    ///
    /// The `-` operator implements the subtraction operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Float, rhs: Float) -> Float

    /// Multiplies two values and produces their product, rounding to a
    /// representable value.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     let x = 7.5
    ///     let y = x * 2.25
    ///     // y == 16.875
    ///
    /// The `*` operator implements the multiplication operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Float, rhs: Float) -> Float

    /// Returns the quotient of dividing the first value by the second, rounded
    /// to a representable value.
    ///
    /// The division operator (`/`) calculates the quotient of the division if
    /// `rhs` is nonzero. If `rhs` is zero, the result of the division is
    /// infinity, with the sign of the result matching the sign of `lhs`.
    ///
    ///     let x = 16.875
    ///     let y = x / 2.25
    ///     // y == 7.5
    ///
    ///     let z = x / 0
    ///     // z.isInfinite == true
    ///
    /// The `/` operator implements the division operation defined by the [IEEE
    /// 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by.
    public static func / (lhs: Float, rhs: Float) -> Float
}

extension Float : Strideable {

    /// Returns the distance from this value to the specified value.
    ///
    /// For two values `x` and `y`, the result of `x.distance(to: y)` is equal to
    /// `y - x`---a distance `d` such that `x.advanced(by: d)` approximates `y`.
    /// For example:
    ///
    ///     let x = 21.5
    ///     let d = x.distance(to: 15.0)
    ///     // d == -6.5
    ///
    ///     print(x.advanced(by: d))
    ///     // Prints "15.0"
    ///
    /// - Parameter other: A value to calculate the distance to.
    /// - Returns: The distance between this value and `other`.
    public func distance(to other: Float) -> Float

    /// Returns a new value advanced by the given distance.
    ///
    /// For two values `x` and `d`, the result of a `x.advanced(by: d)` is equal
    /// to `x + d`---a new value `y` such that `x.distance(to: y)` approximates
    /// `d`. For example:
    ///
    ///     let x = 21.5
    ///     let y = x.advanced(by: -6.5)
    ///     // y == 15.0
    ///
    ///     print(x.distance(to: y))
    ///     // Prints "-6.5"
    ///
    /// - Parameter amount: The distance to advance this value.
    /// - Returns: A new value that is `amount` added to this value.
    public func advanced(by amount: Float) -> Float
}

extension Float : CustomReflectable {

    /// A mirror that reflects the `Float` instance.
    public var customMirror: Mirror { get }
}

extension Float : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `Float` instance.
    @available(*, deprecated, message: "Float.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Float {
}

/// A 32-bit floating point type.
public typealias Float32 = Float

/// A 64-bit floating point type.
public typealias Float64 = Double

/// An extended-precision, floating-point value type.
public struct Float80 {

    /// Creates a value initialized to zero.
    public init()
}

extension Float80 : LosslessStringConvertible {

    /// Creates a new instance from the given string.
    ///
    /// The string passed as `text` can represent a real number in decimal or
    /// hexadecimal format or special floating-point values for infinity and NaN
    /// ("not a number").
    ///
    /// The given string may begin with a plus or minus sign character (`+` or
    /// `-`). The allowed formats for each of these representations is then as
    /// follows:
    ///
    /// - A *decimal value* contains the significand, a sequence of decimal
    ///   digits that may include a decimal point.
    ///
    ///       let c = Float80("-1.0")
    ///       // c == -1.0
    ///
    ///       let d = Float80("28.375")
    ///       // d == 28.375
    ///
    ///   A decimal value may also include an exponent following the significand,
    ///   indicating the power of 10 by which the significand should be
    ///   multiplied. If included, the exponent is separated by a single
    ///   character, `e` or `E`, and consists of an optional plus or minus sign
    ///   character and a sequence of decimal digits.
    ///
    ///       let e = Float80("2837.5e-2")
    ///       // e == 28.375
    ///
    /// - A *hexadecimal value* contains the significand, either `0X` or `0x`,
    ///   followed by a sequence of hexadecimal digits. The significand may
    ///   include a decimal point.
    ///
    ///       let f = Float80("0x1c.6")
    ///       // f == 28.375
    ///
    ///   A hexadecimal value may also include an exponent following the
    ///   significand, indicating the power of 2 by which the significand should
    ///   be multiplied. If included, the exponent is separated by a single
    ///   character, `p` or `P`, and consists of an optional plus or minus sign
    ///   character and a sequence of decimal digits.
    ///
    ///       let g = Float80("0x1.c6p4")
    ///       // g == 28.375
    ///
    /// - A value of *infinity* contains one of the strings `"inf"` or
    ///   `"infinity"`, case insensitive.
    ///
    ///       let i = Float80("inf")
    ///       // i == Float80.infinity
    ///
    ///       let j = Float80("-Infinity")
    ///       // j == -Float80.infinity
    ///
    /// - A value of *NaN* contains the string `"nan"`, case insensitive.
    ///
    ///       let n = Float80("-nan")
    ///       // n?.isNaN == true
    ///       // n?.sign == .minus
    ///
    ///   A NaN value may also include a payload in parentheses following the
    ///   `"nan"` keyword. The payload consists of a sequence of decimal digits,
    ///   or the characters `0X` or `0x` followed by a sequence of hexadecimal
    ///   digits. If the payload contains any other characters, it is ignored.
    ///   If the value of the payload is larger than can be stored as the
    ///   payload of a `Float80.nan`, the least significant bits are used.
    ///
    ///       let p = Float80("nan(0x10)")
    ///       // p?.isNaN == true
    ///       // String(p!) == "nan(0x10)"
    ///
    /// Passing any other format or any additional characters as `text` results
    /// in `nil`. For example, the following conversions result in `nil`:
    ///
    ///     Float80(" 5.0")      // Includes whitespace
    ///     Float80("2.0")      // Invalid character
    ///     Float80("0x1.25e4")  // Incorrect exponent format
    ///
    /// - Parameter text: The input string to convert to a `Float80` instance. If
    ///   `text` has invalid characters or is in an invalid format, the result
    ///   is `nil`.
    public init?<S>(_ text: S) where S : StringProtocol
}

extension Float80 : CustomStringConvertible {

    /// A textual representation of the value.
    public var description: String { get }
}

extension Float80 : CustomDebugStringConvertible {

    /// A textual representation of the value, suitable for debugging.
    public var debugDescription: String { get }
}

extension Float80 : BinaryFloatingPoint {

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = Float80

    /// A type that can represent any written exponent.
    public typealias Exponent = Int

    /// A type that represents the encoded significand of a value.
    public typealias RawSignificand = UInt64

    /// The number of bits used to represent the type's exponent.
    ///
    /// A binary floating-point type's `exponentBitCount` imposes a limit on the
    /// range of the exponent for normal, finite values. The *exponent bias* of
    /// a type `F` can be calculated as the following, where `**` is
    /// exponentiation:
    ///
    ///     let bias = 2 ** (F.exponentBitCount - 1) - 1
    ///
    /// The least normal exponent for values of the type `F` is `1 - bias`, and
    /// the largest finite exponent is `bias`. An all-zeros exponent is reserved
    /// for subnormals and zeros, and an all-ones exponent is reserved for
    /// infinity and NaN.
    ///
    /// For example, the `Float` type has an `exponentBitCount` of 8, which gives
    /// an exponent bias of `127` by the calculation above.
    ///
    ///     let bias = 2 ** (Float.exponentBitCount - 1) - 1
    ///     // bias == 127
    ///     print(Float.greatestFiniteMagnitude.exponent)
    ///     // Prints "127"
    ///     print(Float.leastNormalMagnitude.exponent)
    ///     // Prints "-126"
    public static var exponentBitCount: Int { get }

    /// The available number of fractional significand bits.
    ///
    /// For fixed-width floating-point types, this is the actual number of
    /// fractional significand bits.
    ///
    /// For extensible floating-point types, `significandBitCount` should be the
    /// maximum allowed significand width (without counting any leading integral
    /// bit of the significand). If there is no upper limit, then
    /// `significandBitCount` should be `Int.max`.
    ///
    /// `Float80.significandBitCount` is 63, even though 64 bits are used to
    /// store the significand in the memory representation of a `Float80`
    /// instance. Unlike other floating-point types, the `Float80` type
    /// explicitly stores the leading integral significand bit.
    public static var significandBitCount: Int { get }

    /// The sign of the floating-point value.
    ///
    /// The `sign` property is `.minus` if the value's signbit is set, and
    /// `.plus` otherwise. For example:
    ///
    ///     let x = -33.375
    ///     // x.sign == .minus
    ///
    /// Do not use this property to check whether a floating point value is
    /// negative. For a value `x`, the comparison `x.sign == .minus` is not
    /// necessarily the same as `x < 0`. In particular, `x.sign == .minus` if
    /// `x` is -0, and while `x < 0` is always `false` if `x` is NaN, `x.sign`
    /// could be either `.plus` or `.minus`.
    public var sign: FloatingPointSign { get }

    /// The raw encoding of the value's exponent field.
    ///
    /// This value is unadjusted by the type's exponent bias.
    public var exponentBitPattern: UInt { get }

    /// The raw encoding of the value's significand field.
    ///
    /// The `significandBitPattern` property does not include the leading
    /// integral bit of the significand, even for types like `Float80` that
    /// store it explicitly.
    public var significandBitPattern: UInt64 { get }

    /// Creates a new instance from the specified sign and bit patterns.
    ///
    /// The values passed as `exponentBitPattern` and `significandBitPattern` are
    /// interpreted in the binary interchange format defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - sign: The sign of the new value.
    ///   - exponentBitPattern: The bit pattern to use for the exponent field of
    ///     the new value.
    ///   - significandBitPattern: The bit pattern to use for the significand
    ///     field of the new value.
    public init(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt64)

    /// A Boolean value indicating whether the instance's representation is in
    /// the canonical form.
    ///
    /// The [IEEE 754 specification][spec] defines a *canonical*, or preferred,
    /// encoding of a floating-point value's representation. Every `Float` or
    /// `Double` value is canonical, but noncanonical values of the `Float80`
    /// type exist, and noncanonical values may exist for other types that
    /// conform to the `FloatingPoint` protocol.
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var isCanonical: Bool { get }

    /// Positive infinity.
    ///
    /// Infinity compares greater than all finite numbers and equal to other
    /// infinite values.
    ///
    ///     let x = Double.greatestFiniteMagnitude
    ///     let y = x * 2
    ///     // y == Double.infinity
    ///     // y > x
    public static var infinity: Float80 { get }

    /// A quiet NaN ("not a number").
    ///
    /// A NaN compares not equal, not greater than, and not less than every
    /// value, including itself. Passing a NaN to an operation generally results
    /// in NaN.
    ///
    ///     let x = 1.21
    ///     // x > Double.nan == false
    ///     // x < Double.nan == false
    ///     // x == Double.nan == false
    ///
    /// Because a NaN always compares not equal to itself, to test whether a
    /// floating-point value is NaN, use its `isNaN` property instead of the
    /// equal-to operator (`==`). In the following example, `y` is NaN.
    ///
    ///     let y = x + Double.nan
    ///     print(y == Double.nan)
    ///     // Prints "false"
    ///     print(y.isNaN)
    ///     // Prints "true"
    public static var nan: Float80 { get }

    /// A signaling NaN ("not a number").
    ///
    /// The default IEEE 754 behavior of operations involving a signaling NaN is
    /// to raise the Invalid flag in the floating-point environment and return a
    /// quiet NaN.
    ///
    /// Operations on types conforming to the `FloatingPoint` protocol should
    /// support this behavior, but they might also support other options. For
    /// example, it would be reasonable to implement alternative operations in
    /// which operating on a signaling NaN triggers a runtime error or results
    /// in a diagnostic for debugging purposes. Types that implement alternative
    /// behaviors for a signaling NaN must document the departure.
    ///
    /// Other than these signaling operations, a signaling NaN behaves in the
    /// same manner as a quiet NaN.
    public static var signalingNaN: Float80 { get }

    /// The greatest finite number representable by this type.
    ///
    /// This value compares greater than or equal to all finite numbers, but less
    /// than `infinity`.
    ///
    /// This value corresponds to type-specific C macros such as `FLT_MAX` and
    /// `DBL_MAX`. The naming of those macros is slightly misleading, because
    /// `infinity` is greater than this value.
    public static var greatestFiniteMagnitude: Float80 { get }

    /// The mathematical constant pi.
    ///
    /// This value should be rounded toward zero to keep user computations with
    /// angles from inadvertently ending up in the wrong quadrant. A type that
    /// conforms to the `FloatingPoint` protocol provides the value for `pi` at
    /// its best possible precision.
    ///
    ///     print(Double.pi)
    ///     // Prints "3.14159265358979"
    public static var pi: Float80 { get }

    /// The unit in the last place of this value.
    ///
    /// This is the unit of the least significant digit in this value's
    /// significand. For most numbers `x`, this is the difference between `x`
    /// and the next greater (in magnitude) representable number. There are some
    /// edge cases to be aware of:
    ///
    /// - If `x` is not a finite number, then `x.ulp` is NaN.
    /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal
    ///   number. If a type does not support subnormals, `x.ulp` may be rounded
    ///   to zero.
    /// - `greatestFiniteMagnitude.ulp` is a finite number, even though the next
    ///   greater representable value is `infinity`.
    ///
    /// This quantity, or a related quantity, is sometimes called *epsilon* or
    /// *machine epsilon.* Avoid that name because it has different meanings in
    /// different languages, which can lead to confusion, and because it
    /// suggests that it is a good tolerance to use for comparisons, which it
    /// almost never is.
    public var ulp: Float80 { get }

    /// The least positive normal number.
    ///
    /// This value compares less than or equal to all positive normal numbers.
    /// There may be smaller positive numbers, but they are *subnormal*, meaning
    /// that they are represented with less precision than normal numbers.
    ///
    /// This value corresponds to type-specific C macros such as `FLT_MIN` and
    /// `DBL_MIN`. The naming of those macros is slightly misleading, because
    /// subnormals, zeros, and negative numbers are smaller than this value.
    public static var leastNormalMagnitude: Float80 { get }

    /// The least positive number.
    ///
    /// This value compares less than or equal to all positive numbers, but
    /// greater than zero. If the type supports subnormal values,
    /// `leastNonzeroMagnitude` is smaller than `leastNormalMagnitude`;
    /// otherwise they are equal.
    public static var leastNonzeroMagnitude: Float80 { get }

    /// The unit in the last place of 1.0.
    ///
    /// The positive difference between 1.0 and the next greater representable
    /// number. The `ulpOfOne` constant corresponds to the C macros
    /// `FLT_EPSILON`, `DBL_EPSILON`, and others with a similar purpose.
    public static var ulpOfOne: Float80 { get }

    /// The exponent of the floating-point value.
    ///
    /// The *exponent* of a floating-point value is the integer part of the
    /// logarithm of the value's magnitude. For a value `x` of a floating-point
    /// type `F`, the magnitude can be calculated as the following, where `**`
    /// is exponentiation:
    ///
    ///     let magnitude = x.significand * F.radix ** x.exponent
    ///
    /// In the next example, `y` has a value of `21.5`, which is encoded as
    /// `1.34375 * 2 ** 4`. The significand of `y` is therefore 1.34375.
    ///
    ///     let y: Double = 21.5
    ///     // y.significand == 1.34375
    ///     // y.exponent == 4
    ///     // Double.radix == 2
    ///
    /// The `exponent` property has the following edge cases:
    ///
    /// - If `x` is zero, then `x.exponent` is `Int.min`.
    /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`
    ///
    /// This property implements the `logB` operation defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var exponent: Int { get }

    /// The significand of the floating-point value.
    ///
    /// The magnitude of a floating-point value `x` of type `F` can be calculated
    /// by using the following formula, where `**` is exponentiation:
    ///
    ///     let magnitude = x.significand * F.radix ** x.exponent
    ///
    /// In the next example, `y` has a value of `21.5`, which is encoded as
    /// `1.34375 * 2 ** 4`. The significand of `y` is therefore 1.34375.
    ///
    ///     let y: Double = 21.5
    ///     // y.significand == 1.34375
    ///     // y.exponent == 4
    ///     // Double.radix == 2
    ///
    /// If a type's radix is 2, then for finite nonzero numbers, the significand
    /// is in the range `1.0 ..< 2.0`. For other values of `x`, `x.significand`
    /// is defined as follows:
    ///
    /// - If `x` is zero, then `x.significand` is 0.0.
    /// - If `x` is infinity, then `x.significand` is 1.0.
    /// - If `x` is NaN, then `x.significand` is NaN.
    /// - Note: The significand is frequently also called the *mantissa*, but
    ///   significand is the preferred terminology in the [IEEE 754
    ///   specification][spec], to allay confusion with the use of mantissa for
    ///   the fractional part of a logarithm.
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var significand: Float80 { get }

    /// Creates a new value from the given sign, exponent, and significand.
    ///
    /// The following example uses this initializer to create a new `Double`
    /// instance. `Double` is a binary floating-point type that has a radix of
    /// `2`.
    ///
    ///     let x = Double(sign: .plus, exponent: -2, significand: 1.5)
    ///     // x == 0.375
    ///
    /// This initializer is equivalent to the following calculation, where `**`
    /// is exponentiation, computed as if by a single, correctly rounded,
    /// floating-point operation:
    ///
    ///     let sign: FloatingPointSign = .plus
    ///     let exponent = -2
    ///     let significand = 1.5
    ///     let y = (sign == .minus ? -1 : 1) * significand * Double.radix ** exponent
    ///     // y == 0.375
    ///
    /// As with any basic operation, if this value is outside the representable
    /// range of the type, overflow or underflow occurs, and zero, a subnormal
    /// value, or infinity may result. In addition, there are two other edge
    /// cases:
    ///
    /// - If the value you pass to `significand` is zero or infinite, the result
    ///   is zero or infinite, regardless of the value of `exponent`.
    /// - If the value you pass to `significand` is NaN, the result is NaN.
    ///
    /// For any floating-point value `x` of type `F`, the result of the following
    /// is equal to `x`, with the distinction that the result is canonicalized
    /// if `x` is in a noncanonical encoding:
    ///
    ///     let x0 = F(sign: x.sign, exponent: x.exponent, significand: x.significand)
    ///
    /// This initializer implements the `scaleB` operation defined by the [IEEE
    /// 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - sign: The sign to use for the new value.
    ///   - exponent: The new value's exponent.
    ///   - significand: The new value's significand.
    public init(sign: FloatingPointSign, exponent: Int, significand: Float80)

    /// Creates a NaN ("not a number") value with the specified payload.
    ///
    /// NaN values compare not equal to every value, including themselves. Most
    /// operations with a NaN operand produce a NaN result. Don't use the
    /// equal-to operator (`==`) to test whether a value is NaN. Instead, use
    /// the value's `isNaN` property.
    ///
    ///     let x = Float80(nan: 0, signaling: false)
    ///     print(x == .nan)
    ///     // Prints "false"
    ///     print(x.isNaN)
    ///     // Prints "true"
    ///
    /// - Parameters:
    ///   - payload: The payload to use for the new NaN value.
    ///   - signaling: Pass `true` to create a signaling NaN or `false` to create
    ///     a quiet NaN.
    public init(nan payload: Float80.RawSignificand, signaling: Bool)

    /// The least representable value that compares greater than this value.
    ///
    /// For any finite value `x`, `x.nextUp` is greater than `x`. For `nan` or
    /// `infinity`, `x.nextUp` is `x` itself. The following special cases also
    /// apply:
    ///
    /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestFiniteMagnitude`.
    /// - If `x` is `-leastNonzeroMagnitude`, then `x.nextUp` is `-0.0`.
    /// - If `x` is zero, then `x.nextUp` is `leastNonzeroMagnitude`.
    /// - If `x` is `greatestFiniteMagnitude`, then `x.nextUp` is `infinity`.
    public var nextUp: Float80 { get }

    /// Rounds the value to an integral value using the specified rounding rule.
    ///
    /// The following example rounds a value using four different rounding rules:
    ///
    ///     // Equivalent to the C 'round' function:
    ///     var w = 6.5
    ///     w.round(.toNearestOrAwayFromZero)
    ///     // w == 7.0
    ///
    ///     // Equivalent to the C 'trunc' function:
    ///     var x = 6.5
    ///     x.round(.towardZero)
    ///     // x == 6.0
    ///
    ///     // Equivalent to the C 'ceil' function:
    ///     var y = 6.5
    ///     y.round(.up)
    ///     // y == 7.0
    ///
    ///     // Equivalent to the C 'floor' function:
    ///     var z = 6.5
    ///     z.round(.down)
    ///     // z == 6.0
    ///
    /// For more information about the available rounding rules, see the
    /// `FloatingPointRoundingRule` enumeration. To round a value using the
    /// default "schoolbook rounding", you can use the shorter `round()` method
    /// instead.
    ///
    ///     var w1 = 6.5
    ///     w1.round()
    ///     // w1 == 7.0
    ///
    /// - Parameter rule: The rounding rule to use.
    public mutating func round(_ rule: FloatingPointRoundingRule)

    /// Replaces this value with its additive inverse.
    ///
    /// The result is always exact. This example uses the `negate()` method to
    /// negate the value of the variable `x`:
    ///
    ///     var x = 21.5
    ///     x.negate()
    ///     // x == -21.5
    public mutating func negate()

    /// Adds two values and stores the result in the left-hand-side variable,
    /// rounded to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Float80, rhs: Float80)

    /// Subtracts the second value from the first and stores the difference in
    /// the left-hand-side variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Float80, rhs: Float80)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Float80, rhs: Float80)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by.
    public static func /= (lhs: inout Float80, rhs: Float80)

    /// Replaces this value with the remainder of itself divided by the given
    /// value.
    ///
    /// For two finite values `x` and `y`, the remainder `r` of dividing `x` by
    /// `y` satisfies `x == y * q + r`, where `q` is the integer nearest to
    /// `x / y`. If `x / y` is exactly halfway between two integers, `q` is
    /// chosen to be even. Note that `q` is *not* `x / y` computed in
    /// floating-point arithmetic, and that `q` may not be representable in any
    /// available integer type.
    ///
    /// The following example calculates the remainder of dividing 8.625 by 0.75:
    ///
    ///     var x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.toNearestOrEven)
    ///     // q == 12.0
    ///     x.formRemainder(dividingBy: 0.75)
    ///     // x == -0.375
    ///
    ///     let x1 = 0.75 * q + x
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are finite numbers, the remainder is in the
    /// closed range `-abs(other / 2)...abs(other / 2)`. The
    /// `formRemainder(dividingBy:)` method is always exact.
    ///
    /// - Parameter other: The value to use when dividing this value.
    public mutating func formRemainder(dividingBy other: Float80)

    /// Replaces this value with the remainder of itself divided by the given
    /// value using truncating division.
    ///
    /// Performing truncating division with floating-point values results in a
    /// truncated integer quotient and a remainder. For values `x` and `y` and
    /// their truncated integer quotient `q`, the remainder `r` satisfies
    /// `x == y * q + r`.
    ///
    /// The following example calculates the truncating remainder of dividing
    /// 8.625 by 0.75:
    ///
    ///     var x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.towardZero)
    ///     // q == 11.0
    ///     x.formTruncatingRemainder(dividingBy: 0.75)
    ///     // x == 0.375
    ///
    ///     let x1 = 0.75 * q + x
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are both finite numbers, the truncating
    /// remainder has the same sign as this value and is strictly smaller in
    /// magnitude than `other`. The `formTruncatingRemainder(dividingBy:)`
    /// method is always exact.
    ///
    /// - Parameter other: The value to use when dividing this value.
    public mutating func formTruncatingRemainder(dividingBy other: Float80)

    /// Replaces this value with its square root, rounded to a representable
    /// value.
    public mutating func formSquareRoot()

    /// Adds the product of the two given values to this value in place, computed
    /// without intermediate rounding.
    ///
    /// - Parameters:
    ///   - lhs: One of the values to multiply before adding to this value.
    ///   - rhs: The other value to multiply.
    public mutating func addProduct(_ lhs: Float80, _ rhs: Float80)

    /// Returns a Boolean value indicating whether this instance is equal to the
    /// given value.
    ///
    /// This method serves as the basis for the equal-to operator (`==`) for
    /// floating-point values. When comparing two values with this method, `-0`
    /// is equal to `+0`. NaN is not equal to any value, including itself. For
    /// example:
    ///
    ///     let x = 15.0
    ///     x.isEqual(to: 15.0)
    ///     // true
    ///     x.isEqual(to: .nan)
    ///     // false
    ///     Double.nan.isEqual(to: .nan)
    ///     // false
    ///
    /// The `isEqual(to:)` method implements the equality predicate defined by
    /// the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if `other` has the same value as this instance;
    ///   otherwise, `false`.
    public func isEqual(to other: Float80) -> Bool

    /// Returns a Boolean value indicating whether this instance is less than the
    /// given value.
    ///
    /// This method serves as the basis for the less-than operator (`<`) for
    /// floating-point values. Some special cases apply:
    ///
    /// - Because NaN compares not less than nor greater than any value, this
    ///   method returns `false` when called on NaN or when NaN is passed as
    ///   `other`.
    /// - `-infinity` compares less than all values except for itself and NaN.
    /// - Every value except for NaN and `+infinity` compares less than
    ///   `+infinity`.
    ///
    ///     let x = 15.0
    ///     x.isLess(than: 20.0)
    ///     // true
    ///     x.isLess(than: .nan)
    ///     // false
    ///     Double.nan.isLess(than: x)
    ///     // false
    ///
    /// The `isLess(than:)` method implements the less-than predicate defined by
    /// the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if `other` is less than this value; otherwise, `false`.
    public func isLess(than other: Float80) -> Bool

    /// Returns a Boolean value indicating whether this instance is less than or
    /// equal to the given value.
    ///
    /// This method serves as the basis for the less-than-or-equal-to operator
    /// (`<=`) for floating-point values. Some special cases apply:
    ///
    /// - Because NaN is incomparable with any value, this method returns `false`
    ///   when called on NaN or when NaN is passed as `other`.
    /// - `-infinity` compares less than or equal to all values except NaN.
    /// - Every value except NaN compares less than or equal to `+infinity`.
    ///
    ///     let x = 15.0
    ///     x.isLessThanOrEqualTo(20.0)
    ///     // true
    ///     x.isLessThanOrEqualTo(.nan)
    ///     // false
    ///     Double.nan.isLessThanOrEqualTo(x)
    ///     // false
    ///
    /// The `isLessThanOrEqualTo(_:)` method implements the less-than-or-equal
    /// predicate defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if `other` is less than this value; otherwise, `false`.
    public func isLessThanOrEqualTo(_ other: Float80) -> Bool

    /// A Boolean value indicating whether this instance is normal.
    ///
    /// A *normal* value is a finite number that uses the full precision
    /// available to values of a type. Zero is neither a normal nor a subnormal
    /// number.
    public var isNormal: Bool { get }

    /// A Boolean value indicating whether this instance is finite.
    ///
    /// All values other than NaN and infinity are considered finite, whether
    /// normal or subnormal.
    public var isFinite: Bool { get }

    /// A Boolean value indicating whether the instance is equal to zero.
    ///
    /// The `isZero` property of a value `x` is `true` when `x` represents either
    /// `-0.0` or `+0.0`. `x.isZero` is equivalent to the following comparison:
    /// `x == 0.0`.
    ///
    ///     let x = -0.0
    ///     x.isZero        // true
    ///     x == 0.0        // true
    public var isZero: Bool { get }

    /// A Boolean value indicating whether the instance is subnormal.
    ///
    /// A *subnormal* value is a nonzero number that has a lesser magnitude than
    /// the smallest normal number. Subnormal values do not use the full
    /// precision available to values of a type.
    ///
    /// Zero is neither a normal nor a subnormal number. Subnormal numbers are
    /// often called *denormal* or *denormalized*---these are different names
    /// for the same concept.
    public var isSubnormal: Bool { get }

    /// A Boolean value indicating whether the instance is infinite.
    ///
    /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because
    /// they are not total: If `x` is `NaN`, then both properties are `false`.
    public var isInfinite: Bool { get }

    /// A Boolean value indicating whether the instance is NaN ("not a number").
    ///
    /// Because NaN is not equal to any value, including NaN, use this property
    /// instead of the equal-to operator (`==`) or not-equal-to operator (`!=`)
    /// to test whether a value is or is not NaN. For example:
    ///
    ///     let x = 0.0
    ///     let y = x * .infinity
    ///     // y is a NaN
    ///
    ///     // Comparing with the equal-to operator never returns 'true'
    ///     print(x == Double.nan)
    ///     // Prints "false"
    ///     print(y == Double.nan)
    ///     // Prints "false"
    ///
    ///     // Test with the 'isNaN' property instead
    ///     print(x.isNaN)
    ///     // Prints "false"
    ///     print(y.isNaN)
    ///     // Prints "true"
    ///
    /// This property is `true` for both quiet and signaling NaNs.
    public var isNaN: Bool { get }

    /// A Boolean value indicating whether the instance is a signaling NaN.
    ///
    /// Signaling NaNs typically raise the Invalid flag when used in general
    /// computing operations.
    public var isSignalingNaN: Bool { get }

    /// The floating-point value with the same sign and exponent as this value,
    /// but with a significand of 1.0.
    ///
    /// A *binade* is a set of binary floating-point values that all have the
    /// same sign and exponent. The `binade` property is a member of the same
    /// binade as this value, but with a unit significand.
    ///
    /// In this example, `x` has a value of `21.5`, which is stored as
    /// `1.34375 * 2**4`, where `**` is exponentiation. Therefore, `x.binade` is
    /// equal to `1.0 * 2**4`, or `16.0`.
    ///
    ///     let x = 21.5
    ///     // x.significand == 1.34375
    ///     // x.exponent == 4
    ///
    ///     let y = x.binade
    ///     // y == 16.0
    ///     // y.significand == 1.0
    ///     // y.exponent == 4
    public var binade: Float80 { get }

    /// The number of bits required to represent the value's significand.
    ///
    /// If this value is a finite nonzero number, `significandWidth` is the
    /// number of fractional bits required to represent the value of
    /// `significand`; otherwise, `significandWidth` is -1. The value of
    /// `significandWidth` is always -1 or between zero and
    /// `significandBitCount`. For example:
    ///
    /// - For any representable power of two, `significandWidth` is zero, because
    ///   `significand` is `1.0`.
    /// - If `x` is 10, `x.significand` is `1.01` in binary, so
    ///   `x.significandWidth` is 2.
    /// - If `x` is Float.pi, `x.significand` is `1.10010010000111111011011` in
    ///   binary, and `x.significandWidth` is 23.
    public var significandWidth: Int { get }

    /// Creates a new value from the given floating-point literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you create a new `Float80` instance by using a floating-point literal.
    /// Instead, create a new value by using a literal.
    ///
    /// In this example, the assignment to the `x` constant calls this
    /// initializer behind the scenes.
    ///
    ///     let x: Float80 = 21.25
    ///     // x == 21.25
    ///
    /// - Parameter value: The new floating-point value.
    public init(floatLiteral value: Float80)
}

extension Float80 : ExpressibleByIntegerLiteral {

    /// Creates a new value from the given integer literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you create a new `Float80` instance by using an integer literal.
    /// Instead, create a new value by using a literal.
    ///
    /// In this example, the assignment to the `x` constant calls this
    /// initializer behind the scenes.
    ///
    ///     let x: Float80 = 100
    ///     // x == 100.0
    ///
    /// - Parameter value: The new value.
    public init(integerLiteral value: Int64)
}

extension Float80 {
}

extension Float80 : Hashable {

    /// The number's hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Float80 {

    /// The magnitude of this value.
    ///
    /// For any value `x`, `x.magnitude.sign` is `.plus`. If `x` is not NaN,
    /// `x.magnitude` is the absolute value of `x`.
    ///
    /// The global `abs(_:)` function provides more familiar syntax when you need
    /// to find an absolute value. In addition, because `abs(_:)` always returns
    /// a value of the same type, even in a generic context, using the function
    /// instead of the `magnitude` property is encouraged.
    ///
    ///     let targetDistance: Float80 = 5.25
    ///     let throwDistance: Float80 = 5.5
    ///
    ///     let margin = targetDistance - throwDistance
    ///     // margin == -0.25
    ///     // margin.magnitude == 0.25
    ///
    ///     // Use 'abs(_:)' instead of 'magnitude'
    ///     print("Missed the target by \(abs(margin)) meters.")
    ///     // Prints "Missed the target by 0.25 meters."
    public var magnitude: Float80 { get }
}

extension Float80 {

    /// Calculates the additive inverse of a value.
    ///
    /// The unary minus operator (prefix `-`) calculates the negation of its
    /// operand. The result is always exact.
    ///
    ///     let x = 21.5
    ///     let y = -x
    ///     // y == -21.5
    ///
    /// - Parameter operand: The value to negate.
    prefix public static func - (x: Float80) -> Float80
}

extension Float80 {

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt8)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting UInt8 to Float80 will always succeed.")
    public init?(exactly value: UInt8)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int8)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting Int8 to Float80 will always succeed.")
    public init?(exactly value: Int8)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt16)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting UInt16 to Float80 will always succeed.")
    public init?(exactly value: UInt16)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int16)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting Int16 to Float80 will always succeed.")
    public init?(exactly value: Int16)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt32)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting UInt32 to Float80 will always succeed.")
    public init?(exactly value: UInt32)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int32)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    @available(*, message: "Converting Int32 to Float80 will always succeed.")
    public init?(exactly value: Int32)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt64)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: UInt64)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int64)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: Int64)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: UInt)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: UInt)

    /// Creates the closest representable value to the given integer.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init(_ v: Int)

    /// Creates a value that exactly represents the given integer.
    ///
    /// If the given integer is outside the representable range of this type or
    /// can't be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to represent as a floating-point value.
    public init?(exactly value: Int)
}

extension Float80 {

    /// Creates a new instance that approximates the given value.
    ///
    /// The value of `other` is rounded to a representable value, if necessary.
    /// A NaN passed as `other` results in another NaN, with a signaling NaN
    /// value converted to quiet NaN.
    ///
    ///     let x: Float = 21.25
    ///     let y = Float80(x)
    ///     // y == 21.25
    ///
    ///     let z = Float80(Float.nan)
    ///     // z.isNaN == true
    ///
    /// - Parameter other: The value to use for the new instance.
    public init(_ other: Float)

    /// Creates a new instance initialized to the given value, if it can be
    /// represented without rounding.
    ///
    /// If `other` can't be represented as an instance of `Float80` without
    /// rounding, the result of this initializer is `nil`. In particular,
    /// passing NaN as `other` always results in `nil`.
    ///
    ///     let x: Float = 21.25
    ///     let y = Float80(exactly: x)
    ///     // y == Optional.some(21.25)
    ///
    ///     let z = Float80(exactly: Float.nan)
    ///     // z == nil
    ///
    /// - Parameter other: The value to use for the new instance.
    public init?(exactly other: Float)

    /// Creates a new instance that approximates the given value.
    ///
    /// The value of `other` is rounded to a representable value, if necessary.
    /// A NaN passed as `other` results in another NaN, with a signaling NaN
    /// value converted to quiet NaN.
    ///
    ///     let x: Double = 21.25
    ///     let y = Float80(x)
    ///     // y == 21.25
    ///
    ///     let z = Float80(Double.nan)
    ///     // z.isNaN == true
    ///
    /// - Parameter other: The value to use for the new instance.
    public init(_ other: Double)

    /// Creates a new instance initialized to the given value, if it can be
    /// represented without rounding.
    ///
    /// If `other` can't be represented as an instance of `Float80` without
    /// rounding, the result of this initializer is `nil`. In particular,
    /// passing NaN as `other` always results in `nil`.
    ///
    ///     let x: Double = 21.25
    ///     let y = Float80(exactly: x)
    ///     // y == Optional.some(21.25)
    ///
    ///     let z = Float80(exactly: Double.nan)
    ///     // z == nil
    ///
    /// - Parameter other: The value to use for the new instance.
    public init?(exactly other: Double)

    /// Creates a new instance initialized to the given value.
    ///
    /// The value of `other` is represented exactly by the new instance. A NaN
    /// passed as `other` results in another NaN, with a signaling NaN value
    /// converted to quiet NaN.
    ///
    ///     let x: Float80 = 21.25
    ///     let y = Float80(x)
    ///     // y == 21.25
    ///
    ///     let z = Float80(Float80.nan)
    ///     // z.isNaN == true
    ///
    /// - Parameter other: The value to use for the new instance.
    public init(_ other: Float80)

    /// Creates a new instance initialized to the given value, if it can be
    /// represented without rounding.
    ///
    /// If `other` can't be represented as an instance of `Float80` without
    /// rounding, the result of this initializer is `nil`. In particular,
    /// passing NaN as `other` always results in `nil`.
    ///
    ///     let x: Float80 = 21.25
    ///     let y = Float80(exactly: x)
    ///     // y == Optional.some(21.25)
    ///
    ///     let z = Float80(exactly: Float80.nan)
    ///     // z == nil
    ///
    /// - Parameter other: The value to use for the new instance.
    public init?(exactly other: Float80)
}

extension Float80 {

    /// Adds two values and produces their sum, rounded to a
    /// representable value.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     let x = 1.5
    ///     let y = x + 2.25
    ///     // y == 3.75
    ///
    /// The `+` operator implements the addition operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Float80, rhs: Float80) -> Float80

    /// Subtracts one value from another and produces their difference, rounded
    /// to a representable value.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     let x = 7.5
    ///     let y = x - 2.25
    ///     // y == 5.25
    ///
    /// The `-` operator implements the subtraction operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Float80, rhs: Float80) -> Float80

    /// Multiplies two values and produces their product, rounding to a
    /// representable value.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     let x = 7.5
    ///     let y = x * 2.25
    ///     // y == 16.875
    ///
    /// The `*` operator implements the multiplication operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Float80, rhs: Float80) -> Float80

    /// Returns the quotient of dividing the first value by the second, rounded
    /// to a representable value.
    ///
    /// The division operator (`/`) calculates the quotient of the division if
    /// `rhs` is nonzero. If `rhs` is zero, the result of the division is
    /// infinity, with the sign of the result matching the sign of `lhs`.
    ///
    ///     let x = 16.875
    ///     let y = x / 2.25
    ///     // y == 7.5
    ///
    ///     let z = x / 0
    ///     // z.isInfinite == true
    ///
    /// The `/` operator implements the division operation defined by the [IEEE
    /// 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by.
    public static func / (lhs: Float80, rhs: Float80) -> Float80
}

extension Float80 : Strideable {

    /// Returns the distance from this value to the specified value.
    ///
    /// For two values `x` and `y`, the result of `x.distance(to: y)` is equal to
    /// `y - x`---a distance `d` such that `x.advanced(by: d)` approximates `y`.
    /// For example:
    ///
    ///     let x = 21.5
    ///     let d = x.distance(to: 15.0)
    ///     // d == -6.5
    ///
    ///     print(x.advanced(by: d))
    ///     // Prints "15.0"
    ///
    /// - Parameter other: A value to calculate the distance to.
    /// - Returns: The distance between this value and `other`.
    public func distance(to other: Float80) -> Float80

    /// Returns a new value advanced by the given distance.
    ///
    /// For two values `x` and `d`, the result of a `x.advanced(by: d)` is equal
    /// to `x + d`---a new value `y` such that `x.distance(to: y)` approximates
    /// `d`. For example:
    ///
    ///     let x = 21.5
    ///     let y = x.advanced(by: -6.5)
    ///     // y == 15.0
    ///
    ///     print(x.distance(to: y))
    ///     // Prints "-6.5"
    ///
    /// - Parameter amount: The distance to advance this value.
    /// - Returns: A new value that is `amount` added to this value.
    public func advanced(by amount: Float80) -> Float80
}

@available(*, deprecated, renamed: "ExpressibleByFloatLiteral")
public typealias FloatLiteralConvertible = ExpressibleByFloatLiteral

/// The default type for an otherwise-unconstrained floating point literal.
public typealias FloatLiteralType = Double

/// A floating-point numeric type.
///
/// Floating-point types are used to represent fractional numbers, like 5.5,
/// 100.0, or 3.14159274. Each floating-point type has its own possible range
/// and precision. The floating-point types in the standard library are
/// `Float`, `Double`, and `Float80` where available.
///
/// Create new instances of floating-point types using integer or
/// floating-point literals. For example:
///
///     let temperature = 33.2
///     let recordHigh = 37.5
///
/// The `FloatingPoint` protocol declares common arithmetic operations, so you
/// can write functions and algorithms that work on any floating-point type.
/// The following example declares a function that calculates the length of
/// the hypotenuse of a right triangle given its two perpendicular sides.
/// Because the `hypotenuse(_:_:)` function uses a generic parameter
/// constrained to the `FloatingPoint` protocol, you can call it using any
/// floating-point type.
///
///     func hypotenuse<T: FloatingPoint>(_ a: T, _ b: T) -> T {
///         return (a * a + b * b).squareRoot()
///     }
///
///     let (dx, dy) = (3.0, 4.0)
///     let distance = hypotenuse(dx, dy)
///     // distance == 5.0
///
/// Floating-point values are represented as a *sign* and a *magnitude*, where
/// the magnitude is calculated using the type's *radix* and the instance's
/// *significand* and *exponent*. This magnitude calculation takes the
/// following form for a floating-point value `x` of type `F`, where `**` is
/// exponentiation:
///
///     x.significand * F.radix ** x.exponent
///
/// Here's an example of the number -8.5 represented as an instance of the
/// `Double` type, which defines a radix of 2.
///
///     let y = -8.5
///     // y.sign == .minus
///     // y.significand == 1.0625
///     // y.exponent == 3
///
///     let magnitude = 1.0625 * Double(2 ** 3)
///     // magnitude == 8.5
///
/// Types that conform to the `FloatingPoint` protocol provide most basic
/// (clause 5) operations of the [IEEE 754 specification][spec]. The base,
/// precision, and exponent range are not fixed in any way by this protocol,
/// but it enforces the basic requirements of any IEEE 754 floating-point
/// type.
///
/// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
///
/// Additional Considerations
/// =========================
///
/// In addition to representing specific numbers, floating-point types also
/// have special values for working with overflow and nonnumeric results of
/// calculation.
///
/// Infinity
/// --------
///
/// Any value whose magnitude is so great that it would round to a value
/// outside the range of representable numbers is rounded to *infinity*. For a
/// type `F`, positive and negative infinity are represented as `F.infinity`
/// and `-F.infinity`, respectively. Positive infinity compares greater than
/// every finite value and negative infinity, while negative infinity compares
/// less than every finite value and positive infinity. Infinite values with
/// the same sign are equal to each other.
///
///     let values: [Double] = [10.0, 25.0, -10.0, .infinity, -.infinity]
///     print(values.sorted())
///     // Prints "[-inf, -10.0, 10.0, 25.0, inf]"
///
/// Operations with infinite values follow real arithmetic as much as possible:
/// Adding or subtracting a finite value, or multiplying or dividing infinity
/// by a nonzero finite value, results in infinity.
///
/// NaN ("not a number")
/// --------------------
///
/// Floating-point types represent values that are neither finite numbers nor
/// infinity as NaN, an abbreviation for "not a number." Comparing a NaN with
/// any value, including another NaN, results in `false`.
///
///     let myNaN = Double.nan
///     print(myNaN > 0)
///     // Prints "false"
///     print(myNaN < 0)
///     // Prints "false"
///     print(myNaN == .nan)
///     // Prints "false"
///
/// Because testing whether one NaN is equal to another NaN results in `false`,
/// use the `isNaN` property to test whether a value is NaN.
///
///     print(myNaN.isNaN)
///     // Prints "true"
///
/// NaN propagates through many arithmetic operations. When you are operating
/// on many values, this behavior is valuable because operations on NaN simply
/// forward the value and don't cause runtime errors. The following example
/// shows how NaN values operate in different contexts.
///
/// Imagine you have a set of temperature data for which you need to report
/// some general statistics: the total number of observations, the number of
/// valid observations, and the average temperature. First, a set of
/// observations in Celsius is parsed from strings to `Double` values:
///
///     let temperatureData = ["21.5", "19.25", "27", "no data", "28.25", "no data", "23"]
///     let tempsCelsius = temperatureData.map { Double($0) ?? .nan }
///     // tempsCelsius == [21.5, 19.25, 27, nan, 28.25, nan, 23.0]
///
/// Note that some elements in the `temperatureData ` array are not valid
/// numbers. When these invalid strings are parsed by the `Double` failable
/// initializer, the example uses the nil-coalescing operator (`??`) to
/// provide NaN as a fallback value.
///
/// Next, the observations in Celsius are converted to Fahrenheit:
///
///     let tempsFahrenheit = tempsCelsius.map { $0 * 1.8 + 32 }
///     // tempsFahrenheit == [70.7, 66.65, 80.6, nan, 82.85, nan, 73.4]
///
/// The NaN values in the `tempsCelsius` array are propagated through the
/// conversion and remain NaN in `tempsFahrenheit`.
///
/// Because calculating the average of the observations involves combining
/// every value of the `tempsFahrenheit` array, any NaN values cause the
/// result to also be NaN, as seen in this example:
///
///     let badAverage = tempsFahrenheit.reduce(0.0, combine: +) / Double(tempsFahrenheit.count)
///     // badAverage.isNaN == true
///
/// Instead, when you need an operation to have a specific numeric result,
/// filter out any NaN values using the `isNaN` property.
///
///     let validTemps = tempsFahrenheit.filter { !$0.isNaN }
///     let average = validTemps.reduce(0.0, combine: +) / Double(validTemps.count)
///
/// Finally, report the average temperature and observation counts:
///
///     print("Average: \(average)F in \(validTemps.count) " +
///           "out of \(tempsFahrenheit.count) observations.")
///     // Prints "Average: 74.84F in 5 out of 7 observations."
public protocol FloatingPoint : Hashable, SignedNumeric, Strideable {

    /// A type that can represent the absolute value of any possible value of the
    /// conforming type.
    associatedtype Magnitude = Self

    /// A type that can represent any written exponent.
    associatedtype Exponent : SignedInteger

    /// Creates a new value from the given sign, exponent, and significand.
    ///
    /// The following example uses this initializer to create a new `Double`
    /// instance. `Double` is a binary floating-point type that has a radix of
    /// `2`.
    ///
    ///     let x = Double(sign: .plus, exponent: -2, significand: 1.5)
    ///     // x == 0.375
    ///
    /// This initializer is equivalent to the following calculation, where `**`
    /// is exponentiation, computed as if by a single, correctly rounded,
    /// floating-point operation:
    ///
    ///     let sign: FloatingPointSign = .plus
    ///     let exponent = -2
    ///     let significand = 1.5
    ///     let y = (sign == .minus ? -1 : 1) * significand * Double.radix ** exponent
    ///     // y == 0.375
    ///
    /// As with any basic operation, if this value is outside the representable
    /// range of the type, overflow or underflow occurs, and zero, a subnormal
    /// value, or infinity may result. In addition, there are two other edge
    /// cases:
    ///
    /// - If the value you pass to `significand` is zero or infinite, the result
    ///   is zero or infinite, regardless of the value of `exponent`.
    /// - If the value you pass to `significand` is NaN, the result is NaN.
    ///
    /// For any floating-point value `x` of type `F`, the result of the following
    /// is equal to `x`, with the distinction that the result is canonicalized
    /// if `x` is in a noncanonical encoding:
    ///
    ///     let x0 = F(sign: x.sign, exponent: x.exponent, significand: x.significand)
    ///
    /// This initializer implements the `scaleB` operation defined by the [IEEE
    /// 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - sign: The sign to use for the new value.
    ///   - exponent: The new value's exponent.
    ///   - significand: The new value's significand.
    public init(sign: FloatingPointSign, exponent: Self.Exponent, significand: Self)

    /// Creates a new floating-point value using the sign of one value and the
    /// magnitude of another.
    ///
    /// The following example uses this initializer to create a new `Double`
    /// instance with the sign of `a` and the magnitude of `b`:
    ///
    ///     let a = -21.5
    ///     let b = 305.15
    ///     let c = Double(signOf: a, magnitudeOf: b)
    ///     print(c)
    ///     // Prints "-305.15"
    ///
    /// This initializer implements the IEEE 754 `copysign` operation.
    ///
    /// - Parameters:
    ///   - signOf: A value from which to use the sign. The result of the
    ///     initializer has the same sign as `signOf`.
    ///   - magnitudeOf: A value from which to use the magnitude. The result of
    ///     the initializer has the same magnitude as `magnitudeOf`.
    public init(signOf: Self, magnitudeOf: Self)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init(_ value: UInt8)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init(_ value: Int8)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init(_ value: UInt16)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init(_ value: Int16)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init(_ value: UInt32)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init(_ value: Int32)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init(_ value: UInt64)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init(_ value: Int64)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init(_ value: UInt)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init(_ value: Int)

    /// Creates a new value, rounded to the closest possible representation.
    ///
    /// If two representable values are equally close, the result is the value
    /// with more trailing zeros in its significand bit pattern.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init<Source>(_ value: Source) where Source : BinaryInteger

    /// Creates a new value, if the given integer can be represented exactly.
    ///
    /// If the given integer cannot be represented exactly, the result is `nil`.
    ///
    /// - Parameter value: The integer to convert to a floating-point value.
    public init?<Source>(exactly value: Source) where Source : BinaryInteger

    /// The radix, or base of exponentiation, for a floating-point type.
    ///
    /// The magnitude of a floating-point value `x` of type `F` can be calculated
    /// by using the following formula, where `**` is exponentiation:
    ///
    ///     let magnitude = x.significand * F.radix ** x.exponent
    ///
    /// A conforming type may use any integer radix, but values other than 2 (for
    /// binary floating-point types) or 10 (for decimal floating-point types)
    /// are extraordinarily rare in practice.
    public static var radix: Int { get }

    /// A quiet NaN ("not a number").
    ///
    /// A NaN compares not equal, not greater than, and not less than every
    /// value, including itself. Passing a NaN to an operation generally results
    /// in NaN.
    ///
    ///     let x = 1.21
    ///     // x > Double.nan == false
    ///     // x < Double.nan == false
    ///     // x == Double.nan == false
    ///
    /// Because a NaN always compares not equal to itself, to test whether a
    /// floating-point value is NaN, use its `isNaN` property instead of the
    /// equal-to operator (`==`). In the following example, `y` is NaN.
    ///
    ///     let y = x + Double.nan
    ///     print(y == Double.nan)
    ///     // Prints "false"
    ///     print(y.isNaN)
    ///     // Prints "true"
    public static var nan: Self { get }

    /// A signaling NaN ("not a number").
    ///
    /// The default IEEE 754 behavior of operations involving a signaling NaN is
    /// to raise the Invalid flag in the floating-point environment and return a
    /// quiet NaN.
    ///
    /// Operations on types conforming to the `FloatingPoint` protocol should
    /// support this behavior, but they might also support other options. For
    /// example, it would be reasonable to implement alternative operations in
    /// which operating on a signaling NaN triggers a runtime error or results
    /// in a diagnostic for debugging purposes. Types that implement alternative
    /// behaviors for a signaling NaN must document the departure.
    ///
    /// Other than these signaling operations, a signaling NaN behaves in the
    /// same manner as a quiet NaN.
    public static var signalingNaN: Self { get }

    /// Positive infinity.
    ///
    /// Infinity compares greater than all finite numbers and equal to other
    /// infinite values.
    ///
    ///     let x = Double.greatestFiniteMagnitude
    ///     let y = x * 2
    ///     // y == Double.infinity
    ///     // y > x
    public static var infinity: Self { get }

    /// The greatest finite number representable by this type.
    ///
    /// This value compares greater than or equal to all finite numbers, but less
    /// than `infinity`.
    ///
    /// This value corresponds to type-specific C macros such as `FLT_MAX` and
    /// `DBL_MAX`. The naming of those macros is slightly misleading, because
    /// `infinity` is greater than this value.
    public static var greatestFiniteMagnitude: Self { get }

    /// The mathematical constant pi.
    ///
    /// This value should be rounded toward zero to keep user computations with
    /// angles from inadvertently ending up in the wrong quadrant. A type that
    /// conforms to the `FloatingPoint` protocol provides the value for `pi` at
    /// its best possible precision.
    ///
    ///     print(Double.pi)
    ///     // Prints "3.14159265358979"
    public static var pi: Self { get }

    /// The unit in the last place of this value.
    ///
    /// This is the unit of the least significant digit in this value's
    /// significand. For most numbers `x`, this is the difference between `x`
    /// and the next greater (in magnitude) representable number. There are some
    /// edge cases to be aware of:
    ///
    /// - If `x` is not a finite number, then `x.ulp` is NaN.
    /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal
    ///   number. If a type does not support subnormals, `x.ulp` may be rounded
    ///   to zero.
    /// - `greatestFiniteMagnitude.ulp` is a finite number, even though the next
    ///   greater representable value is `infinity`.
    ///
    /// This quantity, or a related quantity, is sometimes called *epsilon* or
    /// *machine epsilon.* Avoid that name because it has different meanings in
    /// different languages, which can lead to confusion, and because it
    /// suggests that it is a good tolerance to use for comparisons, which it
    /// almost never is.
    public var ulp: Self { get }

    /// The unit in the last place of 1.0.
    ///
    /// The positive difference between 1.0 and the next greater representable
    /// number. The `ulpOfOne` constant corresponds to the C macros
    /// `FLT_EPSILON`, `DBL_EPSILON`, and others with a similar purpose.
    public static var ulpOfOne: Self { get }

    /// The least positive normal number.
    ///
    /// This value compares less than or equal to all positive normal numbers.
    /// There may be smaller positive numbers, but they are *subnormal*, meaning
    /// that they are represented with less precision than normal numbers.
    ///
    /// This value corresponds to type-specific C macros such as `FLT_MIN` and
    /// `DBL_MIN`. The naming of those macros is slightly misleading, because
    /// subnormals, zeros, and negative numbers are smaller than this value.
    public static var leastNormalMagnitude: Self { get }

    /// The least positive number.
    ///
    /// This value compares less than or equal to all positive numbers, but
    /// greater than zero. If the type supports subnormal values,
    /// `leastNonzeroMagnitude` is smaller than `leastNormalMagnitude`;
    /// otherwise they are equal.
    public static var leastNonzeroMagnitude: Self { get }

    /// The sign of the floating-point value.
    ///
    /// The `sign` property is `.minus` if the value's signbit is set, and
    /// `.plus` otherwise. For example:
    ///
    ///     let x = -33.375
    ///     // x.sign == .minus
    ///
    /// Do not use this property to check whether a floating point value is
    /// negative. For a value `x`, the comparison `x.sign == .minus` is not
    /// necessarily the same as `x < 0`. In particular, `x.sign == .minus` if
    /// `x` is -0, and while `x < 0` is always `false` if `x` is NaN, `x.sign`
    /// could be either `.plus` or `.minus`.
    public var sign: FloatingPointSign { get }

    /// The exponent of the floating-point value.
    ///
    /// The *exponent* of a floating-point value is the integer part of the
    /// logarithm of the value's magnitude. For a value `x` of a floating-point
    /// type `F`, the magnitude can be calculated as the following, where `**`
    /// is exponentiation:
    ///
    ///     let magnitude = x.significand * F.radix ** x.exponent
    ///
    /// In the next example, `y` has a value of `21.5`, which is encoded as
    /// `1.34375 * 2 ** 4`. The significand of `y` is therefore 1.34375.
    ///
    ///     let y: Double = 21.5
    ///     // y.significand == 1.34375
    ///     // y.exponent == 4
    ///     // Double.radix == 2
    ///
    /// The `exponent` property has the following edge cases:
    ///
    /// - If `x` is zero, then `x.exponent` is `Int.min`.
    /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`
    ///
    /// This property implements the `logB` operation defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var exponent: Self.Exponent { get }

    /// The significand of the floating-point value.
    ///
    /// The magnitude of a floating-point value `x` of type `F` can be calculated
    /// by using the following formula, where `**` is exponentiation:
    ///
    ///     let magnitude = x.significand * F.radix ** x.exponent
    ///
    /// In the next example, `y` has a value of `21.5`, which is encoded as
    /// `1.34375 * 2 ** 4`. The significand of `y` is therefore 1.34375.
    ///
    ///     let y: Double = 21.5
    ///     // y.significand == 1.34375
    ///     // y.exponent == 4
    ///     // Double.radix == 2
    ///
    /// If a type's radix is 2, then for finite nonzero numbers, the significand
    /// is in the range `1.0 ..< 2.0`. For other values of `x`, `x.significand`
    /// is defined as follows:
    ///
    /// - If `x` is zero, then `x.significand` is 0.0.
    /// - If `x` is infinity, then `x.significand` is 1.0.
    /// - If `x` is NaN, then `x.significand` is NaN.
    /// - Note: The significand is frequently also called the *mantissa*, but
    ///   significand is the preferred terminology in the [IEEE 754
    ///   specification][spec], to allay confusion with the use of mantissa for
    ///   the fractional part of a logarithm.
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var significand: Self { get }

    /// Adds two values and produces their sum, rounded to a
    /// representable value.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     let x = 1.5
    ///     let y = x + 2.25
    ///     // y == 3.75
    ///
    /// The `+` operator implements the addition operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Self, rhs: Self) -> Self

    /// Adds two values and stores the result in the left-hand-side variable,
    /// rounded to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Self, rhs: Self)

    /// Calculates the additive inverse of a value.
    ///
    /// The unary minus operator (prefix `-`) calculates the negation of its
    /// operand. The result is always exact.
    ///
    ///     let x = 21.5
    ///     let y = -x
    ///     // y == -21.5
    ///
    /// - Parameter operand: The value to negate.
    prefix public static func - (operand: Self) -> Self

    /// Replaces this value with its additive inverse.
    ///
    /// The result is always exact. This example uses the `negate()` method to
    /// negate the value of the variable `x`:
    ///
    ///     var x = 21.5
    ///     x.negate()
    ///     // x == -21.5
    public mutating func negate()

    /// Subtracts one value from another and produces their difference, rounded
    /// to a representable value.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     let x = 7.5
    ///     let y = x - 2.25
    ///     // y == 5.25
    ///
    /// The `-` operator implements the subtraction operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Self, rhs: Self) -> Self

    /// Subtracts the second value from the first and stores the difference in
    /// the left-hand-side variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Self, rhs: Self)

    /// Multiplies two values and produces their product, rounding to a
    /// representable value.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     let x = 7.5
    ///     let y = x * 2.25
    ///     // y == 16.875
    ///
    /// The `*` operator implements the multiplication operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Self, rhs: Self) -> Self

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Self, rhs: Self)

    /// Returns the quotient of dividing the first value by the second, rounded
    /// to a representable value.
    ///
    /// The division operator (`/`) calculates the quotient of the division if
    /// `rhs` is nonzero. If `rhs` is zero, the result of the division is
    /// infinity, with the sign of the result matching the sign of `lhs`.
    ///
    ///     let x = 16.875
    ///     let y = x / 2.25
    ///     // y == 7.5
    ///
    ///     let z = x / 0
    ///     // z.isInfinite == true
    ///
    /// The `/` operator implements the division operation defined by the [IEEE
    /// 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by.
    public static func / (lhs: Self, rhs: Self) -> Self

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable, rounding to a representable value.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by.
    public static func /= (lhs: inout Self, rhs: Self)

    /// Returns the remainder of this value divided by the given value.
    ///
    /// For two finite values `x` and `y`, the remainder `r` of dividing `x` by
    /// `y` satisfies `x == y * q + r`, where `q` is the integer nearest to
    /// `x / y`. If `x / y` is exactly halfway between two integers, `q` is
    /// chosen to be even. Note that `q` is *not* `x / y` computed in
    /// floating-point arithmetic, and that `q` may not be representable in any
    /// available integer type.
    ///
    /// The following example calculates the remainder of dividing 8.625 by 0.75:
    ///
    ///     let x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.toNearestOrEven)
    ///     // q == 12.0
    ///     let r = x.remainder(dividingBy: 0.75)
    ///     // r == -0.375
    ///
    ///     let x1 = 0.75 * q + r
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are finite numbers, the remainder is in the
    /// closed range `-abs(other / 2)...abs(other / 2)`. The
    /// `remainder(dividingBy:)` method is always exact. This method implements
    /// the remainder operation defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to use when dividing this value.
    /// - Returns: The remainder of this value divided by `other`.
    public func remainder(dividingBy other: Self) -> Self

    /// Replaces this value with the remainder of itself divided by the given
    /// value.
    ///
    /// For two finite values `x` and `y`, the remainder `r` of dividing `x` by
    /// `y` satisfies `x == y * q + r`, where `q` is the integer nearest to
    /// `x / y`. If `x / y` is exactly halfway between two integers, `q` is
    /// chosen to be even. Note that `q` is *not* `x / y` computed in
    /// floating-point arithmetic, and that `q` may not be representable in any
    /// available integer type.
    ///
    /// The following example calculates the remainder of dividing 8.625 by 0.75:
    ///
    ///     var x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.toNearestOrEven)
    ///     // q == 12.0
    ///     x.formRemainder(dividingBy: 0.75)
    ///     // x == -0.375
    ///
    ///     let x1 = 0.75 * q + x
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are finite numbers, the remainder is in the
    /// closed range `-abs(other / 2)...abs(other / 2)`. The
    /// `formRemainder(dividingBy:)` method is always exact.
    ///
    /// - Parameter other: The value to use when dividing this value.
    public mutating func formRemainder(dividingBy other: Self)

    /// Returns the remainder of this value divided by the given value using
    /// truncating division.
    ///
    /// Performing truncating division with floating-point values results in a
    /// truncated integer quotient and a remainder. For values `x` and `y` and
    /// their truncated integer quotient `q`, the remainder `r` satisfies
    /// `x == y * q + r`.
    ///
    /// The following example calculates the truncating remainder of dividing
    /// 8.625 by 0.75:
    ///
    ///     let x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.towardZero)
    ///     // q == 11.0
    ///     let r = x.truncatingRemainder(dividingBy: 0.75)
    ///     // r == 0.375
    ///
    ///     let x1 = 0.75 * q + r
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are both finite numbers, the truncating
    /// remainder has the same sign as this value and is strictly smaller in
    /// magnitude than `other`. The `truncatingRemainder(dividingBy:)` method
    /// is always exact.
    ///
    /// - Parameter other: The value to use when dividing this value.
    /// - Returns: The remainder of this value divided by `other` using
    ///   truncating division.
    public func truncatingRemainder(dividingBy other: Self) -> Self

    /// Replaces this value with the remainder of itself divided by the given
    /// value using truncating division.
    ///
    /// Performing truncating division with floating-point values results in a
    /// truncated integer quotient and a remainder. For values `x` and `y` and
    /// their truncated integer quotient `q`, the remainder `r` satisfies
    /// `x == y * q + r`.
    ///
    /// The following example calculates the truncating remainder of dividing
    /// 8.625 by 0.75:
    ///
    ///     var x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.towardZero)
    ///     // q == 11.0
    ///     x.formTruncatingRemainder(dividingBy: 0.75)
    ///     // x == 0.375
    ///
    ///     let x1 = 0.75 * q + x
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are both finite numbers, the truncating
    /// remainder has the same sign as this value and is strictly smaller in
    /// magnitude than `other`. The `formTruncatingRemainder(dividingBy:)`
    /// method is always exact.
    ///
    /// - Parameter other: The value to use when dividing this value.
    public mutating func formTruncatingRemainder(dividingBy other: Self)

    /// Returns the square root of the value, rounded to a representable value.
    ///
    /// The following example declares a function that calculates the length of
    /// the hypotenuse of a right triangle given its two perpendicular sides.
    ///
    ///     func hypotenuse(_ a: Double, _ b: Double) -> Double {
    ///         return (a * a + b * b).squareRoot()
    ///     }
    ///
    ///     let (dx, dy) = (3.0, 4.0)
    ///     let distance = hypotenuse(dx, dy)
    ///     // distance == 5.0
    ///
    /// - Returns: The square root of the value.
    public func squareRoot() -> Self

    /// Replaces this value with its square root, rounded to a representable
    /// value.
    public mutating func formSquareRoot()

    /// Returns the result of adding the product of the two given values to this
    /// value, computed without intermediate rounding.
    ///
    /// This method is equivalent to the C `fma` function and implements the
    /// `fusedMultiplyAdd` operation defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: One of the values to multiply before adding to this value.
    ///   - rhs: The other value to multiply.
    /// - Returns: The product of `lhs` and `rhs`, added to this value.
    public func addingProduct(_ lhs: Self, _ rhs: Self) -> Self

    /// Adds the product of the two given values to this value in place, computed
    /// without intermediate rounding.
    ///
    /// - Parameters:
    ///   - lhs: One of the values to multiply before adding to this value.
    ///   - rhs: The other value to multiply.
    public mutating func addProduct(_ lhs: Self, _ rhs: Self)

    /// Returns the lesser of the two given values.
    ///
    /// This method returns the minimum of two values, preserving order and
    /// eliminating NaN when possible. For two values `x` and `y`, the result of
    /// `minimum(x, y)` is `x` if `x <= y`, `y` if `y < x`, or whichever of `x`
    /// or `y` is a number if the other is a quiet NaN. If both `x` and `y` are
    /// NaN, or either `x` or `y` is a signaling NaN, the result is NaN.
    ///
    ///     Double.minimum(10.0, -25.0)
    ///     // -25.0
    ///     Double.minimum(10.0, .nan)
    ///     // 10.0
    ///     Double.minimum(.nan, -25.0)
    ///     // -25.0
    ///     Double.minimum(.nan, .nan)
    ///     // nan
    ///
    /// The `minimum` method implements the `minNum` operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - x: A floating-point value.
    ///   - y: Another floating-point value.
    /// - Returns: The minimum of `x` and `y`, or whichever is a number if the
    ///   other is NaN.
    public static func minimum(_ x: Self, _ y: Self) -> Self

    /// Returns the greater of the two given values.
    ///
    /// This method returns the maximum of two values, preserving order and
    /// eliminating NaN when possible. For two values `x` and `y`, the result of
    /// `maximum(x, y)` is `x` if `x > y`, `y` if `x <= y`, or whichever of `x`
    /// or `y` is a number if the other is a quiet NaN. If both `x` and `y` are
    /// NaN, or either `x` or `y` is a signaling NaN, the result is NaN.
    ///
    ///     Double.maximum(10.0, -25.0)
    ///     // 10.0
    ///     Double.maximum(10.0, .nan)
    ///     // 10.0
    ///     Double.maximum(.nan, -25.0)
    ///     // -25.0
    ///     Double.maximum(.nan, .nan)
    ///     // nan
    ///
    /// The `maximum` method implements the `maxNum` operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - x: A floating-point value.
    ///   - y: Another floating-point value.
    /// - Returns: The greater of `x` and `y`, or whichever is a number if the
    ///   other is NaN.
    public static func maximum(_ x: Self, _ y: Self) -> Self

    /// Returns the value with lesser magnitude.
    ///
    /// This method returns the value with lesser magnitude of the two given
    /// values, preserving order and eliminating NaN when possible. For two
    /// values `x` and `y`, the result of `minimumMagnitude(x, y)` is `x` if
    /// `x.magnitude <= y.magnitude`, `y` if `y.magnitude < x.magnitude`, or
    /// whichever of `x` or `y` is a number if the other is a quiet NaN. If both
    /// `x` and `y` are NaN, or either `x` or `y` is a signaling NaN, the result
    /// is NaN.
    ///
    ///     Double.minimumMagnitude(10.0, -25.0)
    ///     // 10.0
    ///     Double.minimumMagnitude(10.0, .nan)
    ///     // 10.0
    ///     Double.minimumMagnitude(.nan, -25.0)
    ///     // -25.0
    ///     Double.minimumMagnitude(.nan, .nan)
    ///     // nan
    ///
    /// The `minimumMagnitude` method implements the `minNumMag` operation
    /// defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - x: A floating-point value.
    ///   - y: Another floating-point value.
    /// - Returns: Whichever of `x` or `y` has lesser magnitude, or whichever is
    ///   a number if the other is NaN.
    public static func minimumMagnitude(_ x: Self, _ y: Self) -> Self

    /// Returns the value with greater magnitude.
    ///
    /// This method returns the value with greater magnitude of the two given
    /// values, preserving order and eliminating NaN when possible. For two
    /// values `x` and `y`, the result of `maximumMagnitude(x, y)` is `x` if
    /// `x.magnitude > y.magnitude`, `y` if `x.magnitude <= y.magnitude`, or
    /// whichever of `x` or `y` is a number if the other is a quiet NaN. If both
    /// `x` and `y` are NaN, or either `x` or `y` is a signaling NaN, the result
    /// is NaN.
    ///
    ///     Double.maximumMagnitude(10.0, -25.0)
    ///     // -25.0
    ///     Double.maximumMagnitude(10.0, .nan)
    ///     // 10.0
    ///     Double.maximumMagnitude(.nan, -25.0)
    ///     // -25.0
    ///     Double.maximumMagnitude(.nan, .nan)
    ///     // nan
    ///
    /// The `maximumMagnitude` method implements the `maxNumMag` operation
    /// defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - x: A floating-point value.
    ///   - y: Another floating-point value.
    /// - Returns: Whichever of `x` or `y` has greater magnitude, or whichever is
    ///   a number if the other is NaN.
    public static func maximumMagnitude(_ x: Self, _ y: Self) -> Self

    /// Returns this value rounded to an integral value using the specified
    /// rounding rule.
    ///
    /// The following example rounds a value using four different rounding rules:
    ///
    ///     let x = 6.5
    ///
    ///     // Equivalent to the C 'round' function:
    ///     print(x.rounded(.toNearestOrAwayFromZero))
    ///     // Prints "7.0"
    ///
    ///     // Equivalent to the C 'trunc' function:
    ///     print(x.rounded(.towardZero))
    ///     // Prints "6.0"
    ///
    ///     // Equivalent to the C 'ceil' function:
    ///     print(x.rounded(.up))
    ///     // Prints "7.0"
    ///
    ///     // Equivalent to the C 'floor' function:
    ///     print(x.rounded(.down))
    ///     // Prints "6.0"
    ///
    /// For more information about the available rounding rules, see the
    /// `FloatingPointRoundingRule` enumeration. To round a value using the
    /// default "schoolbook rounding", you can use the shorter `rounded()`
    /// method instead.
    ///
    ///     print(x.rounded())
    ///     // Prints "7.0"
    ///
    /// - Parameter rule: The rounding rule to use.
    /// - Returns: The integral value found by rounding using `rule`.
    public func rounded(_ rule: FloatingPointRoundingRule) -> Self

    /// Rounds the value to an integral value using the specified rounding rule.
    ///
    /// The following example rounds a value using four different rounding rules:
    ///
    ///     // Equivalent to the C 'round' function:
    ///     var w = 6.5
    ///     w.round(.toNearestOrAwayFromZero)
    ///     // w == 7.0
    ///
    ///     // Equivalent to the C 'trunc' function:
    ///     var x = 6.5
    ///     x.round(.towardZero)
    ///     // x == 6.0
    ///
    ///     // Equivalent to the C 'ceil' function:
    ///     var y = 6.5
    ///     y.round(.up)
    ///     // y == 7.0
    ///
    ///     // Equivalent to the C 'floor' function:
    ///     var z = 6.5
    ///     z.round(.down)
    ///     // z == 6.0
    ///
    /// For more information about the available rounding rules, see the
    /// `FloatingPointRoundingRule` enumeration. To round a value using the
    /// default "schoolbook rounding", you can use the shorter `round()` method
    /// instead.
    ///
    ///     var w1 = 6.5
    ///     w1.round()
    ///     // w1 == 7.0
    ///
    /// - Parameter rule: The rounding rule to use.
    public mutating func round(_ rule: FloatingPointRoundingRule)

    /// The least representable value that compares greater than this value.
    ///
    /// For any finite value `x`, `x.nextUp` is greater than `x`. For `nan` or
    /// `infinity`, `x.nextUp` is `x` itself. The following special cases also
    /// apply:
    ///
    /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestFiniteMagnitude`.
    /// - If `x` is `-leastNonzeroMagnitude`, then `x.nextUp` is `-0.0`.
    /// - If `x` is zero, then `x.nextUp` is `leastNonzeroMagnitude`.
    /// - If `x` is `greatestFiniteMagnitude`, then `x.nextUp` is `infinity`.
    public var nextUp: Self { get }

    /// The greatest representable value that compares less than this value.
    ///
    /// For any finite value `x`, `x.nextDown` is less than `x`. For `nan` or
    /// `-infinity`, `x.nextDown` is `x` itself. The following special cases
    /// also apply:
    ///
    /// - If `x` is `infinity`, then `x.nextDown` is `greatestFiniteMagnitude`.
    /// - If `x` is `leastNonzeroMagnitude`, then `x.nextDown` is `0.0`.
    /// - If `x` is zero, then `x.nextDown` is `-leastNonzeroMagnitude`.
    /// - If `x` is `-greatestFiniteMagnitude`, then `x.nextDown` is `-infinity`.
    public var nextDown: Self { get }

    /// Returns a Boolean value indicating whether this instance is equal to the
    /// given value.
    ///
    /// This method serves as the basis for the equal-to operator (`==`) for
    /// floating-point values. When comparing two values with this method, `-0`
    /// is equal to `+0`. NaN is not equal to any value, including itself. For
    /// example:
    ///
    ///     let x = 15.0
    ///     x.isEqual(to: 15.0)
    ///     // true
    ///     x.isEqual(to: .nan)
    ///     // false
    ///     Double.nan.isEqual(to: .nan)
    ///     // false
    ///
    /// The `isEqual(to:)` method implements the equality predicate defined by
    /// the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if `other` has the same value as this instance;
    ///   otherwise, `false`. If either this value or `other` is NaN, the result
    ///   of this method is `false`.
    public func isEqual(to other: Self) -> Bool

    /// Returns a Boolean value indicating whether this instance is less than the
    /// given value.
    ///
    /// This method serves as the basis for the less-than operator (`<`) for
    /// floating-point values. Some special cases apply:
    ///
    /// - Because NaN compares not less than nor greater than any value, this
    ///   method returns `false` when called on NaN or when NaN is passed as
    ///   `other`.
    /// - `-infinity` compares less than all values except for itself and NaN.
    /// - Every value except for NaN and `+infinity` compares less than
    ///   `+infinity`.
    ///
    ///     let x = 15.0
    ///     x.isLess(than: 20.0)
    ///     // true
    ///     x.isLess(than: .nan)
    ///     // false
    ///     Double.nan.isLess(than: x)
    ///     // false
    ///
    /// The `isLess(than:)` method implements the less-than predicate defined by
    /// the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if this value is less than `other`; otherwise, `false`.
    ///   If either this value or `other` is NaN, the result of this method is
    ///   `false`.
    public func isLess(than other: Self) -> Bool

    /// Returns a Boolean value indicating whether this instance is less than or
    /// equal to the given value.
    ///
    /// This method serves as the basis for the less-than-or-equal-to operator
    /// (`<=`) for floating-point values. Some special cases apply:
    ///
    /// - Because NaN is incomparable with any value, this method returns `false`
    ///   when called on NaN or when NaN is passed as `other`.
    /// - `-infinity` compares less than or equal to all values except NaN.
    /// - Every value except NaN compares less than or equal to `+infinity`.
    ///
    ///     let x = 15.0
    ///     x.isLessThanOrEqualTo(20.0)
    ///     // true
    ///     x.isLessThanOrEqualTo(.nan)
    ///     // false
    ///     Double.nan.isLessThanOrEqualTo(x)
    ///     // false
    ///
    /// The `isLessThanOrEqualTo(_:)` method implements the less-than-or-equal
    /// predicate defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to compare with this value.
    /// - Returns: `true` if `other` is greater than this value; otherwise,
    ///   `false`. If either this value or `other` is NaN, the result of this
    ///   method is `false`.
    public func isLessThanOrEqualTo(_ other: Self) -> Bool

    /// Returns a Boolean value indicating whether this instance should precede
    /// or tie positions with the given value in an ascending sort.
    ///
    /// This relation is a refinement of the less-than-or-equal-to operator
    /// (`<=`) that provides a total order on all values of the type, including
    /// signed zeros and NaNs.
    ///
    /// The following example uses `isTotallyOrdered(belowOrEqualTo:)` to sort an
    /// array of floating-point values, including some that are NaN:
    ///
    ///     var numbers = [2.5, 21.25, 3.0, .nan, -9.5]
    ///     numbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }
    ///     // numbers == [-9.5, 2.5, 3.0, 21.25, NaN]
    ///
    /// The `isTotallyOrdered(belowOrEqualTo:)` method implements the total order
    /// relation as defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: A floating-point value to compare to this value.
    /// - Returns: `true` if this value is ordered below or the same as `other`
    ///   in a total ordering of the floating-point type; otherwise, `false`.
    public func isTotallyOrdered(belowOrEqualTo other: Self) -> Bool

    /// A Boolean value indicating whether this instance is normal.
    ///
    /// A *normal* value is a finite number that uses the full precision
    /// available to values of a type. Zero is neither a normal nor a subnormal
    /// number.
    public var isNormal: Bool { get }

    /// A Boolean value indicating whether this instance is finite.
    ///
    /// All values other than NaN and infinity are considered finite, whether
    /// normal or subnormal.
    public var isFinite: Bool { get }

    /// A Boolean value indicating whether the instance is equal to zero.
    ///
    /// The `isZero` property of a value `x` is `true` when `x` represents either
    /// `-0.0` or `+0.0`. `x.isZero` is equivalent to the following comparison:
    /// `x == 0.0`.
    ///
    ///     let x = -0.0
    ///     x.isZero        // true
    ///     x == 0.0        // true
    public var isZero: Bool { get }

    /// A Boolean value indicating whether the instance is subnormal.
    ///
    /// A *subnormal* value is a nonzero number that has a lesser magnitude than
    /// the smallest normal number. Subnormal values do not use the full
    /// precision available to values of a type.
    ///
    /// Zero is neither a normal nor a subnormal number. Subnormal numbers are
    /// often called *denormal* or *denormalized*---these are different names
    /// for the same concept.
    public var isSubnormal: Bool { get }

    /// A Boolean value indicating whether the instance is infinite.
    ///
    /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because
    /// they are not total: If `x` is `NaN`, then both properties are `false`.
    public var isInfinite: Bool { get }

    /// A Boolean value indicating whether the instance is NaN ("not a number").
    ///
    /// Because NaN is not equal to any value, including NaN, use this property
    /// instead of the equal-to operator (`==`) or not-equal-to operator (`!=`)
    /// to test whether a value is or is not NaN. For example:
    ///
    ///     let x = 0.0
    ///     let y = x * .infinity
    ///     // y is a NaN
    ///
    ///     // Comparing with the equal-to operator never returns 'true'
    ///     print(x == Double.nan)
    ///     // Prints "false"
    ///     print(y == Double.nan)
    ///     // Prints "false"
    ///
    ///     // Test with the 'isNaN' property instead
    ///     print(x.isNaN)
    ///     // Prints "false"
    ///     print(y.isNaN)
    ///     // Prints "true"
    ///
    /// This property is `true` for both quiet and signaling NaNs.
    public var isNaN: Bool { get }

    /// A Boolean value indicating whether the instance is a signaling NaN.
    ///
    /// Signaling NaNs typically raise the Invalid flag when used in general
    /// computing operations.
    public var isSignalingNaN: Bool { get }

    /// The classification of this value.
    ///
    /// A value's `floatingPointClass` property describes its "class" as
    /// described by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var floatingPointClass: FloatingPointClassification { get }

    /// A Boolean value indicating whether the instance's representation is in
    /// the canonical form.
    ///
    /// The [IEEE 754 specification][spec] defines a *canonical*, or preferred,
    /// encoding of a floating-point value's representation. Every `Float` or
    /// `Double` value is canonical, but noncanonical values of the `Float80`
    /// type exist, and noncanonical values may exist for other types that
    /// conform to the `FloatingPoint` protocol.
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var isCanonical: Bool { get }
}

extension FloatingPoint {

    public static func == (lhs: Self, rhs: Self) -> Bool

    public static func < (lhs: Self, rhs: Self) -> Bool

    public static func <= (lhs: Self, rhs: Self) -> Bool

    public static func > (lhs: Self, rhs: Self) -> Bool

    public static func >= (lhs: Self, rhs: Self) -> Bool
}

extension FloatingPoint {

    /// The unit in the last place of 1.0.
    ///
    /// The positive difference between 1.0 and the next greater representable
    /// number. The `ulpOfOne` constant corresponds to the C macros
    /// `FLT_EPSILON`, `DBL_EPSILON`, and others with a similar purpose.
    public static var ulpOfOne: Self { get }

    /// Returns this value rounded to an integral value using the specified
    /// rounding rule.
    ///
    /// The following example rounds a value using four different rounding rules:
    ///
    ///     let x = 6.5
    ///
    ///     // Equivalent to the C 'round' function:
    ///     print(x.rounded(.toNearestOrAwayFromZero))
    ///     // Prints "7.0"
    ///
    ///     // Equivalent to the C 'trunc' function:
    ///     print(x.rounded(.towardZero))
    ///     // Prints "6.0"
    ///
    ///     // Equivalent to the C 'ceil' function:
    ///     print(x.rounded(.up))
    ///     // Prints "7.0"
    ///
    ///     // Equivalent to the C 'floor' function:
    ///     print(x.rounded(.down))
    ///     // Prints "6.0"
    ///
    /// For more information about the available rounding rules, see the
    /// `FloatingPointRoundingRule` enumeration. To round a value using the
    /// default "schoolbook rounding", you can use the shorter `rounded()`
    /// method instead.
    ///
    ///     print(x.rounded())
    ///     // Prints "7.0"
    ///
    /// - Parameter rule: The rounding rule to use.
    /// - Returns: The integral value found by rounding using `rule`.
    public func rounded(_ rule: FloatingPointRoundingRule) -> Self

    /// Returns this value rounded to an integral value using "schoolbook
    /// rounding."
    ///
    /// The `rounded()` method uses the `.toNearestOrAwayFromZero` rounding rule,
    /// where a value halfway between two integral values is rounded to the one
    /// with greater magnitude. The following example rounds several values
    /// using this default rule:
    ///
    ///     (5.2).rounded()
    ///     // 5.0
    ///     (5.5).rounded()
    ///     // 6.0
    ///     (-5.2).rounded()
    ///     // -5.0
    ///     (-5.5).rounded()
    ///     // -6.0
    ///
    /// To specify an alternative rule for rounding, use the `rounded(_:)` method
    /// instead.
    ///
    /// - Returns: The nearest integral value, or, if two integral values are
    ///   equally close, the integral value with greater magnitude.
    public func rounded() -> Self

    /// Rounds this value to an integral value using "schoolbook rounding."
    ///
    /// The `round()` method uses the `.toNearestOrAwayFromZero` rounding rule,
    /// where a value halfway between two integral values is rounded to the one
    /// with greater magnitude. The following example rounds several values
    /// using this default rule:
    ///
    ///     var x = 5.2
    ///     x.round()
    ///     // x == 5.0
    ///     var y = 5.5
    ///     y.round()
    ///     // y == 6.0
    ///     var z = -5.5
    ///     z.round()
    ///     // z == -6.0
    ///
    /// To specify an alternative rule for rounding, use the `round(_:)` method
    /// instead.
    public mutating func round()

    /// The greatest representable value that compares less than this value.
    ///
    /// For any finite value `x`, `x.nextDown` is less than `x`. For `nan` or
    /// `-infinity`, `x.nextDown` is `x` itself. The following special cases
    /// also apply:
    ///
    /// - If `x` is `infinity`, then `x.nextDown` is `greatestFiniteMagnitude`.
    /// - If `x` is `leastNonzeroMagnitude`, then `x.nextDown` is `0.0`.
    /// - If `x` is zero, then `x.nextDown` is `-leastNonzeroMagnitude`.
    /// - If `x` is `-greatestFiniteMagnitude`, then `x.nextDown` is `-infinity`.
    public var nextDown: Self { get }

    /// Returns the remainder of this value divided by the given value using
    /// truncating division.
    ///
    /// Performing truncating division with floating-point values results in a
    /// truncated integer quotient and a remainder. For values `x` and `y` and
    /// their truncated integer quotient `q`, the remainder `r` satisfies
    /// `x == y * q + r`.
    ///
    /// The following example calculates the truncating remainder of dividing
    /// 8.625 by 0.75:
    ///
    ///     let x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.towardZero)
    ///     // q == 11.0
    ///     let r = x.truncatingRemainder(dividingBy: 0.75)
    ///     // r == 0.375
    ///
    ///     let x1 = 0.75 * q + r
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are both finite numbers, the truncating
    /// remainder has the same sign as this value and is strictly smaller in
    /// magnitude than `other`. The `truncatingRemainder(dividingBy:)` method
    /// is always exact.
    ///
    /// - Parameter other: The value to use when dividing this value.
    /// - Returns: The remainder of this value divided by `other` using
    ///   truncating division.
    public func truncatingRemainder(dividingBy other: Self) -> Self

    /// Returns the remainder of this value divided by the given value.
    ///
    /// For two finite values `x` and `y`, the remainder `r` of dividing `x` by
    /// `y` satisfies `x == y * q + r`, where `q` is the integer nearest to
    /// `x / y`. If `x / y` is exactly halfway between two integers, `q` is
    /// chosen to be even. Note that `q` is *not* `x / y` computed in
    /// floating-point arithmetic, and that `q` may not be representable in any
    /// available integer type.
    ///
    /// The following example calculates the remainder of dividing 8.625 by 0.75:
    ///
    ///     let x = 8.625
    ///     print(x / 0.75)
    ///     // Prints "11.5"
    ///
    ///     let q = (x / 0.75).rounded(.toNearestOrEven)
    ///     // q == 12.0
    ///     let r = x.remainder(dividingBy: 0.75)
    ///     // r == -0.375
    ///
    ///     let x1 = 0.75 * q + r
    ///     // x1 == 8.625
    ///
    /// If this value and `other` are finite numbers, the remainder is in the
    /// closed range `-abs(other / 2)...abs(other / 2)`. The
    /// `remainder(dividingBy:)` method is always exact. This method implements
    /// the remainder operation defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameter other: The value to use when dividing this value.
    /// - Returns: The remainder of this value divided by `other`.
    public func remainder(dividingBy other: Self) -> Self

    /// Returns the square root of the value, rounded to a representable value.
    ///
    /// The following example declares a function that calculates the length of
    /// the hypotenuse of a right triangle given its two perpendicular sides.
    ///
    ///     func hypotenuse(_ a: Double, _ b: Double) -> Double {
    ///         return (a * a + b * b).squareRoot()
    ///     }
    ///
    ///     let (dx, dy) = (3.0, 4.0)
    ///     let distance = hypotenuse(dx, dy)
    ///     // distance == 5.0
    ///
    /// - Returns: The square root of the value.
    public func squareRoot() -> Self

    /// Returns the result of adding the product of the two given values to this
    /// value, computed without intermediate rounding.
    ///
    /// This method is equivalent to the C `fma` function and implements the
    /// `fusedMultiplyAdd` operation defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - lhs: One of the values to multiply before adding to this value.
    ///   - rhs: The other value to multiply.
    /// - Returns: The product of `lhs` and `rhs`, added to this value.
    public func addingProduct(_ lhs: Self, _ rhs: Self) -> Self

    /// Returns the lesser of the two given values.
    ///
    /// This method returns the minimum of two values, preserving order and
    /// eliminating NaN when possible. For two values `x` and `y`, the result of
    /// `minimum(x, y)` is `x` if `x <= y`, `y` if `y < x`, or whichever of `x`
    /// or `y` is a number if the other is a quiet NaN. If both `x` and `y` are
    /// NaN, or either `x` or `y` is a signaling NaN, the result is NaN.
    ///
    ///     Double.minimum(10.0, -25.0)
    ///     // -25.0
    ///     Double.minimum(10.0, .nan)
    ///     // 10.0
    ///     Double.minimum(.nan, -25.0)
    ///     // -25.0
    ///     Double.minimum(.nan, .nan)
    ///     // nan
    ///
    /// The `minimum` method implements the `minNum` operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - x: A floating-point value.
    ///   - y: Another floating-point value.
    /// - Returns: The minimum of `x` and `y`, or whichever is a number if the
    ///   other is NaN.
    public static func minimum(_ x: Self, _ y: Self) -> Self

    /// Returns the greater of the two given values.
    ///
    /// This method returns the maximum of two values, preserving order and
    /// eliminating NaN when possible. For two values `x` and `y`, the result of
    /// `maximum(x, y)` is `x` if `x > y`, `y` if `x <= y`, or whichever of `x`
    /// or `y` is a number if the other is a quiet NaN. If both `x` and `y` are
    /// NaN, or either `x` or `y` is a signaling NaN, the result is NaN.
    ///
    ///     Double.maximum(10.0, -25.0)
    ///     // 10.0
    ///     Double.maximum(10.0, .nan)
    ///     // 10.0
    ///     Double.maximum(.nan, -25.0)
    ///     // -25.0
    ///     Double.maximum(.nan, .nan)
    ///     // nan
    ///
    /// The `maximum` method implements the `maxNum` operation defined by the
    /// [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - x: A floating-point value.
    ///   - y: Another floating-point value.
    /// - Returns: The greater of `x` and `y`, or whichever is a number if the
    ///   other is NaN.
    public static func maximum(_ x: Self, _ y: Self) -> Self

    /// Returns the value with lesser magnitude.
    ///
    /// This method returns the value with lesser magnitude of the two given
    /// values, preserving order and eliminating NaN when possible. For two
    /// values `x` and `y`, the result of `minimumMagnitude(x, y)` is `x` if
    /// `x.magnitude <= y.magnitude`, `y` if `y.magnitude < x.magnitude`, or
    /// whichever of `x` or `y` is a number if the other is a quiet NaN. If both
    /// `x` and `y` are NaN, or either `x` or `y` is a signaling NaN, the result
    /// is NaN.
    ///
    ///     Double.minimumMagnitude(10.0, -25.0)
    ///     // 10.0
    ///     Double.minimumMagnitude(10.0, .nan)
    ///     // 10.0
    ///     Double.minimumMagnitude(.nan, -25.0)
    ///     // -25.0
    ///     Double.minimumMagnitude(.nan, .nan)
    ///     // nan
    ///
    /// The `minimumMagnitude` method implements the `minNumMag` operation
    /// defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - x: A floating-point value.
    ///   - y: Another floating-point value.
    /// - Returns: Whichever of `x` or `y` has lesser magnitude, or whichever is
    ///   a number if the other is NaN.
    public static func minimumMagnitude(_ x: Self, _ y: Self) -> Self

    /// Returns the value with greater magnitude.
    ///
    /// This method returns the value with greater magnitude of the two given
    /// values, preserving order and eliminating NaN when possible. For two
    /// values `x` and `y`, the result of `maximumMagnitude(x, y)` is `x` if
    /// `x.magnitude > y.magnitude`, `y` if `x.magnitude <= y.magnitude`, or
    /// whichever of `x` or `y` is a number if the other is a quiet NaN. If both
    /// `x` and `y` are NaN, or either `x` or `y` is a signaling NaN, the result
    /// is NaN.
    ///
    ///     Double.maximumMagnitude(10.0, -25.0)
    ///     // -25.0
    ///     Double.maximumMagnitude(10.0, .nan)
    ///     // 10.0
    ///     Double.maximumMagnitude(.nan, -25.0)
    ///     // -25.0
    ///     Double.maximumMagnitude(.nan, .nan)
    ///     // nan
    ///
    /// The `maximumMagnitude` method implements the `maxNumMag` operation
    /// defined by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    ///
    /// - Parameters:
    ///   - x: A floating-point value.
    ///   - y: Another floating-point value.
    /// - Returns: Whichever of `x` or `y` has greater magnitude, or whichever is
    ///   a number if the other is NaN.
    public static func maximumMagnitude(_ x: Self, _ y: Self) -> Self

    /// The classification of this value.
    ///
    /// A value's `floatingPointClass` property describes its "class" as
    /// described by the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    public var floatingPointClass: FloatingPointClassification { get }
}

/// The IEEE 754 floating-point classes.
public enum FloatingPointClassification {

    /// A signaling NaN ("not a number").
    ///
    /// A signaling NaN sets the floating-point exception status when used in
    /// many floating-point operations.
    case signalingNaN

    /// A silent NaN ("not a number") value.
    case quietNaN

    /// A value equal to `-infinity`.
    case negativeInfinity

    /// A negative value that uses the full precision of the floating-point type.
    case negativeNormal

    /// A negative, nonzero number that does not use the full precision of the
    /// floating-point type.
    case negativeSubnormal

    /// A value equal to zero with a negative sign.
    case negativeZero

    /// A value equal to zero with a positive sign.
    case positiveZero

    /// A positive, nonzero number that does not use the full precision of the
    /// floating-point type.
    case positiveSubnormal

    /// A positive value that uses the full precision of the floating-point type.
    case positiveNormal

    /// A value equal to `+infinity`.
    case positiveInfinity
}

/// A rule for rounding a floating-point number.
public enum FloatingPointRoundingRule {

    /// Round to the closest allowed value; if two values are equally close, the
    /// one with greater magnitude is chosen.
    ///
    /// This rounding rule is also known as "schoolbook rounding." The following
    /// example shows the results of rounding numbers using this rule:
    ///
    ///     (5.2).rounded(.toNearestOrAwayFromZero)
    ///     // 5.0
    ///     (5.5).rounded(.toNearestOrAwayFromZero)
    ///     // 6.0
    ///     (-5.2).rounded(.toNearestOrAwayFromZero)
    ///     // -5.0
    ///     (-5.5).rounded(.toNearestOrAwayFromZero)
    ///     // -6.0
    ///
    /// This rule is equivalent to the C `round` function and implements the
    /// `roundToIntegralTiesToAway` operation defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    case toNearestOrAwayFromZero

    /// Round to the closest allowed value; if two values are equally close, the
    /// even one is chosen.
    ///
    /// This rounding rule is also known as "bankers rounding," and is the
    /// default IEEE 754 rounding mode for arithmetic. The following example
    /// shows the results of rounding numbers using this rule:
    ///
    ///     (5.2).rounded(.toNearestOrEven)
    ///     // 5.0
    ///     (5.5).rounded(.toNearestOrEven)
    ///     // 6.0
    ///     (4.5).rounded(.toNearestOrEven)
    ///     // 4.0
    ///
    /// This rule implements the `roundToIntegralTiesToEven` operation defined by
    /// the [IEEE 754 specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    case toNearestOrEven

    /// Round to the closest allowed value that is greater than or equal to the
    /// source.
    ///
    /// The following example shows the results of rounding numbers using this
    /// rule:
    ///
    ///     (5.2).rounded(.up)
    ///     // 6.0
    ///     (5.5).rounded(.up)
    ///     // 6.0
    ///     (-5.2).rounded(.up)
    ///     // -5.0
    ///     (-5.5).rounded(.up)
    ///     // -5.0
    ///
    /// This rule is equivalent to the C `ceil` function and implements the
    /// `roundToIntegralTowardPositive` operation defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    case up

    /// Round to the closest allowed value that is less than or equal to the
    /// source.
    ///
    /// The following example shows the results of rounding numbers using this
    /// rule:
    ///
    ///     (5.2).rounded(.down)
    ///     // 5.0
    ///     (5.5).rounded(.down)
    ///     // 5.0
    ///     (-5.2).rounded(.down)
    ///     // -6.0
    ///     (-5.5).rounded(.down)
    ///     // -6.0
    ///
    /// This rule is equivalent to the C `floor` function and implements the
    /// `roundToIntegralTowardNegative` operation defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    case down

    /// Round to the closest allowed value whose magnitude is less than or equal
    /// to that of the source.
    ///
    /// The following example shows the results of rounding numbers using this
    /// rule:
    ///
    ///     (5.2).rounded(.towardZero)
    ///     // 5.0
    ///     (5.5).rounded(.towardZero)
    ///     // 5.0
    ///     (-5.2).rounded(.towardZero)
    ///     // -5.0
    ///     (-5.5).rounded(.towardZero)
    ///     // -5.0
    ///
    /// This rule is equivalent to the C `trunc` function and implements the
    /// `roundToIntegralTowardZero` operation defined by the [IEEE 754
    /// specification][spec].
    ///
    /// [spec]: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933
    case towardZero

    /// Round to the closest allowed value whose magnitude is greater than or
    /// equal to that of the source.
    ///
    /// The following example shows the results of rounding numbers using this
    /// rule:
    ///
    ///     (5.2).rounded(.awayFromZero)
    ///     // 6.0
    ///     (5.5).rounded(.awayFromZero)
    ///     // 6.0
    ///     (-5.2).rounded(.awayFromZero)
    ///     // -6.0
    ///     (-5.5).rounded(.awayFromZero)
    ///     // -6.0
    case awayFromZero
}

/// The sign of a floating-point value.
public enum FloatingPointSign : Int {

    /// The sign for a positive value.
    case plus

    /// The sign for a negative value.
    case minus
}

/// A type that can be hashed into a `Hasher` to produce an integer hash value.
///
/// You can use any type that conforms to the `Hashable` protocol in a set or as
/// a dictionary key. Many types in the standard library conform to `Hashable`:
/// Strings, integers, floating-point and Boolean values, and even sets are
/// hashable by default. Some other types, such as optionals, arrays and ranges
/// automatically become hashable when their type arguments implement the same.
///
/// Your own custom types can be hashable as well. When you define an
/// enumeration without associated values, it gains `Hashable` conformance
/// automatically, and you can add `Hashable` conformance to your other custom
/// types by implementing the `hash(into:)` method. For structs whose stored
/// properties are all `Hashable`, and for enum types that have all-`Hashable`
/// associated values, the compiler is able to provide an implementation of
/// `hash(into:)` automatically.
///
/// Hashing a value means feeding its essential components into a hash function,
/// represented by the `Hasher` type. Essential components are those that
/// contribute to the type's implementation of `Equatable`. Two instances that
/// are equal must feed the same values to `Hasher` in `hash(into:)`, in the
/// same order.
///
/// Conforming to the Hashable Protocol
/// ===================================
///
/// To use your own custom type in a set or as the key type of a dictionary,
/// add `Hashable` conformance to your type. The `Hashable` protocol inherits
/// from the `Equatable` protocol, so you must also satisfy that protocol's
/// requirements.
///
/// The compiler automatically synthesizes your custom type's `Hashable` and
/// requirements when you declare `Hashable` conformance in the type's original
/// declaration and your type meets these criteria:
///
/// - For a `struct`, all its stored properties must conform to `Hashable`.
/// - For an `enum`, all its associated values must conform to `Hashable`. (An
///   `enum` without associated values has `Hashable` conformance even without
///   the declaration.)
///
/// To customize your type's `Hashable` conformance, to adopt `Hashable` in a
/// type that doesn't meet the criteria listed above, or to extend an existing
/// type to conform to `Hashable`, implement the `hash(into:)` method in your
/// custom type.
///
/// In your `hash(into:)` implementation, call `combine(_:)` on the provided
/// `Hasher` instance with the essential components of your type. To ensure
/// that your type meets the semantic requirements of the `Hashable` and
/// `Equatable` protocols, it's a good idea to also customize your type's
/// `Equatable` conformance to match.
///
/// As an example, consider a `GridPoint` type that describes a location in a
/// grid of buttons. Here's the initial declaration of the `GridPoint` type:
///
///     /// A point in an x-y coordinate system.
///     struct GridPoint {
///         var x: Int
///         var y: Int
///     }
///
/// You'd like to create a set of the grid points where a user has already
/// tapped. Because the `GridPoint` type is not hashable yet, it can't be used
/// in a set. To add `Hashable` conformance, provide an `==` operator function
/// and implement the `hash(into:)` method.
///
///     extension GridPoint: Hashable {
///         static func == (lhs: GridPoint, rhs: GridPoint) -> Bool {
///             return lhs.x == rhs.x && lhs.y == rhs.y
///         }
///
///         func hash(into hasher: inout Hasher) {
///             hasher.combine(x)
///             hasher.combine(y)
///         }
///     }
///
/// The `hash(into:)` method in this example feeds the grid point's `x` and `y`
/// properties into the provided hasher. These properties are the same ones
/// used to test for equality in the `==` operator function.
///
/// Now that `GridPoint` conforms to the `Hashable` protocol, you can create a
/// set of previously tapped grid points.
///
///     var tappedPoints: Set = [GridPoint(x: 2, y: 3), GridPoint(x: 4, y: 1)]
///     let nextTap = GridPoint(x: 0, y: 1)
///     if tappedPoints.contains(nextTap) {
///         print("Already tapped at (\(nextTap.x), \(nextTap.y)).")
///     } else {
///         tappedPoints.insert(nextTap)
///         print("New tap detected at (\(nextTap.x), \(nextTap.y)).")
///     }
///     // Prints "New tap detected at (0, 1).")
public protocol Hashable : Equatable {

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

/// The universal hash function used by `Set` and `Dictionary`.
///
/// `Hasher` can be used to map an arbitrary sequence of bytes to an integer
/// hash value. You can feed data to the hasher using a series of calls to
/// mutating `combine` methods. When you've finished feeding the hasher, the
/// hash value can be retrieved by calling `finalize()`:
///
///     var hasher = Hasher()
///     hasher.combine(23)
///     hasher.combine("Hello")
///     let hashValue = hasher.finalize()
///
/// Within the execution of a Swift program, `Hasher` guarantees that finalizing
/// it will always produce the same hash value as long as it is fed the exact
/// same sequence of bytes. However, the underlying hash algorithm is designed
/// to exhibit avalanche effects: slight changes to the seed or the input byte
/// sequence will typically produce drastic changes in the generated hash value.
///
/// - Note: Do not save or otherwise reuse hash values across executions of your
///   program. `Hasher` is usually randomly seeded, which means it will return
///   different values on every new execution of your program. The hash
///   algorithm implemented by `Hasher` may itself change between any two
///   versions of the standard library.
public struct Hasher {

    /// Initialize a new hasher.  The hasher uses a per-execution seed value that
    /// is set during process startup, usually from a high-quality random source.
    public init()

    /// Feed `value` to this hasher, mixing its essential parts into
    /// the hasher state.
    public mutating func combine<H>(_ value: H) where H : Hashable

    /// Feed the contents of `buffer` into this hasher, mixing it into the hasher
    /// state.
    public mutating func combine(bytes: UnsafeRawBufferPointer)

    /// Finalize the hasher state and return the hash value.
    ///
    /// Finalizing consumes the hasher: it is illegal to finalize a hasher you
    /// don't own, or to perform operations on a finalized hasher. (These may
    /// become compile-time errors in the future.)
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public __consuming func finalize() -> Int
}

/// A type that provides subscript access to its elements, with forward index
/// traversal.
///
/// In most cases, it's best to ignore this protocol and use the `Collection`
/// protocol instead, because it has a more complete interface.
@available(*, deprecated, message: "it will be removed in Swift 4.0.  Please use 'Collection' instead")
public typealias Indexable = Collection

/// A type that provides subscript access to its elements, with forward
/// index traversal.
///
/// In most cases, it's best to ignore this protocol and use the `Collection`
/// protocol instead, because it has a more complete interface.
@available(*, deprecated, message: "it will be removed in Swift 4.0.  Please use 'Collection' instead")
public typealias IndexableBase = Collection

/// A type that iterates over a collection using its indices.
///
/// The `IndexingIterator` type is the default iterator for any collection that
/// doesn't declare its own. It acts as an iterator by using a collection's
/// indices to step over each value in the collection. Most collections in the
/// standard library use `IndexingIterator` as their iterator.
///
/// By default, any custom collection type you create will inherit a
/// `makeIterator()` method that returns an `IndexingIterator` instance,
/// making it unnecessary to declare your own. When creating a custom
/// collection type, add the minimal requirements of the `Collection`
/// protocol: starting and ending indices and a subscript for accessing
/// elements. With those elements defined, the inherited `makeIterator()`
/// method satisfies the requirements of the `Sequence` protocol.
///
/// Here's an example of a type that declares the minimal requirements for a
/// collection. The `CollectionOfTwo` structure is a fixed-size collection
/// that always holds two elements of a specific type.
///
///     struct CollectionOfTwo<Element>: Collection {
///         let elements: (Element, Element)
///
///         init(_ first: Element, _ second: Element) {
///             self.elements = (first, second)
///         }
///
///         var startIndex: Int { return 0 }
///         var endIndex: Int   { return 2 }
///
///         subscript(index: Int) -> Element {
///             switch index {
///             case 0: return elements.0
///             case 1: return elements.1
///             default: fatalError("Index out of bounds.")
///             }
///         }
///         
///         func index(after i: Int) -> Int {
///             precondition(i < endIndex, "Can't advance beyond endIndex")
///             return i + 1
///         }
///     }
///
/// Because `CollectionOfTwo` doesn't define its own `makeIterator()`
/// method or `Iterator` associated type, it uses the default iterator type,
/// `IndexingIterator`. This example shows how a `CollectionOfTwo` instance
/// can be created holding the values of a point, and then iterated over
/// using a `for`-`in` loop.
///
///     let point = CollectionOfTwo(15.0, 20.0)
///     for element in point {
///         print(element)
///     }
///     // Prints "15.0"
///     // Prints "20.0"
public struct IndexingIterator<Elements> where Elements : Collection {
}

extension IndexingIterator : IteratorProtocol, Sequence where Elements : Collection {

    /// The type of element traversed by the iterator.
    public typealias Element = Elements.Element

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = IndexingIterator<Elements>

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = AnySequence<Elements.Element>

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns all the elements of the underlying
    /// sequence in order. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// This example shows how an iterator can be used explicitly to emulate a
    /// `for`-`in` loop. First, retrieve a sequence's iterator, and then call
    /// the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> Elements.Element?
}

/// A signed integer value type.
///
/// On 32-bit platforms, `Int` is the same size as `Int32`, and
/// on 64-bit platforms, `Int` is the same size as `Int64`.
public struct Int : FixedWidthInteger, SignedInteger {

    /// A type that represents an integer literal.
    public typealias IntegerLiteralType = Int

    /// Creates a new instance with the same memory representation as the given
    /// value.
    ///
    /// This initializer does not perform any range or overflow checking. The
    /// resulting instance may not have the same numeric value as
    /// `bitPattern`---it is only guaranteed to use the same pattern of bits in
    /// its binary representation.
    ///
    /// - Parameter x: A value to use as the source of the new instance's binary
    ///   representation.
    public init(bitPattern x: UInt)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Double)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Double)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float80)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float80)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Int, rhs: Int) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Int, rhs: Int) -> Bool

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x += 120
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Int, rhs: Int)

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     var x: UInt8 = 21
    ///     x - 50
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Int, rhs: Int)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x * 21
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Int, rhs: Int)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     var x = 21
    ///     x /= 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func /= (lhs: inout Int, rhs: Int)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.dividedReportingOverflow(by: 0)` is `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the division along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   quotient. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains either the truncated quotient
    ///   or, if the quotient is undefined, the dividend.
    public func dividedReportingOverflow(by other: Int) -> (partialValue: Int, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.remainderReportingOverflow(dividingBy: 0)` is
    /// `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the operation along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   remainder. If the `overflow` component is `true`, an overflow occurred
    ///   during division and the `partialValue` component contains either the
    ///   entire remainder or, if the remainder is undefined, the dividend.
    public func remainderReportingOverflow(dividingBy other: Int) -> (partialValue: Int, overflow: Bool)

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: A tuple containing the result of the addition along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   sum. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated sum of this value
    ///   and `rhs`.
    public func addingReportingOverflow(_ other: Int) -> (partialValue: Int, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    /// the operation.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: A tuple containing the result of the subtraction along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   difference. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains the truncated result of `rhs`
    ///   subtracted from this value.
    public func subtractingReportingOverflow(_ other: Int) -> (partialValue: Int, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: A tuple containing the result of the multiplication along with
    ///   a Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   product. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated product of this
    ///   value and `rhs`.
    public func multipliedReportingOverflow(by other: Int) -> (partialValue: Int, overflow: Bool)

    /// Divides the first value by the second and stores the remainder in the
    /// left-hand-side variable.
    ///
    /// The result has the same sign as `lhs` and is less than `rhs.magnitude`.
    ///
    ///     var x = 22
    ///     x %= 5
    ///     // x == 2
    ///
    ///     var y = 22
    ///     y %= -5
    ///     // y == 2
    ///
    ///     var z = -22
    ///     z %= -5
    ///     // z == -2
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func %= (lhs: inout Int, rhs: Int)

    /// Stores the result of performing a bitwise AND operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x &= y                    // 0b00000100
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func &= (lhs: inout Int, rhs: Int)

    /// Stores the result of performing a bitwise OR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x |= y                    // 0b00001111
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func |= (lhs: inout Int, rhs: Int)

    /// Stores the result of performing a bitwise XOR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x ^= y                    // 0b00001011
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^= (lhs: inout Int, rhs: Int)

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= (lhs: inout Int, rhs: Int)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= (lhs: inout Int, rhs: Int)

    /// The number of bits used for the underlying binary representation of
    /// values of this type.
    ///
    /// The bit width of a `Int` instance is 32 on 32-bit
    /// platforms and 64 on 64-bit platforms.
    public static var bitWidth: Int { get }

    /// The number of leading zeros in this value's binary representation.
    ///
    /// For example, in an integer type with a `bitWidth` value of 8,
    /// the number *31* has three leading zeros.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.leadingZeroBitCount == 3
    public var leadingZeroBitCount: Int { get }

    /// The number of trailing zeros in this value's binary representation.
    ///
    /// For example, the number *-8* has three trailing zeros.
    ///
    ///     let x = Int8(bitPattern: 0b1111_1000)
    ///     // x == -8
    ///     // x.trailingZeroBitCount == 3
    public var trailingZeroBitCount: Int { get }

    /// The number of bits equal to 1 in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has five bits equal to *1*.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.nonzeroBitCount == 5
    public var nonzeroBitCount: Int { get }

    /// A type that represents the words of this integer.
    public struct Words : BidirectionalCollection {

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = Range<Int>

        /// A type that represents a subsequence of some of the sequence's elements.
        public typealias SubSequence = Slice<Int.Words>

        public init(_ value: Int)

        /// The number of elements in the collection.
        ///
        /// To check whether a collection is empty, use its `isEmpty` property
        /// instead of comparing `count` to zero. Unless the collection guarantees
        /// random-access performance, calculating `count` can be an O(*n*)
        /// operation.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
        ///   of the collection.
        public var count: Int { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: Int.Words.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Int) -> Int

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: Int) -> Int

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> UInt { get }
    }

    /// A collection containing the words of this value's binary
    /// representation, in order from the least significant to most significant.
    ///
    /// Negative values are returned in two's complement representation,
    /// regardless of the type's underlying implementation.
    public var words: Int.Words { get }

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = UInt

    /// The magnitude of this value.
    ///
    /// For any numeric value `x`, `x.magnitude` is the absolute value of `x`.
    /// You can use the `magnitude` property in operations that are simpler to
    /// implement in terms of unsigned values, such as printing the value of an
    /// integer, which is just printing a '-' character in front of an absolute
    /// value.
    ///
    ///     let x = -200
    ///     // x.magnitude == 200
    ///
    /// The global `abs(_:)` function provides more familiar syntax when you need
    /// to find an absolute value. In addition, because `abs(_:)` always returns
    /// a value of the same type, even in a generic context, using the function
    /// instead of the `magnitude` property is encouraged.
    public var magnitude: UInt { get }

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    ///
    /// Use this method to calculate the full result of a product that would
    /// otherwise overflow. Unlike traditional truncating multiplication, the
    /// `multipliedFullWidth(by:)` method returns a tuple
    /// containing both the `high` and `low` parts of the product of this value and
    /// `other`. The following example uses this method to multiply two `UInt8`
    /// values that normally overflow when multiplied:
    ///
    ///     let x: UInt8 = 100
    ///     let y: UInt8 = 20
    ///     let result = x.multipliedFullWidth(by: y)
    ///     // result.high == 0b00000111
    ///     // result.low  == 0b11010000
    ///
    /// The product of `x` and `y` is 2000, which is too large to represent in a
    /// `UInt8` instance. The `high` and `low` properties of the `result` value
    /// represent 2000 when concatenated to form a double-width integer; that
    /// is, using `result.high` as the high byte and `result.low` as the low byte
    /// of a `UInt16` instance.
    ///
    ///     let z = UInt16(result.high) << 8 | UInt16(result.low)
    ///     // z == 2000
    ///
    /// - Parameter other: The value to multiply this value by.
    /// - Returns: A tuple containing the high and low parts of the result of
    ///   multiplying this value and `other`.
    public func multipliedFullWidth(by other: Int) -> (high: Int, low: Int.Magnitude)

    /// Returns a tuple containing the quotient and remainder of dividing the
    /// given value by this value.
    ///
    /// The resulting quotient must be representable within the bounds of the
    /// type. If the quotient of dividing `dividend` by this value is too large
    /// to represent in the type, a runtime error may occur.
    ///
    /// - Parameter dividend: A tuple containing the high and low parts of a
    ///   double-width integer. The `high` component of the value carries the
    ///   sign, if the type is signed.
    /// - Returns: A tuple containing the quotient and remainder of `dividend`
    ///   divided by this value.
    public func dividingFullWidth(_ dividend: (high: Int, low: Int.Magnitude)) -> (quotient: Int, remainder: Int)

    /// A representation of this integer with the byte order swapped.
    public var byteSwapped: Int { get }

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> Int
}

extension Int : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Int {

    /// Creates a new value with the bit pattern of the given pointer.
    ///
    /// The new value represents the address of the pointer passed as `pointer`.
    /// If `pointer` is `nil`, the result is `0`.
    ///
    /// - Parameter pointer: The pointer to use as the source for the new
    ///   integer.
    public init(bitPattern pointer: OpaquePointer?)
}

extension Int {

    /// Returns the distance from this value to the given value, expressed as a
    /// stride.
    ///
    /// For two values `x` and `y`, and a distance `n = x.distance(to: y)`,
    /// `x.advanced(by: n) == y`.
    ///
    /// - Parameter other: The value to calculate the distance to.
    /// - Returns: The distance from this value to `other`.
    public func distance(to other: Int) -> Int

    /// Returns a value that is offset the specified distance from this value.
    ///
    /// Use the `advanced(by:)` method in generic code to offset a value by a
    /// specified distance. If you're working directly with numeric values, use
    /// the addition operator (`+`) instead of this method.
    ///
    /// For a value `x`, a distance `n`, and a value `y = x.advanced(by: n)`,
    /// `x.distance(to: y) == n`.
    ///
    /// - Parameter n: The distance to advance this value.
    /// - Returns: A value that is offset from this value by `n`.
    public func advanced(by n: Int) -> Int
}

extension Int : Hashable {

    /// The integer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program. Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Int {

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: Int, rhs: Int) -> Int

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: Int, rhs: Int) -> Int

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: Int, rhs: Int) -> Int

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: Int, rhs: Int) -> Int

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: Int, rhs: Int) -> Int

    /// Returns the quotient of dividing the first value by the second.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     let x = 21 / 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func / (lhs: Int, rhs: Int) -> Int

    /// Returns the remainder of dividing the first value by the second.
    ///
    /// The result of the modulo operator (`%`) has the same sign as `lhs` and is
    /// less than `rhs.magnitude`.
    ///
    ///     let x = 22 % 5
    ///     // x == 2
    ///     let y = 22 % -5
    ///     // y == 2
    ///     let z = -22 % -5
    ///     // z == -2
    ///
    /// For any two integers `a` and `b`, their quotient `q`, and their remainder
    /// `r`, `a == b * q + r`.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func % (lhs: Int, rhs: Int) -> Int

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x + 120                 // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow addition operator (`&+`).
    ///
    ///     x &+ 120                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Int, rhs: Int) -> Int

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     x - 50                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow subtraction operator (`&-`).
    ///
    ///     x &- 50                // 227
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Int, rhs: Int) -> Int

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x * 21                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow multiplication operator (`&*`).
    ///
    ///     x &* 21                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Int, rhs: Int) -> Int

    public static func != (lhs: Int, rhs: Int) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: Int, rhs: Int) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: Int, rhs: Int) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: Int, rhs: Int) -> Bool
}

extension Int : CustomReflectable {

    /// A mirror that reflects the `Int` instance.
    public var customMirror: Mirror { get }
}

extension Int : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `Int` instance.
    @available(*, deprecated, message: "Int.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Int {

    /// Creates an integer that captures the full value of the given object
    /// identifier.
    public init(bitPattern objectID: ObjectIdentifier)
}

extension Int {

    /// Creates a new value with the bit pattern of the given pointer.
    ///
    /// The new value represents the address of the pointer passed as `pointer`.
    /// If `pointer` is `nil`, the result is `0`.
    ///
    /// - Parameter pointer: The pointer to use as the source for the new
    ///   integer.
    public init<U>(bitPattern pointer: UnsafeMutablePointer<U>?)
}

extension Int {

    /// Creates a new value with the bit pattern of the given pointer.
    ///
    /// The new value represents the address of the pointer passed as `pointer`.
    /// If `pointer` is `nil`, the result is `0`.
    ///
    /// - Parameter pointer: The pointer to use as the source for the new
    ///   integer.
    public init<U>(bitPattern pointer: UnsafePointer<U>?)
}

extension Int {

    /// Creates a new value with the bit pattern of the given pointer.
    ///
    /// The new value represents the address of the pointer passed as `pointer`.
    /// If `pointer` is `nil`, the result is `0`.
    ///
    /// - Parameter pointer: The pointer to use as the source for the new
    ///   integer.
    public init(bitPattern pointer: UnsafeMutableRawPointer?)
}

extension Int {

    /// Creates a new value with the bit pattern of the given pointer.
    ///
    /// The new value represents the address of the pointer passed as `pointer`.
    /// If `pointer` is `nil`, the result is `0`.
    ///
    /// - Parameter pointer: The pointer to use as the source for the new
    ///   integer.
    public init(bitPattern pointer: UnsafeRawPointer?)
}

extension Int : MirrorPath {
}

extension Int : CVarArg {
}

/// A 16-bit signed integer value
/// type.
public struct Int16 : FixedWidthInteger, SignedInteger {

    /// A type that represents an integer literal.
    public typealias IntegerLiteralType = Int16

    /// Creates a new instance with the same memory representation as the given
    /// value.
    ///
    /// This initializer does not perform any range or overflow checking. The
    /// resulting instance may not have the same numeric value as
    /// `bitPattern`---it is only guaranteed to use the same pattern of bits in
    /// its binary representation.
    ///
    /// - Parameter x: A value to use as the source of the new instance's binary
    ///   representation.
    public init(bitPattern x: UInt16)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Double)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Double)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float80)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float80)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Int16, rhs: Int16) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Int16, rhs: Int16) -> Bool

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x += 120
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Int16, rhs: Int16)

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     var x: UInt8 = 21
    ///     x - 50
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Int16, rhs: Int16)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x * 21
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Int16, rhs: Int16)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     var x = 21
    ///     x /= 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func /= (lhs: inout Int16, rhs: Int16)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.dividedReportingOverflow(by: 0)` is `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the division along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   quotient. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains either the truncated quotient
    ///   or, if the quotient is undefined, the dividend.
    public func dividedReportingOverflow(by other: Int16) -> (partialValue: Int16, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.remainderReportingOverflow(dividingBy: 0)` is
    /// `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the operation along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   remainder. If the `overflow` component is `true`, an overflow occurred
    ///   during division and the `partialValue` component contains either the
    ///   entire remainder or, if the remainder is undefined, the dividend.
    public func remainderReportingOverflow(dividingBy other: Int16) -> (partialValue: Int16, overflow: Bool)

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: A tuple containing the result of the addition along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   sum. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated sum of this value
    ///   and `rhs`.
    public func addingReportingOverflow(_ other: Int16) -> (partialValue: Int16, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    /// the operation.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: A tuple containing the result of the subtraction along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   difference. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains the truncated result of `rhs`
    ///   subtracted from this value.
    public func subtractingReportingOverflow(_ other: Int16) -> (partialValue: Int16, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: A tuple containing the result of the multiplication along with
    ///   a Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   product. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated product of this
    ///   value and `rhs`.
    public func multipliedReportingOverflow(by other: Int16) -> (partialValue: Int16, overflow: Bool)

    /// Divides the first value by the second and stores the remainder in the
    /// left-hand-side variable.
    ///
    /// The result has the same sign as `lhs` and is less than `rhs.magnitude`.
    ///
    ///     var x = 22
    ///     x %= 5
    ///     // x == 2
    ///
    ///     var y = 22
    ///     y %= -5
    ///     // y == 2
    ///
    ///     var z = -22
    ///     z %= -5
    ///     // z == -2
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func %= (lhs: inout Int16, rhs: Int16)

    /// Stores the result of performing a bitwise AND operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x &= y                    // 0b00000100
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func &= (lhs: inout Int16, rhs: Int16)

    /// Stores the result of performing a bitwise OR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x |= y                    // 0b00001111
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func |= (lhs: inout Int16, rhs: Int16)

    /// Stores the result of performing a bitwise XOR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x ^= y                    // 0b00001011
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^= (lhs: inout Int16, rhs: Int16)

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= (lhs: inout Int16, rhs: Int16)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= (lhs: inout Int16, rhs: Int16)

    /// The number of bits used for the underlying binary representation of
    /// values of this type.
    ///
    /// The bit width of a `Int16` instance is 16.
    public static var bitWidth: Int { get }

    /// The number of leading zeros in this value's binary representation.
    ///
    /// For example, in an integer type with a `bitWidth` value of 8,
    /// the number *31* has three leading zeros.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.leadingZeroBitCount == 3
    public var leadingZeroBitCount: Int { get }

    /// The number of trailing zeros in this value's binary representation.
    ///
    /// For example, the number *-8* has three trailing zeros.
    ///
    ///     let x = Int8(bitPattern: 0b1111_1000)
    ///     // x == -8
    ///     // x.trailingZeroBitCount == 3
    public var trailingZeroBitCount: Int { get }

    /// The number of bits equal to 1 in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has five bits equal to *1*.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.nonzeroBitCount == 5
    public var nonzeroBitCount: Int { get }

    /// A type that represents the words of this integer.
    public struct Words : BidirectionalCollection {

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = Range<Int>

        /// A type that represents a subsequence of some of the sequence's elements.
        public typealias SubSequence = Slice<Int16.Words>

        public init(_ value: Int16)

        /// The number of elements in the collection.
        ///
        /// To check whether a collection is empty, use its `isEmpty` property
        /// instead of comparing `count` to zero. Unless the collection guarantees
        /// random-access performance, calculating `count` can be an O(*n*)
        /// operation.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
        ///   of the collection.
        public var count: Int { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: Int16.Words.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Int) -> Int

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: Int) -> Int

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> UInt { get }
    }

    /// A collection containing the words of this value's binary
    /// representation, in order from the least significant to most significant.
    ///
    /// Negative values are returned in two's complement representation,
    /// regardless of the type's underlying implementation.
    public var words: Int16.Words { get }

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = UInt16

    /// The magnitude of this value.
    ///
    /// For any numeric value `x`, `x.magnitude` is the absolute value of `x`.
    /// You can use the `magnitude` property in operations that are simpler to
    /// implement in terms of unsigned values, such as printing the value of an
    /// integer, which is just printing a '-' character in front of an absolute
    /// value.
    ///
    ///     let x = -200
    ///     // x.magnitude == 200
    ///
    /// The global `abs(_:)` function provides more familiar syntax when you need
    /// to find an absolute value. In addition, because `abs(_:)` always returns
    /// a value of the same type, even in a generic context, using the function
    /// instead of the `magnitude` property is encouraged.
    public var magnitude: UInt16 { get }

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    ///
    /// Use this method to calculate the full result of a product that would
    /// otherwise overflow. Unlike traditional truncating multiplication, the
    /// `multipliedFullWidth(by:)` method returns a tuple
    /// containing both the `high` and `low` parts of the product of this value and
    /// `other`. The following example uses this method to multiply two `UInt8`
    /// values that normally overflow when multiplied:
    ///
    ///     let x: UInt8 = 100
    ///     let y: UInt8 = 20
    ///     let result = x.multipliedFullWidth(by: y)
    ///     // result.high == 0b00000111
    ///     // result.low  == 0b11010000
    ///
    /// The product of `x` and `y` is 2000, which is too large to represent in a
    /// `UInt8` instance. The `high` and `low` properties of the `result` value
    /// represent 2000 when concatenated to form a double-width integer; that
    /// is, using `result.high` as the high byte and `result.low` as the low byte
    /// of a `UInt16` instance.
    ///
    ///     let z = UInt16(result.high) << 8 | UInt16(result.low)
    ///     // z == 2000
    ///
    /// - Parameter other: The value to multiply this value by.
    /// - Returns: A tuple containing the high and low parts of the result of
    ///   multiplying this value and `other`.
    public func multipliedFullWidth(by other: Int16) -> (high: Int16, low: Int16.Magnitude)

    /// Returns a tuple containing the quotient and remainder of dividing the
    /// given value by this value.
    ///
    /// The resulting quotient must be representable within the bounds of the
    /// type. If the quotient of dividing `dividend` by this value is too large
    /// to represent in the type, a runtime error may occur.
    ///
    /// - Parameter dividend: A tuple containing the high and low parts of a
    ///   double-width integer. The `high` component of the value carries the
    ///   sign, if the type is signed.
    /// - Returns: A tuple containing the quotient and remainder of `dividend`
    ///   divided by this value.
    public func dividingFullWidth(_ dividend: (high: Int16, low: Int16.Magnitude)) -> (quotient: Int16, remainder: Int16)

    /// A representation of this integer with the byte order swapped.
    public var byteSwapped: Int16 { get }

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> Int16
}

extension Int16 : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Int16 : Hashable {

    /// The integer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program. Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Int16 {

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: Int16, rhs: Int16) -> Int16

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: Int16, rhs: Int16) -> Int16

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: Int16, rhs: Int16) -> Int16

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: Int16, rhs: Int16) -> Int16

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: Int16, rhs: Int16) -> Int16

    /// Returns the quotient of dividing the first value by the second.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     let x = 21 / 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func / (lhs: Int16, rhs: Int16) -> Int16

    /// Returns the remainder of dividing the first value by the second.
    ///
    /// The result of the modulo operator (`%`) has the same sign as `lhs` and is
    /// less than `rhs.magnitude`.
    ///
    ///     let x = 22 % 5
    ///     // x == 2
    ///     let y = 22 % -5
    ///     // y == 2
    ///     let z = -22 % -5
    ///     // z == -2
    ///
    /// For any two integers `a` and `b`, their quotient `q`, and their remainder
    /// `r`, `a == b * q + r`.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func % (lhs: Int16, rhs: Int16) -> Int16

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x + 120                 // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow addition operator (`&+`).
    ///
    ///     x &+ 120                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Int16, rhs: Int16) -> Int16

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     x - 50                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow subtraction operator (`&-`).
    ///
    ///     x &- 50                // 227
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Int16, rhs: Int16) -> Int16

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x * 21                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow multiplication operator (`&*`).
    ///
    ///     x &* 21                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Int16, rhs: Int16) -> Int16

    public static func != (lhs: Int16, rhs: Int16) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: Int16, rhs: Int16) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: Int16, rhs: Int16) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: Int16, rhs: Int16) -> Bool
}

extension Int16 : CustomReflectable {

    /// A mirror that reflects the `Int16` instance.
    public var customMirror: Mirror { get }
}

extension Int16 : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `Int16` instance.
    @available(*, deprecated, message: "Int16.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Int16 : CVarArg {
}

/// A 32-bit signed integer value
/// type.
public struct Int32 : FixedWidthInteger, SignedInteger {

    /// A type that represents an integer literal.
    public typealias IntegerLiteralType = Int32

    /// Creates a new instance with the same memory representation as the given
    /// value.
    ///
    /// This initializer does not perform any range or overflow checking. The
    /// resulting instance may not have the same numeric value as
    /// `bitPattern`---it is only guaranteed to use the same pattern of bits in
    /// its binary representation.
    ///
    /// - Parameter x: A value to use as the source of the new instance's binary
    ///   representation.
    public init(bitPattern x: UInt32)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Double)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Double)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float80)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float80)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Int32, rhs: Int32) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Int32, rhs: Int32) -> Bool

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x += 120
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Int32, rhs: Int32)

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     var x: UInt8 = 21
    ///     x - 50
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Int32, rhs: Int32)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x * 21
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Int32, rhs: Int32)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     var x = 21
    ///     x /= 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func /= (lhs: inout Int32, rhs: Int32)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.dividedReportingOverflow(by: 0)` is `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the division along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   quotient. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains either the truncated quotient
    ///   or, if the quotient is undefined, the dividend.
    public func dividedReportingOverflow(by other: Int32) -> (partialValue: Int32, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.remainderReportingOverflow(dividingBy: 0)` is
    /// `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the operation along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   remainder. If the `overflow` component is `true`, an overflow occurred
    ///   during division and the `partialValue` component contains either the
    ///   entire remainder or, if the remainder is undefined, the dividend.
    public func remainderReportingOverflow(dividingBy other: Int32) -> (partialValue: Int32, overflow: Bool)

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: A tuple containing the result of the addition along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   sum. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated sum of this value
    ///   and `rhs`.
    public func addingReportingOverflow(_ other: Int32) -> (partialValue: Int32, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    /// the operation.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: A tuple containing the result of the subtraction along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   difference. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains the truncated result of `rhs`
    ///   subtracted from this value.
    public func subtractingReportingOverflow(_ other: Int32) -> (partialValue: Int32, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: A tuple containing the result of the multiplication along with
    ///   a Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   product. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated product of this
    ///   value and `rhs`.
    public func multipliedReportingOverflow(by other: Int32) -> (partialValue: Int32, overflow: Bool)

    /// Divides the first value by the second and stores the remainder in the
    /// left-hand-side variable.
    ///
    /// The result has the same sign as `lhs` and is less than `rhs.magnitude`.
    ///
    ///     var x = 22
    ///     x %= 5
    ///     // x == 2
    ///
    ///     var y = 22
    ///     y %= -5
    ///     // y == 2
    ///
    ///     var z = -22
    ///     z %= -5
    ///     // z == -2
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func %= (lhs: inout Int32, rhs: Int32)

    /// Stores the result of performing a bitwise AND operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x &= y                    // 0b00000100
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func &= (lhs: inout Int32, rhs: Int32)

    /// Stores the result of performing a bitwise OR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x |= y                    // 0b00001111
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func |= (lhs: inout Int32, rhs: Int32)

    /// Stores the result of performing a bitwise XOR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x ^= y                    // 0b00001011
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^= (lhs: inout Int32, rhs: Int32)

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= (lhs: inout Int32, rhs: Int32)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= (lhs: inout Int32, rhs: Int32)

    /// The number of bits used for the underlying binary representation of
    /// values of this type.
    ///
    /// The bit width of a `Int32` instance is 32.
    public static var bitWidth: Int { get }

    /// The number of leading zeros in this value's binary representation.
    ///
    /// For example, in an integer type with a `bitWidth` value of 8,
    /// the number *31* has three leading zeros.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.leadingZeroBitCount == 3
    public var leadingZeroBitCount: Int { get }

    /// The number of trailing zeros in this value's binary representation.
    ///
    /// For example, the number *-8* has three trailing zeros.
    ///
    ///     let x = Int8(bitPattern: 0b1111_1000)
    ///     // x == -8
    ///     // x.trailingZeroBitCount == 3
    public var trailingZeroBitCount: Int { get }

    /// The number of bits equal to 1 in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has five bits equal to *1*.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.nonzeroBitCount == 5
    public var nonzeroBitCount: Int { get }

    /// A type that represents the words of this integer.
    public struct Words : BidirectionalCollection {

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = Range<Int>

        /// A type that represents a subsequence of some of the sequence's elements.
        public typealias SubSequence = Slice<Int32.Words>

        public init(_ value: Int32)

        /// The number of elements in the collection.
        ///
        /// To check whether a collection is empty, use its `isEmpty` property
        /// instead of comparing `count` to zero. Unless the collection guarantees
        /// random-access performance, calculating `count` can be an O(*n*)
        /// operation.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
        ///   of the collection.
        public var count: Int { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: Int32.Words.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Int) -> Int

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: Int) -> Int

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> UInt { get }
    }

    /// A collection containing the words of this value's binary
    /// representation, in order from the least significant to most significant.
    ///
    /// Negative values are returned in two's complement representation,
    /// regardless of the type's underlying implementation.
    public var words: Int32.Words { get }

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = UInt32

    /// The magnitude of this value.
    ///
    /// For any numeric value `x`, `x.magnitude` is the absolute value of `x`.
    /// You can use the `magnitude` property in operations that are simpler to
    /// implement in terms of unsigned values, such as printing the value of an
    /// integer, which is just printing a '-' character in front of an absolute
    /// value.
    ///
    ///     let x = -200
    ///     // x.magnitude == 200
    ///
    /// The global `abs(_:)` function provides more familiar syntax when you need
    /// to find an absolute value. In addition, because `abs(_:)` always returns
    /// a value of the same type, even in a generic context, using the function
    /// instead of the `magnitude` property is encouraged.
    public var magnitude: UInt32 { get }

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    ///
    /// Use this method to calculate the full result of a product that would
    /// otherwise overflow. Unlike traditional truncating multiplication, the
    /// `multipliedFullWidth(by:)` method returns a tuple
    /// containing both the `high` and `low` parts of the product of this value and
    /// `other`. The following example uses this method to multiply two `UInt8`
    /// values that normally overflow when multiplied:
    ///
    ///     let x: UInt8 = 100
    ///     let y: UInt8 = 20
    ///     let result = x.multipliedFullWidth(by: y)
    ///     // result.high == 0b00000111
    ///     // result.low  == 0b11010000
    ///
    /// The product of `x` and `y` is 2000, which is too large to represent in a
    /// `UInt8` instance. The `high` and `low` properties of the `result` value
    /// represent 2000 when concatenated to form a double-width integer; that
    /// is, using `result.high` as the high byte and `result.low` as the low byte
    /// of a `UInt16` instance.
    ///
    ///     let z = UInt16(result.high) << 8 | UInt16(result.low)
    ///     // z == 2000
    ///
    /// - Parameter other: The value to multiply this value by.
    /// - Returns: A tuple containing the high and low parts of the result of
    ///   multiplying this value and `other`.
    public func multipliedFullWidth(by other: Int32) -> (high: Int32, low: Int32.Magnitude)

    /// Returns a tuple containing the quotient and remainder of dividing the
    /// given value by this value.
    ///
    /// The resulting quotient must be representable within the bounds of the
    /// type. If the quotient of dividing `dividend` by this value is too large
    /// to represent in the type, a runtime error may occur.
    ///
    /// - Parameter dividend: A tuple containing the high and low parts of a
    ///   double-width integer. The `high` component of the value carries the
    ///   sign, if the type is signed.
    /// - Returns: A tuple containing the quotient and remainder of `dividend`
    ///   divided by this value.
    public func dividingFullWidth(_ dividend: (high: Int32, low: Int32.Magnitude)) -> (quotient: Int32, remainder: Int32)

    /// A representation of this integer with the byte order swapped.
    public var byteSwapped: Int32 { get }

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> Int32
}

extension Int32 : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Int32 : Hashable {

    /// The integer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program. Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Int32 {

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: Int32, rhs: Int32) -> Int32

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: Int32, rhs: Int32) -> Int32

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: Int32, rhs: Int32) -> Int32

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: Int32, rhs: Int32) -> Int32

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: Int32, rhs: Int32) -> Int32

    /// Returns the quotient of dividing the first value by the second.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     let x = 21 / 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func / (lhs: Int32, rhs: Int32) -> Int32

    /// Returns the remainder of dividing the first value by the second.
    ///
    /// The result of the modulo operator (`%`) has the same sign as `lhs` and is
    /// less than `rhs.magnitude`.
    ///
    ///     let x = 22 % 5
    ///     // x == 2
    ///     let y = 22 % -5
    ///     // y == 2
    ///     let z = -22 % -5
    ///     // z == -2
    ///
    /// For any two integers `a` and `b`, their quotient `q`, and their remainder
    /// `r`, `a == b * q + r`.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func % (lhs: Int32, rhs: Int32) -> Int32

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x + 120                 // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow addition operator (`&+`).
    ///
    ///     x &+ 120                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Int32, rhs: Int32) -> Int32

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     x - 50                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow subtraction operator (`&-`).
    ///
    ///     x &- 50                // 227
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Int32, rhs: Int32) -> Int32

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x * 21                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow multiplication operator (`&*`).
    ///
    ///     x &* 21                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Int32, rhs: Int32) -> Int32

    public static func != (lhs: Int32, rhs: Int32) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: Int32, rhs: Int32) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: Int32, rhs: Int32) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: Int32, rhs: Int32) -> Bool
}

extension Int32 : CustomReflectable {

    /// A mirror that reflects the `Int32` instance.
    public var customMirror: Mirror { get }
}

extension Int32 : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `Int32` instance.
    @available(*, deprecated, message: "Int32.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Int32 : CVarArg {
}

/// A 64-bit signed integer value
/// type.
public struct Int64 : FixedWidthInteger, SignedInteger {

    /// A type that represents an integer literal.
    public typealias IntegerLiteralType = Int64

    /// Creates a new instance with the same memory representation as the given
    /// value.
    ///
    /// This initializer does not perform any range or overflow checking. The
    /// resulting instance may not have the same numeric value as
    /// `bitPattern`---it is only guaranteed to use the same pattern of bits in
    /// its binary representation.
    ///
    /// - Parameter x: A value to use as the source of the new instance's binary
    ///   representation.
    public init(bitPattern x: UInt64)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Double)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Double)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float80)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float80)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Int64, rhs: Int64) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Int64, rhs: Int64) -> Bool

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x += 120
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Int64, rhs: Int64)

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     var x: UInt8 = 21
    ///     x - 50
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Int64, rhs: Int64)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x * 21
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Int64, rhs: Int64)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     var x = 21
    ///     x /= 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func /= (lhs: inout Int64, rhs: Int64)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.dividedReportingOverflow(by: 0)` is `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the division along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   quotient. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains either the truncated quotient
    ///   or, if the quotient is undefined, the dividend.
    public func dividedReportingOverflow(by other: Int64) -> (partialValue: Int64, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.remainderReportingOverflow(dividingBy: 0)` is
    /// `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the operation along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   remainder. If the `overflow` component is `true`, an overflow occurred
    ///   during division and the `partialValue` component contains either the
    ///   entire remainder or, if the remainder is undefined, the dividend.
    public func remainderReportingOverflow(dividingBy other: Int64) -> (partialValue: Int64, overflow: Bool)

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: A tuple containing the result of the addition along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   sum. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated sum of this value
    ///   and `rhs`.
    public func addingReportingOverflow(_ other: Int64) -> (partialValue: Int64, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    /// the operation.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: A tuple containing the result of the subtraction along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   difference. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains the truncated result of `rhs`
    ///   subtracted from this value.
    public func subtractingReportingOverflow(_ other: Int64) -> (partialValue: Int64, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: A tuple containing the result of the multiplication along with
    ///   a Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   product. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated product of this
    ///   value and `rhs`.
    public func multipliedReportingOverflow(by other: Int64) -> (partialValue: Int64, overflow: Bool)

    /// Divides the first value by the second and stores the remainder in the
    /// left-hand-side variable.
    ///
    /// The result has the same sign as `lhs` and is less than `rhs.magnitude`.
    ///
    ///     var x = 22
    ///     x %= 5
    ///     // x == 2
    ///
    ///     var y = 22
    ///     y %= -5
    ///     // y == 2
    ///
    ///     var z = -22
    ///     z %= -5
    ///     // z == -2
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func %= (lhs: inout Int64, rhs: Int64)

    /// Stores the result of performing a bitwise AND operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x &= y                    // 0b00000100
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func &= (lhs: inout Int64, rhs: Int64)

    /// Stores the result of performing a bitwise OR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x |= y                    // 0b00001111
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func |= (lhs: inout Int64, rhs: Int64)

    /// Stores the result of performing a bitwise XOR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x ^= y                    // 0b00001011
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^= (lhs: inout Int64, rhs: Int64)

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= (lhs: inout Int64, rhs: Int64)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= (lhs: inout Int64, rhs: Int64)

    /// The number of bits used for the underlying binary representation of
    /// values of this type.
    ///
    /// The bit width of a `Int64` instance is 64.
    public static var bitWidth: Int { get }

    /// The number of leading zeros in this value's binary representation.
    ///
    /// For example, in an integer type with a `bitWidth` value of 8,
    /// the number *31* has three leading zeros.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.leadingZeroBitCount == 3
    public var leadingZeroBitCount: Int { get }

    /// The number of trailing zeros in this value's binary representation.
    ///
    /// For example, the number *-8* has three trailing zeros.
    ///
    ///     let x = Int8(bitPattern: 0b1111_1000)
    ///     // x == -8
    ///     // x.trailingZeroBitCount == 3
    public var trailingZeroBitCount: Int { get }

    /// The number of bits equal to 1 in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has five bits equal to *1*.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.nonzeroBitCount == 5
    public var nonzeroBitCount: Int { get }

    /// A type that represents the words of this integer.
    public struct Words : BidirectionalCollection {

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = Range<Int>

        /// A type that represents a subsequence of some of the sequence's elements.
        public typealias SubSequence = Slice<Int64.Words>

        public init(_ value: Int64)

        /// The number of elements in the collection.
        ///
        /// To check whether a collection is empty, use its `isEmpty` property
        /// instead of comparing `count` to zero. Unless the collection guarantees
        /// random-access performance, calculating `count` can be an O(*n*)
        /// operation.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
        ///   of the collection.
        public var count: Int { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: Int64.Words.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Int) -> Int

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: Int) -> Int

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> UInt { get }
    }

    /// A collection containing the words of this value's binary
    /// representation, in order from the least significant to most significant.
    ///
    /// Negative values are returned in two's complement representation,
    /// regardless of the type's underlying implementation.
    public var words: Int64.Words { get }

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = UInt64

    /// The magnitude of this value.
    ///
    /// For any numeric value `x`, `x.magnitude` is the absolute value of `x`.
    /// You can use the `magnitude` property in operations that are simpler to
    /// implement in terms of unsigned values, such as printing the value of an
    /// integer, which is just printing a '-' character in front of an absolute
    /// value.
    ///
    ///     let x = -200
    ///     // x.magnitude == 200
    ///
    /// The global `abs(_:)` function provides more familiar syntax when you need
    /// to find an absolute value. In addition, because `abs(_:)` always returns
    /// a value of the same type, even in a generic context, using the function
    /// instead of the `magnitude` property is encouraged.
    public var magnitude: UInt64 { get }

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    ///
    /// Use this method to calculate the full result of a product that would
    /// otherwise overflow. Unlike traditional truncating multiplication, the
    /// `multipliedFullWidth(by:)` method returns a tuple
    /// containing both the `high` and `low` parts of the product of this value and
    /// `other`. The following example uses this method to multiply two `UInt8`
    /// values that normally overflow when multiplied:
    ///
    ///     let x: UInt8 = 100
    ///     let y: UInt8 = 20
    ///     let result = x.multipliedFullWidth(by: y)
    ///     // result.high == 0b00000111
    ///     // result.low  == 0b11010000
    ///
    /// The product of `x` and `y` is 2000, which is too large to represent in a
    /// `UInt8` instance. The `high` and `low` properties of the `result` value
    /// represent 2000 when concatenated to form a double-width integer; that
    /// is, using `result.high` as the high byte and `result.low` as the low byte
    /// of a `UInt16` instance.
    ///
    ///     let z = UInt16(result.high) << 8 | UInt16(result.low)
    ///     // z == 2000
    ///
    /// - Parameter other: The value to multiply this value by.
    /// - Returns: A tuple containing the high and low parts of the result of
    ///   multiplying this value and `other`.
    public func multipliedFullWidth(by other: Int64) -> (high: Int64, low: Int64.Magnitude)

    /// Returns a tuple containing the quotient and remainder of dividing the
    /// given value by this value.
    ///
    /// The resulting quotient must be representable within the bounds of the
    /// type. If the quotient of dividing `dividend` by this value is too large
    /// to represent in the type, a runtime error may occur.
    ///
    /// - Parameter dividend: A tuple containing the high and low parts of a
    ///   double-width integer. The `high` component of the value carries the
    ///   sign, if the type is signed.
    /// - Returns: A tuple containing the quotient and remainder of `dividend`
    ///   divided by this value.
    public func dividingFullWidth(_ dividend: (high: Int64, low: Int64.Magnitude)) -> (quotient: Int64, remainder: Int64)

    /// A representation of this integer with the byte order swapped.
    public var byteSwapped: Int64 { get }

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> Int64
}

extension Int64 : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Int64 : Hashable {

    /// The integer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program. Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Int64 {

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: Int64, rhs: Int64) -> Int64

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: Int64, rhs: Int64) -> Int64

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: Int64, rhs: Int64) -> Int64

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: Int64, rhs: Int64) -> Int64

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: Int64, rhs: Int64) -> Int64

    /// Returns the quotient of dividing the first value by the second.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     let x = 21 / 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func / (lhs: Int64, rhs: Int64) -> Int64

    /// Returns the remainder of dividing the first value by the second.
    ///
    /// The result of the modulo operator (`%`) has the same sign as `lhs` and is
    /// less than `rhs.magnitude`.
    ///
    ///     let x = 22 % 5
    ///     // x == 2
    ///     let y = 22 % -5
    ///     // y == 2
    ///     let z = -22 % -5
    ///     // z == -2
    ///
    /// For any two integers `a` and `b`, their quotient `q`, and their remainder
    /// `r`, `a == b * q + r`.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func % (lhs: Int64, rhs: Int64) -> Int64

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x + 120                 // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow addition operator (`&+`).
    ///
    ///     x &+ 120                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Int64, rhs: Int64) -> Int64

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     x - 50                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow subtraction operator (`&-`).
    ///
    ///     x &- 50                // 227
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Int64, rhs: Int64) -> Int64

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x * 21                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow multiplication operator (`&*`).
    ///
    ///     x &* 21                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Int64, rhs: Int64) -> Int64

    public static func != (lhs: Int64, rhs: Int64) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: Int64, rhs: Int64) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: Int64, rhs: Int64) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: Int64, rhs: Int64) -> Bool
}

extension Int64 : CustomReflectable {

    /// A mirror that reflects the `Int64` instance.
    public var customMirror: Mirror { get }
}

extension Int64 : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `Int64` instance.
    @available(*, deprecated, message: "Int64.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Int64 : CVarArg {
}

/// An 8-bit signed integer value
/// type.
public struct Int8 : FixedWidthInteger, SignedInteger {

    /// A type that represents an integer literal.
    public typealias IntegerLiteralType = Int8

    /// Creates a new instance with the same memory representation as the given
    /// value.
    ///
    /// This initializer does not perform any range or overflow checking. The
    /// resulting instance may not have the same numeric value as
    /// `bitPattern`---it is only guaranteed to use the same pattern of bits in
    /// its binary representation.
    ///
    /// - Parameter x: A value to use as the source of the new instance's binary
    ///   representation.
    public init(bitPattern x: UInt8)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Double)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Double)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float80)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float80)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Int8, rhs: Int8) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Int8, rhs: Int8) -> Bool

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x += 120
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Int8, rhs: Int8)

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     var x: UInt8 = 21
    ///     x - 50
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Int8, rhs: Int8)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x * 21
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Int8, rhs: Int8)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     var x = 21
    ///     x /= 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func /= (lhs: inout Int8, rhs: Int8)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.dividedReportingOverflow(by: 0)` is `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the division along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   quotient. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains either the truncated quotient
    ///   or, if the quotient is undefined, the dividend.
    public func dividedReportingOverflow(by other: Int8) -> (partialValue: Int8, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.remainderReportingOverflow(dividingBy: 0)` is
    /// `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the operation along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   remainder. If the `overflow` component is `true`, an overflow occurred
    ///   during division and the `partialValue` component contains either the
    ///   entire remainder or, if the remainder is undefined, the dividend.
    public func remainderReportingOverflow(dividingBy other: Int8) -> (partialValue: Int8, overflow: Bool)

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: A tuple containing the result of the addition along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   sum. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated sum of this value
    ///   and `rhs`.
    public func addingReportingOverflow(_ other: Int8) -> (partialValue: Int8, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    /// the operation.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: A tuple containing the result of the subtraction along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   difference. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains the truncated result of `rhs`
    ///   subtracted from this value.
    public func subtractingReportingOverflow(_ other: Int8) -> (partialValue: Int8, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: A tuple containing the result of the multiplication along with
    ///   a Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   product. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated product of this
    ///   value and `rhs`.
    public func multipliedReportingOverflow(by other: Int8) -> (partialValue: Int8, overflow: Bool)

    /// Divides the first value by the second and stores the remainder in the
    /// left-hand-side variable.
    ///
    /// The result has the same sign as `lhs` and is less than `rhs.magnitude`.
    ///
    ///     var x = 22
    ///     x %= 5
    ///     // x == 2
    ///
    ///     var y = 22
    ///     y %= -5
    ///     // y == 2
    ///
    ///     var z = -22
    ///     z %= -5
    ///     // z == -2
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func %= (lhs: inout Int8, rhs: Int8)

    /// Stores the result of performing a bitwise AND operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x &= y                    // 0b00000100
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func &= (lhs: inout Int8, rhs: Int8)

    /// Stores the result of performing a bitwise OR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x |= y                    // 0b00001111
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func |= (lhs: inout Int8, rhs: Int8)

    /// Stores the result of performing a bitwise XOR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x ^= y                    // 0b00001011
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^= (lhs: inout Int8, rhs: Int8)

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= (lhs: inout Int8, rhs: Int8)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= (lhs: inout Int8, rhs: Int8)

    /// The number of bits used for the underlying binary representation of
    /// values of this type.
    ///
    /// The bit width of an `Int8` instance is 8.
    public static var bitWidth: Int { get }

    /// The number of leading zeros in this value's binary representation.
    ///
    /// For example, in an integer type with a `bitWidth` value of 8,
    /// the number *31* has three leading zeros.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.leadingZeroBitCount == 3
    public var leadingZeroBitCount: Int { get }

    /// The number of trailing zeros in this value's binary representation.
    ///
    /// For example, the number *-8* has three trailing zeros.
    ///
    ///     let x = Int8(bitPattern: 0b1111_1000)
    ///     // x == -8
    ///     // x.trailingZeroBitCount == 3
    public var trailingZeroBitCount: Int { get }

    /// The number of bits equal to 1 in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has five bits equal to *1*.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.nonzeroBitCount == 5
    public var nonzeroBitCount: Int { get }

    /// A type that represents the words of this integer.
    public struct Words : BidirectionalCollection {

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = Range<Int>

        /// A type that represents a subsequence of some of the sequence's elements.
        public typealias SubSequence = Slice<Int8.Words>

        public init(_ value: Int8)

        /// The number of elements in the collection.
        ///
        /// To check whether a collection is empty, use its `isEmpty` property
        /// instead of comparing `count` to zero. Unless the collection guarantees
        /// random-access performance, calculating `count` can be an O(*n*)
        /// operation.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
        ///   of the collection.
        public var count: Int { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: Int8.Words.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Int) -> Int

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: Int) -> Int

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> UInt { get }
    }

    /// A collection containing the words of this value's binary
    /// representation, in order from the least significant to most significant.
    ///
    /// Negative values are returned in two's complement representation,
    /// regardless of the type's underlying implementation.
    public var words: Int8.Words { get }

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = UInt8

    /// The magnitude of this value.
    ///
    /// For any numeric value `x`, `x.magnitude` is the absolute value of `x`.
    /// You can use the `magnitude` property in operations that are simpler to
    /// implement in terms of unsigned values, such as printing the value of an
    /// integer, which is just printing a '-' character in front of an absolute
    /// value.
    ///
    ///     let x = -200
    ///     // x.magnitude == 200
    ///
    /// The global `abs(_:)` function provides more familiar syntax when you need
    /// to find an absolute value. In addition, because `abs(_:)` always returns
    /// a value of the same type, even in a generic context, using the function
    /// instead of the `magnitude` property is encouraged.
    public var magnitude: UInt8 { get }

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    ///
    /// Use this method to calculate the full result of a product that would
    /// otherwise overflow. Unlike traditional truncating multiplication, the
    /// `multipliedFullWidth(by:)` method returns a tuple
    /// containing both the `high` and `low` parts of the product of this value and
    /// `other`. The following example uses this method to multiply two `UInt8`
    /// values that normally overflow when multiplied:
    ///
    ///     let x: UInt8 = 100
    ///     let y: UInt8 = 20
    ///     let result = x.multipliedFullWidth(by: y)
    ///     // result.high == 0b00000111
    ///     // result.low  == 0b11010000
    ///
    /// The product of `x` and `y` is 2000, which is too large to represent in a
    /// `UInt8` instance. The `high` and `low` properties of the `result` value
    /// represent 2000 when concatenated to form a double-width integer; that
    /// is, using `result.high` as the high byte and `result.low` as the low byte
    /// of a `UInt16` instance.
    ///
    ///     let z = UInt16(result.high) << 8 | UInt16(result.low)
    ///     // z == 2000
    ///
    /// - Parameter other: The value to multiply this value by.
    /// - Returns: A tuple containing the high and low parts of the result of
    ///   multiplying this value and `other`.
    public func multipliedFullWidth(by other: Int8) -> (high: Int8, low: Int8.Magnitude)

    /// Returns a tuple containing the quotient and remainder of dividing the
    /// given value by this value.
    ///
    /// The resulting quotient must be representable within the bounds of the
    /// type. If the quotient of dividing `dividend` by this value is too large
    /// to represent in the type, a runtime error may occur.
    ///
    /// - Parameter dividend: A tuple containing the high and low parts of a
    ///   double-width integer. The `high` component of the value carries the
    ///   sign, if the type is signed.
    /// - Returns: A tuple containing the quotient and remainder of `dividend`
    ///   divided by this value.
    public func dividingFullWidth(_ dividend: (high: Int8, low: Int8.Magnitude)) -> (quotient: Int8, remainder: Int8)

    /// A representation of this integer with the byte order swapped.
    public var byteSwapped: Int8 { get }

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> Int8
}

extension Int8 : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Int8 : Hashable {

    /// The integer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program. Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Int8 {

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: Int8, rhs: Int8) -> Int8

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: Int8, rhs: Int8) -> Int8

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: Int8, rhs: Int8) -> Int8

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: Int8, rhs: Int8) -> Int8

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: Int8, rhs: Int8) -> Int8

    /// Returns the quotient of dividing the first value by the second.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     let x = 21 / 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func / (lhs: Int8, rhs: Int8) -> Int8

    /// Returns the remainder of dividing the first value by the second.
    ///
    /// The result of the modulo operator (`%`) has the same sign as `lhs` and is
    /// less than `rhs.magnitude`.
    ///
    ///     let x = 22 % 5
    ///     // x == 2
    ///     let y = 22 % -5
    ///     // y == 2
    ///     let z = -22 % -5
    ///     // z == -2
    ///
    /// For any two integers `a` and `b`, their quotient `q`, and their remainder
    /// `r`, `a == b * q + r`.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func % (lhs: Int8, rhs: Int8) -> Int8

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x + 120                 // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow addition operator (`&+`).
    ///
    ///     x &+ 120                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Int8, rhs: Int8) -> Int8

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     x - 50                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow subtraction operator (`&-`).
    ///
    ///     x &- 50                // 227
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Int8, rhs: Int8) -> Int8

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x * 21                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow multiplication operator (`&*`).
    ///
    ///     x &* 21                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Int8, rhs: Int8) -> Int8

    public static func != (lhs: Int8, rhs: Int8) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: Int8, rhs: Int8) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: Int8, rhs: Int8) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: Int8, rhs: Int8) -> Bool
}

extension Int8 : CustomReflectable {

    /// A mirror that reflects the `Int8` instance.
    public var customMirror: Mirror { get }
}

extension Int8 : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `Int8` instance.
    @available(*, deprecated, message: "Int8.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Int8 : CVarArg {
}

@available(*, deprecated, renamed: "ExpressibleByIntegerLiteral")
public typealias IntegerLiteralConvertible = ExpressibleByIntegerLiteral

/// The default type for an otherwise-unconstrained integer literal.
public typealias IntegerLiteralType = Int

/// An iterator that produces one or zero instances of an element.
///
/// `IteratorOverOne` is the iterator for the `CollectionOfOne` type.
public struct IteratorOverOne<Element> {
}

extension IteratorOverOne : IteratorProtocol, Sequence {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> Element?
}

/// A type that supplies the values of a sequence one at a time.
///
/// The `IteratorProtocol` protocol is tightly linked with the `Sequence`
/// protocol. Sequences provide access to their elements by creating an
/// iterator, which keeps track of its iteration process and returns one
/// element at a time as it advances through the sequence.
///
/// Whenever you use a `for`-`in` loop with an array, set, or any other
/// collection or sequence, you're using that type's iterator. Swift uses a
/// sequence's or collection's iterator internally to enable the `for`-`in`
/// loop language construct.
///
/// Using a sequence's iterator directly gives you access to the same elements
/// in the same order as iterating over that sequence using a `for`-`in` loop.
/// For example, you might typically use a `for`-`in` loop to print each of
/// the elements in an array.
///
///     let animals = ["Antelope", "Butterfly", "Camel", "Dolphin"]
///     for animal in animals {
///         print(animal)
///     }
///     // Prints "Antelope"
///     // Prints "Butterfly"
///     // Prints "Camel"
///     // Prints "Dolphin"
///
/// Behind the scenes, Swift uses the `animals` array's iterator to loop over
/// the contents of the array.
///
///     var animalIterator = animals.makeIterator()
///     while let animal = animalIterator.next() {
///         print(animal)
///     }
///     // Prints "Antelope"
///     // Prints "Butterfly"
///     // Prints "Camel"
///     // Prints "Dolphin"
///
/// The call to `animals.makeIterator()` returns an instance of the array's
/// iterator. Next, the `while` loop calls the iterator's `next()` method
/// repeatedly, binding each element that is returned to `animal` and exiting
/// when the `next()` method returns `nil`.
///
/// Using Iterators Directly
/// ========================
///
/// You rarely need to use iterators directly, because a `for`-`in` loop is the
/// more idiomatic approach to traversing a sequence in Swift. Some
/// algorithms, however, may call for direct iterator use.
///
/// One example is the `reduce1(_:)` method. Similar to the `reduce(_:_:)`
/// method defined in the standard library, which takes an initial value and a
/// combining closure, `reduce1(_:)` uses the first element of the sequence as
/// the initial value.
///
/// Here's an implementation of the `reduce1(_:)` method. The sequence's
/// iterator is used directly to retrieve the initial value before looping
/// over the rest of the sequence.
///
///     extension Sequence {
///         func reduce1(
///             _ nextPartialResult: (Element, Element) -> Element
///         ) -> Element?
///         {
///             var i = makeIterator()
///             guard var accumulated = i.next() else {
///                 return nil
///             }
///
///             while let element = i.next() {
///                 accumulated = nextPartialResult(accumulated, element)
///             }
///             return accumulated
///         }
///     }
///
/// The `reduce1(_:)` method makes certain kinds of sequence operations
/// simpler. Here's how to find the longest string in a sequence, using the
/// `animals` array introduced earlier as an example:
///
///     let longestAnimal = animals.reduce1 { current, element in
///         if current.count > element.count {
///             return current
///         } else {
///             return element
///         }
///     }
///     print(longestAnimal)
///     // Prints "Butterfly"
///
/// Using Multiple Iterators
/// ========================
///
/// Whenever you use multiple iterators (or `for`-`in` loops) over a single
/// sequence, be sure you know that the specific sequence supports repeated
/// iteration, either because you know its concrete type or because the
/// sequence is also constrained to the `Collection` protocol.
///
/// Obtain each separate iterator from separate calls to the sequence's
/// `makeIterator()` method rather than by copying. Copying an iterator is
/// safe, but advancing one copy of an iterator by calling its `next()` method
/// may invalidate other copies of that iterator. `for`-`in` loops are safe in
/// this regard.
///
/// Adding IteratorProtocol Conformance to Your Type
/// ================================================
///
/// Implementing an iterator that conforms to `IteratorProtocol` is simple.
/// Declare a `next()` method that advances one step in the related sequence
/// and returns the current element. When the sequence has been exhausted, the
/// `next()` method returns `nil`.
///
/// For example, consider a custom `Countdown` sequence. You can initialize the
/// `Countdown` sequence with a starting integer and then iterate over the
/// count down to zero. The `Countdown` structure's definition is short: It
/// contains only the starting count and the `makeIterator()` method required
/// by the `Sequence` protocol.
///
///     struct Countdown: Sequence {
///         let start: Int
///
///         func makeIterator() -> CountdownIterator {
///             return CountdownIterator(self)
///         }
///     }
///
/// The `makeIterator()` method returns another custom type, an iterator named
/// `CountdownIterator`. The `CountdownIterator` type keeps track of both the
/// `Countdown` sequence that it's iterating and the number of times it has
/// returned a value.
///
///     struct CountdownIterator: IteratorProtocol {
///         let countdown: Countdown
///         var times = 0
///
///         init(_ countdown: Countdown) {
///             self.countdown = countdown
///         }
///
///         mutating func next() -> Int? {
///             let nextNumber = countdown.start - times
///             guard nextNumber > 0
///                 else { return nil }
///
///             times += 1
///             return nextNumber
///         }
///     }
///
/// Each time the `next()` method is called on a `CountdownIterator` instance,
/// it calculates the new next value, checks to see whether it has reached
/// zero, and then returns either the number, or `nil` if the iterator is
/// finished returning elements of the sequence.
///
/// Creating and iterating over a `Countdown` sequence uses a
/// `CountdownIterator` to handle the iteration.
///
///     let threeTwoOne = Countdown(start: 3)
///     for count in threeTwoOne {
///         print("\(count)...")
///     }
///     // Prints "3..."
///     // Prints "2..."
///     // Prints "1..."
public protocol IteratorProtocol {

    /// The type of element traversed by the iterator.
    associatedtype Element

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> Self.Element?
}

/// A sequence built around an iterator of type `Base`.
///
/// Useful mostly to recover the ability to use `for`...`in`,
/// given just an iterator `i`:
///
///     for x in IteratorSequence(i) { ... }
public struct IteratorSequence<Base> where Base : IteratorProtocol {

    /// Creates an instance whose iterator is a copy of `base`.
    public init(_ base: Base)
}

extension IteratorSequence : IteratorProtocol, Sequence where Base : IteratorProtocol {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    ///
    /// - Precondition: `next()` has not been applied to a copy of `self`
    ///   since the copy was made.
    public mutating func next() -> Base.Element?
}

public typealias JoinedIterator<T> = JoinedSequence<T>.Iterator

/// A sequence that presents the elements of a base sequence of sequences
/// concatenated using a given separator.
public struct JoinedSequence<Base> where Base : Sequence, Base.Element : Sequence {

    /// A type representing the sequence's elements.
    public typealias Element = Base.Element.Element

    /// Creates an iterator that presents the elements of the sequences
    /// traversed by `base`, concatenated using `separator`.
    ///
    /// - Complexity: O(`separator.count`).
    public init<Separator>(base: Base, separator: Separator) where Separator : Sequence, Separator.Element == Base.Element.Element
}

extension JoinedSequence where Base : Sequence, Base.Element : Sequence {

    /// An iterator that presents the elements of the sequences traversed
    /// by a base iterator, concatenated using a given separator.
    public struct Iterator {

        /// Creates a sequence that presents the elements of `base` sequences
        /// concatenated using `separator`.
        ///
        /// - Complexity: O(`separator.count`).
        public init<Separator>(base: Base.Iterator, separator: Separator) where Separator : Sequence, Separator.Element == Base.Element.Element
    }
}

extension JoinedSequence : Sequence where Base : Sequence, Base.Element : Sequence {

    /// Return an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> JoinedSequence<Base>.Iterator
}

extension JoinedSequence.Iterator : IteratorProtocol where Base : Sequence, Base.Element : Sequence {

    /// The type of element traversed by the iterator.
    public typealias Element = Base.Element.Element

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    public mutating func next() -> JoinedSequence<Base>.Iterator.Element?
}

/// A key path from a specific root type to a specific resulting value type.
public class KeyPath<Root, Value> : PartialKeyPath<Root> {
}

/// A concrete container that provides a view into a decoder's storage, making
/// the encoded properties of a decodable type accessible by keys.
public struct KeyedDecodingContainer<K> : KeyedDecodingContainerProtocol where K : CodingKey {

    public typealias Key = K

    /// Creates a new instance with the given container.
    ///
    /// - parameter container: The container to hold.
    public init<Container>(_ container: Container) where K == Container.Key, Container : KeyedDecodingContainerProtocol

    /// The path of coding keys taken to get to this point in decoding.
    public var codingPath: [CodingKey] { get }

    /// All the keys the decoder has for this container.
    ///
    /// Different keyed containers from the same decoder may return different
    /// keys here, because it is possible to encode with multiple key types
    /// which are not convertible to one another. This should report all keys
    /// present which are convertible to the requested type.
    public var allKeys: [K] { get }

    /// Returns a Boolean value indicating whether the decoder contains a value
    /// associated with the given key.
    ///
    /// The value associated with the given key may be a null value as
    /// appropriate for the data format.
    ///
    /// - parameter key: The key to search for.
    /// - returns: Whether the `Decoder` has an entry for the given key.
    public func contains(_ key: KeyedDecodingContainer<K>.Key) -> Bool

    /// Decodes a null value for the given key.
    ///
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: Whether the encountered value was null.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    public func decodeNil(forKey key: KeyedDecodingContainer<K>.Key) throws -> Bool

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Bool.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Bool

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: String.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> String

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Double.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Double

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Float.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Float

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Int.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Int

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Int8.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Int8

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Int16.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Int16

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Int32.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Int32

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Int64.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Int64

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: UInt.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> UInt

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: UInt8.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> UInt8

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: UInt16.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> UInt16

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: UInt32.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> UInt32

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: UInt64.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> UInt64

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode<T>(_ type: T.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> T where T : Decodable

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Bool.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Bool?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: String.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> String?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Double.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Double?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Float.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Float?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Int.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Int?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Int8.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Int8?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Int16.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Int16?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Int32.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Int32?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Int64.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> Int64?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: UInt.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> UInt?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: UInt8.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> UInt8?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: UInt16.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> UInt16?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: UInt32.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> UInt32?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: UInt64.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> UInt64?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent<T>(_ type: T.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> T? where T : Decodable

    /// Returns the data stored for the given key as represented in a container
    /// keyed by the given key type.
    ///
    /// - parameter type: The key type to use for the container.
    /// - parameter key: The key that the nested container is associated with.
    /// - returns: A keyed decoding container view into `self`.
    /// - throws: `DecodingError.typeMismatch` if the encountered stored value is
    ///   not a keyed container.
    public func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey

    /// Returns the data stored for the given key as represented in an unkeyed
    /// container.
    ///
    /// - parameter key: The key that the nested container is associated with.
    /// - returns: An unkeyed decoding container view into `self`.
    /// - throws: `DecodingError.typeMismatch` if the encountered stored value is
    ///   not an unkeyed container.
    public func nestedUnkeyedContainer(forKey key: KeyedDecodingContainer<K>.Key) throws -> UnkeyedDecodingContainer

    /// Returns a `Decoder` instance for decoding `super` from the container
    /// associated with the default `super` key.
    ///
    /// Equivalent to calling `superDecoder(forKey:)` with
    /// `Key(stringValue: "super", intValue: 0)`.
    ///
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the default `super` key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the default `super` key.
    public func superDecoder() throws -> Decoder

    /// Returns a `Decoder` instance for decoding `super` from the container
    /// associated with the given key.
    ///
    /// - parameter key: The key to decode `super` for.
    /// - returns: A new `Decoder` to pass to `super.init(from:)`.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func superDecoder(forKey key: KeyedDecodingContainer<K>.Key) throws -> Decoder
}

/// A type that provides a view into a decoder's storage and is used to hold
/// the encoded properties of a decodable type in a keyed manner.
///
/// Decoders should provide types conforming to `UnkeyedDecodingContainer` for
/// their format.
public protocol KeyedDecodingContainerProtocol {

    associatedtype Key : CodingKey

    /// The path of coding keys taken to get to this point in decoding.
    public var codingPath: [CodingKey] { get }

    /// All the keys the `Decoder` has for this container.
    ///
    /// Different keyed containers from the same `Decoder` may return different
    /// keys here; it is possible to encode with multiple key types which are
    /// not convertible to one another. This should report all keys present
    /// which are convertible to the requested type.
    public var allKeys: [Self.Key] { get }

    /// Returns a Boolean value indicating whether the decoder contains a value
    /// associated with the given key.
    ///
    /// The value associated with `key` may be a null value as appropriate for
    /// the data format.
    ///
    /// - parameter key: The key to search for.
    /// - returns: Whether the `Decoder` has an entry for the given key.
    public func contains(_ key: Self.Key) -> Bool

    /// Decodes a null value for the given key.
    ///
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: Whether the encountered value was null.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    public func decodeNil(forKey key: Self.Key) throws -> Bool

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Bool.Type, forKey key: Self.Key) throws -> Bool

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: String.Type, forKey key: Self.Key) throws -> String

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Double.Type, forKey key: Self.Key) throws -> Double

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Float.Type, forKey key: Self.Key) throws -> Float

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Int.Type, forKey key: Self.Key) throws -> Int

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Int8.Type, forKey key: Self.Key) throws -> Int8

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Int16.Type, forKey key: Self.Key) throws -> Int16

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Int32.Type, forKey key: Self.Key) throws -> Int32

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: Int64.Type, forKey key: Self.Key) throws -> Int64

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: UInt.Type, forKey key: Self.Key) throws -> UInt

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: UInt8.Type, forKey key: Self.Key) throws -> UInt8

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: UInt16.Type, forKey key: Self.Key) throws -> UInt16

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: UInt32.Type, forKey key: Self.Key) throws -> UInt32

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode(_ type: UInt64.Type, forKey key: Self.Key) throws -> UInt64

    /// Decodes a value of the given type for the given key.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func decode<T>(_ type: T.Type, forKey key: Self.Key) throws -> T where T : Decodable

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Bool.Type, forKey key: Self.Key) throws -> Bool?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: String.Type, forKey key: Self.Key) throws -> String?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Double.Type, forKey key: Self.Key) throws -> Double?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Float.Type, forKey key: Self.Key) throws -> Float?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Int.Type, forKey key: Self.Key) throws -> Int?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Int8.Type, forKey key: Self.Key) throws -> Int8?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Int16.Type, forKey key: Self.Key) throws -> Int16?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Int32.Type, forKey key: Self.Key) throws -> Int32?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: Int64.Type, forKey key: Self.Key) throws -> Int64?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: UInt.Type, forKey key: Self.Key) throws -> UInt?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: UInt8.Type, forKey key: Self.Key) throws -> UInt8?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: UInt16.Type, forKey key: Self.Key) throws -> UInt16?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: UInt32.Type, forKey key: Self.Key) throws -> UInt32?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent(_ type: UInt64.Type, forKey key: Self.Key) throws -> UInt64?

    /// Decodes a value of the given type for the given key, if present.
    ///
    /// This method returns `nil` if the container does not have a value
    /// associated with `key`, or if the value is null. The difference between
    /// these states can be distinguished with a `contains(_:)` call.
    ///
    /// - parameter type: The type of value to decode.
    /// - parameter key: The key that the decoded value is associated with.
    /// - returns: A decoded value of the requested type, or `nil` if the
    ///   `Decoder` does not have an entry associated with the given key, or if
    ///   the value is a null value.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public func decodeIfPresent<T>(_ type: T.Type, forKey key: Self.Key) throws -> T? where T : Decodable

    /// Returns the data stored for the given key as represented in a container
    /// keyed by the given key type.
    ///
    /// - parameter type: The key type to use for the container.
    /// - parameter key: The key that the nested container is associated with.
    /// - returns: A keyed decoding container view into `self`.
    /// - throws: `DecodingError.typeMismatch` if the encountered stored value is
    ///   not a keyed container.
    public func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Self.Key) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey

    /// Returns the data stored for the given key as represented in an unkeyed
    /// container.
    ///
    /// - parameter key: The key that the nested container is associated with.
    /// - returns: An unkeyed decoding container view into `self`.
    /// - throws: `DecodingError.typeMismatch` if the encountered stored value is
    ///   not an unkeyed container.
    public func nestedUnkeyedContainer(forKey key: Self.Key) throws -> UnkeyedDecodingContainer

    /// Returns a `Decoder` instance for decoding `super` from the container
    /// associated with the default `super` key.
    ///
    /// Equivalent to calling `superDecoder(forKey:)` with
    /// `Key(stringValue: "super", intValue: 0)`.
    ///
    /// - returns: A new `Decoder` to pass to `super.init(from:)`.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the default `super` key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the default `super` key.
    public func superDecoder() throws -> Decoder

    /// Returns a `Decoder` instance for decoding `super` from the container
    /// associated with the given key.
    ///
    /// - parameter key: The key to decode `super` for.
    /// - returns: A new `Decoder` to pass to `super.init(from:)`.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry
    ///   for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for
    ///   the given key.
    public func superDecoder(forKey key: Self.Key) throws -> Decoder
}

extension KeyedDecodingContainerProtocol {

    public func decodeIfPresent(_ type: Bool.Type, forKey key: Self.Key) throws -> Bool?

    public func decodeIfPresent(_ type: String.Type, forKey key: Self.Key) throws -> String?

    public func decodeIfPresent(_ type: Double.Type, forKey key: Self.Key) throws -> Double?

    public func decodeIfPresent(_ type: Float.Type, forKey key: Self.Key) throws -> Float?

    public func decodeIfPresent(_ type: Int.Type, forKey key: Self.Key) throws -> Int?

    public func decodeIfPresent(_ type: Int8.Type, forKey key: Self.Key) throws -> Int8?

    public func decodeIfPresent(_ type: Int16.Type, forKey key: Self.Key) throws -> Int16?

    public func decodeIfPresent(_ type: Int32.Type, forKey key: Self.Key) throws -> Int32?

    public func decodeIfPresent(_ type: Int64.Type, forKey key: Self.Key) throws -> Int64?

    public func decodeIfPresent(_ type: UInt.Type, forKey key: Self.Key) throws -> UInt?

    public func decodeIfPresent(_ type: UInt8.Type, forKey key: Self.Key) throws -> UInt8?

    public func decodeIfPresent(_ type: UInt16.Type, forKey key: Self.Key) throws -> UInt16?

    public func decodeIfPresent(_ type: UInt32.Type, forKey key: Self.Key) throws -> UInt32?

    public func decodeIfPresent(_ type: UInt64.Type, forKey key: Self.Key) throws -> UInt64?

    public func decodeIfPresent<T>(_ type: T.Type, forKey key: Self.Key) throws -> T? where T : Decodable
}

/// A concrete container that provides a view into an encoder's storage, making
/// the encoded properties of an encodable type accessible by keys.
public struct KeyedEncodingContainer<K> : KeyedEncodingContainerProtocol where K : CodingKey {

    public typealias Key = K

    /// Creates a new instance with the given container.
    ///
    /// - parameter container: The container to hold.
    public init<Container>(_ container: Container) where K == Container.Key, Container : KeyedEncodingContainerProtocol

    /// The path of coding keys taken to get to this point in encoding.
    public var codingPath: [CodingKey] { get }

    /// Encodes a null value for the given key.
    ///
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if a null value is invalid in the
    ///   current context for this format.
    public mutating func encodeNil(forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Bool, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: String, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Double, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Float, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int8, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int16, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int32, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int64, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt8, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt16, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt32, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt64, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode<T>(_ value: T, forKey key: KeyedEncodingContainer<K>.Key) throws where T : Encodable

    /// Encodes a reference to the given object only if it is encoded
    /// unconditionally elsewhere in the payload (previously, or in the future).
    ///
    /// For encoders which don't support this feature, the default implementation
    /// encodes the given object unconditionally.
    ///
    /// - parameter object: The object to encode.
    /// - parameter key: The key to associate the object with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeConditional<T>(_ object: T, forKey key: KeyedEncodingContainer<K>.Key) throws where T : AnyObject, T : Encodable

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Bool?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: String?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Double?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Float?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Int?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Int8?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Int16?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Int32?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Int64?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: UInt?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: UInt8?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: UInt16?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: UInt32?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: UInt64?, forKey key: KeyedEncodingContainer<K>.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent<T>(_ value: T?, forKey key: KeyedEncodingContainer<K>.Key) throws where T : Encodable

    /// Stores a keyed encoding container for the given key and returns it.
    ///
    /// - parameter keyType: The key type to use for the container.
    /// - parameter key: The key to encode the container for.
    /// - returns: A new keyed encoding container.
    public mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: KeyedEncodingContainer<K>.Key) -> KeyedEncodingContainer<NestedKey> where NestedKey : CodingKey

    /// Stores an unkeyed encoding container for the given key and returns it.
    ///
    /// - parameter key: The key to encode the container for.
    /// - returns: A new unkeyed encoding container.
    public mutating func nestedUnkeyedContainer(forKey key: KeyedEncodingContainer<K>.Key) -> UnkeyedEncodingContainer

    /// Stores a new nested container for the default `super` key and returns A
    /// new encoder instance for encoding `super` into that container.
    ///
    /// Equivalent to calling `superEncoder(forKey:)` with
    /// `Key(stringValue: "super", intValue: 0)`.
    ///
    /// - returns: A new encoder to pass to `super.encode(to:)`.
    public mutating func superEncoder() -> Encoder

    /// Stores a new nested container for the given key and returns A new encoder
    /// instance for encoding `super` into that container.
    ///
    /// - parameter key: The key to encode `super` for.
    /// - returns: A new encoder to pass to `super.encode(to:)`.
    public mutating func superEncoder(forKey key: KeyedEncodingContainer<K>.Key) -> Encoder
}

/// A type that provides a view into an encoder's storage and is used to hold
/// the encoded properties of an encodable type in a keyed manner.
///
/// Encoders should provide types conforming to
/// `KeyedEncodingContainerProtocol` for their format.
public protocol KeyedEncodingContainerProtocol {

    associatedtype Key : CodingKey

    /// The path of coding keys taken to get to this point in encoding.
    public var codingPath: [CodingKey] { get }

    /// Encodes a null value for the given key.
    ///
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if a null value is invalid in the
    ///   current context for this format.
    public mutating func encodeNil(forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Bool, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: String, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Double, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Float, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int8, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int16, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int32, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int64, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt8, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt16, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt32, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt64, forKey key: Self.Key) throws

    /// Encodes the given value for the given key.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode<T>(_ value: T, forKey key: Self.Key) throws where T : Encodable

    /// Encodes a reference to the given object only if it is encoded
    /// unconditionally elsewhere in the payload (previously, or in the future).
    ///
    /// For encoders which don't support this feature, the default implementation
    /// encodes the given object unconditionally.
    ///
    /// - parameter object: The object to encode.
    /// - parameter key: The key to associate the object with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeConditional<T>(_ object: T, forKey key: Self.Key) throws where T : AnyObject, T : Encodable

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Bool?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: String?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Double?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Float?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Int?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Int8?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Int16?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Int32?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: Int64?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: UInt?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: UInt8?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: UInt16?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: UInt32?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent(_ value: UInt64?, forKey key: Self.Key) throws

    /// Encodes the given value for the given key if it is not `nil`.
    ///
    /// - parameter value: The value to encode.
    /// - parameter key: The key to associate the value with.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeIfPresent<T>(_ value: T?, forKey key: Self.Key) throws where T : Encodable

    /// Stores a keyed encoding container for the given key and returns it.
    ///
    /// - parameter keyType: The key type to use for the container.
    /// - parameter key: The key to encode the container for.
    /// - returns: A new keyed encoding container.
    public mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type, forKey key: Self.Key) -> KeyedEncodingContainer<NestedKey> where NestedKey : CodingKey

    /// Stores an unkeyed encoding container for the given key and returns it.
    ///
    /// - parameter key: The key to encode the container for.
    /// - returns: A new unkeyed encoding container.
    public mutating func nestedUnkeyedContainer(forKey key: Self.Key) -> UnkeyedEncodingContainer

    /// Stores a new nested container for the default `super` key and returns A
    /// new encoder instance for encoding `super` into that container.
    ///
    /// Equivalent to calling `superEncoder(forKey:)` with
    /// `Key(stringValue: "super", intValue: 0)`.
    ///
    /// - returns: A new encoder to pass to `super.encode(to:)`.
    public mutating func superEncoder() -> Encoder

    /// Stores a new nested container for the given key and returns A new encoder
    /// instance for encoding `super` into that container.
    ///
    /// - parameter key: The key to encode `super` for.
    /// - returns: A new encoder to pass to `super.encode(to:)`.
    public mutating func superEncoder(forKey key: Self.Key) -> Encoder
}

extension KeyedEncodingContainerProtocol {

    public mutating func encodeConditional<T>(_ object: T, forKey key: Self.Key) throws where T : AnyObject, T : Encodable
}

extension KeyedEncodingContainerProtocol {

    public mutating func encodeIfPresent(_ value: Bool?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: String?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: Double?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: Float?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: Int?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: Int8?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: Int16?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: Int32?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: Int64?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: UInt?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: UInt8?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: UInt16?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: UInt32?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent(_ value: UInt64?, forKey key: Self.Key) throws

    public mutating func encodeIfPresent<T>(_ value: T?, forKey key: Self.Key) throws where T : Encodable
}

@available(*, deprecated, renamed: "LazyCollection")
public typealias LazyBidirectionalCollection<T> = LazyCollection<T>

/// A collection containing the same elements as a `Base` collection,
/// but on which some operations such as `map` and `filter` are
/// implemented lazily.
///
/// - See also: `LazySequenceProtocol`, `LazyCollection`
public struct LazyCollection<Base> where Base : Collection {
}

extension LazyCollection : LazyCollectionProtocol where Base : Collection {

    /// The type of the underlying collection.
    public typealias Elements = Base

    /// The underlying collection.
    public var elements: Base { get }
}

/// Forward implementations to the base collection, to pick up any
/// optimizations it might implement.
extension LazyCollection : Sequence where Base : Collection {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = Base.Iterator

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyCollection<Base>.Iterator

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var underestimatedCount: Int { get }
}

extension LazyCollection : Collection where Base : Collection {

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Element = Base.Element

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Base.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Base.Indices

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: Base.Index { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Base.Indices { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: LazyCollection<Base>.Index) -> LazyCollection<Base>.Index

    /// Accesses the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: LazyCollection<Base>.Index) -> LazyCollection<Base>.Element { get }

    /// A Boolean value indicating whether the collection is empty.
    public var isEmpty: Bool { get }

    /// Returns the number of elements.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if `Self` conforms to `RandomAccessCollection`;
    ///   O(*n*) otherwise.
    public var count: Int { get }

    /// Returns the first element of `self`, or `nil` if `self` is empty.
    public var first: Base.Element? { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: LazyCollection<Base>.Index, offsetBy n: Int) -> LazyCollection<Base>.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: LazyCollection<Base>.Index, offsetBy n: Int, limitedBy limit: LazyCollection<Base>.Index) -> LazyCollection<Base>.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: LazyCollection<Base>.Index, to end: LazyCollection<Base>.Index) -> Int
}

extension LazyCollection : BidirectionalCollection where Base : BidirectionalCollection {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: LazyCollection<Base>.Index) -> LazyCollection<Base>.Index

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Base.Element? { get }
}

extension LazyCollection : RandomAccessCollection where Base : RandomAccessCollection {
}

/// A collection on which normally-eager operations such as `map` and
/// `filter` are implemented lazily.
///
/// Please see `LazySequenceProtocol` for background; `LazyCollectionProtocol`
/// is an analogous component, but for collections.
///
/// To add new lazy collection operations, extend this protocol with
/// methods that return lazy wrappers that are themselves
/// `LazyCollectionProtocol`s.
public protocol LazyCollectionProtocol : Collection, LazySequenceProtocol where Self.Elements : Collection {

    /// A `Collection` that can contain the same elements as this one,
    /// possibly with a simpler type.
    ///
    /// - See also: `elements`
    associatedtype Elements = Self
}

extension LazyCollectionProtocol {

    /// Returns a lazy collection that skips any initial elements that satisfy
    /// `predicate`.
    ///
    /// - Parameter predicate: A closure that takes an element of the collection
    ///   as its argument and returns `true` if the element should be skipped or
    ///   `false` otherwise. Once `predicate` returns `false` it will not be
    ///   called again.
    public func drop(while predicate: @escaping (Self.Elements.Element) -> Bool) -> LazyDropWhileCollection<Self.Elements>
}

extension LazyCollectionProtocol {

    /// Returns the elements of `self` that satisfy `predicate`.
    ///
    /// - Note: The elements of the result are computed on-demand, as
    ///   the result is used. No buffering storage is allocated and each
    ///   traversal step invokes `predicate` on one or more underlying
    ///   elements.
    public func filter(_ isIncluded: @escaping (Self.Elements.Element) -> Bool) -> LazyFilterCollection<Self.Elements>
}

extension LazyCollectionProtocol {

    /// Returns the concatenated results of mapping the given transformation over
    /// this collection.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a collection for each element.
    /// Calling `flatMap(_:)` on a collection `c` is equivalent to calling
    /// `c.map(transform).joined()`.
    ///
    /// - Complexity: O(1)
    public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Elements.Element) -> SegmentOfResult) -> LazyCollection<FlattenCollection<LazyMapCollection<Self.Elements, SegmentOfResult>>> where SegmentOfResult : Collection

    /// Returns the non-`nil` results of mapping the given transformation over
    /// this collection.
    ///
    /// Use this method to receive a collection of nonoptional values when your
    /// transformation produces an optional value.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   collection as its argument and returns an optional value.
    ///
    /// - Complexity: O(1)
    public func compactMap<ElementOfResult>(_ transform: @escaping (Self.Elements.Element) -> ElementOfResult?) -> LazyMapCollection<LazyFilterCollection<LazyMapCollection<Self.Elements, ElementOfResult?>>, ElementOfResult>

    /// Returns the non-`nil` results of mapping the given transformation over
    /// this collection.
    ///
    /// Use this method to receive a collection of nonoptional values when your
    /// transformation produces an optional value.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   collection as its argument and returns an optional value.
    ///
    /// - Complexity: O(1)
    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: @escaping (Self.Elements.Element) -> ElementOfResult?) -> LazyMapCollection<LazyFilterCollection<LazyMapCollection<Self.Elements, ElementOfResult?>>, ElementOfResult>
}

extension LazyCollectionProtocol where Self.Element : Collection {

    /// A concatenation of the elements of `self`.
    public func joined() -> LazyCollection<FlattenCollection<Self.Elements>>
}

extension LazyCollectionProtocol {

    public var lazy: LazyCollection<Self.Elements> { get }
}

extension LazyCollectionProtocol where Self.Elements : LazyCollectionProtocol {

    public var lazy: Self.Elements { get }
}

extension LazyCollectionProtocol {

    /// Returns a `LazyMapCollection` over this `Collection`.  The elements of
    /// the result are computed lazily, each time they are read, by
    /// calling `transform` function on a base element.
    public func map<U>(_ transform: @escaping (Self.Elements.Element) -> U) -> LazyMapCollection<Self.Elements, U>
}

extension LazyCollectionProtocol {

    /// Returns a lazy collection of the initial consecutive elements that
    /// satisfy `predicate`.
    ///
    /// - Parameter predicate: A closure that takes an element of the collection
    ///   as its argument and returns `true` if the element should be included
    ///   or `false` otherwise. Once `predicate` returns `false` it will not be
    ///   called again.
    public func prefix(while predicate: @escaping (Self.Element) -> Bool) -> LazyPrefixWhileCollection<Self.Elements>
}

extension LazyCollectionProtocol where Self.Elements : BidirectionalCollection {

    /// Returns the elements of the collection in reverse order.
    ///
    /// - Complexity: O(1)
    public func reversed() -> LazyCollection<ReversedCollection<Self.Elements>>
}

@available(*, deprecated, renamed: "LazyDropWhileCollection")
public typealias LazyDropWhileBidirectionalCollection<T> = LazyDropWhileCollection<T>

/// A lazy wrapper that includes the elements of an underlying
/// collection after any initial consecutive elements that satisfy a
/// predicate.
///
/// - Note: The performance of accessing `startIndex`, `first`, or any methods
///   that depend on `startIndex` depends on how many elements satisfy the
///   predicate at the start of the collection, and may not offer the usual
///   performance given by the `Collection` protocol. Be aware, therefore,
///   that general operations on lazy collections may not have the
///   documented complexity.
public struct LazyDropWhileCollection<Base> where Base : Collection {

    /// A type representing the sequence's elements.
    public typealias Element = Base.Element
}

extension LazyDropWhileCollection where Base : Collection {

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = Slice<LazyDropWhileCollection<Base>>

    /// A position in a `LazyDropWhileCollection` or
    /// `LazyDropWhileBidirectionalCollection` instance.
    public struct Index {

        /// The position corresponding to `self` in the underlying collection.
        public let base: Base.Index
    }
}

extension LazyDropWhileCollection : Sequence where Base : Collection {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = LazyDropWhileSequence<Base>.Iterator

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyDropWhileCollection<Base>.Iterator
}

extension LazyDropWhileCollection : Collection where Base : Collection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: LazyDropWhileCollection<Base>.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: LazyDropWhileCollection<Base>.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: LazyDropWhileCollection<Base>.Index) -> LazyDropWhileCollection<Base>.Index

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: LazyDropWhileCollection<Base>.Index) -> LazyDropWhileCollection<Base>.Element { get }
}

extension LazyDropWhileCollection : LazyCollectionProtocol where Base : Collection {
}

extension LazyDropWhileCollection : BidirectionalCollection where Base : BidirectionalCollection {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: LazyDropWhileCollection<Base>.Index) -> LazyDropWhileCollection<Base>.Index
}

extension LazyDropWhileCollection.Index : Equatable, Comparable where Base : Collection {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: LazyDropWhileCollection<Base>.Index, rhs: LazyDropWhileCollection<Base>.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: LazyDropWhileCollection<Base>.Index, rhs: LazyDropWhileCollection<Base>.Index) -> Bool
}

extension LazyDropWhileCollection.Index : Hashable where Base : Collection, Base.Index : Hashable {

    /// The hash value.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

@available(*, deprecated, renamed: "LazyDropWhileCollection.Index")
public typealias LazyDropWhileIndex<T> = LazyDropWhileCollection<T>.Index

@available(*, deprecated, renamed: "LazyDropWhileSequence.Iterator")
public typealias LazyDropWhileIterator<T> = LazyDropWhileSequence<T>.Iterator

/// A sequence whose elements consist of the elements that follow the initial
/// consecutive elements of some base sequence that satisfy a given predicate.
public struct LazyDropWhileSequence<Base> where Base : Sequence {

    /// A type representing the sequence's elements.
    public typealias Element = Base.Element
}

extension LazyDropWhileSequence where Base : Sequence {

    /// An iterator over the elements traversed by a base iterator that follow the
    /// initial consecutive elements that satisfy a given predicate.
    ///
    /// This is the associated iterator for the `LazyDropWhileSequence`,
    /// `LazyDropWhileCollection`, and `LazyDropWhileBidirectionalCollection`
    /// types.
    public struct Iterator {

        /// The type of element traversed by the iterator.
        public typealias Element = Base.Element
    }
}

extension LazyDropWhileSequence : Sequence where Base : Sequence {

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = AnySequence<Base.Element>

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyDropWhileSequence<Base>.Iterator
}

extension LazyDropWhileSequence : LazySequenceProtocol where Base : Sequence {

    /// A `Sequence` that can contain the same elements as this one,
    /// possibly with a simpler type.
    ///
    /// - See also: `elements`
    public typealias Elements = LazyDropWhileSequence<Base>
}

extension LazyDropWhileSequence.Iterator : IteratorProtocol where Base : Sequence {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> LazyDropWhileSequence<Base>.Iterator.Element?
}

@available(*, deprecated, renamed: "LazyFilterCollection")
public typealias LazyFilterBidirectionalCollection<T> = LazyFilterCollection<T>

/// A lazy `Collection` wrapper that includes the elements of an
/// underlying collection that satisfy a predicate.
///
/// - Note: The performance of accessing `startIndex`, `first`, any methods
///   that depend on `startIndex`, or of advancing an index depends
///   on how sparsely the filtering predicate is satisfied, and may not offer
///   the usual performance given by `Collection`. Be aware, therefore, that
///   general operations on `LazyFilterCollection` instances may not have the
///   documented complexity.
public struct LazyFilterCollection<Base> where Base : Collection {
}

extension LazyFilterCollection : LazySequenceProtocol where Base : Collection {

    /// A type representing the sequence's elements.
    public typealias Element = Base.Element

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = LazyFilterSequence<Base>.Iterator

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = LazyFilterCollection<Base.SubSequence>

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    public var underestimatedCount: Int { get }

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyFilterCollection<Base>.Iterator
}

extension LazyFilterCollection : LazyCollectionProtocol where Base : Collection {

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Index = Base.Index

    /// The position of the first element in a non-empty collection.
    ///
    /// In an empty collection, `startIndex == endIndex`.
    ///
    /// - Complexity: O(*n*), where *n* is the ratio between unfiltered and
    ///   filtered collection counts.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// `endIndex` is always reachable from `startIndex` by zero or more
    /// applications of `index(after:)`.
    public var endIndex: Base.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: LazyFilterCollection<Base>.Index) -> LazyFilterCollection<Base>.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout LazyFilterCollection<Base>.Index)

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: LazyFilterCollection<Base>.Index, to end: LazyFilterCollection<Base>.Index) -> Int

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: LazyFilterCollection<Base>.Index, offsetBy n: Int) -> LazyFilterCollection<Base>.Index

    public func formIndex(_ i: inout LazyFilterCollection<Base>.Index, offsetBy n: Int)

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: LazyFilterCollection<Base>.Index, offsetBy n: Int, limitedBy limit: LazyFilterCollection<Base>.Index) -> LazyFilterCollection<Base>.Index?

    public func formIndex(_ i: inout LazyFilterCollection<Base>.Index, offsetBy n: Int, limitedBy limit: LazyFilterCollection<Base>.Index) -> Bool

    /// Accesses the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    /// `position != endIndex`.
    public subscript(position: LazyFilterCollection<Base>.Index) -> LazyFilterCollection<Base>.Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// For example, using a `PartialRangeFrom` range expression with an array
    /// accesses the subrange from the start of the range expression until the
    /// end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2..<5]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. This example searches `streetsSlice` for one of the
    /// strings in the slice, and then uses that index in the original array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")!    // 4
    ///     print(streets[index])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice may result in a runtime
    /// error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<LazyFilterCollection<Base>.Index>) -> LazyFilterCollection<Base>.SubSequence { get }
}

extension LazyFilterCollection : BidirectionalCollection where Base : BidirectionalCollection {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: LazyFilterCollection<Base>.Index) -> LazyFilterCollection<Base>.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout LazyFilterCollection<Base>.Index)
}

public typealias LazyFilterIndex<Base> = Base.Index

public typealias LazyFilterIterator<T> = LazyFilterSequence<T>.Iterator

/// A sequence whose elements consist of the elements of some base
/// sequence that also satisfy a given predicate.
///
/// - Note: `s.lazy.filter { ... }`, for an arbitrary sequence `s`,
///   is a `LazyFilterSequence`.
public struct LazyFilterSequence<Base> where Base : Sequence {
}

extension LazyFilterSequence where Base : Sequence {

    /// An iterator over the elements traversed by some base iterator that also
    /// satisfy a given predicate.
    ///
    /// - Note: This is the associated `Iterator` of `LazyFilterSequence`
    /// and `LazyFilterCollection`.
    public struct Iterator {

        /// The underlying iterator whose elements are being filtered.
        public var base: Base.Iterator { get }
    }
}

extension LazyFilterSequence : LazySequenceProtocol where Base : Sequence {

    /// A type representing the sequence's elements.
    public typealias Element = Base.Element

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyFilterSequence<Base>.Iterator
}

extension LazyFilterSequence.Iterator : IteratorProtocol, Sequence where Base : Sequence {

    /// The type of element traversed by the iterator.
    public typealias Element = Base.Element

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    ///
    /// - Precondition: `next()` has not been applied to a copy of `self`
    ///   since the copy was made.
    public mutating func next() -> LazyFilterSequence<Base>.Iterator.Element?
}

@available(*, deprecated, renamed: "LazyMapCollection")
public typealias LazyMapBidirectionalCollection<T, E> = LazyMapCollection<T, E>

/// A `Collection` whose elements consist of those in a `Base`
/// `Collection` passed through a transform function returning `Element`.
/// These elements are computed lazily, each time they're read, by
/// calling the transform function on a base element.
public struct LazyMapCollection<Base, Element> where Base : Collection {
}

extension LazyMapCollection : Sequence where Base : Collection {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = LazyMapSequence<Base, Element>.Iterator

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyMapCollection<Base, Element>.Iterator

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var underestimatedCount: Int { get }
}

extension LazyMapCollection : LazyCollectionProtocol where Base : Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Base.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Base.Indices

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = LazyMapCollection<Base.SubSequence, Element>

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: LazyMapCollection<Base, Element>.Index) -> LazyMapCollection<Base, Element>.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout LazyMapCollection<Base, Element>.Index)

    /// Accesses the element at `position`.
    ///
    /// - Precondition: `position` is a valid position in `self` and
    ///   `position != endIndex`.
    public subscript(position: Base.Index) -> Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// For example, using a `PartialRangeFrom` range expression with an array
    /// accesses the subrange from the start of the range expression until the
    /// end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2..<5]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. This example searches `streetsSlice` for one of the
    /// strings in the slice, and then uses that index in the original array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")!    // 4
    ///     print(streets[index])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice may result in a runtime
    /// error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<Base.Index>) -> LazyMapCollection<Base, Element>.SubSequence { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Base.Indices { get }

    /// A Boolean value indicating whether the collection is empty.
    public var isEmpty: Bool { get }

    /// The number of elements in the collection.
    ///
    /// To check whether the collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if `Index` conforms to `RandomAccessIndex`; O(*n*)
    ///   otherwise.
    public var count: Int { get }

    /// The first element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    /// 
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let firstNumber = numbers.first {
    ///         print(firstNumber)
    ///     }
    ///     // Prints "10"
    public var first: Element? { get }

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: LazyMapCollection<Base, Element>.Index, offsetBy n: Int) -> LazyMapCollection<Base, Element>.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: LazyMapCollection<Base, Element>.Index, offsetBy n: Int, limitedBy limit: LazyMapCollection<Base, Element>.Index) -> LazyMapCollection<Base, Element>.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: LazyMapCollection<Base, Element>.Index, to end: LazyMapCollection<Base, Element>.Index) -> Int
}

extension LazyMapCollection : BidirectionalCollection where Base : BidirectionalCollection {

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public func index(before i: LazyMapCollection<Base, Element>.Index) -> LazyMapCollection<Base, Element>.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout LazyMapCollection<Base, Element>.Index)

    /// The last element of the collection.
    ///
    /// If the collection is empty, the value of this property is `nil`.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let lastNumber = numbers.last {
    ///         print(lastNumber)
    ///     }
    ///     // Prints "50"
    ///     
    /// - Complexity: O(1)
    public var last: Element? { get }
}

extension LazyMapCollection : RandomAccessCollection where Base : RandomAccessCollection {
}

public typealias LazyMapIterator<T, E> = LazyMapSequence<T, E>.Iterator

@available(*, deprecated, renamed: "LazyMapCollection")
public typealias LazyMapRandomAccessCollection<T, E> = LazyMapCollection<T, E>

/// A `Sequence` whose elements consist of those in a `Base`
/// `Sequence` passed through a transform function returning `Element`.
/// These elements are computed lazily, each time they're read, by
/// calling the transform function on a base element.
public struct LazyMapSequence<Base, Element> where Base : Sequence {

    /// A `Sequence` that can contain the same elements as this one,
    /// possibly with a simpler type.
    ///
    /// - See also: `elements`
    public typealias Elements = LazyMapSequence<Base, Element>
}

extension LazyMapSequence where Base : Sequence {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator {

        public var base: Base.Iterator { get }
    }
}

extension LazyMapSequence : LazySequenceProtocol where Base : Sequence {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> LazyMapSequence<Base, Element>.Iterator

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    public var underestimatedCount: Int { get }
}

extension LazyMapSequence.Iterator : IteratorProtocol, Sequence where Base : Sequence {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    ///
    /// - Precondition: `next()` has not been applied to a copy of `self`
    ///   since the copy was made.
    public mutating func next() -> Element?
}

@available(*, deprecated, renamed: "LazyPrefixWhileCollection")
public typealias LazyPrefixWhileBidirectionalCollection<T> = LazyPrefixWhileCollection<T>

/// A lazy `${Collection}` wrapper that includes the initial consecutive
/// elements of an underlying collection that satisfy a predicate.
///
/// - Note: The performance of accessing `endIndex`, `last`, any methods that
///   depend on `endIndex`, or moving an index depends on how many elements
///   satisfy the predicate at the start of the collection, and may not offer
///   the usual performance given by the `Collection` protocol. Be aware,
///   therefore, that general operations on `${Self}` instances may not have
///   the documented complexity.
public struct LazyPrefixWhileCollection<Base> where Base : Collection {

    /// A type representing the sequence's elements.
    public typealias Element = Base.Element

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = Slice<LazyPrefixWhileCollection<Base>>
}

extension LazyPrefixWhileCollection where Base : Collection {

    /// A position in a `LazyPrefixWhileCollection` or
    /// `LazyPrefixWhileBidirectionalCollection` instance.
    public struct Index {
    }
}

extension LazyPrefixWhileCollection : Sequence where Base : Collection {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = LazyPrefixWhileSequence<Base>.Iterator

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> LazyPrefixWhileCollection<Base>.Iterator
}

extension LazyPrefixWhileCollection : Collection where Base : Collection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: LazyPrefixWhileCollection<Base>.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: LazyPrefixWhileCollection<Base>.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: LazyPrefixWhileCollection<Base>.Index) -> LazyPrefixWhileCollection<Base>.Index

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: LazyPrefixWhileCollection<Base>.Index) -> LazyPrefixWhileCollection<Base>.Element { get }
}

extension LazyPrefixWhileCollection : BidirectionalCollection where Base : BidirectionalCollection {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: LazyPrefixWhileCollection<Base>.Index) -> LazyPrefixWhileCollection<Base>.Index
}

extension LazyPrefixWhileCollection : LazyCollectionProtocol where Base : Collection {

    /// A `Collection` that can contain the same elements as this one,
    /// possibly with a simpler type.
    ///
    /// - See also: `elements`
    public typealias Elements = LazyPrefixWhileCollection<Base>
}

extension LazyPrefixWhileCollection.Index : Comparable where Base : Collection {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: LazyPrefixWhileCollection<Base>.Index, rhs: LazyPrefixWhileCollection<Base>.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: LazyPrefixWhileCollection<Base>.Index, rhs: LazyPrefixWhileCollection<Base>.Index) -> Bool
}

extension LazyPrefixWhileCollection.Index : Hashable where Base : Collection, Base.Index : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

@available(*, deprecated, renamed: "LazyDropWhileCollection.Index")
public typealias LazyPrefixWhileIndex<T> = LazyPrefixWhileCollection<T>.Index

@available(*, deprecated, renamed: "LazyDropWhileSequence.Iterator")
public typealias LazyPrefixWhileIterator<T> = LazyPrefixWhileSequence<T>.Iterator

/// A sequence whose elements consist of the initial consecutive elements of
/// some base sequence that satisfy a given predicate.
public struct LazyPrefixWhileSequence<Base> where Base : Sequence {

    /// A type representing the sequence's elements.
    public typealias Element = Base.Element
}

extension LazyPrefixWhileSequence where Base : Sequence {

    /// An iterator over the initial elements traversed by a base iterator that
    /// satisfy a given predicate.
    ///
    /// This is the associated iterator for the `LazyPrefixWhileSequence`,
    /// `LazyPrefixWhileCollection`, and `LazyPrefixWhileBidirectionalCollection`
    /// types.
    public struct Iterator {

        /// The type of element traversed by the iterator.
        public typealias Element = Base.Element
    }
}

extension LazyPrefixWhileSequence : Sequence where Base : Sequence {

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = AnySequence<Base.Element>

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> LazyPrefixWhileSequence<Base>.Iterator
}

extension LazyPrefixWhileSequence : LazySequenceProtocol where Base : Sequence {

    /// A `Sequence` that can contain the same elements as this one,
    /// possibly with a simpler type.
    ///
    /// - See also: `elements`
    public typealias Elements = LazyPrefixWhileSequence<Base>
}

extension LazyPrefixWhileSequence.Iterator : IteratorProtocol, Sequence where Base : Sequence {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> LazyPrefixWhileSequence<Base>.Iterator.Element?
}

@available(*, deprecated, renamed: "LazyCollection")
public typealias LazyRandomAccessCollection<T> = LazyCollection<T>

/// A sequence containing the same elements as a `Base` sequence, but
/// on which some operations such as `map` and `filter` are
/// implemented lazily.
///
/// - See also: `LazySequenceProtocol`
public struct LazySequence<Base> : _SequenceWrapper where Base : Sequence {
}

extension LazySequence : LazySequenceProtocol where Base : Sequence {

    /// A `Sequence` that can contain the same elements as this one,
    /// possibly with a simpler type.
    ///
    /// - See also: `elements`
    public typealias Elements = Base

    /// The `Base` (presumably non-lazy) sequence from which `self` was created.
    public var elements: Base { get }
}

/// A sequence on which normally-eager operations such as `map` and
/// `filter` are implemented lazily.
///
/// Lazy sequences can be used to avoid needless storage allocation
/// and computation, because they use an underlying sequence for
/// storage and compute their elements on demand.  For example,
///
///     [1, 2, 3].lazy.map { $0 * 2 }
///
/// is a sequence containing { `2`, `4`, `6` }.  Each time an element
/// of the lazy sequence is accessed, an element of the underlying
/// array is accessed and transformed by the closure.
///
/// Sequence operations taking closure arguments, such as `map` and
/// `filter`, are normally eager: they use the closure immediately and
/// return a new array.  Using the `lazy` property gives the standard
/// library explicit permission to store the closure and the sequence
/// in the result, and defer computation until it is needed.
///
/// To add new lazy sequence operations, extend this protocol with
/// methods that return lazy wrappers that are themselves
/// `LazySequenceProtocol`s.  For example, given an eager `scan`
/// method defined as follows
///
///     extension Sequence {
///       /// Returns an array containing the results of
///       ///
///       ///   p.reduce(initial, nextPartialResult)
///       ///
///       /// for each prefix `p` of `self`, in order from shortest to
///       /// longest.  For example:
///       ///
///       ///     (1..<6).scan(0, +) // [0, 1, 3, 6, 10, 15]
///       ///
///       /// - Complexity: O(n)
///       func scan<ResultElement>(
///         _ initial: ResultElement,
///         _ nextPartialResult: (ResultElement, Element) -> ResultElement
///       ) -> [ResultElement] {
///         var result = [initial]
///         for x in self {
///           result.append(nextPartialResult(result.last!, x))
///         }
///         return result
///       }
///     }
///
/// we can build a sequence that lazily computes the elements in the
/// result of `scan`:
///
///     struct LazyScanIterator<Base : IteratorProtocol, ResultElement>
///       : IteratorProtocol {
///       mutating func next() -> ResultElement? {
///         return nextElement.map { result in
///           nextElement = base.next().map { nextPartialResult(result, $0) }
///           return result
///         }
///       }
///       private var nextElement: ResultElement? // The next result of next().
///       private var base: Base                  // The underlying iterator.
///       private let nextPartialResult: (ResultElement, Base.Element) -> ResultElement
///     }
///     
///     struct LazyScanSequence<Base: Sequence, ResultElement>
///       : LazySequenceProtocol // Chained operations on self are lazy, too
///     {
///       func makeIterator() -> LazyScanIterator<Base.Iterator, ResultElement> {
///         return LazyScanIterator(
///           nextElement: initial, base: base.makeIterator(), nextPartialResult)
///       }
///       private let initial: ResultElement
///       private let base: Base
///       private let nextPartialResult:
///         (ResultElement, Base.Element) -> ResultElement
///     }
///
/// and finally, we can give all lazy sequences a lazy `scan` method:
///     
///     extension LazySequenceProtocol {
///       /// Returns a sequence containing the results of
///       ///
///       ///   p.reduce(initial, nextPartialResult)
///       ///
///       /// for each prefix `p` of `self`, in order from shortest to
///       /// longest.  For example:
///       ///
///       ///     Array((1..<6).lazy.scan(0, +)) // [0, 1, 3, 6, 10, 15]
///       ///
///       /// - Complexity: O(1)
///       func scan<ResultElement>(
///         _ initial: ResultElement,
///         _ nextPartialResult: (ResultElement, Element) -> ResultElement
///       ) -> LazyScanSequence<Self, ResultElement> {
///         return LazyScanSequence(
///           initial: initial, base: self, nextPartialResult)
///       }
///     }
///
/// - See also: `LazySequence`, `LazyCollectionProtocol`, `LazyCollection`
///
/// - Note: The explicit permission to implement further operations
///   lazily applies only in contexts where the sequence is statically
///   known to conform to `LazySequenceProtocol`.  Thus, side-effects such
///   as the accumulation of `result` below are never unexpectedly
///   dropped or deferred:
///
///       extension Sequence where Element == Int {
///         func sum() -> Int {
///           var result = 0
///           _ = self.map { result += $0 }
///           return result
///         }
///       }
///
///   [We don't recommend that you use `map` this way, because it
///   creates and discards an array. `sum` would be better implemented
///   using `reduce`].
public protocol LazySequenceProtocol : Sequence {

    /// A `Sequence` that can contain the same elements as this one,
    /// possibly with a simpler type.
    ///
    /// - See also: `elements`
    associatedtype Elements : Sequence = Self where Self.Element == Self.Elements.Element

    /// A sequence containing the same elements as this one, possibly with
    /// a simpler type.
    ///
    /// When implementing lazy operations, wrapping `elements` instead
    /// of `self` can prevent result types from growing an extra
    /// `LazySequence` layer.  For example,
    ///
    /// _prext_ example needed
    ///
    /// Note: this property need not be implemented by conforming types,
    /// it has a default implementation in a protocol extension that
    /// just returns `self`.
    public var elements: Self.Elements { get }
}

extension LazySequenceProtocol {

    /// Returns a lazy sequence that skips any initial elements that satisfy
    /// `predicate`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns `true` if the element should be skipped or
    ///   `false` otherwise. Once `predicate` returns `false` it will not be
    ///   called again.
    public func drop(while predicate: @escaping (Self.Elements.Element) -> Bool) -> LazyDropWhileSequence<Self.Elements>
}

extension LazySequenceProtocol {

    /// Returns the elements of `self` that satisfy `isIncluded`.
    ///
    /// - Note: The elements of the result are computed on-demand, as
    ///   the result is used. No buffering storage is allocated and each
    ///   traversal step invokes `predicate` on one or more underlying
    ///   elements.
    public func filter(_ isIncluded: @escaping (Self.Elements.Element) -> Bool) -> LazyFilterSequence<Self.Elements>
}

extension LazySequenceProtocol {

    /// Returns the concatenated results of mapping the given transformation over
    /// this sequence.
    ///
    /// Use this method to receive a single-level sequence when your
    /// transformation produces a sequence or collection for each element.
    /// Calling `flatMap(_:)` on a sequence `s` is equivalent to calling
    /// `s.map(transform).joined()`.
    ///
    /// - Complexity: O(1)
    public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Elements.Element) -> SegmentOfResult) -> LazySequence<FlattenSequence<LazyMapSequence<Self.Elements, SegmentOfResult>>> where SegmentOfResult : Sequence

    /// Returns the non-`nil` results of mapping the given transformation over
    /// this sequence.
    ///
    /// Use this method to receive a sequence of nonoptional values when your
    /// transformation produces an optional value.
    ///
    /// - Parameter transform: A closure that accepts an element of this sequence
    ///   as its argument and returns an optional value.
    ///
    /// - Complexity: O(1)
    public func compactMap<ElementOfResult>(_ transform: @escaping (Self.Elements.Element) -> ElementOfResult?) -> LazyMapSequence<LazyFilterSequence<LazyMapSequence<Self.Elements, ElementOfResult?>>, ElementOfResult>

    /// Returns the non-`nil` results of mapping the given transformation over
    /// this sequence.
    ///
    /// Use this method to receive a sequence of nonoptional values when your
    /// transformation produces an optional value.
    ///
    /// - Parameter transform: A closure that accepts an element of this sequence
    ///   as its argument and returns an optional value.
    ///
    /// - Complexity: O(1)
    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: @escaping (Self.Elements.Element) -> ElementOfResult?) -> LazyMapSequence<LazyFilterSequence<LazyMapSequence<Self.Elements, ElementOfResult?>>, ElementOfResult>
}

extension LazySequenceProtocol where Self.Element : Sequence {

    /// Returns a lazy sequence that concatenates the elements of this sequence of
    /// sequences.
    public func joined() -> LazySequence<FlattenSequence<Self.Elements>>
}

/// When there's no special associated `Elements` type, the `elements`
/// property is provided.
extension LazySequenceProtocol where Self == Self.Elements {

    /// Identical to `self`.
    public var elements: Self { get }
}

extension LazySequenceProtocol {

    public var lazy: LazySequence<Self.Elements> { get }
}

extension LazySequenceProtocol where Self.Elements : LazySequenceProtocol {

    public var lazy: Self.Elements { get }
}

extension LazySequenceProtocol {

    /// Returns a `LazyMapSequence` over this `Sequence`.  The elements of
    /// the result are computed lazily, each time they are read, by
    /// calling `transform` function on a base element.
    public func map<U>(_ transform: @escaping (Self.Elements.Element) -> U) -> LazyMapSequence<Self.Elements, U>
}

extension LazySequenceProtocol {

    /// Returns a lazy sequence of the initial consecutive elements that satisfy
    /// `predicate`.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns `true` if the element should be included or
    ///   `false` otherwise. Once `predicate` returns `false` it will not be
    ///   called again.
    public func prefix(while predicate: @escaping (Self.Elements.Element) -> Bool) -> LazyPrefixWhileSequence<Self.Elements>
}

/// A type that can be represented as a string in a lossless, unambiguous way.
///
/// For example, the integer value 1050 can be represented in its entirety as
/// the string "1050".
///
/// The description property of a conforming type must be a value-preserving
/// representation of the original value. As such, it should be possible to
/// re-create an instance from its string representation.
public protocol LosslessStringConvertible : CustomStringConvertible {

    /// Instantiates an instance of the conforming type from a string
    /// representation.
    public init?(_ description: String)
}

/// A class whose instances contain a property of type `Header` and raw
/// storage for an array of `Element`, whose size is determined at
/// instance creation.
///
/// Note that the `Element` array is suitably-aligned **raw memory**.
/// You are expected to construct and---if necessary---destroy objects
/// there yourself, using the APIs on `UnsafeMutablePointer<Element>`.
/// Typical usage stores a count and capacity in `Header` and destroys
/// any live elements in the `deinit` of a subclass.
/// - Note: Subclasses must not have any stored properties; any storage
///   needed should be included in `Header`.
open class ManagedBuffer<Header, Element> {

    /// Create a new instance of the most-derived class, calling
    /// `factory` on the partially-constructed object to generate
    /// an initial `Header`.
    final public class func create(minimumCapacity: Int, makingHeaderWith factory: (ManagedBuffer<Header, Element>) throws -> Header) rethrows -> ManagedBuffer<Header, Element>

    /// The actual number of elements that can be stored in this object.
    ///
    /// This header may be nontrivial to compute; it is usually a good
    /// idea to store this information in the "header" area when
    /// an instance is created.
    final public var capacity: Int { get }

    /// Call `body` with an `UnsafeMutablePointer` to the stored
    /// `Header`.
    ///
    /// - Note: This pointer is valid only for the duration of the
    ///   call to `body`.
    final public func withUnsafeMutablePointerToHeader<R>(_ body: (UnsafeMutablePointer<Header>) throws -> R) rethrows -> R

    /// Call `body` with an `UnsafeMutablePointer` to the `Element`
    /// storage.
    ///
    /// - Note: This pointer is valid only for the duration of the
    ///   call to `body`.
    final public func withUnsafeMutablePointerToElements<R>(_ body: (UnsafeMutablePointer<Element>) throws -> R) rethrows -> R

    /// Call `body` with `UnsafeMutablePointer`s to the stored `Header`
    /// and raw `Element` storage.
    ///
    /// - Note: These pointers are valid only for the duration of the
    ///   call to `body`.
    final public func withUnsafeMutablePointers<R>(_ body: (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R) rethrows -> R

    /// The stored `Header` instance.
    ///
    /// During instance creation, in particular during
    /// `ManagedBuffer.create`'s call to initialize, `ManagedBuffer`'s
    /// `header` property is as-yet uninitialized, and therefore
    /// reading the `header` property during `ManagedBuffer.create` is undefined.
    final public var header: Header
}

/// Contains a buffer object, and provides access to an instance of
/// `Header` and contiguous storage for an arbitrary number of
/// `Element` instances stored in that buffer.
///
/// For most purposes, the `ManagedBuffer` class works fine for this
/// purpose, and can simply be used on its own.  However, in cases
/// where objects of various different classes must serve as storage,
/// `ManagedBufferPointer` is needed.
///
/// A valid buffer class is non-`@objc`, with no declared stored
///   properties.  Its `deinit` must destroy its
///   stored `Header` and any constructed `Element`s.
///
/// Example Buffer Class
/// --------------------
///
///      class MyBuffer<Element> { // non-@objc
///        typealias Manager = ManagedBufferPointer<(Int, String), Element>
///        deinit {
///          Manager(unsafeBufferObject: self).withUnsafeMutablePointers {
///            (pointerToHeader, pointerToElements) -> Void in
///            pointerToElements.deinitialize(count: self.count)
///            pointerToHeader.deinitialize(count: 1)
///          }
///        }
///
///        // All properties are *computed* based on members of the Header
///        var count: Int {
///          return Manager(unsafeBufferObject: self).header.0
///        }
///        var name: String {
///          return Manager(unsafeBufferObject: self).header.1
///        }
///      }
///
public struct ManagedBufferPointer<Header, Element> : Equatable {

    /// Create with new storage containing an initial `Header` and space
    /// for at least `minimumCapacity` `element`s.
    ///
    /// - parameter bufferClass: The class of the object used for storage.
    /// - parameter minimumCapacity: The minimum number of `Element`s that
    ///   must be able to be stored in the new buffer.
    /// - parameter factory: A function that produces the initial
    ///   `Header` instance stored in the buffer, given the `buffer`
    ///   object and a function that can be called on it to get the actual
    ///   number of allocated elements.
    ///
    /// - Precondition: `minimumCapacity >= 0`, and the type indicated by
    ///   `bufferClass` is a non-`@objc` class with no declared stored
    ///   properties.  The `deinit` of `bufferClass` must destroy its
    ///   stored `Header` and any constructed `Element`s.
    public init(bufferClass: AnyClass, minimumCapacity: Int, makingHeaderWith factory: (AnyObject, (AnyObject) -> Int) throws -> Header) rethrows

    /// Manage the given `buffer`.
    ///
    /// - Precondition: `buffer` is an instance of a non-`@objc` class whose
    ///   `deinit` destroys its stored `Header` and any constructed `Element`s.
    public init(unsafeBufferObject buffer: AnyObject)

    /// The stored `Header` instance.
    public var header: Header

    /// Returns the object instance being used for storage.
    public var buffer: AnyObject { get }

    /// The actual number of elements that can be stored in this object.
    ///
    /// This value may be nontrivial to compute; it is usually a good
    /// idea to store this information in the "header" area when
    /// an instance is created.
    public var capacity: Int { get }

    /// Call `body` with an `UnsafeMutablePointer` to the stored
    /// `Header`.
    ///
    /// - Note: This pointer is valid only
    ///   for the duration of the call to `body`.
    public func withUnsafeMutablePointerToHeader<R>(_ body: (UnsafeMutablePointer<Header>) throws -> R) rethrows -> R

    /// Call `body` with an `UnsafeMutablePointer` to the `Element`
    /// storage.
    ///
    /// - Note: This pointer is valid only for the duration of the
    ///   call to `body`.
    public func withUnsafeMutablePointerToElements<R>(_ body: (UnsafeMutablePointer<Element>) throws -> R) rethrows -> R

    /// Call `body` with `UnsafeMutablePointer`s to the stored `Header`
    /// and raw `Element` storage.
    ///
    /// - Note: These pointers are valid only for the duration of the
    ///   call to `body`.
    public func withUnsafeMutablePointers<R>(_ body: (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R) rethrows -> R

    /// Returns `true` iff `self` holds the only strong reference to its buffer.
    ///
    /// See `isUniquelyReferenced` for details.
    public mutating func isUniqueReference() -> Bool

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ManagedBufferPointer<Header, Element>, rhs: ManagedBufferPointer<Header, Element>) -> Bool
}

/// The memory layout of a type, describing its size, stride, and alignment.
///
/// You can use `MemoryLayout` as a source of information about a type when
/// allocating or binding memory using unsafe pointers. The following example
/// declares a `Point` type with `x` and `y` coordinates and a Boolean
/// `isFilled` property.
///
///     struct Point {
///         let x: Double
///         let y: Double
///         let isFilled: Bool
///     }
///
/// The size, stride, and alignment of the `Point` type are accessible as
/// static properties of `MemoryLayout<Point>`.
///
///     // MemoryLayout<Point>.size == 17
///     // MemoryLayout<Point>.stride == 24
///     // MemoryLayout<Point>.alignment == 8
///
/// Always use a multiple of a type's `stride` instead of its `size` when
/// allocating memory or accounting for the distance between instances in
/// memory. This example allocates untyped, uninitialized memory with space
/// for four instances of `Point`.
///
///     let count = 4
///     let pointPointer = UnsafeMutableRawPointer.allocate(
///             bytes: count * MemoryLayout<Point>.stride,
///             alignedTo: MemoryLayout<Point>.alignment)
public enum MemoryLayout<T> {

    /// The contiguous memory footprint of `T`, in bytes.
    ///
    /// A type's size does not include any dynamically allocated or out of line
    /// storage. In particular, `MemoryLayout<T>.size`, when `T` is a class
    /// type, is the same regardless of how many stored properties `T` has.
    ///
    /// When allocating memory for multiple instances of `T` using an unsafe
    /// pointer, use a multiple of the type's stride instead of its size.
    public static var size: Int { get }

    /// The number of bytes from the start of one instance of `T` to the start of
    /// the next when stored in contiguous memory or in an `Array<T>`.
    ///
    /// This is the same as the number of bytes moved when an `UnsafePointer<T>`
    /// instance is incremented. `T` may have a lower minimal alignment that
    /// trades runtime performance for space efficiency. This value is always
    /// positive.
    public static var stride: Int { get }

    /// The default memory alignment of `T`, in bytes.
    ///
    /// Use the `alignment` property for a type when allocating memory using an
    /// unsafe pointer. This value is always positive.
    public static var alignment: Int { get }
}

extension MemoryLayout {

    /// Returns the contiguous memory footprint of the given instance.
    ///
    /// The result does not include any dynamically allocated or out of line
    /// storage. In particular, pointers and class instances all have the same
    /// contiguous memory footprint, regardless of the size of the referenced
    /// data.
    ///
    /// When you have a type instead of an instance, use the
    /// `MemoryLayout<T>.size` static property instead.
    ///
    ///     let x: Int = 100
    ///
    ///     // Finding the size of a value's type
    ///     let s = MemoryLayout.size(ofValue: x)
    ///     // s == 8
    ///
    ///     // Finding the size of a type directly
    ///     let t = MemoryLayout<Int>.size
    ///     // t == 8
    ///
    /// - Parameter value: A value representative of the type to describe.
    /// - Returns: The size, in bytes, of the given value's type.
    public static func size(ofValue value: T) -> Int

    /// Returns the number of bytes from the start of one instance of `T` to the
    /// start of the next when stored in contiguous memory or in an `Array<T>`.
    ///
    /// This is the same as the number of bytes moved when an `UnsafePointer<T>`
    /// instance is incremented. `T` may have a lower minimal alignment that
    /// trades runtime performance for space efficiency. The result is always
    /// positive.
    ///
    /// When you have a type instead of an instance, use the
    /// `MemoryLayout<T>.stride` static property instead.
    ///
    ///     let x: Int = 100
    ///
    ///     // Finding the stride of a value's type
    ///     let s = MemoryLayout.stride(ofValue: x)
    ///     // s == 8
    ///
    ///     // Finding the stride of a type directly
    ///     let t = MemoryLayout<Int>.stride
    ///     // t == 8
    ///
    /// - Parameter value: A value representative of the type to describe.
    /// - Returns: The stride, in bytes, of the given value's type.
    public static func stride(ofValue value: T) -> Int

    /// Returns the default memory alignment of `T`.
    ///
    /// Use a type's alignment when allocating memory using an unsafe pointer.
    ///
    /// When you have a type instead of an instance, use the
    /// `MemoryLayout<T>.stride` static property instead.
    ///
    ///     let x: Int = 100
    ///
    ///     // Finding the alignment of a value's type
    ///     let s = MemoryLayout.alignment(ofValue: x)
    ///     // s == 8
    ///
    ///     // Finding the alignment of a type directly
    ///     let t = MemoryLayout<Int>.alignment
    ///     // t == 8
    ///
    /// - Parameter value: A value representative of the type to describe.
    /// - Returns: The default memory alignment, in bytes, of the given value's
    ///   type. This value is always positive.
    public static func alignment(ofValue value: T) -> Int

    /// Returns the offset of an inline stored property of `T` within the
    /// in-memory representation of `T`.
    ///
    /// If the given key refers to inline, directly addressable storage within
    /// the in-memory representation of `T`, then the return value is a distance
    /// in bytes that can be added to a pointer of type `T` to get a pointer to
    /// the storage referenced by `key`.
    ///
    /// If the return value of this method is non-`nil`, then accessing the value
    /// by key path or by an offset pointer are equivalent. For example, for a
    /// variable `root` of type `T`, `value` of type `U`, and a key path `key`
    /// of type `WritableKeyPath<T, U>`:
    ///
    ///     // Mutation through the key path
    ///     root[keyPath: key] = value
    ///
    ///     // Mutation through the offset pointer
    ///     withUnsafeMutableBytes(of: &root) { bytes in
    ///         let rawPointerToValue = bytes.baseAddress! + MemoryLayout<T>.offset(of: key)!
    ///         let pointerToValue = rawPointerToValue.assumingMemoryBound(to: U.self)
    ///         pointerToValue.pointee = value
    ///     }
    ///
    /// A property has inline, directly addressable storage when it is a stored
    /// property for which no additional work is required to extract or set the
    /// value. Properties are not directly accessible if they trigger any
    /// `didSet` or `willSet` accessors, perform any representation changes such
    /// as bridging or closure reabstraction, or mask the value out of
    /// overlapping storage as for packed bitfields. In addition, because class
    /// instance properties are always stored out-of-line, their positions are
    /// not accessible using `offset(of:)`.
    ///
    /// For example, in the `ProductCategory` type defined here, only
    /// `\.updateCounter`, `\.identifier`, and `\.identifier.name` refer to
    /// properties with inline, directly addressable storage:
    ///
    ///     struct ProductCategory {
    ///         struct Identifier {
    ///             var name: String              // addressable
    ///         }
    ///
    ///         var identifier: Identifier        // addressable
    ///         var updateCounter: Int            // addressable
    ///         var products: [Product] {         // not addressable: didSet handler
    ///             didSet { updateCounter += 1 }
    ///         }
    ///         var productCount: Int {           // not addressable: computed property
    ///             return products.count
    ///         }
    ///     }
    ///
    /// When using `offset(of:)` with a type imported from a library, don't
    /// assume that future versions of the library will have the same behavior.
    /// If a property is converted from a stored property to a computed property,
    /// the result of `offset(of:)` changes to `nil`. That kind of conversion is
    /// non-breaking in other contexts, but would trigger a runtime error if the
    /// result of `offset(of:)` is force-unwrapped.
    ///
    /// - Parameter key: A key path referring to storage that can be accessed
    ///   through a value of type `T`.
    /// - Returns: The offset in bytes from a pointer to a value of type `T`
    ///   to a pointer to the storage referenced by `key`, or `nil` if no
    ///   such offset is available for the storage referenced by `key`, such as
    ///   because `key` is computed, has observers, requires reabstraction, or
    ///   overlaps storage with other properties.
    public static func offset(of key: PartialKeyPath<T>) -> Int?
}

/// A representation of the substructure and display style of an instance of
/// any type.
///
/// A mirror describes the parts that make up a particular instance, such as
/// the instance's stored properties, collection or tuple elements, or its
/// active enumeration case. Mirrors also provide a "display style" property
/// that suggests how this mirror might be rendered.
///
/// Playgrounds and the debugger use the `Mirror` type to display
/// representations of values of any type. For example, when you pass an
/// instance to the `dump(_:_:_:_:)` function, a mirror is used to render that
/// instance's runtime contents.
///
///     struct Point {
///         let x: Int, y: Int
///     }
///
///     let p = Point(x: 21, y: 30)
///     print(String(reflecting: p))
///     // Prints " Point
///     //           - x: 21
///     //           - y: 30"
///
/// To customize the mirror representation of a custom type, add conformance to
/// the `CustomReflectable` protocol.
public struct Mirror {

    /// The representation to use for ancestor classes.
    ///
    /// A class that conforms to the `CustomReflectable` protocol can control how
    /// its mirror represents ancestor classes by initializing the mirror
    /// with an `AncestorRepresentation`. This setting has no effect on mirrors
    /// reflecting value type instances.
    public enum AncestorRepresentation {

        /// Generates a default mirror for all ancestor classes.
        ///
        /// This case is the default when initializing a `Mirror` instance.
        ///
        /// When you use this option, a subclass's mirror generates default mirrors
        /// even for ancestor classes that conform to the `CustomReflectable`
        /// protocol. To avoid dropping the customization provided by ancestor
        /// classes, an override of `customMirror` should pass
        /// `.customized({ super.customMirror })` as `ancestorRepresentation` when
        /// initializing its mirror.
        case generated

        /// Uses the nearest ancestor's implementation of `customMirror` to create
        /// a mirror for that ancestor.
        ///
        /// Other classes derived from such an ancestor are given a default mirror.
        /// The payload for this option should always be `{ super.customMirror }`:
        ///
        ///     var customMirror: Mirror {
        ///         return Mirror(
        ///             self,
        ///             children: ["someProperty": self.someProperty],
        ///             ancestorRepresentation: .customized({ super.customMirror })) // <==
        ///     }
        case customized(@escaping () -> Mirror)

        /// Suppresses the representation of all ancestor classes.
        ///
        /// In a mirror created with this ancestor representation, the
        /// `superclassMirror` property is `nil`.
        case suppressed
    }

    /// Creates a mirror that reflects on the given instance.
    ///
    /// If the dynamic type of `subject` conforms to `CustomReflectable`, the
    /// resulting mirror is determined by its `customMirror` property.
    /// Otherwise, the result is generated by the language.
    ///
    /// If the dynamic type of `subject` has value semantics, subsequent
    /// mutations of `subject` will not observable in `Mirror`.  In general,
    /// though, the observability of mutations is unspecified.
    ///
    /// - Parameter subject: The instance for which to create a mirror.
    public init(reflecting subject: Any)

    /// An element of the reflected instance's structure.
    ///
    /// When the `label` component in not `nil`, it may represent the name of a
    /// stored property or an active `enum` case. If you pass strings to the
    /// `descendant(_:_:)` method, labels are used for lookup.
    public typealias Child = (label: String?, value: Any)

    /// The type used to represent substructure.
    ///
    /// When working with a mirror that reflects a bidirectional or random access
    /// collection, you may find it useful to "upgrade" instances of this type
    /// to `AnyBidirectionalCollection` or `AnyRandomAccessCollection`. For
    /// example, to display the last twenty children of a mirror if they can be
    /// accessed efficiently, you write the following code:
    ///
    ///     if let b = AnyBidirectionalCollection(someMirror.children) {
    ///         for element in b.suffix(20) {
    ///             print(element)
    ///         }
    ///     }
    public typealias Children = AnyCollection<Mirror.Child>

    /// A suggestion of how a mirror's subject is to be interpreted.
    ///
    /// Playgrounds and the debugger will show a representation similar
    /// to the one used for instances of the kind indicated by the
    /// `DisplayStyle` case name when the mirror is used for display.
    public enum DisplayStyle {

        case `struct`

        case `class`

        case `enum`

        case tuple

        case optional

        case collection

        case dictionary

        case set
    }

    /// Creates a mirror representing the given subject with a specified
    /// structure.
    ///
    /// You use this initializer from within your type's `customMirror`
    /// implementation to create a customized mirror.
    ///
    /// If `subject` is a class instance, `ancestorRepresentation` determines
    /// whether ancestor classes will be represented and whether their
    /// `customMirror` implementations will be used. By default, the
    /// `customMirror` implementation of any ancestors is ignored. To prevent
    /// bypassing customized ancestors, pass
    /// `.customized({ super.customMirror })` as the `ancestorRepresentation`
    /// parameter when implementing your type's `customMirror` property.
    ///
    /// - Parameters:
    ///   - subject: The instance to represent in the new mirror.
    ///   - children: The structure to use for the mirror. The collection
    ///     traversal modeled by `children` is captured so that the resulting
    ///     mirror's children may be upgraded to a bidirectional or random
    ///     access collection later. See the `children` property for details.
    ///   - displayStyle: The preferred display style for the mirror when
    ///     presented in the debugger or in a playground. The default is `nil`.
    ///   - ancestorRepresentation: The means of generating the subject's
    ///     ancestor representation. `ancestorRepresentation` is ignored if
    ///     `subject` is not a class instance. The default is `.generated`.
    public init<Subject, C>(_ subject: Subject, children: C, displayStyle: Mirror.DisplayStyle? = default, ancestorRepresentation: Mirror.AncestorRepresentation = default) where C : Collection, C.Element == Mirror.Child

    /// Creates a mirror representing the given subject with unlabeled children.
    ///
    /// You use this initializer from within your type's `customMirror`
    /// implementation to create a customized mirror, particularly for custom
    /// types that are collections. The labels of the resulting mirror's
    /// `children` collection are all `nil`.
    ///
    /// If `subject` is a class instance, `ancestorRepresentation` determines
    /// whether ancestor classes will be represented and whether their
    /// `customMirror` implementations will be used. By default, the
    /// `customMirror` implementation of any ancestors is ignored. To prevent
    /// bypassing customized ancestors, pass
    /// `.customized({ super.customMirror })` as the `ancestorRepresentation`
    /// parameter when implementing your type's `customMirror` property.
    ///
    /// - Parameters:
    ///   - subject: The instance to represent in the new mirror.
    ///   - unlabeledChildren: The children to use for the mirror. The collection
    ///     traversal modeled by `unlabeledChildren` is captured so that the
    ///     resulting mirror's children may be upgraded to a bidirectional or
    ///     random access collection later. See the `children` property for
    ///     details.
    ///   - displayStyle: The preferred display style for the mirror when
    ///     presented in the debugger or in a playground. The default is `nil`.
    ///   - ancestorRepresentation: The means of generating the subject's
    ///     ancestor representation. `ancestorRepresentation` is ignored if
    ///     `subject` is not a class instance. The default is `.generated`.
    public init<Subject, C>(_ subject: Subject, unlabeledChildren: C, displayStyle: Mirror.DisplayStyle? = default, ancestorRepresentation: Mirror.AncestorRepresentation = default) where C : Collection

    /// Creates a mirror representing the given subject using a dictionary
    /// literal for the structure.
    ///
    /// You use this initializer from within your type's `customMirror`
    /// implementation to create a customized mirror. Pass a dictionary literal
    /// with string keys as `children`. Although an *actual* dictionary is
    /// arbitrarily-ordered, when you create a mirror with a dictionary literal,
    /// the ordering of the mirror's `children` will exactly match that of the
    /// literal you pass.
    ///
    /// If `subject` is a class instance, `ancestorRepresentation` determines
    /// whether ancestor classes will be represented and whether their
    /// `customMirror` implementations will be used. By default, the
    /// `customMirror` implementation of any ancestors is ignored. To prevent
    /// bypassing customized ancestors, pass
    /// `.customized({ super.customMirror })` as the `ancestorRepresentation`
    /// parameter when implementing your type's `customMirror` property.
    ///
    /// - Parameters:
    ///   - subject: The instance to represent in the new mirror.
    ///   - children: A dictionary literal to use as the structure for the
    ///     mirror. The `children` collection of the resulting mirror may be
    ///     upgraded to a random access collection later. See the `children`
    ///     property for details.
    ///   - displayStyle: The preferred display style for the mirror when
    ///     presented in the debugger or in a playground. The default is `nil`.
    ///   - ancestorRepresentation: The means of generating the subject's
    ///     ancestor representation. `ancestorRepresentation` is ignored if
    ///     `subject` is not a class instance. The default is `.generated`.
    public init<Subject>(_ subject: Subject, children: DictionaryLiteral<String, Any>, displayStyle: Mirror.DisplayStyle? = default, ancestorRepresentation: Mirror.AncestorRepresentation = default)

    /// The static type of the subject being reflected.
    ///
    /// This type may differ from the subject's dynamic type when this mirror
    /// is the `superclassMirror` of another mirror.
    public let subjectType: Any.Type

    /// A collection of `Child` elements describing the structure of the
    /// reflected subject.
    public let children: Mirror.Children

    /// A suggested display style for the reflected subject.
    public let displayStyle: Mirror.DisplayStyle?

    /// A mirror of the subject's superclass, if one exists.
    public var superclassMirror: Mirror? { get }
}

extension Mirror {

    /// Returns a specific descendant of the reflected subject, or `nil` if no
    /// such descendant exists.
    ///
    /// Pass a variadic list of string and integer arguments. Each string
    /// argument selects the first child with a matching label. Each integer
    /// argument selects the child at that offset. For example, passing
    /// `1, "two", 3` as arguments to `myMirror.descendant(_:_:)` is equivalent
    /// to:
    ///
    ///     var result: Any? = nil
    ///     let children = myMirror.children
    ///     if let i0 = children.index(
    ///         children.startIndex, offsetBy: 1, limitedBy: children.endIndex),
    ///         i0 != children.endIndex
    ///     {
    ///         let grandChildren = Mirror(reflecting: children[i0].value).children
    ///         if let i1 = grandChildren.firstIndex(where: { $0.label == "two" }) {
    ///             let greatGrandChildren =
    ///                 Mirror(reflecting: grandChildren[i1].value).children
    ///             if let i2 = greatGrandChildren.index(
    ///                 greatGrandChildren.startIndex,
    ///                 offsetBy: 3,
    ///                 limitedBy: greatGrandChildren.endIndex),
    ///                 i2 != greatGrandChildren.endIndex
    ///             {
    ///                 // Success!
    ///                 result = greatGrandChildren[i2].value
    ///             }
    ///         }
    ///     }
    ///
    /// This function is suitable for exploring the structure of a mirror in a
    /// REPL or playground, but is not intended to be efficient. The efficiency
    /// of finding each element in the argument list depends on the argument
    /// type and the capabilities of the each level of the mirror's `children`
    /// collections. Each string argument requires a linear search, and unless
    /// the underlying collection supports random-access traversal, each integer
    /// argument also requires a linear operation.
    ///
    /// - Parameters:
    ///   - first: The first mirror path component to access.
    ///   - rest: Any remaining mirror path components.
    /// - Returns: The descendant of this mirror specified by the given mirror
    ///   path components if such a descendant exists; otherwise, `nil`.
    public func descendant(_ first: MirrorPath, _ rest: MirrorPath...) -> Any?
}

/// Reflection for `Mirror` itself.
extension Mirror : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension Mirror : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// A protocol for legitimate arguments to `Mirror`'s `descendant`
/// method.
///
/// Do not declare new conformances to this protocol; they will not
/// work as expected.
public protocol MirrorPath {
}

@available(*, deprecated, renamed: "Slice")
public typealias MutableBidirectionalSlice<T> = Slice<T>

/// A collection that supports subscript assignment.
///
/// Collections that conform to `MutableCollection` gain the ability to
/// change the value of their elements. This example shows how you can
/// modify one of the names in an array of students.
///
///     var students = ["Ben", "Ivy", "Jordell", "Maxime"]
///     if let i = students.firstIndex(of: "Maxime") {
///         students[i] = "Max"
///     }
///     print(students)
///     // Prints "["Ben", "Ivy", "Jordell", "Max"]"
///
/// In addition to changing the value of an individual element, you can also
/// change the values of a slice of elements in a mutable collection. For
/// example, you can sort *part* of a mutable collection by calling the
/// mutable `sort()` method on a subscripted subsequence. Here's an
/// example that sorts the first half of an array of integers:
///
///     var numbers = [15, 40, 10, 30, 60, 25, 5, 100]
///     numbers[0..<4].sort()
///     print(numbers)
///     // Prints "[10, 15, 30, 40, 60, 25, 5, 100]"
///
/// The `MutableCollection` protocol allows changing the values of a
/// collection's elements but not the length of the collection itself. For
/// operations that require adding or removing elements, see the
/// `RangeReplaceableCollection` protocol instead.
///
/// Conforming to the MutableCollection Protocol
/// ============================================
///
/// To add conformance to the `MutableCollection` protocol to your own
/// custom collection, upgrade your type's subscript to support both read
/// and write access.
/// 
/// A value stored into a subscript of a `MutableCollection` instance must
/// subsequently be accessible at that same position. That is, for a mutable
/// collection instance `a`, index `i`, and value `x`, the two sets of
/// assignments in the following code sample must be equivalent:
///
///     a[i] = x
///     let y = a[i]
///     
///     // Must be equivalent to:
///     a[i] = x
///     let y = x
public protocol MutableCollection : Collection where Self.SubSequence : MutableCollection {

    associatedtype Element

    associatedtype Index

    associatedtype SubSequence

    /// Accesses the element at the specified position.
    ///
    /// For example, you can replace an element of an array by using its
    /// subscript.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one
    /// past the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(position: Self.Index) -> Self.Element { get set }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     streets[index!] = "Eustace"
    ///     print(streets[index!])
    ///     // Prints "Eustace"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Self.Index>) -> Self.SubSequence { get set }

    /// Reorders the elements of the collection such that all the elements
    /// that match the given predicate are after all the elements that don't
    /// match.
    ///
    /// After partitioning a collection, there is a pivot index `p` where
    /// no element before `p` satisfies the `belongsInSecondPartition`
    /// predicate and every element at or after `p` satisfies
    /// `belongsInSecondPartition`.
    ///
    /// In the following example, an array of numbers is partitioned by a
    /// predicate that matches elements greater than 30.
    ///
    ///     var numbers = [30, 40, 20, 30, 30, 60, 10]
    ///     let p = numbers.partition(by: { $0 > 30 })
    ///     // p == 5
    ///     // numbers == [30, 10, 20, 30, 30, 60, 40]
    ///
    /// The `numbers` array is now arranged in two partitions. The first
    /// partition, `numbers[..<p]`, is made up of the elements that
    /// are not greater than 30. The second partition, `numbers[p...]`,
    /// is made up of the elements that *are* greater than 30.
    ///
    ///     let first = numbers[..<p]
    ///     // first == [30, 10, 20, 30, 30]
    ///     let second = numbers[p...]
    ///     // second == [60, 40]
    ///
    /// - Parameter belongsInSecondPartition: A predicate used to partition
    ///   the collection. All elements satisfying this predicate are ordered
    ///   after all elements not satisfying it.
    /// - Returns: The index of the first element in the reordered collection
    ///   that matches `belongsInSecondPartition`. If no elements in the
    ///   collection match `belongsInSecondPartition`, the returned index is
    ///   equal to the collection's `endIndex`.
    ///
    /// - Complexity: O(*n*)
    public mutating func partition(by belongsInSecondPartition: (Self.Element) throws -> Bool) rethrows -> Self.Index

    /// Exchanges the values at the specified indices of the collection.
    ///
    /// Both parameters must be valid indices of the collection and not
    /// equal to `endIndex`. Passing the same index as both `i` and `j` has no
    /// effect.
    ///
    /// - Parameters:
    ///   - i: The index of the first value to swap.
    ///   - j: The index of the second value to swap.
    public mutating func swapAt(_ i: Self.Index, _ j: Self.Index)
}

extension MutableCollection {

    /// Reorders the elements of the collection such that all the elements
    /// that match the given predicate are after all the elements that don't
    /// match.
    ///
    /// After partitioning a collection, there is a pivot index `p` where
    /// no element before `p` satisfies the `belongsInSecondPartition`
    /// predicate and every element at or after `p` satisfies
    /// `belongsInSecondPartition`.
    ///
    /// In the following example, an array of numbers is partitioned by a
    /// predicate that matches elements greater than 30.
    ///
    ///     var numbers = [30, 40, 20, 30, 30, 60, 10]
    ///     let p = numbers.partition(by: { $0 > 30 })
    ///     // p == 5
    ///     // numbers == [30, 10, 20, 30, 30, 60, 40]
    ///
    /// The `numbers` array is now arranged in two partitions. The first
    /// partition, `numbers[..<p]`, is made up of the elements that
    /// are not greater than 30. The second partition, `numbers[p...]`,
    /// is made up of the elements that *are* greater than 30.
    ///
    ///     let first = numbers[..<p]
    ///     // first == [30, 10, 20, 30, 30]
    ///     let second = numbers[p...]
    ///     // second == [60, 40]
    ///
    /// - Parameter belongsInSecondPartition: A predicate used to partition
    ///   the collection. All elements satisfying this predicate are ordered
    ///   after all elements not satisfying it.
    /// - Returns: The index of the first element in the reordered collection
    ///   that matches `belongsInSecondPartition`. If no elements in the
    ///   collection match `belongsInSecondPartition`, the returned index is
    ///   equal to the collection's `endIndex`.
    ///
    /// - Complexity: O(*n*)
    public mutating func partition(by belongsInSecondPartition: (Self.Element) throws -> Bool) rethrows -> Self.Index
}

extension MutableCollection {

    /// Reorders the elements of the collection such that all the elements
    /// that match the given predicate are after all the elements that don't
    /// match.
    ///
    /// After partitioning a collection, there is a pivot index `p` where
    /// no element before `p` satisfies the `belongsInSecondPartition`
    /// predicate and every element at or after `p` satisfies
    /// `belongsInSecondPartition`.
    ///
    /// In the following example, an array of numbers is partitioned by a
    /// predicate that matches elements greater than 30.
    ///
    ///     var numbers = [30, 40, 20, 30, 30, 60, 10]
    ///     let p = numbers.partition(by: { $0 > 30 })
    ///     // p == 5
    ///     // numbers == [30, 10, 20, 30, 30, 60, 40]
    ///
    /// The `numbers` array is now arranged in two partitions. The first
    /// partition, `numbers[..<p]`, is made up of the elements that
    /// are not greater than 30. The second partition, `numbers[p...]`,
    /// is made up of the elements that *are* greater than 30.
    ///
    ///     let first = numbers[..<p]
    ///     // first == [30, 10, 20, 30, 30]
    ///     let second = numbers[p...]
    ///     // second == [60, 40]
    ///
    /// - Parameter belongsInSecondPartition: A predicate used to partition
    ///   the collection. All elements satisfying this predicate are ordered
    ///   after all elements not satisfying it.
    /// - Returns: The index of the first element in the reordered collection
    ///   that matches `belongsInSecondPartition`. If no elements in the
    ///   collection match `belongsInSecondPartition`, the returned index is
    ///   equal to the collection's `endIndex`.
    ///
    /// - Complexity: O(*n*)
    public mutating func partition(by belongsInSecondPartition: (Self.Element) throws -> Bool) rethrows -> Self.Index
}

extension MutableCollection {

    /// Shuffles the collection in place, using the given generator as a source
    /// for randomness.
    ///
    /// You use this method to randomize the elements of a collection when you
    /// are using a custom random number generator. For example, you can use the
    /// `shuffle(using:)` method to randomly reorder the elements of an array.
    ///
    ///     var names = ["Alejandro", "Camila", "Diego", "Luciana", "Luis", "Sofa"]
    ///     names.shuffle(using: &myGenerator)
    ///     // names == ["Sofa", "Alejandro", "Camila", "Luis", "Diego", "Luciana"]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the collection.
    ///
    /// - Complexity: O(*n*)
    public mutating func shuffle<T>(using generator: inout T) where T : RandomNumberGenerator

    /// Shuffles the collection in place.
    ///
    /// Use the `shuffle()` method to randomly reorder the elements of an
    /// array.
    ///
    ///     var names = ["Alejandro", "Camila", "Diego", "Luciana", "Luis", "Sofa"]
    ///     names.shuffle(using: myGenerator)
    ///     // names == ["Luis", "Camila", "Luciana", "Sofa", "Alejandro", "Diego"]
    ///
    /// This method uses the default random generator, `Random.default`. The call
    /// to `names.shuffle()` above is equivalent to calling
    /// `names.shuffle(using: &Random.default)`.
    ///
    /// - Complexity: O(*n*)
    public mutating func shuffle()
}

extension MutableCollection where Self.Element : Comparable {

    /// Sorts the collection in place.
    ///
    /// You can sort any mutable collection of elements that conform to the
    /// `Comparable` protocol by calling this method. Elements are sorted in
    /// ascending order.
    ///
    /// The sorting algorithm is not stable. A nonstable sort may change the
    /// relative order of elements that compare equal.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     var students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     students.sort()
    ///     print(students)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your collection in descending order, pass the
    /// greater-than operator (`>`) to the `sort(by:)` method.
    ///
    ///     students.sort(by: >)
    ///     print(students)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    public mutating func sort()
}

extension MutableCollection {

    /// Sorts the collection in place, using the given predicate as the
    /// comparison between elements.
    ///
    /// When you want to sort a collection of elements that doesn't conform to
    /// the `Comparable` protocol, pass a closure to this method that returns
    /// `true` when the first element passed should be ordered before the
    /// second.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not stable. A nonstable sort may change the
    /// relative order of elements for which `areInIncreasingOrder` does not
    /// establish an order.
    ///
    /// In the following example, the closure provides an ordering for an array
    /// of a custom enumeration that describes an HTTP response. The predicate
    /// orders errors before successes and sorts the error responses by their
    /// error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     var responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     responses.sort {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(responses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// Alternatively, use this method to sort a collection of elements that do
    /// conform to `Comparable` when you want the sort to be descending instead
    /// of ascending. Pass the greater-than operator (`>`) operator as the
    /// predicate.
    ///
    ///     var students = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     students.sort(by: >)
    ///     print(students)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`. If `areInIncreasingOrder` throws an error during
    ///   the sort, the elements may be in a different order, but none will be
    ///   lost.
    public mutating func sort(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Bool) rethrows
}

extension MutableCollection {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     streets[index!] = "Eustace"
    ///     print(streets[index!])
    ///     // Prints "Eustace"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Self.Index>) -> Slice<Self>

    /// Exchanges the values at the specified indices of the collection.
    ///
    /// Both parameters must be valid indices of the collection that are not
    /// equal to `endIndex`. Calling `swapAt(_:_:)` with the same index as both
    /// `i` and `j` has no effect.
    ///
    /// - Parameters:
    ///   - i: The index of the first value to swap.
    ///   - j: The index of the second value to swap.
    public mutating func swapAt(_ i: Self.Index, _ j: Self.Index)
}

extension MutableCollection {

    public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound

    public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence
}

extension MutableCollection {

    /// Reverses the elements of the collection in place.
    ///
    /// The following example reverses the elements of an array of characters:
    ///
    ///     var characters: [Character] = ["C", "a", "f", ""]
    ///     characters.reverse()
    ///     print(characters)
    ///     // Prints "["", "f", "a", "C"]
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements in the
    ///   collection.
    public mutating func reverse()
}

/// A type that provides subscript access to its elements.
///
/// In most cases, it's best to ignore this protocol and use the
/// `MutableCollection` protocol instead, because it has a more complete
/// interface.
@available(*, deprecated, message: "it will be removed in Swift 4.0.  Please use 'MutableCollection' instead")
public typealias MutableIndexable = MutableCollection

@available(*, deprecated, renamed: "Slice")
public typealias MutableRandomAccessSlice<T> = Slice<T>

@available(*, deprecated, renamed: "Slice")
public typealias MutableRangeReplaceableBidirectionalSlice<T> = Slice<T>

@available(*, deprecated, renamed: "Slice")
public typealias MutableRangeReplaceableRandomAccessSlice<T> = Slice<T>

@available(*, deprecated, renamed: "Slice")
public typealias MutableRangeReplaceableSlice<T> = Slice<T>

@available(*, deprecated, renamed: "Slice")
public typealias MutableSlice<T> = Slice<T>

/// The return type of functions that do not return normally, that is, a type
/// with no values.
///
/// Use `Never` as the return type when declaring a closure, function, or
/// method that unconditionally throws an error, traps, or otherwise does
/// not terminate.
///
///     func crashAndBurn() -> Never {
///         fatalError("Something very, very bad happened")
///     }
public enum Never {
}

@available(*, deprecated, renamed: "ExpressibleByNilLiteral")
public typealias NilLiteralConvertible = ExpressibleByNilLiteral

/// Declares methods backing binary arithmetic operators--such as `+`, `-` and
/// `*`--and their mutating counterparts.
///
/// The `Numeric` protocol provides a suitable basis for arithmetic on
/// scalar values, such as integers and floating-point numbers. You can write
/// generic methods that operate on any numeric type in the standard library
/// by using the `Numeric` protocol as a generic constraint.
///
/// The following example declares a method that calculates the total of any
/// sequence with `Numeric` elements.
///
///     extension Sequence where Element: Numeric {
///         func sum() -> Element {
///             return reduce(0, +)
///         }
///     }
///
/// The `sum()` method is now available on any sequence or collection with
/// numeric values, whether it is an array of `Double` or a countable range of
/// `Int`.
///
///     let arraySum = [1.1, 2.2, 3.3, 4.4, 5.5].sum()
///     // arraySum == 16.5
///
///     let rangeSum = (1..<10).sum()
///     // rangeSum == 45
///
/// Conforming to the Numeric Protocol
/// =====================================
///
/// To add `Numeric` protocol conformance to your own custom type, implement
/// the required mutating methods. Extensions to `Numeric` provide default
/// implementations for the protocol's nonmutating methods based on the
/// mutating variants.
public protocol Numeric : Equatable, ExpressibleByIntegerLiteral {

    /// Creates a new instance from the given integer, if it can be represented
    /// exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `100`, while the attempt to initialize the
    /// constant `y` from `1_000` fails because the `Int8` type can represent
    /// `127` at maximum:
    ///
    ///     let x = Int8(exactly: 100)
    ///     // x == Optional(100)
    ///     let y = Int8(exactly: 1_000)
    ///     // y == nil
    ///
    /// - Parameter source: A value to convert to this type.
    public init?<T>(exactly source: T) where T : BinaryInteger

    /// A type that can represent the absolute value of any possible value of the
    /// conforming type.
    associatedtype Magnitude : Comparable, Numeric

    /// The magnitude of this value.
    ///
    /// For any numeric value `x`, `x.magnitude` is the absolute value of `x`.
    /// You can use the `magnitude` property in operations that are simpler to
    /// implement in terms of unsigned values, such as printing the value of an
    /// integer, which is just printing a '-' character in front of an absolute
    /// value.
    ///
    ///     let x = -200
    ///     // x.magnitude == 200
    ///
    /// The global `abs(_:)` function provides more familiar syntax when you need
    /// to find an absolute value. In addition, because `abs(_:)` always returns
    /// a value of the same type, even in a generic context, using the function
    /// instead of the `magnitude` property is encouraged.
    public var magnitude: Self.Magnitude { get }

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Self, rhs: Self) -> Self

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Self, rhs: Self)

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Self, rhs: Self) -> Self

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Self, rhs: Self)

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Self, rhs: Self) -> Self

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Self, rhs: Self)
}

extension Numeric {

    /// Returns the given number unchanged.
    ///
    /// You can use the unary plus operator (`+`) to provide symmetry in your
    /// code for positive numbers when also using the unary minus operator.
    ///
    ///     let x = -21
    ///     let y = +21
    ///     // x == -21
    ///     // y == 21
    ///
    /// - Returns: The given argument without any changes.
    prefix public static func + (x: Self) -> Self
}

/// A unique identifier for a class instance or metatype.
///
/// In Swift, only class instances and metatypes have unique identities. There
/// is no notion of identity for structs, enums, functions, or tuples.
public struct ObjectIdentifier {

    /// Creates an instance that uniquely identifies the given class instance.
    ///
    /// The following example creates an example class `A` and compares instances
    /// of the class using their object identifiers and the identical-to
    /// operator (`===`):
    ///
    ///     class IntegerRef {
    ///         let value: Int
    ///         init(_ value: Int) {
    ///             self.value = value
    ///         }
    ///     }
    ///
    ///     let x = IntegerRef(10)
    ///     let y = x
    ///
    ///     print(ObjectIdentifier(x) == ObjectIdentifier(y))
    ///     // Prints "true"
    ///     print(x === y)
    ///     // Prints "true"
    ///
    ///     let z = IntegerRef(10)
    ///     print(ObjectIdentifier(x) == ObjectIdentifier(z))
    ///     // Prints "false"
    ///     print(x === z)
    ///     // Prints "false"
    ///
    /// - Parameter x: An instance of a class.
    public init(_ x: AnyObject)

    /// Creates an instance that uniquely identifies the given metatype.
    ///
    /// - Parameter: A metatype.
    public init(_ x: Any.Type)
}

extension ObjectIdentifier : CustomDebugStringConvertible {

    /// A textual representation of the identifier, suitable for debugging.
    public var debugDescription: String { get }
}

extension ObjectIdentifier : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (x: ObjectIdentifier, y: ObjectIdentifier) -> Bool
}

extension ObjectIdentifier : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: ObjectIdentifier, rhs: ObjectIdentifier) -> Bool
}

extension ObjectIdentifier : Hashable {

    /// The identifier's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program.  Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }
}

/// A wrapper around an opaque C pointer.
///
/// Opaque pointers are used to represent C pointers to types that
/// cannot be represented in Swift, such as incomplete struct types.
public struct OpaquePointer {

    /// Creates an `OpaquePointer` from a given address in memory.
    public init?(bitPattern: Int)

    /// Creates an `OpaquePointer` from a given address in memory.
    public init?(bitPattern: UInt)

    /// Converts a typed `UnsafePointer` to an opaque C pointer.
    public init<T>(_ from: UnsafePointer<T>)

    /// Converts a typed `UnsafePointer` to an opaque C pointer.
    ///
    /// The result is `nil` if `from` is `nil`.
    public init?<T>(_ from: UnsafePointer<T>?)

    /// Converts a typed `UnsafeMutablePointer` to an opaque C pointer.
    public init<T>(_ from: UnsafeMutablePointer<T>)

    /// Converts a typed `UnsafeMutablePointer` to an opaque C pointer.
    ///
    /// The result is `nil` if `from` is `nil`.
    public init?<T>(_ from: UnsafeMutablePointer<T>?)
}

extension OpaquePointer : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: OpaquePointer, rhs: OpaquePointer) -> Bool
}

extension OpaquePointer : Hashable {

    /// The pointer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program.  Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension OpaquePointer : CustomDebugStringConvertible {

    /// A textual representation of the pointer, suitable for debugging.
    public var debugDescription: String { get }
}

extension OpaquePointer {

    public init(_ from: UnsafeMutableRawPointer)

    public init?(_ from: UnsafeMutableRawPointer?)
}

extension OpaquePointer {

    public init(_ from: UnsafeRawPointer)

    public init?(_ from: UnsafeRawPointer?)
}

extension OpaquePointer : CVarArg {
}

/// A type that presents a mathematical set interface to a bit set.
///
/// You use the `OptionSet` protocol to represent bitset types, where
/// individual bits represent members of a set. Adopting this protocol in
/// your custom types lets you perform set-related operations such as
/// membership tests, unions, and intersections on those types. What's more,
/// when implemented using specific criteria, adoption of this protocol
/// requires no extra work on your part.
///
/// When creating an option set, include a `rawValue` property in your type
/// declaration. The `rawValue` property must be of a type that conforms to
/// the `FixedWidthInteger` protocol, such as `Int` or `UInt8`. Next, create
/// unique options as static properties of your custom type using unique
/// powers of two (1, 2, 4, 8, 16, and so forth) for each individual
/// property's raw value so that each property can be represented by a single
/// bit of the type's raw value.
///
/// For example, consider a custom type called `ShippingOptions` that is an
/// option set of the possible ways to ship a customer's purchase.
/// `ShippingOptions` includes a `rawValue` property of type `Int` that stores
/// the bit mask of available shipping options. The static members `nextDay`,
/// `secondDay`, `priority`, and `standard` are unique, individual options.
///
///     struct ShippingOptions: OptionSet {
///         let rawValue: Int
///
///         static let nextDay    = ShippingOptions(rawValue: 1 << 0)
///         static let secondDay  = ShippingOptions(rawValue: 1 << 1)
///         static let priority   = ShippingOptions(rawValue: 1 << 2)
///         static let standard   = ShippingOptions(rawValue: 1 << 3)
///
///         static let express: ShippingOptions = [.nextDay, .secondDay]
///         static let all: ShippingOptions = [.express, .priority, .standard]
///     }
///
/// Declare additional preconfigured option set values as static properties
/// initialized with an array literal containing other option values. In the
/// example, because the `express` static property is assigned an array
/// literal with the `nextDay` and `secondDay` options, it will contain those
/// two elements.
///
/// Using an Option Set Type
/// ========================
///
/// When you need to create an instance of an option set, assign one of the
/// type's static members to your variable or constant. Alternatively, to
/// create an option set instance with multiple members, assign an array
/// literal with multiple static members of the option set. To create an empty
/// instance, assign an empty array literal to your variable.
///
///     let singleOption: ShippingOptions = .priority
///     let multipleOptions: ShippingOptions = [.nextDay, .secondDay, .priority]
///     let noOptions: ShippingOptions = []
///
/// Use set-related operations to check for membership and to add or remove
/// members from an instance of your custom option set type. The following
/// example shows how you can determine free shipping options based on a
/// customer's purchase price:
///
///     let purchasePrice = 87.55
///
///     var freeOptions: ShippingOptions = []
///     if purchasePrice > 50 {
///         freeOptions.insert(.priority)
///     }
///
///     if freeOptions.contains(.priority) {
///         print("You've earned free priority shipping!")
///     } else {
///         print("Add more to your cart for free priority shipping!")
///     }
///     // Prints "You've earned free priority shipping!"
public protocol OptionSet : RawRepresentable, SetAlgebra {

    /// The element type of the option set.
    ///
    /// To inherit all the default implementations from the `OptionSet` protocol,
    /// the `Element` type must be `Self`, the default.
    associatedtype Element = Self

    /// Creates a new option set from the given raw value.
    ///
    /// This initializer always succeeds, even if the value passed as `rawValue`
    /// exceeds the static properties declared as part of the option set. This
    /// example creates an instance of `ShippingOptions` with a raw value beyond
    /// the highest element, with a bit mask that effectively contains all the
    /// declared static members.
    ///
    ///     let extraOptions = ShippingOptions(rawValue: 255)
    ///     print(extraOptions.isStrictSuperset(of: .all))
    ///     // Prints "true"
    ///
    /// - Parameter rawValue: The raw value of the option set to create. Each bit
    ///   of `rawValue` potentially represents an element of the option set,
    ///   though raw values may include bits that are not defined as distinct
    ///   values of the `OptionSet` type.
    public init(rawValue: Self.RawValue)
}

/// `OptionSet` requirements for which default implementations
/// are supplied.
///
/// - Note: A type conforming to `OptionSet` can implement any of
///  these initializers or methods, and those implementations will be
///  used in lieu of these defaults.
extension OptionSet {

    /// Returns a new option set of the elements contained in this set, in the
    /// given set, or in both.
    ///
    /// This example uses the `union(_:)` method to add two more shipping options
    /// to the default set.
    ///
    ///     let defaultShipping = ShippingOptions.standard
    ///     let memberShipping = defaultShipping.union([.secondDay, .priority])
    ///     print(memberShipping.contains(.priority))
    ///     // Prints "true"
    ///
    /// - Parameter other: An option set.
    /// - Returns: A new option set made up of the elements contained in this
    ///   set, in `other`, or in both.
    public func union(_ other: Self) -> Self

    /// Returns a new option set with only the elements contained in both this
    /// set and the given set.
    ///
    /// This example uses the `intersection(_:)` method to limit the available
    /// shipping options to what can be used with a PO Box destination.
    ///
    ///     // Can only ship standard or priority to PO Boxes
    ///     let poboxShipping: ShippingOptions = [.standard, .priority]
    ///     let memberShipping: ShippingOptions =
    ///             [.standard, .priority, .secondDay]
    ///
    ///     let availableOptions = memberShipping.intersection(poboxShipping)
    ///     print(availableOptions.contains(.priority))
    ///     // Prints "true"
    ///     print(availableOptions.contains(.secondDay))
    ///     // Prints "false"
    ///
    /// - Parameter other: An option set.
    /// - Returns: A new option set with only the elements contained in both this
    ///   set and `other`.
    public func intersection(_ other: Self) -> Self

    /// Returns a new option set with the elements contained in this set or in
    /// the given set, but not in both.
    ///
    /// - Parameter other: An option set.
    /// - Returns: A new option set with only the elements contained in either
    ///   this set or `other`, but not in both.
    public func symmetricDifference(_ other: Self) -> Self
}

/// `OptionSet` requirements for which default implementations are
/// supplied when `Element == Self`, which is the default.
///
/// - Note: A type conforming to `OptionSet` can implement any of
///   these initializers or methods, and those implementations will be
///   used in lieu of these defaults.
extension OptionSet where Self == Self.Element {

    /// Returns a Boolean value that indicates whether a given element is a
    /// member of the option set.
    ///
    /// This example uses the `contains(_:)` method to check whether next-day
    /// shipping is in the `availableOptions` instance.
    ///
    ///     let availableOptions = ShippingOptions.express
    ///     if availableOptions.contains(.nextDay) {
    ///         print("Next day shipping available")
    ///     }
    ///     // Prints "Next day shipping available"
    ///
    /// - Parameter member: The element to look for in the option set.
    /// - Returns: `true` if the option set contains `member`; otherwise,
    ///   `false`.
    public func contains(_ member: Self) -> Bool

    /// Adds the given element to the option set if it is not already a member.
    ///
    /// In the following example, the `.secondDay` shipping option is added to
    /// the `freeOptions` option set if `purchasePrice` is greater than 50.0. For
    /// the `ShippingOptions` declaration, see the `OptionSet` protocol
    /// discussion.
    ///
    ///     let purchasePrice = 87.55
    ///
    ///     var freeOptions: ShippingOptions = [.standard, .priority]
    ///     if purchasePrice > 50 {
    ///         freeOptions.insert(.secondDay)
    ///     }
    ///     print(freeOptions.contains(.secondDay))
    ///     // Prints "true"
    ///
    /// - Parameter newMember: The element to insert.
    /// - Returns: `(true, newMember)` if `newMember` was not contained in
    ///   `self`. Otherwise, returns `(false, oldMember)`, where `oldMember` is
    ///   the member of the set equal to `newMember`.
    public mutating func insert(_ newMember: Self.Element) -> (inserted: Bool, memberAfterInsert: Self.Element)

    /// Removes the given element and all elements subsumed by it.
    ///
    /// In the following example, the `.priority` shipping option is removed from
    /// the `options` option set. Attempting to remove the same shipping option
    /// a second time results in `nil`, because `options` no longer contains
    /// `.priority` as a member.
    ///
    ///     var options: ShippingOptions = [.secondDay, .priority]
    ///     let priorityOption = options.remove(.priority)
    ///     print(priorityOption == .priority)
    ///     // Prints "true"
    ///
    ///     print(options.remove(.priority))
    ///     // Prints "nil"
    ///
    /// In the next example, the `.express` element is passed to `remove(_:)`.
    /// Although `.express` is not a member of `options`, `.express` subsumes
    /// the remaining `.secondDay` element of the option set. Therefore,
    /// `options` is emptied and the intersection between `.express` and
    /// `options` is returned.
    ///
    ///     let expressOption = options.remove(.express)
    ///     print(expressOption == .express)
    ///     // Prints "false"
    ///     print(expressOption == .secondDay)
    ///     // Prints "true"
    ///
    /// - Parameter member: The element of the set to remove.
    /// - Returns: The intersection of `[member]` and the set, if the
    ///   intersection was nonempty; otherwise, `nil`.
    public mutating func remove(_ member: Self.Element) -> Self.Element?

    /// Inserts the given element into the set.
    ///
    /// If `newMember` is not contained in the set but subsumes current members
    /// of the set, the subsumed members are returned.
    ///
    ///     var options: ShippingOptions = [.secondDay, .priority]
    ///     let replaced = options.update(with: .express)
    ///     print(replaced == .secondDay)
    ///     // Prints "true"
    ///
    /// - Returns: The intersection of `[newMember]` and the set if the
    ///   intersection was nonempty; otherwise, `nil`.
    public mutating func update(with newMember: Self.Element) -> Self.Element?
}

/// `OptionSet` requirements for which default implementations are
/// supplied when `RawValue` conforms to `FixedWidthInteger`,
/// which is the usual case.  Each distinct bit of an option set's
/// `.rawValue` corresponds to a disjoint value of the `OptionSet`.
///
/// - `union` is implemented as a bitwise "or" (`|`) of `rawValue`s
/// - `intersection` is implemented as a bitwise "and" (`&`) of
///   `rawValue`s
/// - `symmetricDifference` is implemented as a bitwise "exclusive or"
///    (`^`) of `rawValue`s
///
/// - Note: A type conforming to `OptionSet` can implement any of
///   these initializers or methods, and those implementations will be
///   used in lieu of these defaults.
extension OptionSet where Self.RawValue : FixedWidthInteger {

    /// Creates an empty option set.
    ///
    /// This initializer creates an option set with a raw value of zero.
    public convenience init()

    /// Inserts the elements of another set into this option set.
    ///
    /// This method is implemented as a `|` (bitwise OR) operation on the
    /// two sets' raw values.
    ///
    /// - Parameter other: An option set.
    public mutating func formUnion(_ other: Self)

    /// Removes all elements of this option set that are not 
    /// also present in the given set.
    ///
    /// This method is implemented as a `&` (bitwise AND) operation on the
    /// two sets' raw values.
    ///
    /// - Parameter other: An option set.
    public mutating func formIntersection(_ other: Self)

    /// Replaces this set with a new set containing all elements 
    /// contained in either this set or the given set, but not in both.
    ///
    /// This method is implemented as a `^` (bitwise XOR) operation on the two
    /// sets' raw values.
    ///
    /// - Parameter other: An option set.
    public mutating func formSymmetricDifference(_ other: Self)
}

/// A type that represents either a wrapped value or `nil`, the absence of a
/// value.
///
/// You use the `Optional` type whenever you use optional values, even if you
/// never type the word `Optional`. Swift's type system usually shows the
/// wrapped type's name with a trailing question mark (`?`) instead of showing
/// the full type name. For example, if a variable has the type `Int?`, that's
/// just another way of writing `Optional<Int>`. The shortened form is
/// preferred for ease of reading and writing code.
///
/// The types of `shortForm` and `longForm` in the following code sample are
/// the same:
///
///     let shortForm: Int? = Int("42")
///     let longForm: Optional<Int> = Int("42")
///
/// The `Optional` type is an enumeration with two cases. `Optional.none` is
/// equivalent to the `nil` literal. `Optional.some(Wrapped)` stores a wrapped
/// value. For example:
///
///     let number: Int? = Optional.some(42)
///     let noNumber: Int? = Optional.none
///     print(noNumber == nil)
///     // Prints "true"
///
/// You must unwrap the value of an `Optional` instance before you can use it
/// in many contexts. Because Swift provides several ways to safely unwrap
/// optional values, you can choose the one that helps you write clear,
/// concise code.
///
/// The following examples use this dictionary of image names and file paths:
///
///     let imagePaths = ["star": "/glyphs/star.png",
///                       "portrait": "/images/content/portrait.jpg",
///                       "spacer": "/images/shared/spacer.gif"]
///
/// Getting a dictionary's value using a key returns an optional value, so
/// `imagePaths["star"]` has type `Optional<String>` or, written in the
/// preferred manner, `String?`.
///
/// Optional Binding
/// ----------------
///
/// To conditionally bind the wrapped value of an `Optional` instance to a new
/// variable, use one of the optional binding control structures, including
/// `if let`, `guard let`, and `switch`.
///
///     if let starPath = imagePaths["star"] {
///         print("The star image is at '\(starPath)'")
///     } else {
///         print("Couldn't find the star image")
///     }
///     // Prints "The star image is at '/glyphs/star.png'"
///
/// Optional Chaining
/// -----------------
///
/// To safely access the properties and methods of a wrapped instance, use the
/// postfix optional chaining operator (postfix `?`). The following example uses
/// optional chaining to access the `hasSuffix(_:)` method on a `String?`
/// instance.
///
///     if imagePaths["star"]?.hasSuffix(".png") == true {
///         print("The star image is in PNG format")
///     }
///     // Prints "The star image is in PNG format"
///
/// Using the Nil-Coalescing Operator
/// ---------------------------------
///
/// Use the nil-coalescing operator (`??`) to supply a default value in case
/// the `Optional` instance is `nil`. Here a default path is supplied for an
/// image that is missing from `imagePaths`.
///
///     let defaultImagePath = "/images/default.png"
///     let heartPath = imagePaths["heart"] ?? defaultImagePath
///     print(heartPath)
///     // Prints "/images/default.png"
///
/// The `??` operator also works with another `Optional` instance on the
/// right-hand side. As a result, you can chain multiple `??` operators
/// together.
///
///     let shapePath = imagePaths["cir"] ?? imagePaths["squ"] ?? defaultImagePath
///     print(shapePath)
///     // Prints "/images/default.png"
///
/// Unconditional Unwrapping
/// ------------------------
///
/// When you're certain that an instance of `Optional` contains a value, you
/// can unconditionally unwrap the value by using the forced
/// unwrap operator (postfix `!`). For example, the result of the failable `Int`
/// initializer is unconditionally unwrapped in the example below.
///
///     let number = Int("42")!
///     print(number)
///     // Prints "42"
///
/// You can also perform unconditional optional chaining by using the postfix
/// `!` operator.
///
///     let isPNG = imagePaths["star"]!.hasSuffix(".png")
///     print(isPNG)
///     // Prints "true"
///
/// Unconditionally unwrapping a `nil` instance with `!` triggers a runtime
/// error.
public enum Optional<Wrapped> : ExpressibleByNilLiteral {

    /// The absence of a value.
    ///
    /// In code, the absence of a value is typically written using the `nil`
    /// literal rather than the explicit `.none` enumeration case.
    case none

    /// The presence of a value, stored as `Wrapped`.
    case some(Wrapped)

    /// Creates an instance that stores the given value.
    public init(_ some: Wrapped)

    /// Evaluates the given closure when this `Optional` instance is not `nil`,
    /// passing the unwrapped value as a parameter.
    ///
    /// Use the `map` method with a closure that returns a nonoptional value.
    /// This example performs an arithmetic operation on an
    /// optional integer.
    ///
    ///     let possibleNumber: Int? = Int("42")
    ///     let possibleSquare = possibleNumber.map { $0 * $0 }
    ///     print(possibleSquare)
    ///     // Prints "Optional(1764)"
    ///
    ///     let noNumber: Int? = nil
    ///     let noSquare = noNumber.map { $0 * $0 }
    ///     print(noSquare)
    ///     // Prints "nil"
    ///
    /// - Parameter transform: A closure that takes the unwrapped value
    ///   of the instance.
    /// - Returns: The result of the given closure. If this instance is `nil`,
    ///   returns `nil`.
    public func map<U>(_ transform: (Wrapped) throws -> U) rethrows -> U?

    /// Evaluates the given closure when this `Optional` instance is not `nil`,
    /// passing the unwrapped value as a parameter.
    ///
    /// Use the `flatMap` method with a closure that returns an optional value.
    /// This example performs an arithmetic operation with an optional result on
    /// an optional integer.
    ///
    ///     let possibleNumber: Int? = Int("42")
    ///     let nonOverflowingSquare = possibleNumber.flatMap { x -> Int? in
    ///         let (result, overflowed) = x.multipliedReportingOverflow(by: x)
    ///         return overflowed ? nil : result
    ///     }
    ///     print(nonOverflowingSquare)
    ///     // Prints "Optional(1764)"
    ///
    /// - Parameter transform: A closure that takes the unwrapped value
    ///   of the instance.  
    /// - Returns: The result of the given closure. If this instance is `nil`,
    ///   returns `nil`.
    public func flatMap<U>(_ transform: (Wrapped) throws -> U?) rethrows -> U?

    /// Creates an instance initialized with `nil`.
    ///
    /// Do not call this initializer directly. It is used by the compiler when you
    /// initialize an `Optional` instance with a `nil` literal. For example:
    ///
    ///     var i: Index? = nil
    ///
    /// In this example, the assignment to the `i` variable calls this
    /// initializer behind the scenes.
    public init(nilLiteral: ())

    /// The wrapped value of this instance, unwrapped without checking whether
    /// the instance is `nil`.
    ///
    /// The `unsafelyUnwrapped` property provides the same value as the forced
    /// unwrap operator (postfix `!`). However, in optimized builds (`-O`), no
    /// check is performed to ensure that the current instance actually has a
    /// value. Accessing this property in the case of a `nil` value is a serious
    /// programming error and could lead to undefined behavior or a runtime
    /// error.
    ///
    /// In debug builds (`-Onone`), the `unsafelyUnwrapped` property has the same
    /// behavior as using the postfix `!` operator and triggers a runtime error
    /// if the instance is `nil`.
    ///
    /// The `unsafelyUnwrapped` property is recommended over calling the
    /// `unsafeBitCast(_:)` function because the property is more restrictive
    /// and because accessing the property still performs checking in debug
    /// builds.
    ///
    /// - Warning: This property trades safety for performance.  Use
    ///   `unsafelyUnwrapped` only when you are confident that this instance
    ///   will never be equal to `nil` and only after you've tried using the
    ///   postfix `!` operator.
    public var unsafelyUnwrapped: Wrapped { get }
}

extension Optional : Encodable where Wrapped : Encodable {

    /// Encodes this optional value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Optional : Decodable where Wrapped : Decodable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws
}

extension Optional : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    public var debugDescription: String { get }
}

extension Optional : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension Optional : Equatable where Wrapped : Equatable {

    /// Returns a Boolean value indicating whether two optional instances are
    /// equal.
    ///
    /// Use this equal-to operator (`==`) to compare any two optional instances of
    /// a type that conforms to the `Equatable` protocol. The comparison returns
    /// `true` if both arguments are `nil` or if the two arguments wrap values
    /// that are equal. Conversely, the comparison returns `false` if only one of
    /// the arguments is `nil` or if the two arguments wrap values that are not
    /// equal.
    ///
    ///     let group1 = [1, 2, 3, 4, 5]
    ///     let group2 = [1, 3, 5, 7, 9]
    ///     if group1.first == group2.first {
    ///         print("The two groups start the same.")
    ///     }
    ///     // Prints "The two groups start the same."
    ///
    /// You can also use this operator to compare a non-optional value to an
    /// optional that wraps the same type. The non-optional value is wrapped as an
    /// optional before the comparison is made. In the following example, the
    /// `numberToMatch` constant is wrapped as an optional before comparing to the
    /// optional `numberFromString`:
    ///
    ///     let numberToFind: Int = 23
    ///     let numberFromString: Int? = Int("23")      // Optional(23)
    ///     if numberToFind == numberFromString {
    ///         print("It's a match!")
    ///     }
    ///     // Prints "It's a match!"
    ///
    /// An instance that is expressed as a literal can also be used with this
    /// operator. In the next example, an integer literal is compared with the
    /// optional integer `numberFromString`. The literal `23` is inferred as an
    /// `Int` instance and then wrapped as an optional before the comparison is
    /// performed.
    ///
    ///     if 23 == numberFromString {
    ///         print("It's a match!")
    ///     }
    ///     // Prints "It's a match!"
    ///
    /// - Parameters:
    ///   - lhs: An optional value to compare.
    ///   - rhs: Another optional value to compare.
    public static func == (lhs: Wrapped?, rhs: Wrapped?) -> Bool

    /// Returns a Boolean value indicating whether two optional instances are not
    /// equal.
    ///
    /// Use this not-equal-to operator (`!=`) to compare any two optional instances
    /// of a type that conforms to the `Equatable` protocol. The comparison
    /// returns `true` if only one of the arguments is `nil` or if the two
    /// arguments wrap values that are not equal. The comparison returns `false`
    /// if both arguments are `nil` or if the two arguments wrap values that are
    /// equal.
    ///
    ///     let group1 = [2, 4, 6, 8, 10]
    ///     let group2 = [1, 3, 5, 7, 9]
    ///     if group1.first != group2.first {
    ///         print("The two groups start differently.")
    ///     }
    ///     // Prints "The two groups start differently."
    ///
    /// You can also use this operator to compare a non-optional value to an
    /// optional that wraps the same type. The non-optional value is wrapped as an
    /// optional before the comparison is made. In this example, the
    /// `numberToMatch` constant is wrapped as an optional before comparing to the
    /// optional `numberFromString`:
    ///
    ///     let numberToFind: Int = 23
    ///     let numberFromString: Int? = Int("not-a-number")      // nil
    ///     if numberToFind != numberFromString {
    ///         print("No match.")
    ///     }
    ///     // Prints "No match."
    ///
    /// - Parameters:
    ///   - lhs: An optional value to compare.
    ///   - rhs: Another optional value to compare.
    public static func != (lhs: Wrapped?, rhs: Wrapped?) -> Bool
}

extension Optional : Hashable where Wrapped : Hashable {

    /// The hash value for the optional instance.
    ///
    /// Two optionals that are equal will always have equal hash values.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Optional {

    /// Returns a Boolean value indicating whether an argument matches `nil`.
    ///
    /// You can use the pattern-matching operator (`~=`) to test whether an
    /// optional instance is `nil` even when the wrapped value's type does not
    /// conform to the `Equatable` protocol. The pattern-matching operator is used
    /// internally in `case` statements for pattern matching.
    ///
    /// The following example declares the `stream` variable as an optional
    /// instance of a hypothetical `DataStream` type, and then uses a `switch`
    /// statement to determine whether the stream is `nil` or has a configured
    /// value. When evaluating the `nil` case of the `switch` statement, this
    /// operator is called behind the scenes.
    ///
    ///     var stream: DataStream? = nil
    ///     switch stream {
    ///     case nil:
    ///         print("No data stream is configured.")
    ///     case let x?:
    ///         print("The data stream has \(x.availableBytes) bytes available.")
    ///     }
    ///     // Prints "No data stream is configured."
    ///
    /// - Note: To test whether an instance is `nil` in an `if` statement, use the
    ///   equal-to operator (`==`) instead of the pattern-matching operator. The
    ///   pattern-matching operator is primarily intended to enable `case`
    ///   statement pattern matching.
    ///
    /// - Parameters:
    ///   - lhs: A `nil` literal.
    ///   - rhs: A value to match against `nil`.
    public static func ~= (lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool

    /// Returns a Boolean value indicating whether the left-hand-side argument is
    /// `nil`.
    ///
    /// You can use this equal-to operator (`==`) to test whether an optional
    /// instance is `nil` even when the wrapped value's type does not conform to
    /// the `Equatable` protocol.
    ///
    /// The following example declares the `stream` variable as an optional
    /// instance of a hypothetical `DataStream` type. Although `DataStream` is not
    /// an `Equatable` type, this operator allows checking whether `stream` is
    /// `nil`.
    ///
    ///     var stream: DataStream? = nil
    ///     if stream == nil {
    ///         print("No data stream is configured.")
    ///     }
    ///     // Prints "No data stream is configured."
    ///
    /// - Parameters:
    ///   - lhs: A value to compare to `nil`.
    ///   - rhs: A `nil` literal.
    public static func == (lhs: Wrapped?, rhs: _OptionalNilComparisonType) -> Bool

    /// Returns a Boolean value indicating whether the left-hand-side argument is
    /// not `nil`.
    ///
    /// You can use this not-equal-to operator (`!=`) to test whether an optional
    /// instance is not `nil` even when the wrapped value's type does not conform
    /// to the `Equatable` protocol.
    ///
    /// The following example declares the `stream` variable as an optional
    /// instance of a hypothetical `DataStream` type. Although `DataStream` is not
    /// an `Equatable` type, this operator allows checking whether `stream` wraps
    /// a value and is therefore not `nil`.
    ///
    ///     var stream: DataStream? = fetchDataStream()
    ///     if stream != nil {
    ///         print("The data stream has been configured.")
    ///     }
    ///     // Prints "The data stream has been configured."
    ///
    /// - Parameters:
    ///   - lhs: A value to compare to `nil`.
    ///   - rhs: A `nil` literal.
    public static func != (lhs: Wrapped?, rhs: _OptionalNilComparisonType) -> Bool

    /// Returns a Boolean value indicating whether the right-hand-side argument is
    /// `nil`.
    ///
    /// You can use this equal-to operator (`==`) to test whether an optional
    /// instance is `nil` even when the wrapped value's type does not conform to
    /// the `Equatable` protocol.
    ///
    /// The following example declares the `stream` variable as an optional
    /// instance of a hypothetical `DataStream` type. Although `DataStream` is not
    /// an `Equatable` type, this operator allows checking whether `stream` is
    /// `nil`.
    ///
    ///     var stream: DataStream? = nil
    ///     if nil == stream {
    ///         print("No data stream is configured.")
    ///     }
    ///     // Prints "No data stream is configured."
    ///
    /// - Parameters:
    ///   - lhs: A `nil` literal.
    ///   - rhs: A value to compare to `nil`.
    public static func == (lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool

    /// Returns a Boolean value indicating whether the right-hand-side argument is
    /// not `nil`.
    ///
    /// You can use this not-equal-to operator (`!=`) to test whether an optional
    /// instance is not `nil` even when the wrapped value's type does not conform
    /// to the `Equatable` protocol.
    ///
    /// The following example declares the `stream` variable as an optional
    /// instance of a hypothetical `DataStream` type. Although `DataStream` is not
    /// an `Equatable` type, this operator allows checking whether `stream` wraps
    /// a value and is therefore not `nil`.
    ///
    ///     var stream: DataStream? = fetchDataStream()
    ///     if nil != stream {
    ///         print("The data stream has been configured.")
    ///     }
    ///     // Prints "The data stream has been configured."
    ///
    /// - Parameters:
    ///   - lhs: A `nil` literal.
    ///   - rhs: A value to compare to `nil`.
    public static func != (lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool
}

extension Optional {
}

/// A partially type-erased key path, from a concrete root type to any
/// resulting value type.
public class PartialKeyPath<Root> : AnyKeyPath {
}

/// A partial interval extending upward from a lower bound.
///
/// You create `PartialRangeFrom` instances by using the postfix range operator
/// (postfix `...`).
///
///     let atLeastFive = 5...
///
/// You can use a partial range to quickly check if a value is contained in a
/// particular range of values. For example:
///
///     atLeastFive.contains(4)
///     // false
///     atLeastFive.contains(5)
///     // true
///     atLeastFive.contains(6)
///     // true
///
/// You can use a partial range of a collection's indices to represent the
/// range from the partial range's lower bound up to the end of the
/// collection.
///
///     let numbers = [10, 20, 30, 40, 50, 60, 70]
///     print(numbers[3...])
///     // Prints "[40, 50, 60, 70]"
///
/// Using a Partial Range as a Sequence
/// -----------------------------------
///
/// When a partial range uses integers as its lower and upper bounds, or any
/// other type that conforms to the `Strideable` protocol with an integer
/// stride, you can use that range in a `for`-`in` loop or with any sequence
/// method that doesn't require that the sequence is finite. The elements of
/// a partial range are the consecutive values from its lower bound continuing
/// upward indefinitely.
///
///     func isTheMagicNumber(_ x: Int) -> Bool {
///         return x == 3
///     }
///
///     for x in 1... {
///         if isTheMagicNumber(x) {
///             print("\(x) is the magic number!")
///             break
///         } else {
///             print("\(x) wasn't it...")
///         }
///     }
///     // "1 wasn't it..."
///     // "2 wasn't it..."
///     // "3 is the magic number!"
///
/// Because a `PartialRangeFrom` sequence counts upward indefinitely, do not
/// use one with methods that read the entire sequence before returning, such
/// as `map(_:)`, `filter(_:)`, or `suffix(_:)`. It is safe to use operations
/// that put an upper limit on the number of elements they access, such as
/// `prefix(_:)` or `dropFirst(_:)`, and operations that you can guarantee
/// will terminate, such as passing a closure you know will eventually return
/// `true` to `first(where:)`.
///
/// In the following example, the `asciiTable` sequence is made by zipping
/// together the characters in the `alphabet` string with a partial range
/// starting at 65, the ASCII value of the capital letter A. Iterating over
/// two zipped sequences continues only as long as the shorter of the two
/// sequences, so the iteration stops at the end of `alphabet`.
///
///     let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
///     let asciiTable = zip(65..., alphabet)
///     for (code, letter) in asciiTable {
///         print(code, letter)
///     }
///     // "65 A"
///     // "66 B"
///     // "67 C"
///     // ...
///     // "89 Y"
///     // "90 Z"
///
/// The behavior of incrementing indefinitely is determined by the type of
/// `Bound`. For example, iterating over an instance of
/// `PartialRangeFrom<Int>` traps when the sequence's next value would be
/// above `Int.max`.
public struct PartialRangeFrom<Bound> where Bound : Comparable {

    public let lowerBound: Bound

    public init(_ lowerBound: PartialRangeFrom<Bound>.Bound)
}

extension PartialRangeFrom : RangeExpression where Bound : Comparable {

    /// Returns the range of indices described by this range expression within
    /// the given collection.
    ///
    /// You can use the `relative(to:)` method to convert a range expression,
    /// which could be missing one or both of its endpoints, into a concrete
    /// range that is bounded on both sides. The following example uses this
    /// method to convert a partial range up to `4` into a half-open range,
    /// using an array instance to add the range's lower bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     let upToFour = ..<4
    ///
    ///     let r1 = upToFour.relative(to: numbers)
    ///     // r1 == 0..<4
    ///
    /// The `r1` range is bounded on the lower end by `0` because that is the
    /// starting index of the `numbers` array. When the collection passed to
    /// `relative(to:)` starts with a different index, that index is used as the
    /// lower bound instead. The next example creates a slice of `numbers`
    /// starting at index `2`, and then uses the slice with `relative(to:)` to
    /// convert `upToFour` to a concrete range.
    ///
    ///     let numbersSuffix = numbers[2...]
    ///     // numbersSuffix == [30, 40, 50, 60, 70]
    ///
    ///     let r2 = upToFour.relative(to: numbersSuffix)
    ///     // r2 == 2..<4
    ///
    /// Use this method only if you need the concrete range it produces. To
    /// access a slice of a collection using a range expression, use the
    /// collection's generic subscript that uses a range expression as its
    /// parameter.
    ///
    ///     let numbersPrefix = numbers[upToFour]
    ///     // numbersPrefix == [10, 20, 30, 40]
    ///
    /// - Parameter collection: The collection to evaluate this range expression
    ///   in relation to.
    /// - Returns: A range suitable for slicing `collection`. The returned range
    ///   is *not* guaranteed to be inside the bounds of `collection`. Callers
    ///   should apply the same preconditions to the return value as they would
    ///   to a range provided directly by the user.
    public func relative<C>(to collection: C) -> Range<Bound> where Bound == C.Index, C : Collection

    /// Returns a Boolean value indicating whether the given element is contained
    /// within the range expression.
    ///
    /// - Parameter element: The element to check for containment.
    /// - Returns: `true` if `element` is contained in the range expression;
    ///   otherwise, `false`.
    public func contains(_ element: Bound) -> Bool
}

extension PartialRangeFrom : Sequence where Bound : Strideable, Bound.Stride : SignedInteger {

    /// A type representing the sequence's elements.
    public typealias Element = Bound

    /// The iterator for a `PartialRangeFrom` instance.
    public struct Iterator : IteratorProtocol {

        /// Advances to the next element and returns it, or `nil` if no next
        /// element exists.
        ///
        /// Once `nil` has been returned, all subsequent calls return `nil`.
        ///
        /// - Returns: The next element in the underlying sequence, if a next
        ///   element exists; otherwise, `nil`.
        public mutating func next() -> PartialRangeFrom<Bound>.Bound?
    }

    /// Returns an iterator for this sequence.
    public func makeIterator() -> PartialRangeFrom<Bound>.Iterator
}

/// A partial interval up to, and including, an upper bound.
///
/// You create `PartialRangeThrough` instances by using the prefix closed range
/// operator (prefix `...`).
///
///     let throughFive = ...5.0
///
/// You can use a `PartialRangeThrough` instance to quickly check if a value is
/// contained in a particular range of values. For example:
///
///     throughFive.contains(4.0)     // true
///     throughFive.contains(5.0)     // true
///     throughFive.contains(6.0)     // false
///
/// You can use a `PartialRangeThrough` instance of a collection's indices to
/// represent the range from the start of the collection up to, and including,
/// the partial range's upper bound.
///
///     let numbers = [10, 20, 30, 40, 50, 60, 70]
///     print(numbers[...3])
///     // Prints "[10, 20, 30, 40]"
public struct PartialRangeThrough<Bound> where Bound : Comparable {

    public let upperBound: Bound

    public init(_ upperBound: Bound)
}

extension PartialRangeThrough : RangeExpression where Bound : Comparable {

    /// Returns the range of indices described by this range expression within
    /// the given collection.
    ///
    /// You can use the `relative(to:)` method to convert a range expression,
    /// which could be missing one or both of its endpoints, into a concrete
    /// range that is bounded on both sides. The following example uses this
    /// method to convert a partial range up to `4` into a half-open range,
    /// using an array instance to add the range's lower bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     let upToFour = ..<4
    ///
    ///     let r1 = upToFour.relative(to: numbers)
    ///     // r1 == 0..<4
    ///
    /// The `r1` range is bounded on the lower end by `0` because that is the
    /// starting index of the `numbers` array. When the collection passed to
    /// `relative(to:)` starts with a different index, that index is used as the
    /// lower bound instead. The next example creates a slice of `numbers`
    /// starting at index `2`, and then uses the slice with `relative(to:)` to
    /// convert `upToFour` to a concrete range.
    ///
    ///     let numbersSuffix = numbers[2...]
    ///     // numbersSuffix == [30, 40, 50, 60, 70]
    ///
    ///     let r2 = upToFour.relative(to: numbersSuffix)
    ///     // r2 == 2..<4
    ///
    /// Use this method only if you need the concrete range it produces. To
    /// access a slice of a collection using a range expression, use the
    /// collection's generic subscript that uses a range expression as its
    /// parameter.
    ///
    ///     let numbersPrefix = numbers[upToFour]
    ///     // numbersPrefix == [10, 20, 30, 40]
    ///
    /// - Parameter collection: The collection to evaluate this range expression
    ///   in relation to.
    /// - Returns: A range suitable for slicing `collection`. The returned range
    ///   is *not* guaranteed to be inside the bounds of `collection`. Callers
    ///   should apply the same preconditions to the return value as they would
    ///   to a range provided directly by the user.
    public func relative<C>(to collection: C) -> Range<Bound> where Bound == C.Index, C : Collection

    /// Returns a Boolean value indicating whether the given element is contained
    /// within the range expression.
    ///
    /// - Parameter element: The element to check for containment.
    /// - Returns: `true` if `element` is contained in the range expression;
    ///   otherwise, `false`.
    public func contains(_ element: Bound) -> Bool
}

/// A partial half-open interval up to, but not including, an upper bound.
///
/// You create `PartialRangeUpTo` instances by using the prefix half-open range
/// operator (prefix `..<`).
///
///     let upToFive = ..<5.0
///
/// You can use a `PartialRangeUpTo` instance to quickly check if a value is
/// contained in a particular range of values. For example:
///
///     upToFive.contains(3.14)       // true
///     upToFive.contains(6.28)       // false
///     upToFive.contains(5.0)        // false
///
/// You can use a `PartialRangeUpTo` instance of a collection's indices to
/// represent the range from the start of the collection up to, but not
/// including, the partial range's upper bound.
///
///     let numbers = [10, 20, 30, 40, 50, 60, 70]
///     print(numbers[..<3])
///     // Prints "[10, 20, 30]"
public struct PartialRangeUpTo<Bound> where Bound : Comparable {

    public let upperBound: Bound

    public init(_ upperBound: PartialRangeUpTo<Bound>.Bound)
}

extension PartialRangeUpTo : RangeExpression where Bound : Comparable {

    /// Returns the range of indices described by this range expression within
    /// the given collection.
    ///
    /// You can use the `relative(to:)` method to convert a range expression,
    /// which could be missing one or both of its endpoints, into a concrete
    /// range that is bounded on both sides. The following example uses this
    /// method to convert a partial range up to `4` into a half-open range,
    /// using an array instance to add the range's lower bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     let upToFour = ..<4
    ///
    ///     let r1 = upToFour.relative(to: numbers)
    ///     // r1 == 0..<4
    ///
    /// The `r1` range is bounded on the lower end by `0` because that is the
    /// starting index of the `numbers` array. When the collection passed to
    /// `relative(to:)` starts with a different index, that index is used as the
    /// lower bound instead. The next example creates a slice of `numbers`
    /// starting at index `2`, and then uses the slice with `relative(to:)` to
    /// convert `upToFour` to a concrete range.
    ///
    ///     let numbersSuffix = numbers[2...]
    ///     // numbersSuffix == [30, 40, 50, 60, 70]
    ///
    ///     let r2 = upToFour.relative(to: numbersSuffix)
    ///     // r2 == 2..<4
    ///
    /// Use this method only if you need the concrete range it produces. To
    /// access a slice of a collection using a range expression, use the
    /// collection's generic subscript that uses a range expression as its
    /// parameter.
    ///
    ///     let numbersPrefix = numbers[upToFour]
    ///     // numbersPrefix == [10, 20, 30, 40]
    ///
    /// - Parameter collection: The collection to evaluate this range expression
    ///   in relation to.
    /// - Returns: A range suitable for slicing `collection`. The returned range
    ///   is *not* guaranteed to be inside the bounds of `collection`. Callers
    ///   should apply the same preconditions to the return value as they would
    ///   to a range provided directly by the user.
    public func relative<C>(to collection: C) -> Range<Bound> where Bound == C.Index, C : Collection

    /// Returns a Boolean value indicating whether the given element is contained
    /// within the range expression.
    ///
    /// - Parameter element: The element to check for containment.
    /// - Returns: `true` if `element` is contained in the range expression;
    ///   otherwise, `false`.
    public func contains(_ element: Bound) -> Bool
}

/// The sum of types that can be used as a Quick Look representation.
///
/// The `PlaygroundQuickLook` protocol is deprecated, and will be removed from
/// the standard library in a future Swift release. To customize the logging of
/// your type in a playground, conform to the
/// `CustomPlaygroundDisplayConvertible` protocol, which does not use the
/// `PlaygroundQuickLook` enum.
///
/// If you need to provide a customized playground representation in Swift 4.0
/// or Swift 3.2 or earlier, use a conditional compilation block:
///
///     #if swift(>=4.1) || (swift(>=3.3) && !swift(>=4.0))
///         // With Swift 4.1 and later (including Swift 3.3 and later), use
///         // the CustomPlaygroundDisplayConvertible protocol.
///     #else
///         // With Swift 4.0 and Swift 3.2 and earlier, use PlaygroundQuickLook
///         // and the CustomPlaygroundQuickLookable protocol.
///     #endif
@available(*, deprecated, message: "PlaygroundQuickLook will be removed in a future Swift version. For customizing how types are presented in playgrounds, use CustomPlaygroundDisplayConvertible instead.")
public enum PlaygroundQuickLook {

    /// Plain text.
    case text(String)

    /// An integer numeric value.
    case int(Int64)

    /// An unsigned integer numeric value.
    case uInt(UInt64)

    /// A single precision floating-point numeric value.
    case float(Float32)

    /// A double precision floating-point numeric value.
    case double(Float64)

    /// An image.
    case image(Any)

    /// A sound.
    case sound(Any)

    /// A color.
    case color(Any)

    /// A bezier path.
    case bezierPath(Any)

    /// An attributed string.
    case attributedString(Any)

    /// A rectangle.
    case rectangle(Float64, Float64, Float64, Float64)

    /// A point.
    case point(Float64, Float64)

    /// A size.
    case size(Float64, Float64)

    /// A boolean value.
    case bool(Bool)

    /// A range.
    case range(Int64, Int64)

    /// A GUI view.
    case view(Any)

    /// A graphical sprite.
    case sprite(Any)

    /// A Uniform Resource Locator.
    case url(String)

    /// Raw data that has already been encoded in a format the IDE understands.
    case _raw([UInt8], String)
}

extension PlaygroundQuickLook {

    /// Creates a new Quick Look for the given instance.
    ///
    /// If the dynamic type of `subject` conforms to
    /// `CustomPlaygroundQuickLookable`, the result is found by calling its
    /// `customPlaygroundQuickLook` property. Otherwise, the result is
    /// synthesized by the language. In some cases, the synthesized result may
    /// be `.text(String(reflecting: subject))`.
    ///
    /// - Note: If the dynamic type of `subject` has value semantics, subsequent
    ///   mutations of `subject` will not observable in the Quick Look. In
    ///   general, though, the observability of such mutations is unspecified.
    ///
    /// - Parameter subject: The instance to represent with the resulting Quick
    ///   Look.
    @available(*, deprecated, message: "PlaygroundQuickLook will be removed in a future Swift version.")
    public init(reflecting subject: Any)
}

/// The default source of random data.
///
/// When you generate random values, shuffle a collection, or perform another
/// operation that depends on random data, this type's `default` property is
/// the generator used by default. For example, the two method calls in this
/// example are equivalent:
///
///     let x = Int.random(in: 1...100)
///     let y = Int.random(in: 1...100, using: &Random.default)
///
/// `Random.default` is automatically seeded, is safe to use in multiple
/// threads, and uses a cryptographically secure algorithm whenever possible.
///
/// Platform Implementation of `Random`
/// ===================================
///
/// While the `Random.default` generator is automatically seeded and
/// thread-safe on every platform, the cryptographic quality of the stream of
/// random data produced by the generator may vary. For more detail, see the
/// documentation for the APIs used by each platform.
///
/// - Apple platforms use `arc4random_buf(3)`.
/// - Linux platforms use `getrandom(2)` when available; otherwise, they read
///   from `/dev/urandom`.
public struct Random : RandomNumberGenerator {

    /// The default instance of the `Random` random number generator.
    public static var `default`: Random

    /// Returns a value from a uniform, independent distribution of binary data.
    ///
    /// - Returns: An unsigned 64-bit random value.
    public mutating func next() -> UInt64
}

/// A collection that supports efficient random-access index traversal.
///
/// Random-access collections can move indices any distance and 
/// measure the distance between indices in O(1) time. Therefore, the
/// fundamental difference between random-access and bidirectional collections
/// is that operations that depend on index movement or distance measurement
/// offer significantly improved efficiency. For example, a random-access
/// collection's `count` property is calculated in O(1) instead of requiring
/// iteration of an entire collection.
///
/// Conforming to the RandomAccessCollection Protocol
/// =================================================
///
/// The `RandomAccessCollection` protocol adds further constraints on the
/// associated `Indices` and `SubSequence` types, but otherwise imposes no
/// additional requirements over the `BidirectionalCollection` protocol.
/// However, in order to meet the complexity guarantees of a random-access
/// collection, either the index for your custom type must conform to the
/// `Strideable` protocol or you must implement the `index(_:offsetBy:)` and
/// `distance(from:to:)` methods with O(1) efficiency.
public protocol RandomAccessCollection : BidirectionalCollection where Self.Indices : RandomAccessCollection, Self.SubSequence : RandomAccessCollection {

    associatedtype Element

    associatedtype Index

    associatedtype SubSequence

    associatedtype Indices

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Self.Indices { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Self.Index>) -> Self.SubSequence { get }

    public subscript(position: Self.Index) -> Self.Element { get }

    public var startIndex: Self.Index { get }

    public var endIndex: Self.Index { get }
}

/// Default implementation for random access collections.
extension RandomAccessCollection {

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position. The
    /// operation doesn't require going beyond the limiting `numbers.endIndex`
    /// value, so it succeeds.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// The next example attempts to retrieve an index ten positions from
    /// `numbers.startIndex`, but fails, because that distance is beyond the
    /// index passed as `limit`.
    ///
    ///     let j = numbers.index(numbers.startIndex,
    ///                           offsetBy: 10,
    ///                           limitedBy: numbers.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the array.
    ///   - n: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     `limit` should be greater than `i` to have any effect. Likewise, if
    ///     `n < 0`, `limit` should be less than `i` to have any effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1)
    public func index(_ i: Self.Index, offsetBy n: Int, limitedBy limit: Self.Index) -> Self.Index?
}

extension RandomAccessCollection where Self.Index : Strideable, Self.Indices == Range<Self.Index>, Self.Index.Stride == Int {

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    public var indices: Range<Self.Index> { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Self.Index) -> Self.Index

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Self.Index) -> Self.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from an
    /// array's starting index and then prints the element at that position.
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     let i = numbers.index(numbers.startIndex, offsetBy: 4)
    ///     print(numbers[i])
    ///     // Prints "50"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1)
    public func index(_ i: Self.Index, offsetBy n: Self.Index.Stride) -> Self.Index

    /// Returns the distance between two indices.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`.
    ///
    /// - Complexity: O(1)
    public func distance(from start: Self.Index, to end: Self.Index) -> Self.Index.Stride
}

/// A collection that supports efficient random-access index traversal.
///
/// In most cases, it's best to ignore this protocol and use the
/// `RandomAccessCollection` protocol instead, because it has a more complete
/// interface.
@available(*, deprecated, message: "it will be removed in Swift 4.0.  Please use 'RandomAccessCollection' instead")
public typealias RandomAccessIndexable = RandomAccessCollection

@available(*, deprecated, renamed: "Slice")
public typealias RandomAccessSlice<T> = Slice<T>

/// A type that provides uniformly distributed random data.
///
/// When you call methods that use random data, such as creating new random
/// values or shuffling a collection, you can pass a `RandomNumberGenerator`
/// type to be used as the source for randomness. When you don't pass a
/// generator, the default `Random` type is used.
///
/// When providing new APIs that use randomness, provide a version that accepts
/// a generator conforming to the `RandomNumberGenerator` protocol as well as a
/// version that uses the default generator. For example, this `Weekday`
/// enumeration provides static methods that return a random day of the week:
///
///     enum Weekday: CaseIterable {
///         case sunday, monday, tuesday, wednesday, thursday, friday, saturday
///
///         static func random<G: RandomNumberGenerator>(using generator: inout G) -> Weekday {
///             return Weekday.allCases.randomElement(using: &generator)!
///         }
///
///         static func random() -> Weekday {
///             return Weekday.randomWeekday(using: &Random.default)
///         }
///     }
///
/// Conforming to the RandomNumberGenerator Protocol
/// ================================================
///
/// A custom `RandomNumberGenerator` type can have different characteristics
/// than the default `Random` type. For example, a seedable generator can be
/// used to generate the same sequence of random values for testing purposes.
///
/// To make a custom type conform to the `RandomNumberGenerator` protocol,
/// implement the required `next()` method. Each call to `next()` must produce
/// a uniform and independent random value.
///
/// Types that conform to `RandomNumberGenerator` should specifically document
/// the thread safety and quality of the generator.
public protocol RandomNumberGenerator {

    /// Returns a value from a uniform, independent distribution of binary data.
    ///
    /// - Returns: An unsigned 64-bit random value.
    public mutating func next() -> UInt64
}

extension RandomNumberGenerator {

    /// Returns a value from a uniform, independent distribution of binary data.
    ///
    /// - Returns: A random value of `T`. Bits are randomly distributed so that
    ///   every value of `T` is equally likely to be returned.
    public mutating func next<T>() -> T where T : FixedWidthInteger, T : UnsignedInteger

    /// Returns a random value that is less than the given upper bound.
    ///
    /// - Parameter upperBound: The upper bound for the randomly generated value.
    /// - Returns: A random value of `T` in the range `0..<upperBound`. Every
    ///   value in the range `0..<upperBound` is equally likely to be returned.
    public mutating func next<T>(upperBound: T) -> T where T : FixedWidthInteger, T : UnsignedInteger
}

/// A half-open interval from a lower bound up to, but not including, an upper
/// bound.
///
/// You create a `Range` instance by using the half-open range operator
/// (`..<`).
///
///     let underFive = 0.0..<5.0
///
/// You can use a `Range` instance to quickly check if a value is contained in
/// a particular range of values. For example:
///
///     underFive.contains(3.14)
///     // true
///     underFive.contains(6.28)
///     // false
///     underFive.contains(5.0)
///     // false
///
/// `Range` instances can represent an empty interval, unlike `ClosedRange`.
///
///     let empty = 0.0..<0.0
///     empty.contains(0.0)
///     // false
///     empty.isEmpty
///     // true
///
/// Using a Range as a Collection of Consecutive Values
/// ----------------------------------------------------
///
/// When a range uses integers as its lower and upper bounds, or any other type
/// that conforms to the `Strideable` protocol with an integer stride, you can
/// use that range in a `for`-`in` loop or with any sequence or collection
/// method. The elements of the range are the consecutive values from its
/// lower bound up to, but not including, its upper bound.
///
///     for n in 3..<5 {
///         print(n)
///     }
///     // Prints "3"
///     // Prints "4"
///
/// Because floating-point types such as `Float` and `Double` are their own
/// `Stride` types, they cannot be used as the bounds of a countable range. If
/// you need to iterate over consecutive floating-point values, see the
/// `stride(from:to:by:)` function.
public struct Range<Bound> where Bound : Comparable {

    /// The range's lower bound.
    ///
    /// In an empty range, `lowerBound` is equal to `upperBound`.
    public let lowerBound: Bound

    /// The range's upper bound.
    ///
    /// In an empty range, `upperBound` is equal to `lowerBound`. A `Range`
    /// instance does not contain its upper bound.
    public let upperBound: Bound

    /// Creates an instance with the given bounds.
    ///
    /// Because this initializer does not perform any checks, it should be used
    /// as an optimization only when you are absolutely certain that `lower` is
    /// less than or equal to `upper`. Using the half-open range operator
    /// (`..<`) to form `Range` instances is preferred.
    ///
    /// - Parameter bounds: A tuple of the lower and upper bounds of the range.
    public init(uncheckedBounds bounds: (lower: Range<Bound>.Bound, upper: Range<Bound>.Bound))

    /// Returns a Boolean value indicating whether the given element is contained
    /// within the range.
    ///
    /// Because `Range` represents a half-open range, a `Range` instance does not
    /// contain its upper bound. `element` is contained in the range if it is
    /// greater than or equal to the lower bound and less than the upper bound.
    ///
    /// - Parameter element: The element to check for containment.
    /// - Returns: `true` if `element` is contained in the range; otherwise,
    ///   `false`.
    public func contains(_ element: Bound) -> Bool

    /// A Boolean value indicating whether the range contains no elements.
    ///
    /// An empty `Range` instance has equal lower and upper bounds.
    ///
    ///     let empty: Range = 10..<10
    ///     print(empty.isEmpty)
    ///     // Prints "true"
    public var isEmpty: Bool { get }
}

extension Range where Bound : FixedWidthInteger, Bound.Magnitude : UnsignedInteger, Bound.Stride : SignedInteger {

    /// Returns a random element of the range, using the given generator as
    /// a source for randomness.
    ///
    /// You can use this method to select a random element of a range when you
    /// are using a custom random number generator. If you're generating a random
    /// number, in most cases, you should prefer using the `random(in:using:)`
    /// static method of the desired numeric type. That static method is available
    /// for both integer and floating point types, and returns a non-optional
    /// value.
    ///
    /// - Parameter generator: The random number generator to use when choosing
    ///   a random element.
    /// - Returns: A random element of the range.
    ///   If the range is empty, the method returns `nil`.
    public func randomElement<T>(using generator: inout T) -> Range<Bound>.Element? where T : RandomNumberGenerator

    /// Returns a random element of the range, using the given generator as
    /// a source for randomness.
    ///
    /// You can use this method to select a random element of a range when you
    /// are using a custom random number generator. If you're generating a random
    /// number, in most cases, you should prefer using the `random(in:)`
    /// static method of the desired numeric type. That static method is available
    /// for both integer and floating point types, and returns a non-optional
    /// value.
    ///
    /// This method uses the default random generator, `Random.default`. Calling
    /// `(1..<100).randomElement()` is equivalent to calling
    /// `(1..<100).randomElement(using: &Random.default)`.
    ///
    /// - Returns: A random element of the range.
    ///   If the range is empty, the method returns `nil`.
    public func randomElement() -> Range<Bound>.Element?
}

extension Range : Sequence where Bound : Strideable, Bound.Stride : SignedInteger {

    /// A type representing the sequence's elements.
    public typealias Element = Bound

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = IndexingIterator<Range<Bound>>
}

extension Range : Collection, BidirectionalCollection, RandomAccessCollection where Bound : Strideable, Bound.Stride : SignedInteger {

    /// A type that represents a position in the range.
    public typealias Index = Bound

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Bound>

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = Range<Bound>

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Bound { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Bound { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Range<Bound>.Index) -> Range<Bound>.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Range<Bound>.Index) -> Range<Bound>.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Range<Bound>.Index, offsetBy n: Int) -> Range<Bound>.Index

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Range<Bound>.Index, to end: Range<Bound>.Index) -> Int

    /// Accesses the subsequence bounded by the given range.
    ///
    /// - Parameter bounds: A range of the range's indices. The upper and lower
    ///   bounds of the `bounds` range must be valid indices of the collection.
    public subscript(bounds: Range<Range<Bound>.Index>) -> Range<Range<Bound>.Bound> { get }

    /// The indices that are valid for subscripting the range, in ascending
    /// order.
    public var indices: Range<Bound> { get }

    /// Accesses the element at specified position.
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the range, and must not equal the range's end
    ///   index.
    public subscript(position: Range<Bound>.Index) -> Range<Bound>.Element { get }
}

extension Range where Bound : Strideable, Bound.Stride : SignedInteger {

    /// Now that Range is conditionally a collection when Bound: Strideable,
    /// CountableRange is no longer needed. This is a deprecated initializer
    /// for any remaining uses of Range(countableRange).
    @available(swift, deprecated: 4.2, message: "CountableRange is now Range. No need to convert any more.")
    public init(_ other: Range<Range<Bound>.Bound>)

    /// Creates an instance equivalent to the given `ClosedRange`.
    ///
    /// - Parameter other: A closed range to convert to a `Range` instance.
    ///
    /// An equivalent range must be representable as an instance of Range<Bound>.
    /// For example, passing a closed range with an upper bound of `Int.max`
    /// triggers a runtime error, because the resulting half-open range would
    /// require an upper bound of `Int.max + 1`, which is not representable as
    public init(_ other: ClosedRange<Range<Bound>.Bound>)
}

extension Range : RangeExpression where Bound : Comparable {

    /// Returns the range of indices described by this range expression within
    /// the given collection.
    ///
    /// - Parameter collection: The collection to evaluate this range expression
    ///   in relation to.
    /// - Returns: A range suitable for slicing `collection`. The returned range
    ///   is *not* guaranteed to be inside the bounds of `collection`. Callers
    ///   should apply the same preconditions to the return value as they would
    ///   to a range provided directly by the user.
    public func relative<C>(to collection: C) -> Range<Bound> where Bound == C.Index, C : Collection
}

extension Range where Bound : Comparable {

    /// Returns a copy of this range clamped to the given limiting range.
    ///
    /// The bounds of the result are always limited to the bounds of `limits`.
    /// For example:
    ///
    ///     let x: Range = 0..<20
    ///     print(x.clamped(to: 10..<1000))
    ///     // Prints "10..<20"
    ///
    /// If the two ranges do not overlap, the result is an empty range within the
    /// bounds of `limits`.
    ///
    ///     let y: Range = 0..<5
    ///     print(y.clamped(to: 10..<1000))
    ///     // Prints "10..<10"
    ///
    /// - Parameter limits: The range to clamp the bounds of this range.
    /// - Returns: A new range clamped to the bounds of `limits`.
    public func clamped(to limits: Range<Bound>) -> Range<Bound>
}

extension Range : CustomStringConvertible where Bound : Comparable {

    /// A textual representation of the range.
    public var description: String { get }
}

extension Range : CustomDebugStringConvertible where Bound : Comparable {

    /// A textual representation of the range, suitable for debugging.
    public var debugDescription: String { get }
}

extension Range : CustomReflectable where Bound : Comparable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension Range : Equatable where Bound : Comparable {

    /// Returns a Boolean value indicating whether two ranges are equal.
    ///
    /// Two ranges are equal when they have the same lower and upper bounds.
    /// That requirement holds even for empty ranges.
    ///
    ///     let x: Range = 5..<15
    ///     print(x == 5..<15)
    ///     // Prints "true"
    ///
    ///     let y: Range = 5..<5
    ///     print(y == 15..<15)
    ///     // Prints "false"
    ///
    /// - Parameters:
    ///   - lhs: A range to compare.
    ///   - rhs: Another range to compare.
    public static func == (lhs: Range<Range<Bound>.Bound>, rhs: Range<Range<Bound>.Bound>) -> Bool
}

extension Range : Hashable where Bound : Comparable, Bound : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Range where Bound : Comparable {

    /// Returns a Boolean value indicating whether this range and the given range
    /// contain an element in common.
    ///
    /// This example shows two overlapping ranges:
    ///
    ///     let x: Range = 0..<20
    ///     print(x.overlaps(10...1000))
    ///     // Prints "true"
    ///
    /// Because a half-open range does not include its upper bound, the ranges
    /// in the following example do not overlap:
    ///
    ///     let y = 20..<30
    ///     print(x.overlaps(y))
    ///     // Prints "false"
    ///
    /// - Parameter other: A range to check for elements in common.
    /// - Returns: `true` if this range and `other` have at least one element in
    ///   common; otherwise, `false`.
    public func overlaps(_ other: Range<Range<Bound>.Bound>) -> Bool

    public func overlaps(_ other: ClosedRange<Range<Bound>.Bound>) -> Bool
}

/// A type that can be used to slice a collection.
///
/// A type that conforms to `RangeExpression` can convert itself to a
/// `Range<Bound>` of indices within a given collection.
public protocol RangeExpression {

    /// The type for which the expression describes a range.
    associatedtype Bound : Comparable

    /// Returns the range of indices described by this range expression within
    /// the given collection.
    ///
    /// You can use the `relative(to:)` method to convert a range expression,
    /// which could be missing one or both of its endpoints, into a concrete
    /// range that is bounded on both sides. The following example uses this
    /// method to convert a partial range up to `4` into a half-open range,
    /// using an array instance to add the range's lower bound.
    ///
    ///     let numbers = [10, 20, 30, 40, 50, 60, 70]
    ///     let upToFour = ..<4
    ///
    ///     let r1 = upToFour.relative(to: numbers)
    ///     // r1 == 0..<4
    ///
    /// The `r1` range is bounded on the lower end by `0` because that is the
    /// starting index of the `numbers` array. When the collection passed to
    /// `relative(to:)` starts with a different index, that index is used as the
    /// lower bound instead. The next example creates a slice of `numbers`
    /// starting at index `2`, and then uses the slice with `relative(to:)` to
    /// convert `upToFour` to a concrete range.
    ///
    ///     let numbersSuffix = numbers[2...]
    ///     // numbersSuffix == [30, 40, 50, 60, 70]
    ///
    ///     let r2 = upToFour.relative(to: numbersSuffix)
    ///     // r2 == 2..<4
    ///
    /// Use this method only if you need the concrete range it produces. To
    /// access a slice of a collection using a range expression, use the
    /// collection's generic subscript that uses a range expression as its
    /// parameter.
    ///
    ///     let numbersPrefix = numbers[upToFour]
    ///     // numbersPrefix == [10, 20, 30, 40]
    ///
    /// - Parameter collection: The collection to evaluate this range expression
    ///   in relation to.
    /// - Returns: A range suitable for slicing `collection`. The returned range
    ///   is *not* guaranteed to be inside the bounds of `collection`. Callers
    ///   should apply the same preconditions to the return value as they would
    ///   to a range provided directly by the user.
    public func relative<C>(to collection: C) -> Range<Self.Bound> where C : Collection, Self.Bound == C.Index

    /// Returns a Boolean value indicating whether the given element is contained
    /// within the range expression.
    ///
    /// - Parameter element: The element to check for containment.
    /// - Returns: `true` if `element` is contained in the range expression;
    ///   otherwise, `false`.
    public func contains(_ element: Self.Bound) -> Bool
}

extension RangeExpression {

    public static func ~= (pattern: Self, value: Self.Bound) -> Bool
}

@available(*, deprecated, renamed: "Slice")
public typealias RangeReplaceableBidirectionalSlice<T> = Slice<T>

/// A collection that supports replacement of an arbitrary subrange of elements
/// with the elements of another collection.
///
/// Range-replaceable collections provide operations that insert and remove
/// elements. For example, you can add elements to an array of strings by
/// calling any of the inserting or appending operations that the
/// `RangeReplaceableCollection` protocol defines.
///
///     var bugs = ["Aphid", "Damselfly"]
///     bugs.append("Earwig")
///     bugs.insert(contentsOf: ["Bumblebee", "Cicada"], at: 1)
///     print(bugs)
///     // Prints "["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]"
///
/// Likewise, `RangeReplaceableCollection` types can remove one or more
/// elements using a single operation.
///
///     bugs.removeLast()
///     bugs.removeSubrange(1...2)
///     print(bugs)
///     // Prints "["Aphid", "Damselfly"]"
///
///     bugs.removeAll()
///     print(bugs)
///     // Prints "[]"
///
/// Lastly, use the eponymous `replaceSubrange(_:with:)` method to replace
/// a subrange of elements with the contents of another collection. Here,
/// three elements in the middle of an array of integers are replaced by the
/// five elements of a `Repeated<Int>` instance.
///
///      var nums = [10, 20, 30, 40, 50]
///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
///      print(nums)
///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
///
/// Conforming to the RangeReplaceableCollection Protocol
/// =====================================================
///
/// To add `RangeReplaceableCollection` conformance to your custom collection,
/// add an empty initializer and the `replaceSubrange(_:with:)` method to your
/// custom type. `RangeReplaceableCollection` provides default implementations
/// of all its other methods using this initializer and method. For example,
/// the `removeSubrange(_:)` method is implemented by calling 
/// `replaceSubrange(_:with:)` with an empty collection for the `newElements` 
/// parameter. You can override any of the protocol's required methods to 
/// provide your own custom implementation.
public protocol RangeReplaceableCollection : Collection where Self.SubSequence : RangeReplaceableCollection {

    associatedtype SubSequence

    /// Creates a new, empty collection.
    public init()

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C>(_ subrange: Range<Self.Index>, with newElements: C) where C : Collection, Self.Element == C.Element

    /// Prepares the collection to store the specified number of elements, when
    /// doing so is appropriate for the underlying type.
    ///
    /// If you are adding a known number of elements to a collection, use this
    /// method to avoid multiple reallocations. A type that conforms to
    /// `RangeReplaceableCollection` can choose how to respond when this method
    /// is called. Depending on the type, it may make sense to allocate more or
    /// less storage than requested, or to take no action at all.
    ///
    /// - Parameter n: The requested number of elements to store.
    public mutating func reserveCapacity(_ n: Int)

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// The following example creates an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Self.Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element

    /// Adds an element to the end of the collection.
    ///
    /// If the collection does not have sufficient capacity for another element,
    /// additional storage is allocated before appending `newElement`. The
    /// following example adds a new number to an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(100)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 100]"
    ///
    /// - Parameter newElement: The element to append to the collection.
    ///
    /// - Complexity: O(1) on average, over many additions to the same
    ///   collection.
    public mutating func append(_ newElement: Self.Element)

    public mutating func append<S>(contentsOf newElements: S) where S : Sequence, Self.Element == S.Element

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Self.Element, at i: Self.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<S>(contentsOf newElements: S, at i: Self.Index) where S : Collection, Self.Element == S.Element

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter i: The position of the element to remove. `index` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at i: Self.Index) -> Self.Element

    /// Removes the specified subrange of elements from the collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeSubrange(1...3)
    ///     print(bugs)
    ///     // Prints "["Aphid", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The subrange of the collection to remove. The bounds
    ///   of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: Range<Self.Index>)

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst()
    ///     print(bugs)
    ///     // Prints "["Bumblebee", "Cicada", "Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeFirst() -> Self.Element

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst(3)
    ///     print(bugs)
    ///     // Prints "["Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter n: The number of elements to remove from the collection.
    ///   `n` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeFirst(_ n: Int)

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool)

    /// Removes from the collection all elements that satisfy the given predicate.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be removed from the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeAll(where predicate: (Self.Element) throws -> Bool) rethrows

    public subscript(bounds: Self.Index) -> Self.Element { get }

    public subscript(bounds: Range<Self.Index>) -> Self.SubSequence { get }
}

extension RangeReplaceableCollection {

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// Here's an example of creating an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public convenience init(repeating repeatedValue: Self.Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    public convenience init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element

    /// Adds an element to the end of the collection.
    ///
    /// If the collection does not have sufficient capacity for another element,
    /// additional storage is allocated before appending `newElement`. The
    /// following example adds a new number to an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(100)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 100]"
    ///
    /// - Parameter newElement: The element to append to the collection.
    ///
    /// - Complexity: O(1) on average, over many additions to the same
    ///   collection.
    public mutating func append(_ newElement: Self.Element)

    /// Adds the elements of a sequence or collection to the end of this
    /// collection.
    ///
    /// The collection being appended to allocates any additional necessary
    /// storage to hold the new elements.
    ///
    /// The following example appends the elements of a `Range<Int>` instance to
    /// an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting
    ///   collection.
    public mutating func append<S>(contentsOf newElements: S) where S : Sequence, Self.Element == S.Element

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Self.Element, at i: Self.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<C>(contentsOf newElements: C, at i: Self.Index) where C : Collection, Self.Element == C.Element

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter position: The position of the element to remove. `position` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at position: Self.Index) -> Self.Element

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes three elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<4)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: Range<Self.Index>)

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst(3)
    ///     print(bugs)
    ///     // Prints "["Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter n: The number of elements to remove from the collection.
    ///   `n` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeFirst(_ n: Int)

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeFirst()
    ///     print(bugs)
    ///     // Prints "["Bumblebee", "Cicada", "Damselfly", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeFirst() -> Self.Element

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)

    /// Prepares the collection to store the specified number of elements, when
    /// doing so is appropriate for the underlying type.
    ///
    /// If you will be adding a known number of elements to a collection, use
    /// this method to avoid multiple reallocations. A type that conforms to
    /// `RangeReplaceableCollection` can choose how to respond when this method
    /// is called. Depending on the type, it may make sense to allocate more or
    /// less storage than requested or to take no action at all.
    ///
    /// - Parameter n: The requested number of elements to store.
    public mutating func reserveCapacity(_ n: Int)
}

extension RangeReplaceableCollection where Self == Self.SubSequence {

    /// Removes and returns the first element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The first element of the collection.
    ///
    /// - Complexity: O(1)
    /// - Precondition: `!self.isEmpty`.
    public mutating func removeFirst() -> Self.Element

    /// Removes the specified number of elements from the beginning of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter n: The number of elements to remove from the collection.
    ///   `n` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(1)
    public mutating func removeFirst(_ n: Int)
}

extension RangeReplaceableCollection {

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C, R>(_ subrange: R, with newElements: C) where C : Collection, R : RangeExpression, Self.Element == C.Element, Self.Index == R.Bound

    /// Removes the elements in the specified subrange from the collection.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes three elements from the middle of an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.5]
    ///     measurements.removeSubrange(1..<4)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The range of the collection to be removed. The
    ///   bounds of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange<R>(_ bounds: R) where R : RangeExpression, Self.Index == R.Bound
}

extension RangeReplaceableCollection {

    /// Removes and returns the last element of the collection.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection if the collection is not
    /// empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    public mutating func popLast() -> Self.Element?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    public mutating func removeLast() -> Self.Element

    /// Removes the specified number of elements from the end of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter n: The number of elements to remove from the collection.
    ///   `n` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the specified number of elements.
    public mutating func removeLast(_ n: Int)
}

/// Ambiguity breakers.
extension RangeReplaceableCollection where Self == Self.SubSequence {

    /// Removes and returns the last element of the collection.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection if the collection is not
    /// empty; otherwise, `nil`.
    ///
    /// - Complexity: O(1)
    public mutating func popLast() -> Self.Element?

    /// Removes and returns the last element of the collection.
    ///
    /// The collection must not be empty.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Returns: The last element of the collection.
    ///
    /// - Complexity: O(1)
    public mutating func removeLast() -> Self.Element

    /// Removes the specified number of elements from the end of the
    /// collection.
    ///
    /// Attempting to remove more elements than exist in the collection
    /// triggers a runtime error.
    ///
    /// Calling this method may invalidate all saved indices of this
    /// collection. Do not rely on a previously stored index value after
    /// altering a collection with any operation that can change its length.
    ///
    /// - Parameter n: The number of elements to remove from the collection.
    ///   `n` must be greater than or equal to zero and must not exceed the
    ///   number of elements in the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the specified number of elements.
    public mutating func removeLast(_ n: Int)
}

extension RangeReplaceableCollection {

    /// Creates a new collection by concatenating the elements of a collection and
    /// a sequence.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of an integer array and a `Range<Int>` instance.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let moreNumbers = numbers + 5...10
    ///     print(moreNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of the argument on the left-hand
    /// side. In the example above, `moreNumbers` has the same type as `numbers`,
    /// which is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A range-replaceable collection.
    ///   - rhs: A collection or finite sequence.
    public static func + <Other>(lhs: Self, rhs: Other) -> Self where Other : Sequence, Self.Element == Other.Element

    /// Creates a new collection by concatenating the elements of a sequence and a
    /// collection.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of a `Range<Int>` instance and an integer array.
    ///
    ///     let numbers = [7, 8, 9, 10]
    ///     let moreNumbers = 1...6 + numbers
    ///     print(moreNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of argument on the right-hand side.
    /// In the example above, `moreNumbers` has the same type as `numbers`, which
    /// is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A collection or finite sequence.
    ///   - rhs: A range-replaceable collection.
    public static func + <Other>(lhs: Other, rhs: Self) -> Self where Other : Sequence, Self.Element == Other.Element

    /// Appends the elements of a sequence to a range-replaceable collection.
    ///
    /// Use this operator to append the elements of a sequence to the end of
    /// range-replaceable collection with same `Element` type. This example appends
    /// the elements of a `Range<Int>` instance to an array of integers.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers += 10...15
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameters:
    ///   - lhs: The array to append to.
    ///   - rhs: A collection or finite sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting array.
    public static func += <Other>(lhs: inout Self, rhs: Other) where Other : Sequence, Self.Element == Other.Element

    /// Creates a new collection by concatenating the elements of two collections.
    ///
    /// The two arguments must have the same `Element` type. For example, you can
    /// concatenate the elements of two integer arrays.
    ///
    ///     let lowerNumbers = [1, 2, 3, 4]
    ///     let higherNumbers: ContiguousArray = [5, 6, 7, 8, 9, 10]
    ///     let allNumbers = lowerNumbers + higherNumbers
    ///     print(allNumbers)
    ///     // Prints "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
    ///
    /// The resulting collection has the type of the argument on the left-hand
    /// side. In the example above, `moreNumbers` has the same type as `numbers`,
    /// which is `[Int]`.
    ///
    /// - Parameters:
    ///   - lhs: A range-replaceable collection.
    ///   - rhs: Another range-replaceable collection.
    public static func + <Other>(lhs: Self, rhs: Other) -> Self where Other : RangeReplaceableCollection, Self.Element == Other.Element
}

extension RangeReplaceableCollection {

    /// Returns a new collection of the same type containing, in order, the
    /// elements of the original collection that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    @available(swift 4.0)
    public func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self
}

extension RangeReplaceableCollection {

    /// Removes all the elements that satisfy the given predicate.
    ///
    /// Use this method to remove every element in a collection that meets
    /// particular criteria. This example removes all the odd values from an
    /// array of numbers:
    ///
    ///     var numbers = [5, 6, 7, 8, 9, 10, 11]
    ///     numbers.removeAll(where: { $0 % 2 == 1 })
    ///     // numbers == [6, 8, 10]
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be removed from the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeAll(where predicate: (Self.Element) throws -> Bool) rethrows
}

extension RangeReplaceableCollection {

    /// Removes all the elements that satisfy the given predicate.
    ///
    /// Use this method to remove every element in a collection that meets
    /// particular criteria. This example removes all the vowels from a string:
    ///
    ///     var phrase = "The rain in Spain stays mainly in the plain."
    ///
    ///     let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    ///     phrase.removeAll(where: { vowels.contains($0) })
    ///     // phrase == "Th rn n Spn stys mnly n th pln."
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be removed from the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeAll(where predicate: (Self.Element) throws -> Bool) rethrows
}

/// A type that supports replacement of an arbitrary subrange of elements with
/// the elements of another collection.
///
/// In most cases, it's best to ignore this protocol and use the
/// `RangeReplaceableCollection` protocol instead, because it has a more
/// complete interface.
@available(*, deprecated, message: "it will be removed in Swift 4.0.  Please use 'RandomAccessCollection' instead")
public typealias RangeReplaceableIndexable = RangeReplaceableCollection

@available(*, deprecated, renamed: "Slice")
public typealias RangeReplaceableRandomAccessSlice<T> = Slice<T>

@available(*, deprecated, renamed: "Slice")
public typealias RangeReplaceableSlice<T> = Slice<T>

/// A type that can be converted to and from an associated raw value.
///
/// With a `RawRepresentable` type, you can switch back and forth between a
/// custom type and an associated `RawValue` type without losing the value of
/// the original `RawRepresentable` type. Using the raw value of a conforming
/// type streamlines interoperation with Objective-C and legacy APIs and
/// simplifies conformance to other protocols, such as `Equatable`,
/// `Comparable`, and `Hashable`.
///
/// The `RawRepresentable` protocol is seen mainly in two categories of types:
/// enumerations with raw value types and option sets.
///
/// Enumerations with Raw Values
/// ============================
///
/// For any enumeration with a string, integer, or floating-point raw type, the
/// Swift compiler automatically adds `RawRepresentable` conformance. When
/// defining your own custom enumeration, you give it a raw type by specifying
/// the raw type as the first item in the enumeration's type inheritance list.
/// You can also use literals to specify values for one or more cases.
///
/// For example, the `Counter` enumeration defined here has an `Int` raw value
/// type and gives the first case a raw value of `1`:
///
///     enum Counter: Int {
///         case one = 1, two, three, four, five
///     }
///
/// You can create a `Counter` instance from an integer value between 1 and 5
/// by using the `init?(rawValue:)` initializer declared in the
/// `RawRepresentable` protocol. This initializer is failable because although
/// every case of the `Counter` type has a corresponding `Int` value, there
/// are many `Int` values that *don't* correspond to a case of `Counter`.
///
///     for i in 3...6 {
///         print(Counter(rawValue: i))
///     }
///     // Prints "Optional(Counter.three)"
///     // Prints "Optional(Counter.four)"
///     // Prints "Optional(Counter.five)"
///     // Prints "nil"
///
/// Option Sets
/// ===========
///
/// Option sets all conform to `RawRepresentable` by inheritance using the
/// `OptionSet` protocol. Whether using an option set or creating your own,
/// you use the raw value of an option set instance to store the instance's
/// bitfield. The raw value must therefore be of a type that conforms to the
/// `FixedWidthInteger` protocol, such as `UInt8` or `Int`. For example, the
/// `Direction` type defines an option set for the four directions you can
/// move in a game.
///
///     struct Directions: OptionSet {
///         let rawValue: UInt8
///
///         static let up    = Directions(rawValue: 1 << 0)
///         static let down  = Directions(rawValue: 1 << 1)
///         static let left  = Directions(rawValue: 1 << 2)
///         static let right = Directions(rawValue: 1 << 3)
///     }
///
/// Unlike enumerations, option sets provide a nonfailable `init(rawValue:)`
/// initializer to convert from a raw value, because option sets don't have an
/// enumerated list of all possible cases. Option set values have
/// a one-to-one correspondence with their associated raw values.
///
/// In the case of the `Directions` option set, an instance can contain zero,
/// one, or more of the four defined directions. This example declares a
/// constant with three currently allowed moves. The raw value of the
/// `allowedMoves` instance is the result of the bitwise OR of its three
/// members' raw values:
///
///     let allowedMoves: Directions = [.up, .down, .left]
///     print(allowedMoves.rawValue)
///     // Prints "7"
///
/// Option sets use bitwise operations on their associated raw values to
/// implement their mathematical set operations. For example, the `contains()`
/// method on `allowedMoves` performs a bitwise AND operation to check whether
/// the option set contains an element.
///
///     print(allowedMoves.contains(.right))
///     // Prints "false"
///     print(allowedMoves.rawValue & Directions.right.rawValue)
///     // Prints "0"
public protocol RawRepresentable {

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    associatedtype RawValue

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional("PaperSize.Legal")"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init?(rawValue: Self.RawValue)

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public var rawValue: Self.RawValue { get }
}

extension RawRepresentable where Self.RawValue == Bool {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `Bool`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == Bool {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `Bool`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == String {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `String`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == String {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `String`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == Double {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `Double`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == Double {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `Double`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == Float {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `Float`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == Float {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `Float`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == Int {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `Int`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == Int {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `Int`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == Int8 {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `Int8`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == Int8 {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `Int8`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == Int16 {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `Int16`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == Int16 {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `Int16`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == Int32 {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `Int32`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == Int32 {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `Int32`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == Int64 {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `Int64`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == Int64 {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `Int64`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == UInt {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `UInt`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == UInt {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `UInt`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == UInt8 {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `UInt8`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == UInt8 {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `UInt8`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == UInt16 {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `UInt16`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == UInt16 {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `UInt16`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == UInt32 {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `UInt32`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == UInt32 {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `UInt32`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

extension RawRepresentable where Self.RawValue == UInt64 {

    /// Encodes this value into the given encoder, when the type's `RawValue`
    /// is `UInt64`.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension RawRepresentable where Self.RawValue == UInt64 {

    /// Creates a new instance by decoding from the given decoder, when the
    /// type's `RawValue` is `UInt64`.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public convenience init(from decoder: Decoder) throws
}

/// A key path that supports reading from and writing to the resulting value
/// with reference semantics.
public class ReferenceWritableKeyPath<Root, Value> : WritableKeyPath<Root, Value> {
}

/// A collection whose elements are all identical.
///
/// You create an instance of the `Repeated` collection by calling the
/// `repeatElement(_:count:)` function. The following example creates a
/// collection containing the name "Humperdinck" repeated five times:
///
///     let repeatedName = repeatElement("Humperdinck", count: 5)
///     for name in repeatedName {
///         print(name)
///     }
///     // "Humperdinck"
///     // "Humperdinck"
///     // "Humperdinck"
///     // "Humperdinck"
///     // "Humperdinck"
public struct Repeated<Element> {

    /// The number of elements in this collection.
    public let count: Int

    /// The value of every element in this collection.
    public let repeatedValue: Element
}

extension Repeated : RandomAccessCollection {

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a "past the
    /// end" position that's not valid for use as a subscript.
    public typealias Index = Int

    /// The position of the first element in a nonempty collection.
    ///
    /// In a `Repeated` collection, `startIndex` is always equal to zero. If the
    /// collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Repeated<Element>.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// In a `Repeated` collection, `endIndex` is always equal to `count`. If the
    /// collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Repeated<Element>.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(position: Int) -> Element { get }
}

/// A collection that presents the elements of its base collection
/// in reverse order.
///
/// - Note: This type is the result of `x.reversed()` where `x` is a
///   collection having bidirectional indices.
///
/// The `reversed()` method is always lazy when applied to a collection
/// with bidirectional indices, but does not implicitly confer
/// laziness on algorithms applied to its result.  In other words, for
/// ordinary collections `c` having bidirectional indices:
///
/// * `c.reversed()` does not create new storage
/// * `c.reversed().map(f)` maps eagerly and returns a new array
/// * `c.lazy.reversed().map(f)` maps lazily and returns a `LazyMapCollection`
public struct ReversedCollection<Base> where Base : BidirectionalCollection {
}

extension ReversedCollection : LazySequenceProtocol where Base : BidirectionalCollection, Base : LazySequenceProtocol {
}

extension ReversedCollection : LazyCollectionProtocol where Base : BidirectionalCollection, Base : LazyCollectionProtocol {
}

extension ReversedCollection where Base : BidirectionalCollection {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public struct Iterator {
    }
}

extension ReversedCollection : Sequence where Base : BidirectionalCollection {

    /// A type that represents a valid position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript.
    public typealias Element = Base.Element

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> ReversedCollection<Base>.Iterator
}

extension ReversedCollection where Base : BidirectionalCollection {

    /// An index that traverses the same positions as an underlying index,
    /// with inverted traversal direction.
    public struct Index {

        /// The position after this position in the underlying collection.
        ///
        /// To find the position that corresponds with this index in the original,
        /// underlying collection, use that collection's `index(before:)` method
        /// with the `base` property.
        ///
        /// The following example declares a function that returns the index of the
        /// last even number in the passed array, if one is found. First, the
        /// function finds the position of the last even number as a `ReversedIndex`
        /// in a reversed view of the array of numbers. Next, the function calls the
        /// array's `index(before:)` method to return the correct position in the
        /// passed array.
        ///
        ///     func indexOfLastEven(_ numbers: [Int]) -> Int? {
        ///         let reversedNumbers = numbers.reversed()
        ///         guard let i = reversedNumbers.firstIndex(where: { $0 % 2 == 0 })
        ///             else { return nil }
        ///
        ///         return numbers.index(before: i.base)
        ///     }
        ///
        ///     let numbers = [10, 20, 13, 19, 30, 52, 17, 40, 51]
        ///     if let lastEven = indexOfLastEven(numbers) {
        ///         print("Last even number: \(numbers[lastEven])")
        ///     }
        ///     // Prints "Last even number: 40"
        public let base: Base.Index

        /// Creates a new index into a reversed collection for the position before
        /// the specified index.
        ///
        /// When you create an index into a reversed collection using `base`, an
        /// index from the underlying collection, the resulting index is the
        /// position of the element *before* the element referenced by `base`. The
        /// following example creates a new `ReversedIndex` from the index of the
        /// `"a"` character in a string's character view.
        ///
        ///     let name = "Horatio"
        ///     let aIndex = name.firstIndex(of: "a")!
        ///     // name[aIndex] == "a"
        ///
        ///     let reversedName = name.reversed()
        ///     let i = ReversedIndex<String>(aIndex)
        ///     // reversedName[i] == "r"
        ///
        /// The element at the position created using `ReversedIndex<...>(aIndex)` is
        /// `"r"`, the character before `"a"` in the `name` string.
        ///
        /// - Parameter base: The position after the element to create an index for.
        public init(_ base: Base.Index)
    }
}

extension ReversedCollection : BidirectionalCollection where Base : BidirectionalCollection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: ReversedCollection<Base>.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: ReversedCollection<Base>.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: ReversedCollection<Base>.Index) -> ReversedCollection<Base>.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: ReversedCollection<Base>.Index) -> ReversedCollection<Base>.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: ReversedCollection<Base>.Index, offsetBy n: Int) -> ReversedCollection<Base>.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: ReversedCollection<Base>.Index, offsetBy n: Int, limitedBy limit: ReversedCollection<Base>.Index) -> ReversedCollection<Base>.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: ReversedCollection<Base>.Index, to end: ReversedCollection<Base>.Index) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: ReversedCollection<Base>.Index) -> ReversedCollection<Base>.Element { get }
}

extension ReversedCollection : RandomAccessCollection where Base : RandomAccessCollection {
}

extension ReversedCollection where Base : BidirectionalCollection {

    /// Reversing a reversed collection returns the original collection.
    ///
    /// - Complexity: O(1)
    @available(swift 4.2)
    public func reversed() -> Base
}

extension ReversedCollection.Iterator : IteratorProtocol, Sequence where Base : BidirectionalCollection {

    /// The type of element traversed by the iterator.
    public typealias Element = Base.Element

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> ReversedCollection<Base>.Iterator.Element?
}

extension ReversedCollection.Index : Comparable where Base : BidirectionalCollection {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ReversedCollection<Base>.Index, rhs: ReversedCollection<Base>.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: ReversedCollection<Base>.Index, rhs: ReversedCollection<Base>.Index) -> Bool
}

extension ReversedCollection.Index : Hashable where Base : BidirectionalCollection, Base.Index : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: Never call `finalize()` on `hasher`. Doing so may become a
    ///   compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

public typealias ReversedIndex<T> = ReversedCollection<T>

public typealias ReversedRandomAccessCollection<T> = ReversedCollection<T>

/// A type that provides sequential, iterated access to its elements.
///
/// A sequence is a list of values that you can step through one at a time. The
/// most common way to iterate over the elements of a sequence is to use a
/// `for`-`in` loop:
///
///     let oneTwoThree = 1...3
///     for number in oneTwoThree {
///         print(number)
///     }
///     // Prints "1"
///     // Prints "2"
///     // Prints "3"
///
/// While seemingly simple, this capability gives you access to a large number
/// of operations that you can perform on any sequence. As an example, to
/// check whether a sequence includes a particular value, you can test each
/// value sequentially until you've found a match or reached the end of the
/// sequence. This example checks to see whether a particular insect is in an
/// array.
///
///     let bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
///     var hasMosquito = false
///     for bug in bugs {
///         if bug == "Mosquito" {
///             hasMosquito = true
///             break
///         }
///     }
///     print("'bugs' has a mosquito: \(hasMosquito)")
///     // Prints "'bugs' has a mosquito: false"
///
/// The `Sequence` protocol provides default implementations for many common
/// operations that depend on sequential access to a sequence's values. For
/// clearer, more concise code, the example above could use the array's
/// `contains(_:)` method, which every sequence inherits from `Sequence`,
/// instead of iterating manually:
///
///     if bugs.contains("Mosquito") {
///         print("Break out the bug spray.")
///     } else {
///         print("Whew, no mosquitos!")
///     }
///     // Prints "Whew, no mosquitos!"
///
/// Repeated Access
/// ===============
///
/// The `Sequence` protocol makes no requirement on conforming types regarding
/// whether they will be destructively consumed by iteration. As a
/// consequence, don't assume that multiple `for`-`in` loops on a sequence
/// will either resume iteration or restart from the beginning:
///
///     for element in sequence {
///         if ... some condition { break }
///     }
///
///     for element in sequence {
///         // No defined behavior
///     }
///
/// In this case, you cannot assume either that a sequence will be consumable
/// and will resume iteration, or that a sequence is a collection and will
/// restart iteration from the first element. A conforming sequence that is
/// not a collection is allowed to produce an arbitrary sequence of elements
/// in the second `for`-`in` loop.
///
/// To establish that a type you've created supports nondestructive iteration,
/// add conformance to the `Collection` protocol.
///
/// Conforming to the Sequence Protocol
/// ===================================
///
/// Making your own custom types conform to `Sequence` enables many useful
/// operations, like `for`-`in` looping and the `contains` method, without
/// much effort. To add `Sequence` conformance to your own custom type, add a
/// `makeIterator()` method that returns an iterator.
///
/// Alternatively, if your type can act as its own iterator, implementing the
/// requirements of the `IteratorProtocol` protocol and declaring conformance
/// to both `Sequence` and `IteratorProtocol` are sufficient.
///
/// Here's a definition of a `Countdown` sequence that serves as its own
/// iterator. The `makeIterator()` method is provided as a default
/// implementation.
///
///     struct Countdown: Sequence, IteratorProtocol {
///         var count: Int
///
///         mutating func next() -> Int? {
///             if count == 0 {
///                 return nil
///             } else {
///                 defer { count -= 1 }
///                 return count
///             }
///         }
///     }
///
///     let threeToGo = Countdown(count: 3)
///     for i in threeToGo {
///         print(i)
///     }
///     // Prints "3"
///     // Prints "2"
///     // Prints "1"
///
/// Expected Performance
/// ====================
///
/// A sequence should provide its iterator in O(1). The `Sequence` protocol
/// makes no other requirements about element access, so routines that
/// traverse a sequence should be considered O(*n*) unless documented
/// otherwise.
public protocol Sequence {

    /// A type representing the sequence's elements.
    associatedtype Element where Self.Element == Self.Iterator.Element, Self.Iterator.Element == Self.SubSequence.Element, Self.SubSequence.Element == Self.SubSequence.Iterator.Element

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    associatedtype Iterator : IteratorProtocol

    /// A type that represents a subsequence of some of the sequence's elements.
    associatedtype SubSequence : Sequence = AnySequence<Self.Element> where Self.SubSequence == Self.SubSequence.SubSequence

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> Self.Iterator

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    public var underestimatedCount: Int { get }

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    public func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> [Self.Element]

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: (Self.Element) throws -> Void) rethrows

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(*n*), where *n* is the number of elements to drop from
    ///   the beginning of the sequence.
    public func dropFirst(_ n: Int) -> Self.SubSequence

    /// Returns a subsequence containing all but the specified number of final
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence leaving off the specified number of elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> Self.SubSequence

    /// Returns a subsequence by skipping elements while `predicate` returns
    /// `true` and returning the remaining elements.
    ///
    /// - Parameter predicate: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element is a match.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func drop(while predicate: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence

    /// Returns a subsequence, up to the specified maximum length, containing
    /// the initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return.
    ///   `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    public func prefix(_ maxLength: Int) -> Self.SubSequence

    /// Returns a subsequence containing the initial, consecutive elements that
    /// satisfy the given predicate.
    ///
    /// The following example uses the `prefix(while:)` method to find the
    /// positive numbers at the beginning of the `numbers` array. Every element
    /// of `numbers` up to, but not including, the first negative value is
    /// included in the result.
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     let positivePrefix = numbers.prefix(while: { $0 > 0 })
    ///     // positivePrefix == [3, 7, 4]
    ///
    /// If `predicate` matches every element in the sequence, the resulting
    /// sequence contains every element of the sequence.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element should be included in the result.
    /// - Returns: A subsequence of the initial, consecutive elements that
    ///   satisfy `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func prefix(while predicate: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number
    /// of elements in the sequence, the result contains all the elements in
    /// the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence terminating at the end of this sequence with
    ///   at most `maxLength` elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> Self.SubSequence

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " })
    ///               .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(
    ///         line.split(maxSplits: 1, whereSeparator: { $0 == " " })
    ///             .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(omittingEmptySubsequences: false,
    ///                      whereSeparator: { $0 == " " })
    ///          ).map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator isSeparator: (Self.Element) throws -> Bool) rethrows -> [Self.SubSequence]
}

extension Sequence {

    /// Returns an array containing the results of mapping the given closure
    /// over the sequence's elements.
    ///
    /// In this example, `map` is used first to convert the names in the array
    /// to lowercase strings and then to count their characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let lowercaseNames = cast.map { $0.lowercased() }
    ///     // 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
    ///     let letterCounts = cast.map { $0.count }
    ///     // 'letterCounts' == [6, 6, 3, 4]
    ///
    /// - Parameter transform: A mapping closure. `transform` accepts an
    ///   element of this sequence as its parameter and returns a transformed
    ///   value of the same or of a different type.
    /// - Returns: An array containing the transformed elements of this
    ///   sequence.
    public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]

    /// Returns an array containing, in order, the elements of the sequence
    /// that satisfy the given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///     print(shortNames)
    ///     // Prints "["Kim", "Karl"]"
    ///
    /// - Parameter isIncluded: A closure that takes an element of the
    ///   sequence as its argument and returns a Boolean value indicating
    ///   whether the element should be included in the returned array.
    /// - Returns: An array of the elements that `isIncluded` allowed.
    public func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> [Self.Element]

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    public var underestimatedCount: Int { get }

    /// Calls the given closure on each element in the sequence in the same order
    /// as a `for`-`in` loop.
    ///
    /// The two loops in the following example produce the same output:
    ///
    ///     let numberWords = ["one", "two", "three"]
    ///     for word in numberWords {
    ///         print(word)
    ///     }
    ///     // Prints "one"
    ///     // Prints "two"
    ///     // Prints "three"
    ///
    ///     numberWords.forEach { word in
    ///         print(word)
    ///     }
    ///     // Same as above
    ///
    /// Using the `forEach` method is distinct from a `for`-`in` loop in two
    /// important ways:
    ///
    /// 1. You cannot use a `break` or `continue` statement to exit the current
    ///    call of the `body` closure or skip subsequent calls.
    /// 2. Using the `return` statement in the `body` closure will exit only from
    ///    the current call to `body`, not from any outer scope, and won't skip
    ///    subsequent calls.
    ///
    /// - Parameter body: A closure that takes an element of the sequence as a
    ///   parameter.
    public func forEach(_ body: (Self.Element) throws -> Void) rethrows
}

extension Sequence {

    /// Returns the elements of the sequence, shuffled using the given generator
    /// as a source for randomness.
    ///
    /// You use this method to randomize the elements of a sequence when you
    /// are using a custom random number generator. For example, you can shuffle
    /// the numbers between `0` and `9` by calling the `shuffled(using:)` method
    /// on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled(using: &myGenerator)
    ///     // shuffledNumbers == [8, 9, 4, 3, 2, 6, 7, 0, 5, 1]
    ///
    /// - Parameter generator: The random number generator to use when shuffling
    ///   the sequence.
    /// - Returns: An array of this sequence's elements in a shuffled order.
    ///
    /// - Complexity: O(*n*)
    public func shuffled<T>(using generator: inout T) -> [Self.Element] where T : RandomNumberGenerator

    /// Returns the elements of the sequence, shuffled.
    ///
    /// For example, you can shuffle the numbers between `0` and `9` by calling
    /// the `shuffled()` method on that range:
    ///
    ///     let numbers = 0...9
    ///     let shuffledNumbers = numbers.shuffled()
    ///     // shuffledNumbers == [1, 7, 6, 2, 8, 9, 4, 3, 5, 0]
    ///
    /// This method uses the default random generator, `Random.default`. The call
    /// to `numbers.shuffled()` above is equivalent to calling
    /// `numbers.shuffled(using: &Random.default)`.
    ///
    /// - Returns: A shuffled array of this sequence's elements.
    ///
    /// - Complexity: O(*n*)
    public func shuffled() -> [Self.Element]
}

extension Sequence where Self.Element : Comparable {

    /// Returns the elements of the sequence, sorted.
    ///
    /// You can sort any sequence of elements that conform to the `Comparable`
    /// protocol by calling this method. Elements are sorted in ascending order.
    ///
    /// The sorting algorithm is not stable. A nonstable sort may change the
    /// relative order of elements that compare equal.
    ///
    /// Here's an example of sorting a list of students' names. Strings in Swift
    /// conform to the `Comparable` protocol, so the names are sorted in
    /// ascending order according to the less-than operator (`<`).
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let sortedStudents = students.sorted()
    ///     print(sortedStudents)
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// To sort the elements of your sequence in descending order, pass the
    /// greater-than operator (`>`) to the `sorted(by:)` method.
    ///
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// - Returns: A sorted array of the sequence's elements.
    public func sorted() -> [Self.Element]
}

extension Sequence {

    /// Returns the elements of the sequence, sorted using the given predicate as
    /// the comparison between elements.
    ///
    /// When you want to sort a sequence of elements that don't conform to the
    /// `Comparable` protocol, pass a predicate to this method that returns
    /// `true` when the first element passed should be ordered before the
    /// second. The elements of the resulting array are ordered according to the
    /// given predicate.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also `true`.
    ///   (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// The sorting algorithm is not stable. A nonstable sort may change the
    /// relative order of elements for which `areInIncreasingOrder` does not
    /// establish an order.
    ///
    /// In the following example, the predicate provides an ordering for an array
    /// of a custom `HTTPResponse` type. The predicate orders errors before
    /// successes and sorts the error responses by their error code.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]
    ///     let sortedResponses = responses.sorted {
    ///         switch ($0, $1) {
    ///         // Order errors by code
    ///         case let (.error(aCode), .error(bCode)):
    ///             return aCode < bCode
    ///
    ///         // All successes are equivalent, so none is before any other
    ///         case (.ok, .ok): return false
    ///
    ///         // Order errors before successes
    ///         case (.error, .ok): return true
    ///         case (.ok, .error): return false
    ///         }
    ///     }
    ///     print(sortedResponses)
    ///     // Prints "[.error(403), .error(404), .error(500), .ok, .ok]"
    ///
    /// You also use this method to sort elements that conform to the
    /// `Comparable` protocol in descending order. To sort your sequence in
    /// descending order, pass the greater-than operator (`>`) as the
    /// `areInIncreasingOrder` parameter.
    ///
    ///     let students: Set = ["Kofi", "Abena", "Peter", "Kweku", "Akosua"]
    ///     let descendingStudents = students.sorted(by: >)
    ///     print(descendingStudents)
    ///     // Prints "["Peter", "Kweku", "Kofi", "Akosua", "Abena"]"
    ///
    /// Calling the related `sorted()` method is equivalent to calling this
    /// method and passing the less-than operator (`<`) as the predicate.
    ///
    ///     print(students.sorted())
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///     print(students.sorted(by: <))
    ///     // Prints "["Abena", "Akosua", "Kofi", "Kweku", "Peter"]"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: A sorted array of the sequence's elements.
    public func sorted(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Bool) rethrows -> [Self.Element]
}

extension Sequence where Self.Element : Sequence {

    /// Returns the elements of this sequence of sequences, concatenated.
    ///
    /// In this example, an array of three ranges is flattened so that the
    /// elements of each range can be iterated in turn.
    ///
    ///     let ranges = [0..<3, 8..<10, 15..<17]
    ///
    ///     // A for-in loop over 'ranges' accesses each range:
    ///     for range in ranges {
    ///       print(range)
    ///     }
    ///     // Prints "0..<3"
    ///     // Prints "8..<10"
    ///     // Prints "15..<17"
    ///
    ///     // Use 'joined()' to access each element of each range:
    ///     for index in ranges.joined() {
    ///         print(index, terminator: " ")
    ///     }
    ///     // Prints: "0 1 2 8 9 15 16"
    ///
    /// - Returns: A flattened view of the elements of this
    ///   sequence of sequences.
    public func joined() -> FlattenSequence<Self>
}

extension Sequence where Self.Element : Sequence {

    /// Returns the concatenated elements of this sequence of sequences,
    /// inserting the given separator between each element.
    ///
    /// This example shows how an array of `[Int]` instances can be joined, using
    /// another `[Int]` instance as the separator:
    ///
    ///     let nestedNumbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    ///     let joined = nestedNumbers.joined(separator: [-1, -2])
    ///     print(Array(joined))
    ///     // Prints "[1, 2, 3, -1, -2, 4, 5, 6, -1, -2, 7, 8, 9]"
    ///
    /// - Parameter separator: A sequence to insert between each of this
    ///   sequence's elements.
    /// - Returns: The joined sequence of elements.
    public func joined<Separator>(separator: Separator) -> JoinedSequence<Self> where Separator : Sequence, Separator.Element == Self.Element.Element
}

extension Sequence {

    /// A sequence containing the same elements as this sequence,
    /// but on which some operations, such as `map` and `filter`, are
    /// implemented lazily.
    public var lazy: LazySequence<Self> { get }
}

/// A default makeIterator() function for `IteratorProtocol` instances that
/// are declared to conform to `Sequence`
extension Sequence where Self == Self.Iterator {

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> Self
}

extension Sequence {

    /// Returns the first element of the sequence that satisfies the given
    /// predicate.
    ///
    /// The following example uses the `first(where:)` method to find the first
    /// negative number in an array of integers:
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     if let firstNegative = numbers.first(where: { $0 < 0 }) {
    ///         print("The first negative number is \(firstNegative).")
    ///     }
    ///     // Prints "The first negative number is -2."
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element is a match.
    /// - Returns: The first element of the sequence that satisfies `predicate`,
    ///   or `nil` if there is no element that satisfies `predicate`.
    public func first(where predicate: (Self.Element) throws -> Bool) rethrows -> Self.Element?
}

extension Sequence where Self.Element : Equatable {

    /// Returns the longest possible subsequences of the sequence, in order,
    /// around elements equal to the given element.
    ///
    /// The resulting array consists of at most `maxSplits + 1` subsequences.
    /// Elements that are used to split the sequence are not returned as part of
    /// any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string at each
    /// space character (" "). The first use of `split` returns each word that
    /// was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(separator: " ")
    ///               .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(line.split(separator: " ", maxSplits: 1)
    ///               .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `false` for the `omittingEmptySubsequences`
    /// parameter, so the returned array contains empty strings where spaces
    /// were repeated.
    ///
    ///     print(line.split(separator: " ", omittingEmptySubsequences: false)
    ///               .map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - separator: The element that should be split upon.
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each consecutive pair of `separator`
    ///     elements in the sequence and for each instance of `separator` at the
    ///     start or end of the sequence. If `true`, only nonempty subsequences
    ///     are returned. The default value is `true`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(separator: Self.Element, maxSplits: Int = default, omittingEmptySubsequences: Bool = default) -> [Self.SubSequence]
}

extension Sequence where Self.SubSequence == AnySequence<Self.Element> {

    /// Returns the longest possible subsequences of the sequence, in order, that
    /// don't contain elements satisfying the given predicate. Elements that are
    /// used to split the sequence are not returned as part of any subsequence.
    ///
    /// The following examples show the effects of the `maxSplits` and
    /// `omittingEmptySubsequences` parameters when splitting a string using a
    /// closure that matches spaces. The first use of `split` returns each word
    /// that was originally separated by one or more spaces.
    ///
    ///     let line = "BLANCHE:   I don't want realism. I want magic!"
    ///     print(line.split(whereSeparator: { $0 == " " })
    ///               .map(String.init))
    ///     // Prints "["BLANCHE:", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// The second example passes `1` for the `maxSplits` parameter, so the
    /// original string is split just once, into two new strings.
    ///
    ///     print(
    ///        line.split(maxSplits: 1, whereSeparator: { $0 == " " })
    ///                       .map(String.init))
    ///     // Prints "["BLANCHE:", "  I don\'t want realism. I want magic!"]"
    ///
    /// The final example passes `true` for the `allowEmptySlices` parameter, so
    /// the returned array contains empty strings where spaces were repeated.
    ///
    ///     print(
    ///         line.split(
    ///             omittingEmptySubsequences: false,
    ///             whereSeparator: { $0 == " " }
    ///         ).map(String.init))
    ///     // Prints "["BLANCHE:", "", "", "I", "don\'t", "want", "realism.", "I", "want", "magic!"]"
    ///
    /// - Parameters:
    ///   - maxSplits: The maximum number of times to split the sequence, or one
    ///     less than the number of subsequences to return. If `maxSplits + 1`
    ///     subsequences are returned, the last one is a suffix of the original
    ///     sequence containing the remaining elements. `maxSplits` must be
    ///     greater than or equal to zero. The default value is `Int.max`.
    ///   - omittingEmptySubsequences: If `false`, an empty subsequence is
    ///     returned in the result for each pair of consecutive elements
    ///     satisfying the `isSeparator` predicate and for each element at the
    ///     start or end of the sequence satisfying the `isSeparator` predicate.
    ///     If `true`, only nonempty subsequences are returned. The default
    ///     value is `true`.
    ///   - isSeparator: A closure that returns `true` if its argument should be
    ///     used to split the sequence; otherwise, `false`.
    /// - Returns: An array of subsequences, split from this sequence's elements.
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: (Self.Element) throws -> Bool) rethrows -> [AnySequence<Self.Element>]

    /// Returns a subsequence, up to the given maximum length, containing the
    /// final elements of the sequence.
    ///
    /// The sequence must be finite. If the maximum length exceeds the number of
    /// elements in the sequence, the result contains all the elements in the
    /// sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.suffix(2))
    ///     // Prints "[4, 5]"
    ///     print(numbers.suffix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func suffix(_ maxLength: Int) -> AnySequence<Self.Element>

    /// Returns a subsequence containing all but the given number of initial
    /// elements.
    ///
    /// If the number of elements to drop exceeds the number of elements in
    /// the sequence, the result is an empty subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst(2))
    ///     // Prints "[3, 4, 5]"
    ///     print(numbers.dropFirst(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop from the beginning of
    ///   the sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence starting after the specified number of
    ///   elements.
    ///
    /// - Complexity: O(1).
    public func dropFirst(_ n: Int) -> AnySequence<Self.Element>

    /// Returns a subsequence containing all but the given number of final
    /// elements.
    ///
    /// The sequence must be finite. If the number of elements to drop exceeds
    /// the number of elements in the sequence, the result is an empty
    /// subsequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast(2))
    ///     // Prints "[1, 2, 3]"
    ///     print(numbers.dropLast(10))
    ///     // Prints "[]"
    ///
    /// - Parameter n: The number of elements to drop off the end of the
    ///   sequence. `n` must be greater than or equal to zero.
    /// - Returns: A subsequence leaving off the specified number of elements.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast(_ n: Int) -> AnySequence<Self.Element>

    /// Returns a subsequence by skipping the initial, consecutive elements that
    /// satisfy the given predicate.
    ///
    /// The following example uses the `drop(while:)` method to skip over the
    /// positive numbers at the beginning of the `numbers` array. The result
    /// begins with the first element of `numbers` that does not satisfy
    /// `predicate`.
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     let startingWithNegative = numbers.drop(while: { $0 > 0 })
    ///     // startingWithNegative == [-2, 9, -6, 10, 1]
    ///
    /// If `predicate` matches every element in the sequence, the result is an
    /// empty sequence.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element should be included in the result.
    /// - Returns: A subsequence starting after the initial, consecutive elements
    ///   that satisfy `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func drop(while predicate: (Self.Element) throws -> Bool) rethrows -> AnySequence<Self.Element>

    /// Returns a subsequence, up to the specified maximum length, containing the
    /// initial elements of the sequence.
    ///
    /// If the maximum length exceeds the number of elements in the sequence,
    /// the result contains all the elements in the sequence.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.prefix(2))
    ///     // Prints "[1, 2]"
    ///     print(numbers.prefix(10))
    ///     // Prints "[1, 2, 3, 4, 5]"
    ///
    /// - Parameter maxLength: The maximum number of elements to return. The
    ///   value of `maxLength` must be greater than or equal to zero.
    /// - Returns: A subsequence starting at the beginning of this sequence
    ///   with at most `maxLength` elements.
    ///
    /// - Complexity: O(1)
    public func prefix(_ maxLength: Int) -> AnySequence<Self.Element>

    /// Returns a subsequence containing the initial, consecutive elements that
    /// satisfy the given predicate.
    ///
    /// The following example uses the `prefix(while:)` method to find the
    /// positive numbers at the beginning of the `numbers` array. Every element
    /// of `numbers` up to, but not including, the first negative value is
    /// included in the result.
    ///
    ///     let numbers = [3, 7, 4, -2, 9, -6, 10, 1]
    ///     let positivePrefix = numbers.prefix(while: { $0 > 0 })
    ///     // positivePrefix == [3, 7, 4]
    ///
    /// If `predicate` matches every element in the sequence, the resulting
    /// sequence contains every element of the sequence.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence as
    ///   its argument and returns a Boolean value indicating whether the
    ///   element should be included in the result.
    /// - Returns: A subsequence of the initial, consecutive elements that
    ///   satisfy `predicate`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public func prefix(while predicate: (Self.Element) throws -> Bool) rethrows -> AnySequence<Self.Element>
}

extension Sequence {

    /// Returns a subsequence containing all but the first element of the
    /// sequence.
    ///
    /// The following example drops the first element from an array of integers.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropFirst())
    ///     // Prints "[2, 3, 4, 5]"
    ///
    /// If the sequence has no elements, the result is an empty subsequence.
    ///
    ///     let empty: [Int] = []
    ///     print(empty.dropFirst())
    ///     // Prints "[]"
    ///
    /// - Returns: A subsequence starting after the first element of the
    ///   sequence.
    ///
    /// - Complexity: O(1)
    public func dropFirst() -> Self.SubSequence

    /// Returns a subsequence containing all but the last element of the
    /// sequence.
    ///
    /// The sequence must be finite.
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     print(numbers.dropLast())
    ///     // Prints "[1, 2, 3, 4]"
    ///
    /// If the sequence has no elements, the result is an empty subsequence.
    ///
    ///     let empty: [Int] = []
    ///     print(empty.dropLast())
    ///     // Prints "[]"
    ///
    /// - Returns: A subsequence leaving off the last element of the sequence.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    public func dropLast() -> Self.SubSequence
}

extension Sequence {

    /// Returns a sequence of pairs (*n*, *x*), where *n* represents a
    /// consecutive integer starting at zero and *x* represents an element of
    /// the sequence.
    ///
    /// This example enumerates the characters of the string "Swift" and prints
    /// each character along with its place in the string.
    ///
    ///     for (n, c) in "Swift".enumerated() {
    ///         print("\(n): '\(c)'")
    ///     }
    ///     // Prints "0: 'S'"
    ///     // Prints "1: 'w'"
    ///     // Prints "2: 'i'"
    ///     // Prints "3: 'f'"
    ///     // Prints "4: 't'"
    ///
    /// When you enumerate a collection, the integer part of each pair is a counter
    /// for the enumeration, but is not necessarily the index of the paired value.
    /// These counters can be used as indices only in instances of zero-based,
    /// integer-indexed collections, such as `Array` and `ContiguousArray`. For
    /// other collections the counters may be out of range or of the wrong type
    /// to use as an index. To iterate over the elements of a collection with its
    /// indices, use the `zip(_:_:)` function.
    ///
    /// This example iterates over the indices and elements of a set, building a
    /// list consisting of indices of names with five or fewer letters.
    ///
    ///     let names: Set = ["Sofia", "Camilla", "Martina", "Mateo", "Nicols"]
    ///     var shorterIndices: [SetIndex<String>] = []
    ///     for (i, name) in zip(names.indices, names) {
    ///         if name.count <= 5 {
    ///             shorterIndices.append(i)
    ///         }
    ///     }
    ///
    /// Now that the `shorterIndices` array holds the indices of the shorter
    /// names in the `names` set, you can use those indices to access elements in
    /// the set.
    ///
    ///     for i in shorterIndices {
    ///         print(names[i])
    ///     }
    ///     // Prints "Sofia"
    ///     // Prints "Mateo"
    ///
    /// - Returns: A sequence of pairs enumerating the sequence.
    public func enumerated() -> EnumeratedSequence<Self>
}

extension Sequence {

    /// Returns the minimum element in the sequence, using the given predicate as
    /// the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `min(by:)` method on a
    /// dictionary to find the key-value pair with the lowest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let leastHue = hues.min { a, b in a.value < b.value }
    ///     print(leastHue)
    ///     // Prints "Optional(("Coral", 16))"
    ///
    /// - Parameter areInIncreasingOrder: A predicate that returns `true`
    ///   if its first argument should be ordered before its second
    ///   argument; otherwise, `false`.
    /// - Returns: The sequence's minimum element, according to
    ///   `areInIncreasingOrder`. If the sequence has no elements, returns
    ///   `nil`.
    @warn_unqualified_access
    public func min(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?

    /// Returns the maximum element in the sequence, using the given predicate
    /// as the comparison between elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// This example shows how to use the `max(by:)` method on a
    /// dictionary to find the key-value pair with the highest value.
    ///
    ///     let hues = ["Heliotrope": 296, "Coral": 16, "Aquamarine": 156]
    ///     let greatestHue = hues.max { a, b in a.value < b.value }
    ///     print(greatestHue)
    ///     // Prints "Optional(("Heliotrope", 296))"
    ///
    /// - Parameter areInIncreasingOrder:  A predicate that returns `true` if its
    ///   first argument should be ordered before its second argument;
    ///   otherwise, `false`.
    /// - Returns: The sequence's maximum element if the sequence is not empty;
    ///   otherwise, `nil`.
    @warn_unqualified_access
    public func max(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Bool) rethrows -> Self.Element?
}

extension Sequence where Self.Element : Comparable {

    /// Returns the minimum element in the sequence.
    ///
    /// This example finds the smallest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let lowestHeight = heights.min()
    ///     print(lowestHeight)
    ///     // Prints "Optional(58.5)"
    ///
    /// - Returns: The sequence's minimum element. If the sequence has no
    ///   elements, returns `nil`.
    @warn_unqualified_access
    public func min() -> Self.Element?

    /// Returns the maximum element in the sequence.
    ///
    /// This example finds the largest value in an array of height measurements.
    ///
    ///     let heights = [67.5, 65.7, 64.3, 61.1, 58.5, 60.3, 64.9]
    ///     let greatestHeight = heights.max()
    ///     print(greatestHeight)
    ///     // Prints "Optional(67.5)"
    ///
    /// - Returns: The sequence's maximum element. If the sequence has no
    ///   elements, returns `nil`.
    @warn_unqualified_access
    public func max() -> Self.Element?
}

extension Sequence {

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are equivalent to the elements in another sequence, using
    /// the given predicate as the equivalence test.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - possiblePrefix: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if the initial elements of the sequence are equivalent
    ///   to the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix, by areEquivalent: (Self.Element, PossiblePrefix.Element) throws -> Bool) rethrows -> Bool where PossiblePrefix : Sequence
}

extension Sequence where Self.Element : Equatable {

    /// Returns a Boolean value indicating whether the initial elements of the
    /// sequence are the same as the elements in another sequence.
    ///
    /// This example tests whether one countable range begins with the elements
    /// of another countable range.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(b.starts(with: a))
    ///     // Prints "true"
    ///
    /// Passing a sequence with no elements or an empty collection as
    /// `possiblePrefix` always results in `true`.
    ///
    ///     print(b.starts(with: []))
    ///     // Prints "true"
    ///
    /// - Parameter possiblePrefix: A sequence to compare to this sequence.
    /// - Returns: `true` if the initial elements of the sequence are the same as
    ///   the elements of `possiblePrefix`; otherwise, `false`. If
    ///   `possiblePrefix` has no elements, the return value is `true`.
    public func starts<PossiblePrefix>(with possiblePrefix: PossiblePrefix) -> Bool where PossiblePrefix : Sequence, Self.Element == PossiblePrefix.Element
}

extension Sequence {

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain equivalent elements in the same order, using the given
    /// predicate as the equivalence test.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// The predicate must be a *equivalence relation* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areEquivalent(a, a)` is always `true`. (Reflexivity)
    /// - `areEquivalent(a, b)` implies `areEquivalent(b, a)`. (Symmetry)
    /// - If `areEquivalent(a, b)` and `areEquivalent(b, c)` are both `true`, then
    ///   `areEquivalent(a, c)` is also `true`. (Transitivity)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areEquivalent: A predicate that returns `true` if its two arguments
    ///     are equivalent; otherwise, `false`.
    /// - Returns: `true` if this sequence and `other` contain equivalent items,
    ///   using `areEquivalent` as the equivalence test; otherwise, `false.`
    public func elementsEqual<OtherSequence>(_ other: OtherSequence, by areEquivalent: (Self.Element, OtherSequence.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence
}

extension Sequence where Self.Element : Equatable {

    /// Returns a Boolean value indicating whether this sequence and another
    /// sequence contain the same elements in the same order.
    ///
    /// At least one of the sequences must be finite.
    ///
    /// This example tests whether one countable range shares the same elements
    /// as another countable range and an array.
    ///
    ///     let a = 1...3
    ///     let b = 1...10
    ///
    ///     print(a.elementsEqual(b))
    ///     // Prints "false"
    ///     print(a.elementsEqual([1, 2, 3]))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence and `other` contain the same elements
    ///   in the same order.
    public func elementsEqual<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element
}

extension Sequence {

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the given
    /// predicate to compare elements.
    ///
    /// The predicate must be a *strict weak ordering* over the elements. That
    /// is, for any elements `a`, `b`, and `c`, the following conditions must
    /// hold:
    ///
    /// - `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)
    /// - If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are
    ///   both `true`, then `areInIncreasingOrder(a, c)` is also
    ///   `true`. (Transitive comparability)
    /// - Two elements are *incomparable* if neither is ordered before the other
    ///   according to the predicate. If `a` and `b` are incomparable, and `b`
    ///   and `c` are incomparable, then `a` and `c` are also incomparable.
    ///   (Transitive incomparability)
    ///
    /// - Parameters:
    ///   - other: A sequence to compare to this sequence.
    ///   - areInIncreasingOrder:  A predicate that returns `true` if its first
    ///     argument should be ordered before its second argument; otherwise,
    ///     `false`.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering as ordered by `areInIncreasingOrder`; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that perform
    ///   localized comparison instead.
    public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence, by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Bool) rethrows -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element
}

extension Sequence where Self.Element : Comparable {

    /// Returns a Boolean value indicating whether the sequence precedes another
    /// sequence in a lexicographical (dictionary) ordering, using the
    /// less-than operator (`<`) to compare elements.
    ///
    /// This example uses the `lexicographicallyPrecedes` method to test which
    /// array of integers comes first in a lexicographical ordering.
    ///
    ///     let a = [1, 2, 2, 2]
    ///     let b = [1, 2, 3, 4]
    ///
    ///     print(a.lexicographicallyPrecedes(b))
    ///     // Prints "true"
    ///     print(b.lexicographicallyPrecedes(b))
    ///     // Prints "false"
    ///
    /// - Parameter other: A sequence to compare to this sequence.
    /// - Returns: `true` if this sequence precedes `other` in a dictionary
    ///   ordering; otherwise, `false`.
    ///
    /// - Note: This method implements the mathematical notion of lexicographical
    ///   ordering, which has no connection to Unicode.  If you are sorting
    ///   strings to present to the end user, use `String` APIs that
    ///   perform localized comparison.
    public func lexicographicallyPrecedes<OtherSequence>(_ other: OtherSequence) -> Bool where OtherSequence : Sequence, Self.Element == OtherSequence.Element
}

extension Sequence {

    /// Returns a Boolean value indicating whether the sequence contains an
    /// element that satisfies the given predicate.
    ///
    /// You can use the predicate to check for an element of a type that
    /// doesn't conform to the `Equatable` protocol, such as the
    /// `HTTPResponse` enumeration in this example.
    ///
    ///     enum HTTPResponse {
    ///         case ok
    ///         case error(Int)
    ///     }
    ///
    ///     let lastThreeResponses: [HTTPResponse] = [.ok, .ok, .error(404)]
    ///     let hadError = lastThreeResponses.contains { element in
    ///         if case .error = element {
    ///             return true
    ///         } else {
    ///             return false
    ///         }
    ///     }
    ///     // 'hadError' == true
    ///
    /// Alternatively, a predicate can be satisfied by a range of `Equatable`
    /// elements or a general condition. This example shows how you can check an
    /// array for an expense greater than $100.
    ///
    ///     let expenses = [21.37, 55.21, 9.32, 10.18, 388.77, 11.41]
    ///     let hasBigPurchase = expenses.contains { $0 > 100 }
    ///     // 'hasBigPurchase' == true
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element represents a match.
    /// - Returns: `true` if the sequence contains an element that satisfies
    ///   `predicate`; otherwise, `false`.
    public func contains(where predicate: (Self.Element) throws -> Bool) rethrows -> Bool

    /// Returns a Boolean value indicating whether every element of a sequence
    /// satisfies a given predicate.
    ///
    /// - Parameter predicate: A closure that takes an element of the sequence
    ///   as its argument and returns a Boolean value that indicates whether
    ///   the passed element satisfies a condition.
    /// - Returns: `true` if the sequence contains only elements that satisfy
    ///   `predicate`; otherwise, `false`.
    public func allSatisfy(_ predicate: (Self.Element) throws -> Bool) rethrows -> Bool
}

extension Sequence where Self.Element : Equatable {

    /// Returns a Boolean value indicating whether the sequence contains the
    /// given element.
    ///
    /// This example checks to see whether a favorite actor is in an array
    /// storing a movie's cast.
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     print(cast.contains("Marlon"))
    ///     // Prints "true"
    ///     print(cast.contains("James"))
    ///     // Prints "false"
    ///
    /// - Parameter element: The element to find in the sequence.
    /// - Returns: `true` if the element was found in the sequence; otherwise,
    ///   `false`.
    public func contains(_ element: Self.Element) -> Bool
}

extension Sequence {

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(_:_:)` method to produce a single value from the elements
    /// of an entire sequence. For example, you can use this method on an array
    /// of numbers to find their sum or product.
    ///
    /// The `nextPartialResult` closure is called sequentially with an
    /// accumulating value initialized to `initialResult` and each element of
    /// the sequence. This example shows how to find the sum of an array of
    /// numbers.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///     let numberSum = numbers.reduce(0, { x, y in
    ///         x + y
    ///     })
    ///     // numberSum == 10
    ///
    /// When `numbers.reduce(_:_:)` is called, the following steps occur:
    ///
    /// 1. The `nextPartialResult` closure is called with `initialResult`---`0`
    ///    in this case---and the first element of `numbers`, returning the sum:
    ///    `1`.
    /// 2. The closure is called again repeatedly with the previous call's return
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the last value returned from the
    ///    closure is returned to the caller.
    ///
    /// If the sequence has no elements, `nextPartialResult` is never executed
    /// and `initialResult` is the result of the call to `reduce(_:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///     `initialResult` is passed to `nextPartialResult` the first time the
    ///     closure is executed.
    ///   - nextPartialResult: A closure that combines an accumulating value and
    ///     an element of the sequence into a new accumulating value, to be used
    ///     in the next call of the `nextPartialResult` closure or returned to
    ///     the caller.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Self.Element) throws -> Result) rethrows -> Result

    /// Returns the result of combining the elements of the sequence using the
    /// given closure.
    ///
    /// Use the `reduce(into:_:)` method to produce a single value from the
    /// elements of an entire sequence. For example, you can use this method on an
    /// array of integers to filter adjacent equal entries or count frequencies.
    ///
    /// This method is preferred over `reduce(_:_:)` for efficiency when the
    /// result is a copy-on-write type, for example an Array or a Dictionary.
    ///
    /// The `updateAccumulatingResult` closure is called sequentially with a
    /// mutable accumulating value initialized to `initialResult` and each element
    /// of the sequence. This example shows how to build a dictionary of letter
    /// frequencies of a string.
    ///
    ///     let letters = "abracadabra"
    ///     let letterCount = letters.reduce(into: [:]) { counts, letter in
    ///         counts[letter, default: 0] += 1
    ///     }
    ///     // letterCount == ["a": 5, "b": 2, "r": 2, "c": 1, "d": 1]
    ///
    /// When `letters.reduce(into:_:)` is called, the following steps occur:
    ///
    /// 1. The `updateAccumulatingResult` closure is called with the initial
    ///    accumulating value---`[:]` in this case---and the first character of
    ///    `letters`, modifying the accumulating value by setting `1` for the key
    ///    `"a"`.
    /// 2. The closure is called again repeatedly with the updated accumulating
    ///    value and each element of the sequence.
    /// 3. When the sequence is exhausted, the accumulating value is returned to
    ///    the caller.
    ///
    /// If the sequence has no elements, `updateAccumulatingResult` is never
    /// executed and `initialResult` is the result of the call to
    /// `reduce(into:_:)`.
    ///
    /// - Parameters:
    ///   - initialResult: The value to use as the initial accumulating value.
    ///   - updateAccumulatingResult: A closure that updates the accumulating
    ///     value with an element of the sequence.
    /// - Returns: The final accumulated value. If the sequence has no elements,
    ///   the result is `initialResult`.
    public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, Self.Element) throws -> ()) rethrows -> Result
}

extension Sequence {

    /// Returns an array containing the elements of this sequence in reverse
    /// order.
    ///
    /// The sequence must be finite.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the sequence.
    ///
    /// - Returns: An array containing the elements of this sequence in
    ///   reverse order.
    public func reversed() -> [Self.Element]
}

extension Sequence {

    /// Returns an array containing the concatenated results of calling the
    /// given transformation with each element of this sequence.
    ///
    /// Use this method to receive a single-level collection when your
    /// transformation produces a sequence or collection for each element.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an array.
    ///
    ///     let numbers = [1, 2, 3, 4]
    ///
    ///     let mapped = numbers.map { Array(repeating: $0, count: $0) }
    ///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]
    ///
    ///     let flatMapped = numbers.flatMap { Array(repeating: $0, count: $0) }
    ///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
    ///
    /// In fact, `s.flatMap(transform)`  is equivalent to
    /// `Array(s.map(transform).joined())`.
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns a sequence or collection.
    /// - Returns: The resulting flattened array.
    ///
    /// - Complexity: O(*m* + *n*), where *m* is the length of this sequence
    ///   and *n* is the length of the result.
    public func flatMap<SegmentOfResult>(_ transform: (Self.Element) throws -> SegmentOfResult) rethrows -> [SegmentOfResult.Element] where SegmentOfResult : Sequence
}

extension Sequence {

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of nonoptional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `compactMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let compactMapped: [Int] = possibleNumbers.compactMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *m* is the length of this sequence
    ///   and *n* is the length of the result.
    public func compactMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]

    /// Returns an array containing the non-`nil` results of calling the given
    /// transformation with each element of this sequence.
    ///
    /// Use this method to receive an array of nonoptional values when your
    /// transformation produces an optional value.
    ///
    /// In this example, note the difference in the result of using `map` and
    /// `flatMap` with a transformation that returns an optional `Int` value.
    ///
    ///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]
    ///
    ///     let mapped: [Int?] = possibleNumbers.map { str in Int(str) }
    ///     // [1, 2, nil, nil, 5]
    ///
    ///     let flatMapped: [Int] = possibleNumbers.flatMap { str in Int(str) }
    ///     // [1, 2, 5]
    ///
    /// - Parameter transform: A closure that accepts an element of this
    ///   sequence as its argument and returns an optional value.
    /// - Returns: An array of the non-`nil` results of calling `transform`
    ///   with each element of the sequence.
    ///
    /// - Complexity: O(*m* + *n*), where *m* is the length of this sequence
    ///   and *n* is the length of the result.
    @available(swift, deprecated: 4.1, renamed: "compactMap(_:)", message: "Please use compactMap(_:) for the case where closure returns an optional value")
    public func flatMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]
}

extension Sequence where Self.Element : StringProtocol {

    /// Returns a new string by concatenating the elements of the sequence,
    /// adding the given separator between each element.
    ///
    /// The following example shows how an array of strings can be joined to a
    /// single, comma-separated string:
    ///
    ///     let cast = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let list = cast.joined(separator: ", ")
    ///     print(list)
    ///     // Prints "Vivien, Marlon, Kim, Karl"
    ///
    /// - Parameter separator: A string to insert between each of the elements
    ///   in this sequence. The default separator is an empty string.
    /// - Returns: A single, concatenated string.
    public func joined(separator: String = default) -> String
}

/// An unordered collection of unique elements.
///
/// You use a set instead of an array when you need to test efficiently for
/// membership and you aren't concerned with the order of the elements in the
/// collection, or when you need to ensure that each element appears only once
/// in a collection.
///
/// You can create a set with any element type that conforms to the `Hashable`
/// protocol. By default, most types in the standard library are hashable,
/// including strings, numeric and Boolean types, enumeration cases without
/// associated values, and even sets themselves.
///
/// Swift makes it as easy to create a new set as to create a new array. Simply
/// assign an array literal to a variable or constant with the `Set` type
/// specified.
///
///     let ingredients: Set = ["cocoa beans", "sugar", "cocoa butter", "salt"]
///     if ingredients.contains("sugar") {
///         print("No thanks, too sweet.")
///     }
///     // Prints "No thanks, too sweet."
///
/// Set Operations
/// ==============
///
/// Sets provide a suite of mathematical set operations. For example, you can
/// efficiently test a set for membership of an element or check its
/// intersection with another set:
///
/// - Use the `contains(_:)` method to test whether a set contains a specific
///   element.
/// - Use the "equal to" operator (`==`) to test whether two sets contain the
///   same elements.
/// - Use the `isSubset(of:)` method to test whether a set contains all the
///   elements of another set or sequence.
/// - Use the `isSuperset(of:)` method to test whether all elements of a set
///   are contained in another set or sequence.
/// - Use the `isStrictSubset(of:)` and `isStrictSuperset(of:)` methods to test
///   whether a set is a subset or superset of, but not equal to, another set.
/// - Use the `isDisjoint(with:)` method to test whether a set has any elements
///   in common with another set.
///
/// You can also combine, exclude, or subtract the elements of two sets:
///
/// - Use the `union(_:)` method to create a new set with the elements of a set
///   and another set or sequence.
/// - Use the `intersection(_:)` method to create a new set with only the
///   elements common to a set and another set or sequence.
/// - Use the `symmetricDifference(_:)` method to create a new set with the
///   elements that are in either a set or another set or sequence, but not in
///   both.
/// - Use the `subtracting(_:)` method to create a new set with the elements of
///   a set that are not also in another set or sequence.
///
/// You can modify a set in place by using these methods' mutating
/// counterparts: `formUnion(_:)`, `formIntersection(_:)`,
/// `formSymmetricDifference(_:)`, and `subtract(_:)`.
///
/// Set operations are not limited to use with other sets. Instead, you can
/// perform set operations with another set, an array, or any other sequence
/// type.
///
///     var primes: Set = [2, 3, 5, 7]
///
///     // Tests whether primes is a subset of a Range<Int>
///     print(primes.isSubset(of: 0..<10))
///     // Prints "true"
///
///     // Performs an intersection with an Array<Int>
///     let favoriteNumbers = [5, 7, 15, 21]
///     print(primes.intersection(favoriteNumbers))
///     // Prints "[5, 7]"
///
/// Sequence and Collection Operations
/// ==================================
///
/// In addition to the `Set` type's set operations, you can use any nonmutating
/// sequence or collection methods with a set.
///
///     if primes.isEmpty {
///         print("No primes!")
///     } else {
///         print("We have \(primes.count) primes.")
///     }
///     // Prints "We have 4 primes."
///
///     let primesSum = primes.reduce(0, +)
///     // 'primesSum' == 17
///
///     let primeStrings = primes.sorted().map(String.init)
///     // 'primeStrings' == ["2", "3", "5", "7"]
///
/// You can iterate through a set's unordered elements with a `for`-`in` loop.
///
///     for number in primes {
///         print(number)
///     }
///     // Prints "5"
///     // Prints "7"
///     // Prints "2"
///     // Prints "3"
///
/// Many sequence and collection operations return an array or a type-erasing
/// collection wrapper instead of a set. To restore efficient set operations,
/// create a new set from the result.
///
///     let morePrimes = primes.union([11, 13, 17, 19])
///
///     let laterPrimes = morePrimes.filter { $0 > 10 }
///     // 'laterPrimes' is of type Array<Int>
///
///     let laterPrimesSet = Set(morePrimes.filter { $0 > 10 })
///     // 'laterPrimesSet' is of type Set<Int>
///
/// Bridging Between Set and NSSet
/// ==============================
///
/// You can bridge between `Set` and `NSSet` using the `as` operator. For
/// bridging to be possible, the `Element` type of a set must be a class, an
/// `@objc` protocol (a protocol imported from Objective-C or marked with the
/// `@objc` attribute), or a type that bridges to a Foundation type.
///
/// Bridging from `Set` to `NSSet` always takes O(1) time and space. When the
/// set's `Element` type is neither a class nor an `@objc` protocol, any
/// required bridging of elements occurs at the first access of each element,
/// so the first operation that uses the contents of the set (for example, a
/// membership test) can take O(*n*).
///
/// Bridging from `NSSet` to `Set` first calls the `copy(with:)` method
/// (`- copyWithZone:` in Objective-C) on the set to get an immutable copy and
/// then performs additional Swift bookkeeping work that takes O(1) time. For
/// instances of `NSSet` that are already immutable, `copy(with:)` returns the
/// same set in constant time; otherwise, the copying performance is
/// unspecified. The instances of `NSSet` and `Set` share buffer using the
/// same copy-on-write optimization that is used when two instances of `Set`
/// share buffer.
public struct Set<Element> where Element : Hashable {
}

extension Set where Element : Hashable {

    /// The position of an element in a set.
    public struct Index : Comparable, Hashable {
    }
}

extension Set : Encodable where Element : Encodable, Element : Hashable {

    /// Encodes the elements of this set into the given encoder in an unkeyed
    /// container.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension Set : Decodable where Element : Decodable, Element : Hashable {

    /// Creates a new set by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws
}

extension Set where Element == AnyHashable {

    public mutating func insert<ConcreteElement>(_ newMember: ConcreteElement) -> (inserted: Bool, memberAfterInsert: ConcreteElement) where ConcreteElement : Hashable

    public mutating func update<ConcreteElement>(with newMember: ConcreteElement) -> ConcreteElement? where ConcreteElement : Hashable

    public mutating func remove<ConcreteElement>(_ member: ConcreteElement) -> ConcreteElement? where ConcreteElement : Hashable
}

extension Set where Element : Hashable {

    /// Creates an empty set with preallocated space for at least the specified
    /// number of elements.
    ///
    /// Use this initializer to avoid intermediate reallocations of a set's
    /// storage buffer when you know how many elements you'll insert into the set
    /// after creation.
    ///
    /// - Parameter minimumCapacity: The minimum number of elements that the
    ///   newly created set should be able to store without reallocating its
    ///   storage buffer.
    public init(minimumCapacity: Int)
}

extension Set : ExpressibleByArrayLiteral where Element : Hashable {

    /// Creates a set containing the elements of the given array literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use an array literal. Instead, create a new set using an array
    /// literal as its value by enclosing a comma-separated list of values in
    /// square brackets. You can use an array literal anywhere a set is expected
    /// by the type context.
    ///
    /// Here, a set of strings is created from an array literal holding only
    /// strings.
    ///
    ///     let ingredients: Set = ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///     if ingredients.isSuperset(of: ["sugar", "salt"]) {
    ///         print("Whatever it is, it's bound to be delicious!")
    ///     }
    ///     // Prints "Whatever it is, it's bound to be delicious!"
    ///
    /// - Parameter elements: A variadic list of elements of the new set.
    public init(arrayLiteral elements: Set<Element>.Element...)
}

extension Set : Sequence where Element : Hashable {

    /// Returns an iterator over the members of the set.
    public func makeIterator() -> SetIterator<Element>

    /// Returns a Boolean value that indicates whether the given element exists
    /// in the set.
    ///
    /// This example uses the `contains(_:)` method to test whether an integer is
    /// a member of a set of prime numbers.
    ///
    ///     let primes: Set = [2, 3, 5, 7]
    ///     let x = 5
    ///     if primes.contains(x) {
    ///         print("\(x) is prime!")
    ///     } else {
    ///         print("\(x). Not prime.")
    ///     }
    ///     // Prints "5 is prime!"
    ///
    /// - Parameter member: An element to look for in the set.
    /// - Returns: `true` if `member` exists in the set; otherwise, `false`.
    ///
    /// - Complexity: O(1)
    public func contains(_ member: Set<Element>.Element) -> Bool
}

extension Set where Element : Hashable {

    /// Returns a new set containing the elements of the set that satisfy the
    /// given predicate.
    ///
    /// In this example, `filter(_:)` is used to include only names shorter than
    /// five characters.
    ///
    ///     let cast: Set = ["Vivien", "Marlon", "Kim", "Karl"]
    ///     let shortNames = cast.filter { $0.count < 5 }
    ///
    ///     shortNames.isSubset(of: cast)
    ///     // true
    ///     shortNames.contains("Vivien")
    ///     // false
    ///
    /// - Parameter isIncluded: A closure that takes an element as its argument
    ///   and returns a Boolean value indicating whether the element should be
    ///   included in the returned set.
    /// - Returns: A set of the elements that `isIncluded` allows.
    @available(swift 4.0)
    public func filter(_ isIncluded: (Set<Element>.Element) throws -> Bool) rethrows -> Set<Element>
}

extension Set : Collection where Element : Hashable {

    /// The starting position for iterating members of the set.
    ///
    /// If the set is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Set<Element>.Index { get }

    /// The "past the end" position for the set---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// If the set is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Set<Element>.Index { get }

    /// Accesses the member at the given position.
    public subscript(position: Set<Element>.Index) -> Element { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Set<Element>.Index) -> Set<Element>.Index

    /// Returns the index of the given element in the set, or `nil` if the
    /// element is not a member of the set.
    ///
    /// - Parameter member: An element to search for in the set.
    /// - Returns: The index of `member` if it exists in the set; otherwise,
    ///   `nil`.
    ///
    /// - Complexity: O(1)
    public func firstIndex(of member: Set<Element>.Element) -> Set<Element>.Index?

    /// The number of elements in the set.
    ///
    /// - Complexity: O(1).
    public var count: Int { get }

    /// A Boolean value that indicates whether the set is empty.
    public var isEmpty: Bool { get }

    /// The first element of the set.
    ///
    /// The first element of the set is not necessarily the first element added
    /// to the set. Don't expect any particular ordering of set elements.
    ///
    /// If the set is empty, the value of this property is `nil`.
    public var first: Element? { get }
}

extension Set : Equatable where Element : Hashable {

    /// Returns a Boolean value indicating whether two sets have equal elements.
    ///
    /// - Parameters:
    ///   - lhs: A set.
    ///   - rhs: Another set.
    /// - Returns: `true` if the `lhs` and `rhs` have the same elements; otherwise,
    ///   `false`.
    public static func == (lhs: Set<Element>, rhs: Set<Element>) -> Bool
}

extension Set : Hashable where Element : Hashable {

    /// The hash value for the set.
    ///
    /// Two sets that are equal will always have equal hash values.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension Set : SetAlgebra where Element : Hashable {

    /// Inserts the given element in the set if it is not already present.
    ///
    /// If an element equal to `newMember` is already contained in the set, this
    /// method has no effect. In the following example, a new element is
    /// inserted into `classDays`, a set of days of the week. When an existing
    /// element is inserted, the `classDays` set does not change.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.wednesday, .friday]
    ///     print(classDays.insert(.monday))
    ///     // Prints "(true, .monday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    ///     print(classDays.insert(.friday))
    ///     // Prints "(false, .friday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: `(true, newMember)` if `newMember` was not contained in the
    ///   set. If an element equal to `newMember` was already contained in the
    ///   set, the method returns `(false, oldMember)`, where `oldMember` is the
    ///   element that was equal to `newMember`. In some cases, `oldMember` may
    ///   be distinguishable from `newMember` by identity comparison or some
    ///   other means.
    public mutating func insert(_ newMember: Set<Element>.Element) -> (inserted: Bool, memberAfterInsert: Set<Element>.Element)

    /// Inserts the given element into the set unconditionally.
    ///
    /// If an element equal to `newMember` is already contained in the set,
    /// `newMember` replaces the existing element. In this example, an existing
    /// element is inserted into `classDays`, a set of days of the week.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.monday, .wednesday, .friday]
    ///     print(classDays.update(with: .monday))
    ///     // Prints "Optional(.monday)"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: An element equal to `newMember` if the set already contained
    ///   such a member; otherwise, `nil`. In some cases, the returned element
    ///   may be distinguishable from `newMember` by identity comparison or some
    ///   other means.
    public mutating func update(with newMember: Set<Element>.Element) -> Set<Element>.Element?

    /// Removes the specified element from the set.
    ///
    /// This example removes the element `"sugar"` from a set of ingredients.
    ///
    ///     var ingredients: Set = ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///     let toRemove = "sugar"
    ///     if let removed = ingredients.remove(toRemove) {
    ///         print("The recipe is now \(removed)-free.")
    ///     }
    ///     // Prints "The recipe is now sugar-free."
    ///
    /// - Parameter member: The element to remove from the set.
    /// - Returns: The value of the `member` parameter if it was a member of the
    ///   set; otherwise, `nil`.
    public mutating func remove(_ member: Set<Element>.Element) -> Set<Element>.Element?

    /// Removes the element at the given index of the set.
    ///
    /// - Parameter position: The index of the member to remove. `position` must
    ///   be a valid index of the set, and must not be equal to the set's end
    ///   index.
    /// - Returns: The element that was removed from the set.
    public mutating func remove(at position: Set<Element>.Index) -> Set<Element>.Element

    /// Removes all members from the set.
    ///
    /// - Parameter keepingCapacity: If `true`, the set's buffer capacity is
    ///   preserved; if `false`, the underlying buffer is released. The
    ///   default is `false`.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)

    /// Removes the first element of the set.
    ///
    /// Because a set is not an ordered collection, the "first" element may not
    /// be the first element that was added to the set. The set must not be
    /// empty.
    ///
    /// - Complexity: Amortized O(1) if the set does not wrap a bridged `NSSet`.
    ///   If the set wraps a bridged `NSSet`, the performance is unspecified.
    ///
    /// - Returns: A member of the set.
    public mutating func removeFirst() -> Set<Element>.Element

    /// Creates an empty set.
    ///
    /// This is equivalent to initializing with an empty array literal. For
    /// example:
    ///
    ///     var emptySet = Set<Int>()
    ///     print(emptySet.isEmpty)
    ///     // Prints "true"
    ///
    ///     emptySet = []
    ///     print(emptySet.isEmpty)
    ///     // Prints "true"
    public init()

    /// Creates a new set from a finite sequence of items.
    ///
    /// Use this initializer to create a new set from an existing sequence, for
    /// example, an array or a range.
    ///
    ///     let validIndices = Set(0..<7).subtracting([2, 4, 5])
    ///     print(validIndices)
    ///     // Prints "[6, 0, 1, 3]"
    ///
    /// This initializer can also be used to restore set methods after performing
    /// sequence operations such as `filter(_:)` or `map(_:)` on a set. For
    /// example, after filtering a set of prime numbers to remove any below 10,
    /// you can create a new set by using this initializer.
    ///
    ///     let primes: Set = [2, 3, 5, 7, 11, 13, 17, 19, 23]
    ///     let laterPrimes = Set(primes.lazy.filter { $0 > 10 })
    ///     print(laterPrimes)
    ///     // Prints "[17, 19, 23, 11, 13]"
    ///
    /// - Parameter sequence: The elements to use as members of the new set.
    public init<Source>(_ sequence: Source) where Element == Source.Element, Source : Sequence

    /// Returns a Boolean value that indicates whether the set is a subset of the
    /// given sequence.
    ///
    /// Set *A* is a subset of another set *B* if every member of *A* is also a
    /// member of *B*.
    ///
    ///     let employees = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isSubset(of: employees))
    ///     // Prints "true"
    ///
    /// - Parameter possibleSuperset: A sequence of elements. `possibleSuperset`
    ///   must be finite.
    /// - Returns: `true` if the set is a subset of `possibleSuperset`;
    ///   otherwise, `false`.
    public func isSubset<S>(of possibleSuperset: S) -> Bool where Element == S.Element, S : Sequence

    /// Returns a Boolean value that indicates whether the set is a strict subset
    /// of the given sequence.
    ///
    /// Set *A* is a strict subset of another set *B* if every member of *A* is
    /// also a member of *B* and *B* contains at least one element that is not a
    /// member of *A*.
    ///
    ///     let employees = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isStrictSubset(of: employees))
    ///     // Prints "true"
    ///
    ///     // A set is never a strict subset of itself:
    ///     print(attendees.isStrictSubset(of: attendees))
    ///     // Prints "false"
    ///
    /// - Parameter possibleStrictSuperset: A sequence of elements.
    ///   `possibleStrictSuperset` must be finite.
    /// - Returns: `true` is the set is strict subset of
    ///   `possibleStrictSuperset`; otherwise, `false`.
    public func isStrictSubset<S>(of possibleStrictSuperset: S) -> Bool where Element == S.Element, S : Sequence

    /// Returns a Boolean value that indicates whether the set is a superset of
    /// the given sequence.
    ///
    /// Set *A* is a superset of another set *B* if every member of *B* is also a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isSuperset(of: attendees))
    ///     // Prints "true"
    ///
    /// - Parameter possibleSubset: A sequence of elements. `possibleSubset` must
    ///   be finite.
    /// - Returns: `true` if the set is a superset of `possibleSubset`;
    ///   otherwise, `false`.
    public func isSuperset<S>(of possibleSubset: S) -> Bool where Element == S.Element, S : Sequence

    /// Returns a Boolean value that indicates whether the set is a strict
    /// superset of the given sequence.
    ///
    /// Set *A* is a strict superset of another set *B* if every member of *B* is
    /// also a member of *A* and *A* contains at least one element that is *not*
    /// a member of *B*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isStrictSuperset(of: attendees))
    ///     // Prints "true"
    ///     print(employees.isStrictSuperset(of: employees))
    ///     // Prints "false"
    ///
    /// - Parameter possibleStrictSubset: A sequence of elements.
    ///   `possibleStrictSubset` must be finite.
    /// - Returns: `true` if the set is a strict superset of
    ///   `possibleStrictSubset`; otherwise, `false`.
    public func isStrictSuperset<S>(of possibleStrictSubset: S) -> Bool where Element == S.Element, S : Sequence

    /// Returns a Boolean value that indicates whether the set has no members in
    /// common with the given sequence.
    ///
    /// In the following example, the `employees` set is disjoint with the
    /// elements of the `visitors` array because no name appears in both.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let visitors = ["Marcia", "Nathaniel", "Olivia"]
    ///     print(employees.isDisjoint(with: visitors))
    ///     // Prints "true"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    /// - Returns: `true` if the set has no elements in common with `other`;
    ///   otherwise, `false`.
    public func isDisjoint<S>(with other: S) -> Bool where Element == S.Element, S : Sequence

    /// Returns a new set with the elements of both this set and the given
    /// sequence.
    ///
    /// In the following example, the `attendeesAndVisitors` set is made up
    /// of the elements of the `attendees` set and the `visitors` array:
    ///
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors = ["Marcia", "Nathaniel"]
    ///     let attendeesAndVisitors = attendees.union(visitors)
    ///     print(attendeesAndVisitors)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept. If `other` contains multiple
    /// instances of equivalent elements, only the first instance is kept.
    ///
    ///     let initialIndices = Set(0..<5)
    ///     let expandedIndices = initialIndices.union([2, 3, 6, 6, 7, 7])
    ///     print(expandedIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    /// - Returns: A new set with the unique elements of this set and `other`.
    public func union<S>(_ other: S) -> Set<Set<Element>.Element> where Element == S.Element, S : Sequence

    /// Inserts the elements of the given sequence into the set.
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept. If `other` contains multiple
    /// instances of equivalent elements, only the first instance is kept.
    ///
    ///     var attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors = ["Diana", "Marcia", "Nathaniel"]
    ///     attendees.formUnion(visitors)
    ///     print(attendees)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    public mutating func formUnion<S>(_ other: S) where Element == S.Element, S : Sequence

    /// Returns a new set containing the elements of this set that do not occur
    /// in the given sequence.
    ///
    /// In the following example, the `nonNeighbors` set is made up of the
    /// elements of the `employees` set that are not elements of `neighbors`:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let nonNeighbors = employees.subtracting(neighbors)
    ///     print(nonNeighbors)
    ///     // Prints "["Chris", "Diana", "Alicia"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    /// - Returns: A new set.
    public func subtracting<S>(_ other: S) -> Set<Set<Element>.Element> where Element == S.Element, S : Sequence

    /// Removes the elements of the given sequence from the set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// also elements of the `neighbors` array are removed. In particular, the
    /// names `"Bethany"` and `"Eric"` are removed from `employees`.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.subtract(neighbors)
    ///     print(employees)
    ///     // Prints "["Chris", "Diana", "Alicia"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    public mutating func subtract<S>(_ other: S) where Element == S.Element, S : Sequence

    /// Returns a new set with the elements that are common to both this set and
    /// the given sequence.
    ///
    /// In the following example, the `bothNeighborsAndEmployees` set is made up
    /// of the elements that are in *both* the `employees` and `neighbors` sets.
    /// Elements that are in only one or the other are left out of the result of
    /// the intersection.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let bothNeighborsAndEmployees = employees.intersection(neighbors)
    ///     print(bothNeighborsAndEmployees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    /// - Returns: A new set.
    public func intersection<S>(_ other: S) -> Set<Set<Element>.Element> where Element == S.Element, S : Sequence

    /// Removes the elements of the set that aren't also in the given sequence.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// not also members of the `neighbors` set are removed. In particular, the
    /// names `"Alicia"`, `"Chris"`, and `"Diana"` are removed.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.formIntersection(neighbors)
    ///     print(employees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    public mutating func formIntersection<S>(_ other: S) where Element == S.Element, S : Sequence

    /// Returns a new set with the elements that are either in this set or in the
    /// given sequence, but not in both.
    ///
    /// In the following example, the `eitherNeighborsOrEmployees` set is made up
    /// of the elements of the `employees` and `neighbors` sets that are not in
    /// both `employees` *and* `neighbors`. In particular, the names `"Bethany"`
    /// and `"Eric"` do not appear in `eitherNeighborsOrEmployees`.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani"]
    ///     let eitherNeighborsOrEmployees = employees.symmetricDifference(neighbors)
    ///     print(eitherNeighborsOrEmployees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    /// - Returns: A new set.
    public func symmetricDifference<S>(_ other: S) -> Set<Set<Element>.Element> where Element == S.Element, S : Sequence

    /// Replace this set with the elements contained in this set or the given
    /// set, but not both.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// also members of `neighbors` are removed from `employees`, while the
    /// elements of `neighbors` that are not members of `employees` are added to
    /// `employees`. In particular, the names `"Bethany"` and `"Eric"` are
    /// removed from `employees` while the name `"Forlani"` is added.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors = ["Bethany", "Eric", "Forlani"]
    ///     employees.formSymmetricDifference(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A sequence of elements. `other` must be finite.
    public mutating func formSymmetricDifference<S>(_ other: S) where Element == S.Element, S : Sequence
}

extension Set : CustomStringConvertible, CustomDebugStringConvertible where Element : Hashable {

    /// A string that represents the contents of the set.
    public var description: String { get }

    /// A string that represents the contents of the set, suitable for debugging.
    public var debugDescription: String { get }
}

extension Set where Element : Hashable {

    /// Removes the elements of the given set from this set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// also members of the `neighbors` set are removed. In particular, the
    /// names `"Bethany"` and `"Eric"` are removed from `employees`.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.subtract(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: Another set.
    public mutating func subtract(_ other: Set<Set<Element>.Element>)

    /// Returns a Boolean value that indicates whether this set is a subset of
    /// the given set.
    ///
    /// Set *A* is a subset of another set *B* if every member of *A* is also a
    /// member of *B*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isSubset(of: employees))
    ///     // Prints "true"
    ///
    /// - Parameter other: Another set.
    /// - Returns: `true` if the set is a subset of `other`; otherwise, `false`.
    public func isSubset(of other: Set<Set<Element>.Element>) -> Bool

    /// Returns a Boolean value that indicates whether this set is a superset of
    /// the given set.
    ///
    /// Set *A* is a superset of another set *B* if every member of *B* is also a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isSuperset(of: attendees))
    ///     // Prints "true"
    ///
    /// - Parameter other: Another set.
    /// - Returns: `true` if the set is a superset of `other`; otherwise,
    ///   `false`.
    public func isSuperset(of other: Set<Set<Element>.Element>) -> Bool

    /// Returns a Boolean value that indicates whether this set has no members in
    /// common with the given set.
    ///
    /// In the following example, the `employees` set is disjoint with the
    /// `visitors` set because no name appears in both sets.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let visitors: Set = ["Marcia", "Nathaniel", "Olivia"]
    ///     print(employees.isDisjoint(with: visitors))
    ///     // Prints "true"
    ///
    /// - Parameter other: Another set.
    /// - Returns: `true` if the set has no elements in common with `other`;
    ///   otherwise, `false`.
    public func isDisjoint(with other: Set<Set<Element>.Element>) -> Bool

    /// Returns a new set containing the elements of this set that do not occur
    /// in the given set.
    ///
    /// In the following example, the `nonNeighbors` set is made up of the
    /// elements of the `employees` set that are not elements of `neighbors`:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let nonNeighbors = employees.subtracting(neighbors)
    ///     print(nonNeighbors)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: Another set.
    /// - Returns: A new set.
    public func subtracting(_ other: Set<Set<Element>.Element>) -> Set<Set<Element>.Element>

    /// Returns a Boolean value that indicates whether the set is a strict
    /// superset of the given sequence.
    ///
    /// Set *A* is a strict superset of another set *B* if every member of *B* is
    /// also a member of *A* and *A* contains at least one element that is *not*
    /// a member of *B*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isStrictSuperset(of: attendees))
    ///     // Prints "true"
    ///     print(employees.isStrictSuperset(of: employees))
    ///     // Prints "false"
    ///
    /// - Parameter other: Another set.
    /// - Returns: `true` if the set is a strict superset of
    ///   `other`; otherwise, `false`.
    public func isStrictSuperset(of other: Set<Set<Element>.Element>) -> Bool

    /// Returns a Boolean value that indicates whether the set is a strict subset
    /// of the given sequence.
    ///
    /// Set *A* is a strict subset of another set *B* if every member of *A* is
    /// also a member of *B* and *B* contains at least one element that is not a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isStrictSubset(of: employees))
    ///     // Prints "true"
    ///
    ///     // A set is never a strict subset of itself:
    ///     print(attendees.isStrictSubset(of: attendees))
    ///     // Prints "false"
    ///
    /// - Parameter other: Another set.
    /// - Returns: `true` if the set is a strict subset of
    ///   `other`; otherwise, `false`.
    public func isStrictSubset(of other: Set<Set<Element>.Element>) -> Bool

    /// Returns a new set with the elements that are common to both this set and
    /// the given sequence.
    ///
    /// In the following example, the `bothNeighborsAndEmployees` set is made up
    /// of the elements that are in *both* the `employees` and `neighbors` sets.
    /// Elements that are in only one or the other are left out of the result of
    /// the intersection.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let bothNeighborsAndEmployees = employees.intersection(neighbors)
    ///     print(bothNeighborsAndEmployees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: Another set.
    /// - Returns: A new set.
    public func intersection(_ other: Set<Set<Element>.Element>) -> Set<Set<Element>.Element>

    /// Removes the elements of the set that are also in the given sequence and
    /// adds the members of the sequence that are not already in the set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// also members of `neighbors` are removed from `employees`, while the
    /// elements of `neighbors` that are not members of `employees` are added to
    /// `employees`. In particular, the names `"Alicia"`, `"Chris"`, and
    /// `"Diana"` are removed from `employees` while the names `"Forlani"` and
    /// `"Greta"` are added.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.formSymmetricDifference(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Chris", "Forlani", "Alicia", "Greta"]"
    ///
    /// - Parameter other: Another set.
    public mutating func formSymmetricDifference(_ other: Set<Set<Element>.Element>)
}

extension Set : CustomReflectable where Element : Hashable {

    /// A mirror that reflects the set.
    public var customMirror: Mirror { get }
}

extension Set where Element : Hashable {

    /// Removes and returns the first element of the set.
    ///
    /// Because a set is not an ordered collection, the "first" element may not
    /// be the first element that was added to the set.
    ///
    /// - Returns: A member of the set. If the set is empty, returns `nil`.
    public mutating func popFirst() -> Set<Element>.Element?

    /// The total number of elements that the set can contain without
    /// allocating new storage.
    public var capacity: Int { get }

    /// Reserves enough space to store the specified number of elements.
    ///
    /// If you are adding a known number of elements to a set, use this
    /// method to avoid multiple reallocations. This method ensures that the
    /// set has unique, mutable, contiguous storage, with space allocated
    /// for at least the requested number of elements.
    ///
    /// Calling the `reserveCapacity(_:)` method on a set with bridged
    /// storage triggers a copy to contiguous storage even if the existing
    /// storage has room to store `minimumCapacity` elements.
    ///
    /// - Parameter minimumCapacity: The requested number of elements to
    ///   store.
    public mutating func reserveCapacity(_ minimumCapacity: Int)
}

extension Set.Index where Element : Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Set<Element>.Index, rhs: Set<Element>.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Set<Element>.Index, rhs: Set<Element>.Index) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }
}

/// A type that provides mathematical set operations.
///
/// You use types that conform to the `SetAlgebra` protocol when you need
/// efficient membership tests or mathematical set operations such as
/// intersection, union, and subtraction. In the standard library, you can
/// use the `Set` type with elements of any hashable type, or you can easily
/// create bit masks with `SetAlgebra` conformance using the `OptionSet`
/// protocol. See those types for more information.
///
/// - Note: Unlike ordinary set types, the `Element` type of an `OptionSet` is
///   identical to the `OptionSet` type itself. The `SetAlgebra` protocol is
///   specifically designed to accommodate both kinds of set.
///
/// Conforming to the SetAlgebra Protocol
/// =====================================
///
/// When implementing a custom type that conforms to the `SetAlgebra` protocol,
/// you must implement the required initializers and methods. For the
/// inherited methods to work properly, conforming types must meet the
/// following axioms. Assume that `S` is a custom type that conforms to the
/// `SetAlgebra` protocol, `x` and `y` are instances of `S`, and `e` is of
/// type `S.Element`---the type that the set holds.
///
/// - `S() == []`
/// - `x.intersection(x) == x`
/// - `x.intersection([]) == []`
/// - `x.union(x) == x`
/// - `x.union([]) == x`
/// - `x.contains(e)` implies `x.union(y).contains(e)`
/// - `x.union(y).contains(e)` implies `x.contains(e) || y.contains(e)`
/// - `x.contains(e) && y.contains(e)` if and only if
///   `x.intersection(y).contains(e)`
/// - `x.isSubset(of: y)` implies `x.union(y) == y`
/// - `x.isSuperset(of: y)` implies `x.union(y) == x`
/// - `x.isSubset(of: y)` if and only if `y.isSuperset(of: x)`
/// - `x.isStrictSuperset(of: y)` if and only if
///   `x.isSuperset(of: y) && x != y`
/// - `x.isStrictSubset(of: y)` if and only if `x.isSubset(of: y) && x != y`
public protocol SetAlgebra : Equatable, ExpressibleByArrayLiteral {

    /// A type for which the conforming type provides a containment test.
    associatedtype Element

    /// Creates an empty set.
    ///
    /// This initializer is equivalent to initializing with an empty array
    /// literal. For example, you create an empty `Set` instance with either
    /// this initializer or with an empty array literal.
    ///
    ///     var emptySet = Set<Int>()
    ///     print(emptySet.isEmpty)
    ///     // Prints "true"
    ///
    ///     emptySet = []
    ///     print(emptySet.isEmpty)
    ///     // Prints "true"
    public init()

    /// Returns a Boolean value that indicates whether the given element exists
    /// in the set.
    ///
    /// This example uses the `contains(_:)` method to test whether an integer is
    /// a member of a set of prime numbers.
    ///
    ///     let primes: Set = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
    ///     let x = 5
    ///     if primes.contains(x) {
    ///         print("\(x) is prime!")
    ///     } else {
    ///         print("\(x). Not prime.")
    ///     }
    ///     // Prints "5 is prime!"
    ///
    /// - Parameter member: An element to look for in the set.
    /// - Returns: `true` if `member` exists in the set; otherwise, `false`.
    public func contains(_ member: Self.Element) -> Bool

    /// Returns a new set with the elements of both this and the given set.
    ///
    /// In the following example, the `attendeesAndVisitors` set is made up
    /// of the elements of the `attendees` and `visitors` sets:
    ///
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors = ["Marcia", "Nathaniel"]
    ///     let attendeesAndVisitors = attendees.union(visitors)
    ///     print(attendeesAndVisitors)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept.
    ///
    ///     let initialIndices = Set(0..<5)
    ///     let expandedIndices = initialIndices.union([2, 3, 6, 7])
    ///     print(expandedIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set with the unique elements of this set and `other`.
    ///
    /// - Note: if this set and `other` contain elements that are equal but
    ///   distinguishable (e.g. via `===`), which of these elements is present
    ///   in the result is unspecified.
    public func union(_ other: Self) -> Self

    /// Returns a new set with the elements that are common to both this set and
    /// the given set.
    ///
    /// In the following example, the `bothNeighborsAndEmployees` set is made up
    /// of the elements that are in *both* the `employees` and `neighbors` sets.
    /// Elements that are in only one or the other are left out of the result of
    /// the intersection.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let bothNeighborsAndEmployees = employees.intersection(neighbors)
    ///     print(bothNeighborsAndEmployees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    ///
    /// - Note: if this set and `other` contain elements that are equal but
    ///   distinguishable (e.g. via `===`), which of these elements is present
    ///   in the result is unspecified.
    public func intersection(_ other: Self) -> Self

    /// Returns a new set with the elements that are either in this set or in the
    /// given set, but not in both.
    ///
    /// In the following example, the `eitherNeighborsOrEmployees` set is made up
    /// of the elements of the `employees` and `neighbors` sets that are not in
    /// both `employees` *and* `neighbors`. In particular, the names `"Bethany"`
    /// and `"Eric"` do not appear in `eitherNeighborsOrEmployees`.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani"]
    ///     let eitherNeighborsOrEmployees = employees.symmetricDifference(neighbors)
    ///     print(eitherNeighborsOrEmployees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    public func symmetricDifference(_ other: Self) -> Self

    /// Inserts the given element in the set if it is not already present.
    ///
    /// If an element equal to `newMember` is already contained in the set, this
    /// method has no effect. In this example, a new element is inserted into
    /// `classDays`, a set of days of the week. When an existing element is
    /// inserted, the `classDays` set does not change.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.wednesday, .friday]
    ///     print(classDays.insert(.monday))
    ///     // Prints "(true, .monday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    ///     print(classDays.insert(.friday))
    ///     // Prints "(false, .friday)"
    ///     print(classDays)
    ///     // Prints "[.friday, .wednesday, .monday]"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: `(true, newMember)` if `newMember` was not contained in the
    ///   set. If an element equal to `newMember` was already contained in the
    ///   set, the method returns `(false, oldMember)`, where `oldMember` is the
    ///   element that was equal to `newMember`. In some cases, `oldMember` may
    ///   be distinguishable from `newMember` by identity comparison or some
    ///   other means.
    public mutating func insert(_ newMember: Self.Element) -> (inserted: Bool, memberAfterInsert: Self.Element)

    /// Removes the given element and any elements subsumed by the given element.
    ///
    /// - Parameter member: The element of the set to remove.
    /// - Returns: For ordinary sets, an element equal to `member` if `member` is
    ///   contained in the set; otherwise, `nil`. In some cases, a returned
    ///   element may be distinguishable from `newMember` by identity comparison
    ///   or some other means.
    ///
    ///   For sets where the set type and element type are the same, like
    ///   `OptionSet` types, this method returns any intersection between the set
    ///   and `[member]`, or `nil` if the intersection is empty.
    public mutating func remove(_ member: Self.Element) -> Self.Element?

    /// Inserts the given element into the set unconditionally.
    ///
    /// If an element equal to `newMember` is already contained in the set,
    /// `newMember` replaces the existing element. In this example, an existing
    /// element is inserted into `classDays`, a set of days of the week.
    ///
    ///     enum DayOfTheWeek: Int {
    ///         case sunday, monday, tuesday, wednesday, thursday,
    ///             friday, saturday
    ///     }
    ///
    ///     var classDays: Set<DayOfTheWeek> = [.monday, .wednesday, .friday]
    ///     print(classDays.update(with: .monday))
    ///     // Prints "Optional(.monday)"
    ///
    /// - Parameter newMember: An element to insert into the set.
    /// - Returns: For ordinary sets, an element equal to `newMember` if the set
    ///   already contained such a member; otherwise, `nil`. In some cases, the
    ///   returned element may be distinguishable from `newMember` by identity
    ///   comparison or some other means.
    ///
    ///   For sets where the set type and element type are the same, like
    ///   `OptionSet` types, this method returns any intersection between the 
    ///   set and `[newMember]`, or `nil` if the intersection is empty.
    public mutating func update(with newMember: Self.Element) -> Self.Element?

    /// Adds the elements of the given set to the set.
    ///
    /// In the following example, the elements of the `visitors` set are added to
    /// the `attendees` set:
    ///
    ///     var attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     let visitors: Set = ["Diana", "Marcia", "Nathaniel"]
    ///     attendees.formUnion(visitors)
    ///     print(attendees)
    ///     // Prints "["Diana", "Nathaniel", "Bethany", "Alicia", "Marcia"]"
    ///
    /// If the set already contains one or more elements that are also in
    /// `other`, the existing members are kept.
    ///
    ///     var initialIndices = Set(0..<5)
    ///     initialIndices.formUnion([2, 3, 6, 7])
    ///     print(initialIndices)
    ///     // Prints "[2, 4, 6, 7, 0, 1, 3]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func formUnion(_ other: Self)

    /// Removes the elements of this set that aren't also in the given set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// not also members of the `neighbors` set are removed. In particular, the
    /// names `"Alicia"`, `"Chris"`, and `"Diana"` are removed.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.formIntersection(neighbors)
    ///     print(employees)
    ///     // Prints "["Bethany", "Eric"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func formIntersection(_ other: Self)

    /// Removes the elements of the set that are also in the given set and adds
    /// the members of the given set that are not already in the set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// also members of `neighbors` are removed from `employees`, while the
    /// elements of `neighbors` that are not members of `employees` are added to
    /// `employees`. In particular, the names `"Bethany"` and `"Eric"` are
    /// removed from `employees` while the name `"Forlani"` is added.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani"]
    ///     employees.formSymmetricDifference(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Forlani", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type.
    public mutating func formSymmetricDifference(_ other: Self)

    /// Returns a new set containing the elements of this set that do not occur
    /// in the given set.
    ///
    /// In the following example, the `nonNeighbors` set is made up of the
    /// elements of the `employees` set that are not elements of `neighbors`:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let nonNeighbors = employees.subtracting(neighbors)
    ///     print(nonNeighbors)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    public func subtracting(_ other: Self) -> Self

    /// Returns a Boolean value that indicates whether the set is a subset of
    /// another set.
    ///
    /// Set *A* is a subset of another set *B* if every member of *A* is also a
    /// member of *B*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isSubset(of: employees))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a subset of `other`; otherwise, `false`.
    public func isSubset(of other: Self) -> Bool

    /// Returns a Boolean value that indicates whether the set has no members in
    /// common with the given set.
    ///
    /// In the following example, the `employees` set is disjoint with the
    /// `visitors` set because no name appears in both sets.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let visitors: Set = ["Marcia", "Nathaniel", "Olivia"]
    ///     print(employees.isDisjoint(with: visitors))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set has no elements in common with `other`;
    ///   otherwise, `false`.
    public func isDisjoint(with other: Self) -> Bool

    /// Returns a Boolean value that indicates whether the set is a superset of
    /// the given set.
    ///
    /// Set *A* is a superset of another set *B* if every member of *B* is also a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isSuperset(of: attendees))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a superset of `possibleSubset`;
    ///   otherwise, `false`.
    public func isSuperset(of other: Self) -> Bool

    /// A Boolean value that indicates whether the set has no elements.
    public var isEmpty: Bool { get }

    /// Creates a new set from a finite sequence of items.
    ///
    /// Use this initializer to create a new set from an existing sequence, like
    /// an array or a range:
    ///
    ///     let validIndices = Set(0..<7).subtracting([2, 4, 5])
    ///     print(validIndices)
    ///     // Prints "[6, 0, 1, 3]"
    ///
    /// - Parameter sequence: The elements to use as members of the new set.
    public init<S>(_ sequence: S) where S : Sequence, Self.Element == S.Element

    /// Removes the elements of the given set from this set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// also members of the `neighbors` set are removed. In particular, the
    /// names `"Bethany"` and `"Eric"` are removed from `employees`.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.subtract(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func subtract(_ other: Self)
}

/// `SetAlgebra` requirements for which default implementations
/// are supplied.
///
/// - Note: A type conforming to `SetAlgebra` can implement any of
///   these initializers or methods, and those implementations will be
///   used in lieu of these defaults.
extension SetAlgebra {

    /// Creates a new set from a finite sequence of items.
    ///
    /// Use this initializer to create a new set from an existing sequence, like
    /// an array or a range:
    ///
    ///     let validIndices = Set(0..<7).subtracting([2, 4, 5])
    ///     print(validIndices)
    ///     // Prints "[6, 0, 1, 3]"
    ///
    /// - Parameter sequence: The elements to use as members of the new set.
    public convenience init<S>(_ sequence: S) where S : Sequence, Self.Element == S.Element

    /// Removes the elements of the given set from this set.
    ///
    /// In the following example, the elements of the `employees` set that are
    /// also members of the `neighbors` set are removed. In particular, the
    /// names `"Bethany"` and `"Eric"` are removed from `employees`.
    ///
    ///     var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     employees.subtract(neighbors)
    ///     print(employees)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    public mutating func subtract(_ other: Self)

    /// Returns a Boolean value that indicates whether the set is a subset of
    /// another set.
    ///
    /// Set *A* is a subset of another set *B* if every member of *A* is also a
    /// member of *B*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isSubset(of: employees))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a subset of `other`; otherwise, `false`.
    public func isSubset(of other: Self) -> Bool

    /// Returns a Boolean value that indicates whether the set is a superset of
    /// the given set.
    ///
    /// Set *A* is a superset of another set *B* if every member of *B* is also a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isSuperset(of: attendees))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a superset of `other`; otherwise,
    ///   `false`.
    public func isSuperset(of other: Self) -> Bool

    /// Returns a Boolean value that indicates whether the set has no members in
    /// common with the given set.
    ///
    /// In the following example, the `employees` set is disjoint with the
    /// `visitors` set because no name appears in both sets.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let visitors: Set = ["Marcia", "Nathaniel", "Olivia"]
    ///     print(employees.isDisjoint(with: visitors))
    ///     // Prints "true"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set has no elements in common with `other`;
    ///   otherwise, `false`.
    public func isDisjoint(with other: Self) -> Bool

    /// Returns a new set containing the elements of this set that do not occur
    /// in the given set.
    ///
    /// In the following example, the `nonNeighbors` set is made up of the
    /// elements of the `employees` set that are not elements of `neighbors`:
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    ///     let nonNeighbors = employees.subtract(neighbors)
    ///     print(nonNeighbors)
    ///     // Prints "["Diana", "Chris", "Alicia"]"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: A new set.
    public func subtracting(_ other: Self) -> Self

    /// A Boolean value that indicates whether the set has no elements.
    public var isEmpty: Bool { get }

    /// Returns a Boolean value that indicates whether this set is a strict
    /// superset of the given set.
    ///
    /// Set *A* is a strict superset of another set *B* if every member of *B* is
    /// also a member of *A* and *A* contains at least one element that is *not*
    /// a member of *B*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(employees.isStrictSuperset(of: attendees))
    ///     // Prints "true"
    ///
    ///     // A set is never a strict superset of itself:
    ///     print(employees.isStrictSuperset(of: employees))
    ///     // Prints "false"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a strict superset of `other`; otherwise,
    ///   `false`.
    public func isStrictSuperset(of other: Self) -> Bool

    /// Returns a Boolean value that indicates whether this set is a strict
    /// subset of the given set.
    ///
    /// Set *A* is a strict subset of another set *B* if every member of *A* is
    /// also a member of *B* and *B* contains at least one element that is not a
    /// member of *A*.
    ///
    ///     let employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    ///     let attendees: Set = ["Alicia", "Bethany", "Diana"]
    ///     print(attendees.isStrictSubset(of: employees))
    ///     // Prints "true"
    ///
    ///     // A set is never a strict subset of itself:
    ///     print(attendees.isStrictSubset(of: attendees))
    ///     // Prints "false"
    ///
    /// - Parameter other: A set of the same type as the current set.
    /// - Returns: `true` if the set is a strict subset of `other`; otherwise,
    ///   `false`.
    public func isStrictSubset(of other: Self) -> Bool
}

extension SetAlgebra where Self.ArrayLiteralElement == Self.Element {

    /// Creates a set containing the elements of the given array literal.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you use an array literal. Instead, create a new set using an array
    /// literal as its value by enclosing a comma-separated list of values in
    /// square brackets. You can use an array literal anywhere a set is expected
    /// by the type context.
    ///
    /// Here, a set of strings is created from an array literal holding only
    /// strings:
    ///
    ///     let ingredients: Set = ["cocoa beans", "sugar", "cocoa butter", "salt"]
    ///     if ingredients.isSuperset(of: ["sugar", "salt"]) {
    ///         print("Whatever it is, it's bound to be delicious!")
    ///     }
    ///     // Prints "Whatever it is, it's bound to be delicious!"
    ///
    /// - Parameter arrayLiteral: A list of elements of the new set.
    public convenience init(arrayLiteral: Self.Element...)
}

public typealias SetIndex<Element> = Set<Element>.Index

/// An iterator over the members of a `Set<Element>`.
public struct SetIterator<Element> : IteratorProtocol where Element : Hashable {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    public mutating func next() -> Element?
}

extension SetIterator : CustomReflectable where Element : Hashable {

    /// A mirror that reflects the iterator.
    public var customMirror: Mirror { get }
}

/// An integer type that can represent both positive and negative values.
public protocol SignedInteger : BinaryInteger, SignedNumeric {
}

extension SignedInteger {

    /// A Boolean value indicating whether this type is a signed integer type.
    ///
    /// This property is always `true` for signed integer types.
    public static var isSigned: Bool { get }
}

extension SignedInteger {

    /// Creates a new instance from the given integer.
    ///
    /// Use this initializer to convert from another integer type when you know
    /// the value is within the bounds of this type. Passing a value that can't
    /// be represented in this type results in a runtime error.
    ///
    /// In the following example, the constant `y` is successfully created from
    /// `x`, an `Int` instance with a value of `100`. Because the `Int8` type
    /// can represent `127` at maximum, the attempt to create `z` with a value
    /// of `1000` results in a runtime error.
    ///
    ///     let x = 100
    ///     let y = Int8(x)
    ///     // y == 100
    ///     let z = Int8(x * 10)
    ///     // Error: Not enough bits to represent the given value
    ///
    /// - Parameter source: A value to convert to this type of integer. The value
    ///   passed as `source` must be representable in this type.
    public convenience init<T>(_ source: T) where T : BinaryInteger

    /// Creates a new instance from the given integer, if it can be represented
    /// exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `100`, while the attempt to initialize the
    /// constant `y` from `1_000` fails because the `Int8` type can represent
    /// `127` at maximum:
    ///
    ///     let x = Int8(exactly: 100)
    ///     // x == Optional(100)
    ///     let y = Int8(exactly: 1_000)
    ///     // y == nil
    ///
    /// - Parameter source: A value to convert to this type of integer.
    public convenience init?<T>(exactly source: T) where T : BinaryInteger

    /// The maximum representable integer in this type.
    ///
    /// For signed integer types, this value is `(2 ** (bitWidth - 1)) - 1`,
    /// where `**` is exponentiation.
    public static var max: Self { get }

    /// The minimum representable integer in this type.
    ///
    /// For signed integer types, this value is `-(2 ** (bitWidth - 1))`, where
    /// `**` is exponentiation.
    public static var min: Self { get }
}

extension SignedInteger {

    public static func &+ (lhs: Self, rhs: Self) -> Self

    public static func &- (lhs: Self, rhs: Self) -> Self
}

/// A type that can represent both positive and negative values.
///
/// The `SignedNumeric` protocol extends the operations defined by the
/// `Numeric` protocol to include a value's additive inverse.
///
/// Conforming to the SignedNumeric Protocol
/// ===========================================
///
/// Because the `SignedNumeric` protocol provides default implementations of
/// both of its required methods, you don't need to do anything beyond
/// declaring conformance to the protocol and ensuring that the values of your
/// type support negation. To customize your type's implementation, provide
/// your own mutating `negate()` method.
public protocol SignedNumeric : Numeric {

    /// Returns the additive inverse of the specified value.
    ///
    /// The negation operator (prefix `-`) returns the additive inverse of its
    /// argument.
    ///
    ///     let x = 21
    ///     let y = -x
    ///     // y == -21
    ///
    /// The resulting value must be representable in the same type as the
    /// argument. In particular, negating a signed, fixed-width integer type's
    /// minimum results in a value that cannot be represented.
    ///
    ///     let z = -Int8.min
    ///     // Overflow error
    ///
    /// - Returns: The additive inverse of this value.
    prefix public static func - (operand: Self) -> Self

    /// Replaces this value with its additive inverse.
    ///
    /// The following example uses the `negate()` method to negate the value of
    /// an integer `x`:
    ///
    ///     var x = 21
    ///     x.negate()
    ///     // x == -21
    public mutating func negate()
}

extension SignedNumeric {

    /// Returns the additive inverse of the specified value.
    ///
    /// The negation operator (prefix `-`) returns the additive inverse of its
    /// argument.
    ///
    ///     let x = 21
    ///     let y = -x
    ///     // y == -21
    ///
    /// The resulting value must be representable in the same type as the
    /// argument. In particular, negating a signed, fixed-width integer type's
    /// minimum results in a value that cannot be represented.
    ///
    ///     let z = -Int8.min
    ///     // Overflow error
    ///
    /// - Returns: The additive inverse of the argument.
    prefix public static func - (operand: Self) -> Self

    /// Replaces this value with its additive inverse.
    ///
    /// The following example uses the `negate()` method to negate the value of
    /// an integer `x`:
    ///
    ///     var x = 21
    ///     x.negate()
    ///     // x == -21
    public mutating func negate()
}

/// A container that can support the storage and direct decoding of a single
/// nonkeyed value.
public protocol SingleValueDecodingContainer {

    /// The path of coding keys taken to get to this point in encoding.
    public var codingPath: [CodingKey] { get }

    /// Decodes a null value.
    ///
    /// - returns: Whether the encountered value was null.
    public func decodeNil() -> Bool

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: Bool.Type) throws -> Bool

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: String.Type) throws -> String

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: Double.Type) throws -> Double

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: Float.Type) throws -> Float

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: Int.Type) throws -> Int

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: Int8.Type) throws -> Int8

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: Int16.Type) throws -> Int16

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: Int32.Type) throws -> Int32

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: Int64.Type) throws -> Int64

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: UInt.Type) throws -> UInt

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: UInt8.Type) throws -> UInt8

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: UInt16.Type) throws -> UInt16

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: UInt32.Type) throws -> UInt32

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode(_ type: UInt64.Type) throws -> UInt64

    /// Decodes a single value of the given type.
    ///
    /// - parameter type: The type to decode as.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   cannot be converted to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null.
    public func decode<T>(_ type: T.Type) throws -> T where T : Decodable
}

/// A container that can support the storage and direct encoding of a single
/// non-keyed value.
public protocol SingleValueEncodingContainer {

    /// The path of coding keys taken to get to this point in encoding.
    public var codingPath: [CodingKey] { get }

    /// Encodes a null value.
    ///
    /// - throws: `EncodingError.invalidValue` if a null value is invalid in the
    ///   current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encodeNil() throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: Bool) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: String) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: Double) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: Float) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: Int) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: Int8) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: Int16) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: Int32) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: Int64) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: UInt) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: UInt8) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: UInt16) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: UInt32) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode(_ value: UInt64) throws

    /// Encodes a single value of the given type.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    /// - precondition: May not be called after a previous `self.encode(_:)`
    ///   call.
    public mutating func encode<T>(_ value: T) throws where T : Encodable
}

/// A view into a subsequence of elements of another collection.
///
/// A slice stores a base collection and the start and end indices of the view.
/// It does not copy the elements from the collection into separate storage.
/// Thus, creating a slice has O(1) complexity.
///
/// Slices Share Indices
/// --------------------
///
/// Indices of a slice can be used interchangeably with indices of the base
/// collection. An element of a slice is located under the same index in the
/// slice and in the base collection, as long as neither the collection nor
/// the slice has been mutated since the slice was created.
///
/// For example, suppose you have an array holding the number of absences from
/// each class during a session.
///
///     var absences = [0, 2, 0, 4, 0, 3, 1, 0]
///
/// You're tasked with finding the day with the most absences in the second
/// half of the session. To find the index of the day in question, follow
/// these setps:
///
/// 1) Create a slice of the `absences` array that holds the second half of the
///    days.
/// 2) Use the `max(by:)` method to determine the index of the day with the
///    most absences.
/// 3) Print the result using the index found in step 2 on the original
///    `absences` array.
///
/// Here's an implementation of those steps:
///
///     let secondHalf = absences.suffix(absences.count / 2)
///     if let i = secondHalf.indices.max(by: { secondHalf[$0] < secondHalf[$1] }) {
///         print("Highest second-half absences: \(absences[i])")
///     }
///     // Prints "Highest second-half absences: 3"
///
/// Slices Inherit Semantics
/// ------------------------
///
/// A slice inherits the value or reference semantics of its base collection.
/// That is, if a `Slice` instance is wrapped around a mutable collection that
/// has value semantics, such as an array, mutating the original collection
/// would trigger a copy of that collection, and not affect the base
/// collection stored inside of the slice.
///
/// For example, if you update the last element of the `absences` array from
/// `0` to `2`, the `secondHalf` slice is unchanged.
///
///     absences[7] = 2
///     print(absences)
///     // Prints "[0, 2, 0, 4, 0, 3, 1, 2]"
///     print(secondHalf)
///     // Prints "[0, 3, 1, 0]"
///
/// Use slices only for transient computation. A slice may hold a reference to
/// the entire storage of a larger collection, not just to the portion it
/// presents, even after the base collection's lifetime ends. Long-term
/// storage of a slice may therefore prolong the lifetime of elements that are
/// no longer otherwise accessible, which can erroneously appear to be memory
/// leakage.
///
/// - Note: Using a `Slice` instance with a mutable collection requires that
///   the base collection's `subscript(_: Index)` setter does not invalidate
///   indices. If mutations need to invalidate indices in your custom
///   collection type, don't use `Slice` as its subsequence type. Instead,
///   define your own subsequence type that takes your index invalidation
///   requirements into account.
public struct Slice<Base> where Base : Collection {

    /// Creates a view into the given collection that allows access to elements
    /// within the specified range.
    ///
    /// It is unusual to need to call this method directly. Instead, create a
    /// slice of a collection by using the collection's range-based subscript or
    /// by using methods that return a subsequence.
    ///
    ///     let singleDigits = 0...9
    ///     let subSequence = singleDigits.dropFirst(5)
    ///     print(Array(subSequence))
    ///     // Prints "[5, 6, 7, 8, 9]"
    ///
    /// In this example, the expression `singleDigits.dropFirst(5))` is
    /// equivalent to calling this initializer with `singleDigits` and a
    /// range covering the last five items of `singleDigits.indices`.
    ///
    /// - Parameters:
    ///   - base: The collection to create a view into.
    ///   - bounds: The range of indices to allow access to in the new slice.
    public init(base: Base, bounds: Range<Base.Index>)

    /// The underlying collection of the slice.
    ///
    /// You can use a slice's `base` property to access its base collection. The
    /// following example declares `singleDigits`, a range of single digit
    /// integers, and then drops the first element to create a slice of that
    /// range, `singleNonZeroDigits`. The `base` property of the slice is equal
    /// to `singleDigits`.
    ///
    ///     let singleDigits = 0..<10
    ///     let singleNonZeroDigits = singleDigits.dropFirst()
    ///     // singleNonZeroDigits is a Slice<Range<Int>>
    ///
    ///     print(singleNonZeroDigits.count)
    ///     // Prints "9"
    ///     prints(singleNonZeroDigits.base.count)
    ///     // Prints "10"
    ///     print(singleDigits == singleNonZeroDigits.base)
    ///     // Prints "true"
    public var base: Base { get }
}

extension Slice : LazySequenceProtocol where Base : Collection, Base : LazySequenceProtocol {
}

extension Slice : LazyCollectionProtocol where Base : LazyCollectionProtocol {
}

extension Slice : Collection where Base : Collection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Base.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Base.Indices

    /// A type representing the sequence's elements.
    public typealias Element = Base.Element

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = Slice<Base>

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = IndexingIterator<Slice<Base>>

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Base.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Base.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: Slice<Base>.Index) -> Base.Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// For example, using a `PartialRangeFrom` range expression with an array
    /// accesses the subrange from the start of the range expression until the
    /// end of the array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2..<5]
    ///     print(streetsSlice)
    ///     // ["Channing", "Douglas", "Evarts"]
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. This example searches `streetsSlice` for one of the
    /// strings in the slice, and then uses that index in the original array.
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")!    // 4
    ///     print(streets[index])
    ///     // "Evarts"
    ///
    /// Always use the slice's `startIndex` property instead of assuming that its
    /// indices start at a particular value. Attempting to access an element by
    /// using an index outside the bounds of the slice may result in a runtime
    /// error, even if that index is valid for the original collection.
    ///
    ///     print(streetsSlice.startIndex)
    ///     // 2
    ///     print(streetsSlice[2])
    ///     // "Channing"
    ///
    ///     print(streetsSlice[0])
    ///     // error: Index out of bounds
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<Slice<Base>.Index>) -> Slice<Base> { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: Base.Indices { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Slice<Base>.Index) -> Slice<Base>.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Slice<Base>.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Slice<Base>.Index, offsetBy n: Int) -> Slice<Base>.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Slice<Base>.Index, offsetBy n: Int, limitedBy limit: Slice<Base>.Index) -> Slice<Base>.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Slice<Base>.Index, to end: Slice<Base>.Index) -> Int
}

extension Slice : BidirectionalCollection where Base : BidirectionalCollection {

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Slice<Base>.Index) -> Slice<Base>.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Slice<Base>.Index)
}

extension Slice : MutableCollection where Base : MutableCollection {

    /// Accesses the element at the specified position.
    ///
    /// For example, you can replace an element of an array by using its
    /// subscript.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one
    /// past the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(index: Slice<Base>.Index) -> Base.Element

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     streets[index!] = "Eustace"
    ///     print(streets[index!])
    ///     // Prints "Eustace"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<Slice<Base>.Index>) -> Slice<Base>
}

extension Slice : RandomAccessCollection where Base : RandomAccessCollection {
}

extension Slice : RangeReplaceableCollection where Base : RangeReplaceableCollection {

    /// Creates a new, empty collection.
    public init()

    /// Creates a new collection containing the specified number of a single,
    /// repeated value.
    ///
    /// The following example creates an array initialized with five strings
    /// containing the letter *Z*.
    ///
    ///     let fiveZs = Array(repeating: "Z", count: 5)
    ///     print(fiveZs)
    ///     // Prints "["Z", "Z", "Z", "Z", "Z"]"
    ///
    /// - Parameters:
    ///   - repeatedValue: The element to repeat.
    ///   - count: The number of times to repeat the value passed in the
    ///     `repeating` parameter. `count` must be zero or greater.
    public init(repeating repeatedValue: Base.Element, count: Int)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S>(_ elements: S) where S : Sequence, Base.Element == S.Element

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C>(_ subRange: Range<Slice<Base>.Index>, with newElements: C) where C : Collection, Base.Element == C.Element

    /// Inserts a new element into the collection at the specified position.
    ///
    /// The new element is inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as
    /// the `index` parameter, the new element is appended to the
    /// collection.
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(100, at: 3)
    ///     numbers.insert(200, at: numbers.endIndex)
    ///
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 4, 5, 200]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElement: The new element to insert into the collection.
    /// - Parameter i: The position at which to insert the new element.
    ///   `index` must be a valid index into the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func insert(_ newElement: Base.Element, at i: Slice<Base>.Index)

    /// Inserts the elements of a sequence into the collection at the specified
    /// position.
    ///
    /// The new elements are inserted before the element currently at the
    /// specified index. If you pass the collection's `endIndex` property as the
    /// `index` parameter, the new elements are appended to the collection.
    ///
    /// Here's an example of inserting a range of integers into an array of the
    /// same type:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.insert(contentsOf: 100...103, at: 3)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 100, 101, 102, 103, 4, 5]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter newElements: The new elements to insert into the collection.
    /// - Parameter i: The position at which to insert the new elements. `index`
    ///   must be a valid index of the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If `i` is equal to the collection's `endIndex`
    ///   property, the complexity is O(*n*), where *n* is the length of
    ///   `newElements`.
    public mutating func insert<S>(contentsOf newElements: S, at i: Slice<Base>.Index) where S : Collection, Base.Element == S.Element

    /// Removes and returns the element at the specified position.
    ///
    /// All the elements following the specified position are moved to close the
    /// gap. This example removes the middle element from an array of
    /// measurements.
    ///
    ///     var measurements = [1.2, 1.5, 2.9, 1.2, 1.6]
    ///     let removed = measurements.remove(at: 2)
    ///     print(measurements)
    ///     // Prints "[1.2, 1.5, 1.2, 1.6]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter i: The position of the element to remove. `index` must be
    ///   a valid index of the collection that is not equal to the collection's
    ///   end index.
    /// - Returns: The removed element.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func remove(at i: Slice<Base>.Index) -> Base.Element

    /// Removes the specified subrange of elements from the collection.
    ///
    ///     var bugs = ["Aphid", "Bumblebee", "Cicada", "Damselfly", "Earwig"]
    ///     bugs.removeSubrange(1...3)
    ///     print(bugs)
    ///     // Prints "["Aphid", "Earwig"]"
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter bounds: The subrange of the collection to remove. The bounds
    ///   of the range must be valid indices of the collection.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeSubrange(_ bounds: Range<Slice<Base>.Index>)
}

extension Slice where Base : BidirectionalCollection, Base : RangeReplaceableCollection {

    public mutating func replaceSubrange<C>(_ subRange: Range<Slice<Base>.Index>, with newElements: C) where C : Collection, Base.Element == C.Element

    public mutating func insert(_ newElement: Base.Element, at i: Slice<Base>.Index)

    public mutating func insert<S>(contentsOf newElements: S, at i: Slice<Base>.Index) where S : Collection, Base.Element == S.Element

    public mutating func remove(at i: Slice<Base>.Index) -> Base.Element

    public mutating func removeSubrange(_ bounds: Range<Slice<Base>.Index>)
}

/// A string type designed to represent text that is known at compile time.
///
/// Instances of the `StaticString` type are immutable. `StaticString` provides
/// limited, pointer-based access to its contents, unlike Swift's more
/// commonly used `String` type. A static string can store its value as a
/// pointer to an ASCII code unit sequence, as a pointer to a UTF-8 code unit
/// sequence, or as a single Unicode scalar value.
public struct StaticString : ExpressibleByUnicodeScalarLiteral, ExpressibleByExtendedGraphemeClusterLiteral, ExpressibleByStringLiteral, CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A pointer to the beginning of the string's UTF-8 encoded representation.
    ///
    /// The static string must store a pointer to either ASCII or UTF-8 code
    /// units. Accessing this property when `hasPointerRepresentation` is
    /// `false` triggers a runtime error.
    public var utf8Start: UnsafePointer<UInt8> { get }

    /// The stored Unicode scalar value.
    ///
    /// The static string must store a single Unicode scalar value. Accessing
    /// this property when `hasPointerRepresentation` is `true` triggers a
    /// runtime error.
    public var unicodeScalar: Unicode.Scalar { get }

    /// The length in bytes of the static string's ASCII or UTF-8 representation.
    ///
    /// - Warning: If the static string stores a single Unicode scalar value, the
    ///   value of `utf8CodeUnitCount` is unspecified.
    public var utf8CodeUnitCount: Int { get }

    /// A Boolean value indicating whether the static string stores a pointer to
    /// ASCII or UTF-8 code units.
    public var hasPointerRepresentation: Bool { get }

    /// A Boolean value that is `true` if the static string stores a pointer to
    /// ASCII code units.
    ///
    /// Use this property in conjunction with `hasPointerRepresentation` to
    /// determine whether a static string with pointer representation stores an
    /// ASCII or UTF-8 code unit sequence.
    ///
    /// - Warning: If the static string stores a single Unicode scalar value, the
    ///   value of `isASCII` is unspecified.
    public var isASCII: Bool { get }

    /// Invokes the given closure with a buffer containing the static string's
    /// UTF-8 code unit sequence.
    ///
    /// This method works regardless of whether the static string stores a
    /// pointer or a single Unicode scalar value.
    ///
    /// The pointer argument to `body` is valid only during the execution of
    /// `withUTF8Buffer(_:)`. Do not store or return the pointer for later use.
    ///
    /// - Parameter body: A closure that takes a buffer pointer to the static
    ///   string's UTF-8 code unit sequence as its sole argument. If the closure
    ///   has a return value, that value is also used as the return value of the
    ///   `withUTF8Buffer(invoke:)` method. The pointer argument is valid only
    ///   for the duration of the method's execution.
    /// - Returns: The return value, if any, of the `body` closure.
    public func withUTF8Buffer<R>(_ body: (UnsafeBufferPointer<UInt8>) -> R) -> R

    /// Creates an empty static string.
    public init()

    /// Creates an instance initialized to a single Unicode scalar.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you initialize a static string with a Unicode scalar.
    public init(unicodeScalarLiteral value: StaticString)

    /// Creates an instance initialized to a single character that is made up of
    /// one or more Unicode scalar values.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you initialize a static string using an extended grapheme cluster.
    public init(extendedGraphemeClusterLiteral value: StaticString)

    /// Creates an instance initialized to the value of a string literal.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you initialize a static string using a string literal.
    public init(stringLiteral value: StaticString)

    /// A string representation of the static string.
    public var description: String { get }

    /// A textual representation of the static string, suitable for debugging.
    public var debugDescription: String { get }
}

extension StaticString {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// A sequence of values formed by striding over a closed interval.
///
/// Use the `stride(from:through:by:)` function to create `StrideThrough` 
/// instances.
public struct StrideThrough<Element> where Element : Strideable {
}

extension StrideThrough : Sequence where Element : Strideable {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> StrideThroughIterator<Element>

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    public var underestimatedCount: Int { get }
}

extension StrideThrough : CustomReflectable where Element : Strideable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// An iterator for a `StrideThrough` instance.
public struct StrideThroughIterator<Element> where Element : Strideable {
}

extension StrideThroughIterator : IteratorProtocol where Element : Strideable {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    public mutating func next() -> Element?
}

/// A sequence of values formed by striding over a half-open interval.
///
/// Use the `stride(from:to:by:)` function to create `StrideTo` instances.
public struct StrideTo<Element> where Element : Strideable {
}

extension StrideTo : Sequence where Element : Strideable {

    /// Returns an iterator over the elements of this sequence.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> StrideToIterator<Element>

    /// A value less than or equal to the number of elements in the sequence,
    /// calculated nondestructively.
    ///
    /// The default implementation returns 0. If you provide your own
    /// implementation, make sure to compute the value nondestructively.
    ///
    /// - Complexity: O(1), except if the sequence also conforms to `Collection`.
    ///   In this case, see the documentation of `Collection.underestimatedCount`.
    public var underestimatedCount: Int { get }
}

extension StrideTo : CustomReflectable where Element : Strideable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// An iterator for a `StrideTo` instance.
public struct StrideToIterator<Element> where Element : Strideable {
}

extension StrideToIterator : IteratorProtocol where Element : Strideable {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    public mutating func next() -> Element?
}

/// A type representing continuous, one-dimensional values that can be offset
/// and measured.
///
/// You can use a type that conforms to the `Strideable` protocol with the
/// `stride(from:to:by:)` and `stride(from:through:by:)` functions. For
/// example, you can use `stride(from:to:by:)` to iterate over an
/// interval of floating-point values:
///
///     for radians in stride(from: 0.0, to: .pi * 2, by: .pi / 2) {
///         let degrees = Int(radians * 180 / .pi)
///         print("Degrees: \(degrees), radians: \(radians)")
///     }
///     // Degrees: 0, radians: 0.0
///     // Degrees: 90, radians: 1.5707963267949
///     // Degrees: 180, radians: 3.14159265358979
///     // Degrees: 270, radians: 4.71238898038469
///
/// The last parameter of these functions is of the associated `Stride`
/// type---the type that represents the distance between any two instances of
/// the `Strideable` type.
///
/// Types that have an integer `Stride` can be used as the boundaries of a
/// countable range or as the lower bound of an iterable one-sided range. For
/// example, you can iterate over a range of `Int` and use sequence and
/// collection methods.
///
///     var sum = 0
///     for x in 1...100 {
///         sum += x
///     }
///     // sum == 5050
///
///     let digits = (0..<10).map(String.init)
///     // ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
///
/// Conforming to the Strideable Protocol
/// =====================================
///
/// To add `Strideable` conformance to a custom type, choose a `Stride` type
/// that can represent the distance between two instances and implement the
/// `advanced(by:)` and `distance(to:)` methods. For example, this
/// hypothetical `Date` type stores its value as the number of days before or
/// after January 1, 2000:
///
///     struct Date: Equatable, CustomStringConvertible {
///         var daysAfterY2K: Int
///
///         var description: String {
///             // ...
///         }
///     }
///
/// The `Stride` type for `Date` is `Int`, inferred from the parameter and
/// return types of `advanced(by:)` and `distance(to:)`:
///
///     extension Date: Strideable {
///         func advanced(by n: Int) -> Date {
///             var result = self
///             result.daysAfterY2K += n
///             return result
///         }
///
///         func distance(to other: Date) -> Int {
///             return other.daysAfterY2K - self.daysAfterY2K
///         }
///     }
///
/// The `Date` type can now be used with the `stride(from:to:by:)` and
/// `stride(from:through:by:)` functions and as the bounds of an iterable
/// range.
///
///     let startDate = Date(daysAfterY2K: 0)   // January 1, 2000
///     let endDate = Date(daysAfterY2K: 15)    // January 16, 2000
///
///     for date in stride(from: startDate, to: endDate, by: 7) {
///         print(date)
///     }
///     // January 1, 2000
///     // January 8, 2000
///     // January 15, 2000
///
/// - Important: The `Strideable` protocol provides default implementations for
///   the equal-to (`==`) and less-than (`<`) operators that depend on the
///   `Stride` type's implementations. If a type conforming to `Strideable` is
///   its own `Stride` type, it must provide concrete implementations of the
///   two operators to avoid infinite recursion.
public protocol Strideable : Comparable {

    /// A type that represents the distance between two values.
    associatedtype Stride : Comparable, SignedNumeric

    /// Returns the distance from this value to the given value, expressed as a 
    /// stride.
    ///
    /// If this type's `Stride` type conforms to `BinaryInteger`, then for two
    /// values `x` and `y`, and a distance `n = x.distance(to: y)`,
    /// `x.advanced(by: n) == y`. Using this method with types that have a
    /// noninteger `Stride` may result in an approximation.
    ///
    /// - Parameter other: The value to calculate the distance to.
    /// - Returns: The distance from this value to `other`.
    ///
    /// - Complexity: O(1)
    public func distance(to other: Self) -> Self.Stride

    /// Returns a value that is offset the specified distance from this value.
    ///
    /// Use the `advanced(by:)` method in generic code to offset a value by a
    /// specified distance. If you're working directly with numeric values, use
    /// the addition operator (`+`) instead of this method.
    ///
    ///     func addOne<T: Strideable>(to x: T) -> T
    ///         where T.Stride : ExpressibleByIntegerLiteral
    ///     {
    ///         return x.advanced(by: 1)
    ///     }
    ///
    ///     let x = addOne(to: 5)
    ///     // x == 6
    ///     let y = addOne(to: 3.5)
    ///     // y = 4.5
    ///
    /// If this type's `Stride` type conforms to `BinaryInteger`, then for a
    /// value `x`, a distance `n`, and a value `y = x.advanced(by: n)`,
    /// `x.distance(to: y) == n`. Using this method with types that have a
    /// noninteger `Stride` may result in an approximation.
    ///
    /// - Parameter n: The distance to advance this value.
    /// - Returns: A value that is offset from this value by `n`.
    ///
    /// - Complexity: O(1)
    public func advanced(by n: Self.Stride) -> Self
}

extension Strideable where Self.Stride : SignedInteger {

    /// Returns a countable closed range that contains both of its bounds.
    ///
    /// Use the closed range operator (`...`) to create a closed range of any type
    /// that conforms to the `Strideable` protocol with an associated signed
    /// integer `Stride` type, such as any of the standard library's integer
    /// types. This example creates a `ClosedRange<Int>` from zero up to,
    /// and including, nine.
    ///
    ///     let singleDigits = 0...9
    ///     print(singleDigits.contains(9))
    ///     // Prints "true"
    ///
    /// You can use sequence or collection methods on the `singleDigits` range.
    ///
    ///     print(singleDigits.count)
    ///     // Prints "10"
    ///     print(singleDigits.last)
    ///     // Prints "9"
    ///
    /// - Parameters:)`.
    ///   - minimum: The lower bound for the range.
    ///   - maximum: The upper bound for the range.
    public static func ... (minimum: Self, maximum: Self) -> ClosedRange<Self>
}

extension Strideable {

    public static func < (x: Self, y: Self) -> Bool

    public static func == (x: Self, y: Self) -> Bool
}

extension Strideable {

    public static func + (lhs: Self, rhs: Self.Stride) -> Self

    public static func + (lhs: Self.Stride, rhs: Self) -> Self

    public static func - (lhs: Self, rhs: Self.Stride) -> Self

    public static func - (lhs: Self, rhs: Self) -> Self.Stride

    public static func += (lhs: inout Self, rhs: Self.Stride)

    public static func -= (lhs: inout Self, rhs: Self.Stride)
}

/// A Unicode string value that is a collection of characters.
///
/// A string is a series of characters, such as `"Swift"`, that forms a
/// collection. Strings in Swift are Unicode correct and locale insensitive,
/// and are designed to be efficient. The `String` type bridges with the
/// Objective-C class `NSString` and offers interoperability with C functions
/// that works with strings.
///
/// You can create new strings using string literals or string interpolations.
/// A *string literal* is a series of characters enclosed in quotes.
///
///     let greeting = "Welcome!"
///
/// *String interpolations* are string literals that evaluate any included
/// expressions and convert the results to string form. String interpolations
/// give you an easy way to build a string from multiple pieces. Wrap each
/// expression in a string interpolation in parentheses, prefixed by a
/// backslash.
///
///     let name = "Rosa"
///     let personalizedGreeting = "Welcome, \(name)!"
///     // personalizedGreeting == "Welcome, Rosa!"
///
///     let price = 2
///     let number = 3
///     let cookiePrice = "\(number) cookies: $\(price * number)."
///     // cookiePrice == "3 cookies: $6."
///
/// Combine strings using the concatenation operator (`+`).
///
///     let longerGreeting = greeting + " We're glad you're here!"
///     // longerGreeting == "Welcome! We're glad you're here!"
///
/// Multiline string literals are enclosed in three double quotation marks
/// (`"""`), with each delimiter on its own line. Indentation is stripped from
/// each line of a multiline string literal to match the indentation of the
/// closing delimiter.
///
///     let banner = """
///               __,
///              (           o  /) _/_
///               `.  , , , ,  //  /
///             (___)(_(_/_(_ //_ (__
///                          /)
///                         (/
///             """
///
/// Modifying and Comparing Strings
/// ===============================
///
/// Strings always have value semantics. Modifying a copy of a string leaves
/// the original unaffected.
///
///     var otherGreeting = greeting
///     otherGreeting += " Have a nice time!"
///     // otherGreeting == "Welcome! Have a nice time!"
///
///     print(greeting)
///     // Prints "Welcome!"
///
/// Comparing strings for equality using the equal-to operator (`==`) or a
/// relational operator (like `<` or `>=`) is always performed using Unicode
/// canonical representation. As a result, different representations of a
/// string compare as being equal.
///
///     let cafe1 = "Cafe\u{301}"
///     let cafe2 = "Caf"
///     print(cafe1 == cafe2)
///     // Prints "true"
///
/// The Unicode scalar value `"\u{301}"` modifies the preceding character to
/// include an accent, so `"e\u{301}"` has the same canonical representation
/// as the single Unicode scalar value `""`.
///
/// Basic string operations are not sensitive to locale settings, ensuring that
/// string comparisons and other operations always have a single, stable
/// result, allowing strings to be used as keys in `Dictionary` instances and
/// for other purposes.
///
/// Accessing String Elements
/// =========================
///
/// A string is a collection of *extended grapheme clusters*, which approximate
/// human-readable characters. Many individual characters, such as "", "",
/// and "", can be made up of multiple Unicode scalar values. These scalar
/// values are combined by Unicode's boundary algorithms into extended
/// grapheme clusters, represented by the Swift `Character` type. Each element
/// of a string is represented by a `Character` instance.
///
/// For example, to retrieve the first word of a longer string, you can search
/// for a space and then create a substring from a prefix of the string up to
/// that point:
///
///     let name = "Marie Curie"
///     let firstSpace = name.firstIndex(of: " ") ?? name.endIndex
///     let firstName = name[..<firstSpace]
///     // firstName == "Marie"
///
/// The `firstName` constant is an instance of the `Substring` type---a type
/// that represents substrings of a string while sharing the original string's
/// storage. Substrings present the same interface as strings.
///
///     print("\(name)'s first name has \(firstName.count) letters.")
///     // Prints "Marie Curie's first name has 5 letters."
///
/// Accessing a String's Unicode Representation
/// ===========================================
///
/// If you need to access the contents of a string as encoded in different
/// Unicode encodings, use one of the string's `unicodeScalars`, `utf16`, or
/// `utf8` properties. Each property provides access to a view of the string
/// as a series of code units, each encoded in a different Unicode encoding.
///
/// To demonstrate the different views available for every string, the
/// following examples use this `String` instance:
///
///     let cafe = "Cafe\u{301} du "
///     print(cafe)
///     // Prints "Caf du "
///
/// The `cafe` string is a collection of the nine characters that are visible
/// when the string is displayed.
///
///     print(cafe.count)
///     // Prints "9"
///     print(Array(cafe))
///     // Prints "["C", "a", "f", "", " ", "d", "u", " ", ""]"
///
/// Unicode Scalar View
/// -------------------
///
/// A string's `unicodeScalars` property is a collection of Unicode scalar
/// values, the 21-bit codes that are the basic unit of Unicode. Each scalar
/// value is represented by a `Unicode.Scalar` instance and is equivalent to a
/// UTF-32 code unit.
///
///     print(cafe.unicodeScalars.count)
///     // Prints "10"
///     print(Array(cafe.unicodeScalars))
///     // Prints "["C", "a", "f", "e", "\u{0301}", " ", "d", "u", " ", "\u{0001F30D}"]"
///     print(cafe.unicodeScalars.map { $0.value })
///     // Prints "[67, 97, 102, 101, 769, 32, 100, 117, 32, 127757]"
///
/// The `unicodeScalars` view's elements comprise each Unicode scalar value in
/// the `cafe` string. In particular, because `cafe` was declared using the
/// decomposed form of the `""` character, `unicodeScalars` contains the
/// scalar values for both the letter `"e"` (101) and the accent character
/// `""` (769).
///
/// UTF-16 View
/// -----------
///
/// A string's `utf16` property is a collection of UTF-16 code units, the
/// 16-bit encoding form of the string's Unicode scalar values. Each code unit
/// is stored as a `UInt16` instance.
///
///     print(cafe.utf16.count)
///     // Prints "11"
///     print(Array(cafe.utf16))
///     // Prints "[67, 97, 102, 101, 769, 32, 100, 117, 32, 55356, 57101]"
///
/// The elements of the `utf16` view are the code units for the string when
/// encoded in UTF-16. These elements match those accessed through indexed
/// `NSString` APIs.
///
///     let nscafe = cafe as NSString
///     print(nscafe.length)
///     // Prints "11"
///     print(nscafe.character(at: 3))
///     // Prints "101"
///
/// UTF-8 View
/// ----------
///
/// A string's `utf8` property is a collection of UTF-8 code units, the 8-bit
/// encoding form of the string's Unicode scalar values. Each code unit is
/// stored as a `UInt8` instance.
///
///     print(cafe.utf8.count)
///     // Prints "14"
///     print(Array(cafe.utf8))
///     // Prints "[67, 97, 102, 101, 204, 129, 32, 100, 117, 32, 240, 159, 140, 141]"
///
/// The elements of the `utf8` view are the code units for the string when
/// encoded in UTF-8. This representation matches the one used when `String`
/// instances are passed to C APIs.
///
///     let cLength = strlen(cafe)
///     print(cLength)
///     // Prints "14"
///
/// Measuring the Length of a String
/// ================================
///
/// When you need to know the length of a string, you must first consider what
/// you'll use the length for. Are you measuring the number of characters that
/// will be displayed on the screen, or are you measuring the amount of
/// storage needed for the string in a particular encoding? A single string
/// can have greatly differing lengths when measured by its different views.
///
/// For example, an ASCII character like the capital letter *A* is represented
/// by a single element in each of its four views. The Unicode scalar value of
/// *A* is `65`, which is small enough to fit in a single code unit in both
/// UTF-16 and UTF-8.
///
///     let capitalA = "A"
///     print(capitalA.count)
///     // Prints "1"
///     print(capitalA.unicodeScalars.count)
///     // Prints "1"
///     print(capitalA.utf16.count)
///     // Prints "1"
///     print(capitalA.utf8.count)
///     // Prints "1"
///
/// On the other hand, an emoji flag character is constructed from a pair of
/// Unicode scalar values, like `"\u{1F1F5}"` and `"\u{1F1F7}"`. Each of these
/// scalar values, in turn, is too large to fit into a single UTF-16 or UTF-8
/// code unit. As a result, each view of the string `""` reports a different
/// length.
///
///     let flag = ""
///     print(flag.count)
///     // Prints "1"
///     print(flag.unicodeScalars.count)
///     // Prints "2"
///     print(flag.utf16.count)
///     // Prints "4"
///     print(flag.utf8.count)
///     // Prints "8"
///
/// To check whether a string is empty, use its `isEmpty` property instead of
/// comparing the length of one of the views to `0`. Unlike with `isEmpty`,
/// calculating a view's `count` property requires iterating through the
/// elements of the string.
///
/// Accessing String View Elements
/// ==============================
///
/// To find individual elements of a string, use the appropriate view for your
/// task. For example, to retrieve the first word of a longer string, you can
/// search the string for a space and then create a new string from a prefix
/// of the string up to that point.
///
///     let name = "Marie Curie"
///     let firstSpace = name.firstIndex(of: " ") ?? name.endIndex
///     let firstName = name[..<firstSpace]
///     print(firstName)
///     // Prints "Marie"
///
/// Strings and their views share indices, so you can access the UTF-8 view of
/// the `name` string using the same `firstSpace` index.
///
///     print(Array(name.utf8[..<firstSpace]))
///     // Prints "[77, 97, 114, 105, 101]"
///
/// Note that an index into one view may not have an exact corresponding
/// position in another view. For example, the `flag` string declared above
/// comprises a single character, but is composed of eight code units when
/// encoded as UTF-8. The following code creates constants for the first and
/// second positions in the `flag.utf8` view. Accessing the `utf8` view with
/// these indices yields the first and second code UTF-8 units.
///
///     let firstCodeUnit = flag.startIndex
///     let secondCodeUnit = flag.utf8.index(after: firstCodeUnit)
///     // flag.utf8[firstCodeUnit] == 240
///     // flag.utf8[secondCodeUnit] == 159
///
/// When used to access the elements of the `flag` string itself, however, the
/// `secondCodeUnit` index does not correspond to the position of a specific
/// character. Instead of only accessing the specific UTF-8 code unit, that
/// index is treated as the position of the character at the index's encoded
/// offset. In the case of `secondCodeUnit`, that character is still the flag
/// itself.
///
///     // flag[firstCodeUnit] == ""
///     // flag[secondCodeUnit] == ""
///
/// If you need to validate that an index from one string's view corresponds
/// with an exact position in another view, use the index's
/// `samePosition(in:)` method or the `init(_:within:)` initializer.
///
///     if let exactIndex = secondCodeUnit.samePosition(in: flag) {
///         print(flag[exactIndex])
///     } else {
///         print("No exact match for this position.")
///     }
///     // Prints "No exact match for this position."
///
/// Performance Optimizations
/// =========================
///
/// Although strings in Swift have value semantics, strings use a copy-on-write
/// strategy to store their data in a buffer. This buffer can then be shared
/// by different copies of a string. A string's data is only copied lazily,
/// upon mutation, when more than one string instance is using the same
/// buffer. Therefore, the first in any sequence of mutating operations may
/// cost O(*n*) time and space.
///
/// When a string's contiguous storage fills up, a new buffer must be allocated
/// and data must be moved to the new storage. String buffers use an
/// exponential growth strategy that makes appending to a string a constant
/// time operation when averaged over many append operations.
///
/// Bridging Between String and NSString
/// ====================================
///
/// Any `String` instance can be bridged to `NSString` using the type-cast
/// operator (`as`), and any `String` instance that originates in Objective-C
/// may use an `NSString` instance as its storage. Because any arbitrary
/// subclass of `NSString` can become a `String` instance, there are no
/// guarantees about representation or efficiency when a `String` instance is
/// backed by `NSString` storage. Because `NSString` is immutable, it is just
/// as though the storage was shared by a copy. The first in any sequence of
/// mutating operations causes elements to be copied into unique, contiguous
/// storage which may cost O(*n*) time and space, where *n* is the length of
/// the string's encoded representation (or more, if the underlying `NSString`
/// has unusual performance characteristics).
///
/// For more information about the Unicode terms used in this discussion, see
/// the [Unicode.org glossary][glossary]. In particular, this discussion
/// mentions [extended grapheme clusters][clusters], [Unicode scalar
/// values][scalars], and [canonical equivalence][equivalence].
///
/// [glossary]: http://www.unicode.org/glossary/
/// [clusters]: http://www.unicode.org/glossary/#extended_grapheme_cluster
/// [scalars]: http://www.unicode.org/glossary/#unicode_scalar_value
/// [equivalence]: http://www.unicode.org/glossary/#canonical_equivalent
public struct String {

    /// Creates an empty string.
    ///
    /// Using this initializer is equivalent to initializing a string with an
    /// empty string literal.
    ///
    ///     let empty = ""
    ///     let alsoEmpty = String()
    public init()
}

extension String {

    /// A view of a string's contents as a collection of UTF-8 code units.
    ///
    /// You can access a string's view of UTF-8 code units by using its `utf8`
    /// property. A string's UTF-8 view encodes the string's Unicode scalar
    /// values as 8-bit integers.
    ///
    ///     let flowers = "Flowers "
    ///     for v in flowers.utf8 {
    ///         print(v)
    ///     }
    ///     // 70
    ///     // 108
    ///     // 111
    ///     // 119
    ///     // 101
    ///     // 114
    ///     // 115
    ///     // 32
    ///     // 240
    ///     // 159
    ///     // 146
    ///     // 144
    ///
    /// A string's Unicode scalar values can be up to 21 bits in length. To
    /// represent those scalar values using 8-bit integers, more than one UTF-8
    /// code unit is often required.
    ///
    ///     let flowermoji = ""
    ///     for v in flowermoji.unicodeScalars {
    ///         print(v, v.value)
    ///     }
    ///     //  128144
    ///
    ///     for v in flowermoji.utf8 {
    ///         print(v)
    ///     }
    ///     // 240
    ///     // 159
    ///     // 146
    ///     // 144
    ///
    /// In the encoded representation of a Unicode scalar value, each UTF-8 code
    /// unit after the first is called a *continuation byte*.
    ///
    /// UTF8View Elements Match Encoded C Strings
    /// =========================================
    ///
    /// Swift streamlines interoperation with C string APIs by letting you pass a
    /// `String` instance to a function as an `Int8` or `UInt8` pointer. When you
    /// call a C function using a `String`, Swift automatically creates a buffer
    /// of UTF-8 code units and passes a pointer to that buffer. The code units
    /// of that buffer match the code units in the string's `utf8` view.
    ///
    /// The following example uses the C `strncmp` function to compare the
    /// beginning of two Swift strings. The `strncmp` function takes two
    /// `const char*` pointers and an integer specifying the number of characters
    /// to compare. Because the strings are identical up to the 14th character,
    /// comparing only those characters results in a return value of `0`.
    ///
    ///     let s1 = "They call me 'Bell'"
    ///     let s2 = "They call me 'Stacey'"
    ///
    ///     print(strncmp(s1, s2, 14))
    ///     // Prints "0"
    ///     print(String(s1.utf8.prefix(14)))
    ///     // Prints "They call me '"
    ///
    /// Extending the compared character count to 15 includes the differing
    /// characters, so a nonzero result is returned.
    ///
    ///     print(strncmp(s1, s2, 15))
    ///     // Prints "-17"
    ///     print(String(s1.utf8.prefix(15)))
    ///     // Prints "They call me 'B"
    public struct UTF8View : BidirectionalCollection, CustomStringConvertible, CustomDebugStringConvertible {

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = String.Index

        /// The position of the first code unit if the UTF-8 view is
        /// nonempty.
        ///
        /// If the UTF-8 view is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: String.UTF8View.Index { get }

        /// The "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// In an empty UTF-8 view, `endIndex` is equal to `startIndex`.
        public var endIndex: String.UTF8View.Index { get }

        /// Returns the next consecutive position after `i`.
        ///
        /// - Precondition: The next position is representable.
        public func index(after i: String.UTF8View.Index) -> String.UTF8View.Index

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: String.UTF8View.Index) -> String.UTF8View.Index

        /// Returns the distance between two indices.
        ///
        /// Unless the collection conforms to the `BidirectionalCollection` protocol,
        /// `start` must be less than or equal to `end`.
        ///
        /// - Parameters:
        ///   - start: A valid index of the collection.
        ///   - end: Another valid index of the collection. If `end` is equal to
        ///     `start`, the result is zero.
        /// - Returns: The distance between `start` and `end`. The result can be
        ///   negative only if the collection conforms to the
        ///   `BidirectionalCollection` protocol.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
        ///   resulting distance.
        public func distance(from i: String.UTF8View.Index, to j: String.UTF8View.Index) -> Int

        /// Accesses the code unit at the given position.
        ///
        /// The following example uses the subscript to print the value of a
        /// string's first UTF-8 code unit.
        ///
        ///     let greeting = "Hello, friend!"
        ///     let i = greeting.utf8.startIndex
        ///     print("First character's UTF-8 code unit: \(greeting.utf8[i])")
        ///     // Prints "First character's UTF-8 code unit: 72"
        ///
        /// - Parameter position: A valid index of the view. `position`
        ///   must be less than the view's end index.
        public subscript(position: String.UTF8View.Index) -> UTF8.CodeUnit { get }

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        public var debugDescription: String { get }
    }

    /// A UTF-8 encoding of `self`.
    public var utf8: String.UTF8View

    /// A contiguously stored null-terminated UTF-8 representation of the string.
    ///
    /// To access the underlying memory, invoke `withUnsafeBufferPointer` on the
    /// array.
    ///
    ///     let s = "Hello!"
    ///     let bytes = s.utf8CString
    ///     print(bytes)
    ///     // Prints "[72, 101, 108, 108, 111, 33, 0]"
    ///
    ///     bytes.withUnsafeBufferPointer { ptr in
    ///         print(strlen(ptr.baseAddress!))
    ///     }
    ///     // Prints "6"
    public var utf8CString: ContiguousArray<CChar> { get }

    /// Creates a string corresponding to the given sequence of UTF-8 code units.
    @available(swift, introduced: 4.0, message: "Please use failable String.init?(_:UTF8View) when in Swift 3.2 mode")
    public init(_ utf8: String.UTF8View)

    /// The index type for subscripting a string.
    public typealias UTF8Index = String.UTF8View.Index
}

extension String {

    /// Creates a string containing the given character.
    ///
    /// - Parameter c: The character to convert to a string.
    public init(_ c: Character)
}

extension String : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension String {

    /// Creates a new string by copying the null-terminated UTF-8 data referenced
    /// by the given pointer.
    ///
    /// If `cString` contains ill-formed UTF-8 code unit sequences, this
    /// initializer replaces them with the Unicode replacement character
    /// (`"\u{FFFD}"`).
    ///
    /// The following example calls this initializer with pointers to the
    /// contents of two different `CChar` arrays---the first with well-formed
    /// UTF-8 code unit sequences and the second with an ill-formed sequence at
    /// the end.
    ///
    ///     let validUTF8: [CChar] = [67, 97, 102, -61, -87, 0]
    ///     validUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(cString: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "Caf"
    ///
    ///     let invalidUTF8: [CChar] = [67, 97, 102, -61, 0]
    ///     invalidUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(cString: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "Caf"
    ///
    /// - Parameter cString: A pointer to a null-terminated UTF-8 code sequence.
    public init(cString: UnsafePointer<CChar>)

    /// Creates a new string by copying the null-terminated UTF-8 data referenced
    /// by the given pointer.
    ///
    /// This is identical to init(cString: UnsafePointer<CChar> but operates on an
    /// unsigned sequence of bytes.
    public init(cString: UnsafePointer<UInt8>)

    /// Creates a new string by copying and validating the null-terminated UTF-8
    /// data referenced by the given pointer.
    ///
    /// This initializer does not try to repair ill-formed UTF-8 code unit
    /// sequences. If any are found, the result of the initializer is `nil`.
    ///
    /// The following example calls this initializer with pointers to the
    /// contents of two different `CChar` arrays---the first with well-formed
    /// UTF-8 code unit sequences and the second with an ill-formed sequence at
    /// the end.
    ///
    ///     let validUTF8: [CChar] = [67, 97, 102, -61, -87, 0]
    ///     validUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(validatingUTF8: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "Optional(Caf)"
    ///
    ///     let invalidUTF8: [CChar] = [67, 97, 102, -61, 0]
    ///     invalidUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String(validatingUTF8: ptr.baseAddress!)
    ///         print(s)
    ///     }
    ///     // Prints "nil"
    ///
    /// - Parameter cString: A pointer to a null-terminated UTF-8 code sequence.
    public init?(validatingUTF8 cString: UnsafePointer<CChar>)

    /// Creates a new string by copying the null-terminated data referenced by
    /// the given pointer using the specified encoding.
    ///
    /// When you pass `true` as `isRepairing`, this method replaces ill-formed
    /// sequences with the Unicode replacement character (`"\u{FFFD}"`);
    /// otherwise, an ill-formed sequence causes this method to stop decoding
    /// and return `nil`.
    ///
    /// The following example calls this method with pointers to the contents of
    /// two different `CChar` arrays---the first with well-formed UTF-8 code
    /// unit sequences and the second with an ill-formed sequence at the end.
    ///
    ///     let validUTF8: [UInt8] = [67, 97, 102, 195, 169, 0]
    ///     validUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String.decodeCString(ptr.baseAddress,
    ///                                      as: UTF8.self,
    ///                                      repairingInvalidCodeUnits: true)
    ///         print(s)
    ///     }
    ///     // Prints "Optional((Caf, false))"
    ///
    ///     let invalidUTF8: [UInt8] = [67, 97, 102, 195, 0]
    ///     invalidUTF8.withUnsafeBufferPointer { ptr in
    ///         let s = String.decodeCString(ptr.baseAddress,
    ///                                      as: UTF8.self,
    ///                                      repairingInvalidCodeUnits: true)
    ///         print(s)
    ///     }
    ///     // Prints "Optional((Caf, true))"
    ///
    /// - Parameters:
    ///   - cString: A pointer to a null-terminated code sequence encoded in
    ///     `encoding`.
    ///   - encoding: The Unicode encoding of the data referenced by `cString`.
    ///   - isRepairing: Pass `true` to create a new string, even when the data
    ///     referenced by `cString` contains ill-formed sequences. Ill-formed
    ///     sequences are replaced with the Unicode replacement character
    ///     (`"\u{FFFD}"`). Pass `false` to interrupt the creation of the new
    ///     string if an ill-formed sequence is detected.
    /// - Returns: A tuple with the new string and a Boolean value that indicates
    ///   whether any repairs were made. If `isRepairing` is `false` and an
    ///   ill-formed sequence is detected, this method returns `nil`.
    public static func decodeCString<Encoding>(_ cString: UnsafePointer<Encoding.CodeUnit>?, as encoding: Encoding.Type, repairingInvalidCodeUnits isRepairing: Bool = default) -> (result: String, repairsMade: Bool)? where Encoding : _UnicodeEncoding
}

extension String {

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of UTF-8 code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(_:)`. Do not store or return the pointer for
    /// later use.
    ///
    /// - Parameter body: A closure with a pointer parameter that points to a
    ///   null-terminated sequence of UTF-8 code units. If `body` has a return
    ///   value, that value is also used as the return value for the
    ///   `withCString(_:)` method. The pointer argument is valid only for the
    ///   duration of the method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withCString<Result>(_ body: (UnsafePointer<Int8>) throws -> Result) rethrows -> Result
}

extension String : CustomReflectable {

    /// A mirror that reflects the `String` instance.
    public var customMirror: Mirror { get }
}

extension String : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `String` instance.
    @available(*, deprecated, message: "String.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension String : TextOutputStream {

    /// Appends the given string to this string.
    /// 
    /// - Parameter other: A string to append.
    public mutating func write(_ other: String)
}

extension String : TextOutputStreamable {

    /// Writes the string into the given output stream.
    /// 
    /// - Parameter target: An output stream.
    public func write<Target>(to target: inout Target) where Target : TextOutputStream
}

extension String {

    @available(swift, deprecated: 3.2, message: "Please use String or Substring directly")
    public typealias CharacterView

    /// A view of the string's contents as a collection of characters.
    @available(swift, deprecated: 3.2, message: "Please use String or Substring directly")
    public var characters: String.CharacterView

    /// Applies the given closure to a mutable view of the string's characters.
    ///
    /// Do not use the string that is the target of this method inside the
    /// closure passed to `body`, as it may not have its correct value. Instead,
    /// use the closure's `CharacterView` argument.
    ///
    /// This example below uses the `withMutableCharacters(_:)` method to
    /// truncate the string `str` at the first space and to return the remainder
    /// of the string.
    ///
    ///     var str = "All this happened, more or less."
    ///     let afterSpace = str.withMutableCharacters {
    ///         chars -> String.CharacterView in
    ///         if let i = chars.firstIndex(of: " ") {
    ///             let result = chars[chars.index(after: i)...]
    ///             chars.removeSubrange(i...)
    ///             return result
    ///         }
    ///         return String.CharacterView()
    ///     }
    ///
    ///     print(str)
    ///     // Prints "All"
    ///     print(String(afterSpace))
    ///     // Prints "this happened, more or less."
    ///
    /// - Parameter body: A closure that takes a character view as its argument.
    ///   If `body` has a return value, that value is also used as the return
    ///   value for the `withMutableCharacters(_:)` method. The `CharacterView`
    ///   argument is valid only for the duration of the closure's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    @available(swift, deprecated: 3.2, message: "Please mutate String or Substring directly")
    public mutating func withMutableCharacters<R>(_ body: (inout String.CharacterView) -> R) -> R

    /// Creates a string from the given character view.
    ///
    /// Use this initializer to recover a string after performing a collection
    /// slicing operation on a string's character view.
    ///
    ///     let poem = """
    ///           'Twas brillig, and the slithy toves /
    ///           Did gyre and gimbal in the wabe: /
    ///           All mimsy were the borogoves /
    ///           And the mome raths outgrabe.
    ///           """
    ///     let excerpt = String(poem.characters.prefix(22)) + "..."
    ///     print(excerpt)
    ///     // Prints "'Twas brillig, and the..."
    ///
    /// - Parameter characters: A character view to convert to a string.
    @available(swift, deprecated: 3.2, message: "Please use String or Substring directly")
    public init(_ characters: String.CharacterView)
}

extension String : Hashable {

    /// The string's hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension String {

    /// Creates a string from the given Unicode code units in the specified
    /// encoding.
    ///
    /// - Parameters:
    ///   - codeUnits: A collection of code units encoded in the encoding
    ///     specified in `sourceEncoding`.
    ///   - sourceEncoding: The encoding in which `codeUnits` should be
    ///     interpreted.
    public init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Collection, Encoding : _UnicodeEncoding, C.Element == Encoding.CodeUnit

    /// Creates a string from the null-terminated sequence of bytes at the given
    /// pointer.
    ///
    /// - Parameters:
    ///   - nullTerminatedCodeUnits: A pointer to a sequence of contiguous code
    ///     units in the encoding specified in `sourceEncoding`, ending just
    ///     before the first zero code unit.
    ///   - sourceEncoding: The encoding in which the code units should be
    ///     interpreted.
    public init<Encoding>(decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : _UnicodeEncoding

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(encodedAs:_:)`. Do not store or return the
    /// pointer for later use.
    ///
    /// - Parameters:
    ///   - body: A closure with a pointer parameter that points to a
    ///     null-terminated sequence of code units. If `body` has a return
    ///     value, that value is also used as the return value for the
    ///     `withCString(encodedAs:_:)` method. The pointer argument is valid
    ///     only for the duration of the method's execution.
    ///   - targetEncoding: The encoding in which the code units should be
    ///     interpreted.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : _UnicodeEncoding
}

extension String {

    public init(_ scalar: Unicode.Scalar)
}

extension String {
}

extension String {
}

extension String {
}

extension String : ExpressibleByStringLiteral {

    /// Creates an instance initialized to the given string value.
    ///
    /// Do not call this initializer directly. It is used by the compiler when you
    /// initialize a string using a string literal. For example:
    ///
    ///     let nextStop = "Clark & Lake"
    ///
    /// This assignment to the `nextStop` constant calls this string literal
    /// initializer behind the scenes.
    public init(stringLiteral value: String)
}

extension String : CustomDebugStringConvertible {

    /// A representation of the string that is suitable for debugging.
    public var debugDescription: String { get }
}

extension String {

    /// Appends the given string to this string.
    ///
    /// The following example builds a customized greeting by using the
    /// `append(_:)` method:
    ///
    ///     var greeting = "Hello, "
    ///     if let name = getUserName() {
    ///         greeting.append(name)
    ///     } else {
    ///         greeting.append("friend")
    ///     }
    ///     print(greeting)
    ///     // Prints "Hello, friend"
    ///
    /// - Parameter other: Another string.
    public mutating func append(_ other: String)
}

extension String {

    public static func + (lhs: String, rhs: String) -> String

    public static func += (lhs: inout String, rhs: String)
}

extension String {

    /// Returns a lowercase version of the string.
    ///
    /// Here's an example of transforming a string to all lowercase letters.
    ///
    ///     let cafe = "BBQ Caf "
    ///     print(cafe.lowercased())
    ///     // Prints "bbq caf "
    ///
    /// - Returns: A lowercase copy of the string.
    ///
    /// - Complexity: O(*n*)
    public func lowercased() -> String

    /// Returns an uppercase version of the string.
    ///
    /// The following example transforms a string to uppercase letters:
    ///
    ///     let cafe = "Caf "
    ///     print(cafe.uppercased())
    ///     // Prints "CAF "
    ///
    /// - Returns: An uppercase copy of the string.
    ///
    /// - Complexity: O(*n*)
    public func uppercased() -> String

    /// Creates an instance from the description of a given
    /// `LosslessStringConvertible` instance.
    public init<T>(_ value: T) where T : LosslessStringConvertible
}

extension String : CustomStringConvertible {

    /// The value of this string.
    ///
    /// Using this property directly is discouraged. Instead, use simple
    /// assignment to create a new constant or variable equal to this string.
    public var description: String { get }
}

extension String : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: String, rhs: String) -> Bool
}

extension String : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: String, rhs: String) -> Bool
}

extension String {
}

extension String {
}

extension String {

    /// A position of a character or code unit in a string.
    public struct Index {
    }
}

extension String {

    /// Creates a new string by concatenating the given interpolations.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// you create a string using string interpolation. Instead, use string
    /// interpolation to create a new string by including values, literals,
    /// variables, or expressions enclosed in parentheses, prefixed by a
    /// backslash (`\(`...`)`).
    ///
    ///     let price = 2
    ///     let number = 3
    ///     let message = "If one cookie costs \(price) dollars, " +
    ///                   "\(number) cookies cost \(price * number) dollars."
    ///     print(message)
    ///     // Prints "If one cookie costs 2 dollars, 3 cookies cost 6 dollars."
    public init(stringInterpolation strings: String...)

    /// Creates a string containing the given expression's textual
    /// representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    public init<T>(stringInterpolationSegment expr: T)

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    public init<T>(stringInterpolationSegment expr: T) where T : TextOutputStreamable

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    public init<T>(stringInterpolationSegment expr: T) where T : CustomStringConvertible

    /// Creates a string containing the given value's textual representation.
    ///
    /// Do not call this initializer directly. It is used by the compiler when
    /// interpreting string interpolations.
    public init<T>(stringInterpolationSegment expr: T) where T : CustomStringConvertible, T : TextOutputStreamable
}

extension String {

    /// Creates a new string representing the given string repeated the specified
    /// number of times.
    ///
    /// For example, you can use this initializer to create a string with ten
    /// `"ab"` strings in a row.
    ///
    ///     let s = String(repeating: "ab", count: 10)
    ///     print(s)
    ///     // Prints "abababababababababab"
    ///
    /// - Parameters:
    ///   - repeatedValue: The string to repeat.
    ///   - count: The number of times to repeat `repeatedValue` in the resulting
    ///     string.
    public init(repeating repeatedValue: String, count: Int)

    /// A Boolean value indicating whether a string has no characters.
    public var isEmpty: Bool { get }
}

extension String {

    public func hasPrefix(_ prefix: String) -> Bool

    public func hasSuffix(_ suffix: String) -> Bool
}

extension String {

    /// Creates a string representing the given value in base 10, or some other
    /// specified base.
    ///
    /// The following example converts the maximal `Int` value to a string and
    /// prints its length:
    ///
    ///     let max = String(Int.max)
    ///     print("\(max) has \(max.count) digits.")
    ///     // Prints "9223372036854775807 has 19 digits."
    ///
    /// Numerals greater than 9 are represented as Roman letters. These letters
    /// start with `"A"` if `uppercase` is `true`; otherwise, with `"a"`.
    ///
    ///     let v = 999_999
    ///     print(String(v, radix: 2))
    ///     // Prints "11110100001000111111"
    ///
    ///     print(String(v, radix: 16))
    ///     // Prints "f423f"
    ///     print(String(v, radix: 16, uppercase: true))
    ///     // Prints "F423F"
    ///
    /// - Parameters:
    ///   - value: The value to convert to a string.
    ///   - radix: The base to use for the string representation. `radix` must be
    ///     at least 2 and at most 36. The default is 10.
    ///   - uppercase: Pass `true` to use uppercase letters to represent numerals
    ///     greater than 9, or `false` to use lowercase letters. The default is
    ///     `false`.
    public init<T>(_ value: T, radix: Int = default, uppercase: Bool = default) where T : BinaryInteger
}

extension String : StringProtocol, RangeReplaceableCollection {

    /// A type that represents the number of steps between two `String.Index`
    /// values, where one value is reachable from the other.
    ///
    /// In Swift, *reachability* refers to the ability to produce one value from
    /// the other through zero or more applications of `index(after:)`.
    public typealias IndexDistance = Int

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = Substring

    /// Creates a string representing the given character repeated the specified
    /// number of times.
    ///
    /// For example, use this initializer to create a string with ten `"0"`
    /// characters in a row.
    ///
    ///     let zeroes = String(repeating: "0" as Character, count: 10)
    ///     print(zeroes)
    ///     // Prints "0000000000"
    ///
    /// - Parameters:
    ///   - repeatedValue: The character to repeat.
    ///   - count: The number of times to repeat `repeatedValue` in the
    ///     resulting string.
    public init(repeating repeatedValue: Character, count: Int)

    /// Creates a new string containing the characters in the given sequence.
    ///
    /// You can use this initializer to create a new string from the result of
    /// one or more collection operations on a string's characters. For example:
    ///
    ///     let str = "The rain in Spain stays mainly in the plain."
    ///
    ///     let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    ///     let disemvoweled = String(str.lazy.filter { !vowels.contains($0) })
    ///
    ///     print(disemvoweled)
    ///     // Prints "Th rn n Spn stys mnly n th pln."
    ///
    /// - Parameter other: A string instance or another sequence of
    ///   characters.
    public init<S>(_ other: S) where S : LosslessStringConvertible, S : Sequence, S.Element == Character

    /// The position of the first character in a nonempty string.
    ///
    /// In an empty string, `startIndex` is equal to `endIndex`.
    public var startIndex: String.Index { get }

    /// A string's "past the end" position---that is, the position one greater
    /// than the last valid subscript argument.
    ///
    /// In an empty string, `endIndex` is equal to `startIndex`.
    public var endIndex: String.Index { get }

    /// The number of characters in a string.
    public var count: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: String.Index) -> String.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: String.Index) -> String.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(*n*), where *n* is the absolute value of `n`.
    public func index(_ i: String.Index, offsetBy n: String.IndexDistance) -> String.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(*n*), where *n* is the absolute value of `n`.
    public func index(_ i: String.Index, offsetBy n: String.IndexDistance, limitedBy limit: String.Index) -> String.Index?

    /// Returns the distance between two indices.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`.
    ///
    /// - Complexity: O(*n*), where *n* is the resulting distance.
    public func distance(from start: String.Index, to end: String.Index) -> String.IndexDistance

    /// Accesses the character at the given position.
    ///
    /// You can use the same indices for subscripting a string and its substring.
    /// For example, this code finds the first letter after the first space:
    ///
    ///     let str = "Greetings, friend! How are you?"
    ///     let firstSpace = str.firstIndex(of: " ") ?? str.endIndex
    ///     let substr = str[firstSpace...]
    ///     if let nextCapital = substr.firstIndex(where: { $0 >= "A" && $0 <= "Z" }) {
    ///         print("Capital after a space: \(str[nextCapital])")
    ///     }
    ///     // Prints "Capital after a space: H"
    ///
    /// - Parameter i: A valid index of the string. `i` must be less than the
    ///   string's end index.
    public subscript(i: String.Index) -> Character { get }
}

extension String {

    /// Creates a new string containing the characters in the given sequence.
    ///
    /// You can use this initializer to create a new string from the result of
    /// one or more collection operations on a string's characters. For example:
    ///
    ///     let str = "The rain in Spain stays mainly in the plain."
    ///
    ///     let vowels: Set<Character> = ["a", "e", "i", "o", "u"]
    ///     let disemvoweled = String(str.lazy.filter { !vowels.contains($0) })
    ///
    ///     print(disemvoweled)
    ///     // Prints "Th rn n Spn stys mnly n th pln."
    ///
    /// - Parameter characters: A string instance or another sequence of
    ///   characters.
    public init<S>(_ characters: S) where S : Sequence, S.Element == Character

    /// Reserves enough space in the string's underlying storage to store the
    /// specified number of ASCII characters.
    ///
    /// Because each character in a string can require more than a single ASCII
    /// character's worth of storage, additional allocation may be necessary
    /// when adding characters to a string after a call to
    /// `reserveCapacity(_:)`.
    ///
    /// - Parameter n: The minimum number of ASCII character's worth of storage
    ///   to allocate.
    ///
    /// - Complexity: O(*n*)
    public mutating func reserveCapacity(_ n: Int)

    /// Appends the given character to the string.
    ///
    /// The following example adds an emoji globe to the end of a string.
    ///
    ///     var globe = "Globe "
    ///     globe.append("")
    ///     print(globe)
    ///     // Prints "Globe "
    ///
    /// - Parameter c: The character to append to the string.
    public mutating func append(_ c: Character)

    public mutating func append(contentsOf newElements: String)

    public mutating func append(contentsOf newElements: Substring)

    /// Appends the characters in the given sequence to the string.
    ///
    /// - Parameter newElements: A sequence of characters.
    public mutating func append<S>(contentsOf newElements: S) where S : Sequence, S.Element == Character

    /// Replaces the text within the specified bounds with the given characters.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - bounds: The range of text to replace. The bounds of the range must be
    ///     valid indices of the string.
    ///   - newElements: The new characters to add to the string.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the string and
    ///   `newElements`. If the call to `replaceSubrange(_:with:)` simply
    ///   removes text at the end of the string, the complexity is O(*n*), where
    ///   *n* is equal to `bounds.count`.
    public mutating func replaceSubrange<C>(_ bounds: Range<String.Index>, with newElements: C) where C : Collection, C.Element == Character

    /// Inserts a new character at the specified position.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - newElement: The new character to insert into the string.
    ///   - i: A valid index of the string. If `i` is equal to the string's end
    ///     index, this methods appends `newElement` to the string.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the string.
    public mutating func insert(_ newElement: Character, at i: String.Index)

    /// Inserts a collection of characters at the specified position.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - newElements: A collection of `Character` elements to insert into the
    ///     string.
    ///   - i: A valid index of the string. If `i` is equal to the string's end
    ///     index, this methods appends the contents of `newElements` to the
    ///     string.
    ///
    /// - Complexity: O(*n*), where *n* is the combined length of the string and
    ///   `newElements`.
    public mutating func insert<S>(contentsOf newElements: S, at i: String.Index) where S : Collection, S.Element == Character

    /// Removes and returns the character at the specified position.
    ///
    /// All the elements following `i` are moved to close the gap. This example
    /// removes the hyphen from the middle of a string.
    ///
    ///     var nonempty = "non-empty"
    ///     if let i = nonempty.firstIndex(of: "-") {
    ///         nonempty.remove(at: i)
    ///     }
    ///     print(nonempty)
    ///     // Prints "nonempty"
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameter i: The position of the character to remove. `i` must be a
    ///   valid index of the string that is not equal to the string's end index.
    /// - Returns: The character that was removed.
    public mutating func remove(at i: String.Index) -> Character

    /// Removes the characters in the given range.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameter bounds: The range of the elements to remove. The upper and
    ///   lower bounds of `bounds` must be valid indices of the string and not
    ///   equal to the string's end index.
    /// - Parameter bounds: The range of the elements to remove. The upper and
    ///   lower bounds of `bounds` must be valid indices of the string.
    public mutating func removeSubrange(_ bounds: Range<String.Index>)

    /// Replaces this string with the empty string.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameter keepCapacity: Pass `true` to prevent the release of the
    ///   string's allocated storage. Retaining the storage can be a useful
    ///   optimization when you're planning to grow the string again. The
    ///   default value is `false`.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = default)
}

extension String {

    public func max<T>(_ x: T, _ y: T) -> T where T : Comparable

    public func min<T>(_ x: T, _ y: T) -> T where T : Comparable
}

extension String {

    /// A view of a string's contents as a collection of Unicode scalar values.
    ///
    /// You can access a string's view of Unicode scalar values by using its
    /// `unicodeScalars` property. Unicode scalar values are the 21-bit codes
    /// that are the basic unit of Unicode. Each scalar value is represented by
    /// a `Unicode.Scalar` instance and is equivalent to a UTF-32 code unit.
    ///
    ///     let flowers = "Flowers "
    ///     for v in flowers.unicodeScalars {
    ///         print(v.value)
    ///     }
    ///     // 70
    ///     // 108
    ///     // 111
    ///     // 119
    ///     // 101
    ///     // 114
    ///     // 115
    ///     // 32
    ///     // 128144
    ///
    /// Some characters that are visible in a string are made up of more than one
    /// Unicode scalar value. In that case, a string's `unicodeScalars` view
    /// contains more elements than the string itself.
    ///
    ///     let flag = ""
    ///     for c in flag {
    ///         print(c)
    ///     }
    ///     // 
    ///
    ///     for v in flag.unicodeScalars {
    ///         print(v.value)
    ///     }
    ///     // 127477
    ///     // 127479
    ///
    /// You can convert a `String.UnicodeScalarView` instance back into a string
    /// using the `String` type's `init(_:)` initializer.
    ///
    ///     let favemoji = "My favorite emoji is "
    ///     if let i = favemoji.unicodeScalars.firstIndex(where: { $0.value >= 128 }) {
    ///         let asciiPrefix = String(favemoji.unicodeScalars[..<i])
    ///         print(asciiPrefix)
    ///     }
    ///     // Prints "My favorite emoji is "
    public struct UnicodeScalarView : BidirectionalCollection, CustomStringConvertible, CustomDebugStringConvertible {

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = String.Index

        /// The position of the first Unicode scalar value if the string is
        /// nonempty.
        ///
        /// If the string is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: String.UnicodeScalarView.Index { get }

        /// The "past the end" position---that is, the position one greater than
        /// the last valid subscript argument.
        ///
        /// In an empty Unicode scalars view, `endIndex` is equal to `startIndex`.
        public var endIndex: String.UnicodeScalarView.Index { get }

        /// Returns the next consecutive location after `i`.
        ///
        /// - Precondition: The next location exists.
        public func index(after i: String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index

        /// Returns the previous consecutive location before `i`.
        ///
        /// - Precondition: The previous location exists.
        public func index(before i: String.UnicodeScalarView.Index) -> String.UnicodeScalarView.Index

        /// Accesses the Unicode scalar value at the given position.
        ///
        /// The following example searches a string's Unicode scalars view for a
        /// capital letter and then prints the character and Unicode scalar value
        /// at the found index:
        ///
        ///     let greeting = "Hello, friend!"
        ///     if let i = greeting.unicodeScalars.firstIndex(where: { "A"..."Z" ~= $0 }) {
        ///         print("First capital letter: \(greeting.unicodeScalars[i])")
        ///         print("Unicode scalar value: \(greeting.unicodeScalars[i].value)")
        ///     }
        ///     // Prints "First capital letter: H"
        ///     // Prints "Unicode scalar value: 72"
        ///
        /// - Parameter position: A valid index of the character view. `position`
        ///   must be less than the view's end index.
        public subscript(position: String.UnicodeScalarView.Index) -> Unicode.Scalar { get }

        /// An iterator over the Unicode scalars that make up a `UnicodeScalarView`
        /// collection.
        public struct Iterator : IteratorProtocol {

            /// Advances to the next element and returns it, or `nil` if no next
            /// element exists.
            ///
            /// Once `nil` has been returned, all subsequent calls return `nil`.
            ///
            /// - Precondition: `next()` has not been applied to a copy of `self`
            ///   since the copy was made.
            public mutating func next() -> Unicode.Scalar?
        }

        /// Returns an iterator over the Unicode scalars that make up this view.
        ///
        /// - Returns: An iterator over this collection's `Unicode.Scalar` elements.
        public func makeIterator() -> String.UnicodeScalarView.Iterator

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        public var debugDescription: String { get }
    }

    /// Creates a string corresponding to the given collection of Unicode
    /// scalars.
    ///
    /// You can use this initializer to create a new string from a slice of
    /// another string's `unicodeScalars` view.
    ///
    ///     let picnicGuest = "Deserving porcupine"
    ///     if let i = picnicGuest.unicodeScalars.firstIndex(of: " ") {
    ///         let adjective = String(picnicGuest.unicodeScalars[..<i])
    ///         print(adjective)
    ///     }
    ///     // Prints "Deserving"
    ///
    /// The `adjective` constant is created by calling this initializer with a
    /// slice of the `picnicGuest.unicodeScalars` view.
    ///
    /// - Parameter unicodeScalars: A collection of Unicode scalar values.
    public init(_ unicodeScalars: String.UnicodeScalarView)

    /// The index type for a string's `unicodeScalars` view.
    public typealias UnicodeScalarIndex = String.UnicodeScalarView.Index
}

extension String {

    /// The string's value represented as a collection of Unicode scalar values.
    public var unicodeScalars: String.UnicodeScalarView
}

extension String {

    /// A view of a string's contents as a collection of UTF-16 code units.
    ///
    /// You can access a string's view of UTF-16 code units by using its `utf16`
    /// property. A string's UTF-16 view encodes the string's Unicode scalar
    /// values as 16-bit integers.
    ///
    ///     let flowers = "Flowers "
    ///     for v in flowers.utf16 {
    ///         print(v)
    ///     }
    ///     // 70
    ///     // 108
    ///     // 111
    ///     // 119
    ///     // 101
    ///     // 114
    ///     // 115
    ///     // 32
    ///     // 55357
    ///     // 56464
    ///
    /// Unicode scalar values that make up a string's contents can be up to 21
    /// bits long. The longer scalar values may need two `UInt16` values for
    /// storage. Those "pairs" of code units are called *surrogate pairs*.
    ///
    ///     let flowermoji = ""
    ///     for v in flowermoji.unicodeScalars {
    ///         print(v, v.value)
    ///     }
    ///     //  128144
    ///
    ///     for v in flowermoji.utf16 {
    ///         print(v)
    ///     }
    ///     // 55357
    ///     // 56464
    ///
    /// To convert a `String.UTF16View` instance back into a string, use the
    /// `String` type's `init(_:)` initializer.
    ///
    ///     let favemoji = "My favorite emoji is "
    ///     if let i = favemoji.utf16.firstIndex(where: { $0 >= 128 }) {
    ///         let asciiPrefix = String(favemoji.utf16[..<i])
    ///         print(asciiPrefix)
    ///     }
    ///     // Prints "My favorite emoji is "
    ///
    /// UTF16View Elements Match NSString Characters
    /// ============================================
    ///
    /// The UTF-16 code units of a string's `utf16` view match the elements
    /// accessed through indexed `NSString` APIs.
    ///
    ///     print(flowers.utf16.count)
    ///     // Prints "10"
    ///
    ///     let nsflowers = flowers as NSString
    ///     print(nsflowers.length)
    ///     // Prints "10"
    ///
    /// Unlike `NSString`, however, `String.UTF16View` does not use integer
    /// indices. If you need to access a specific position in a UTF-16 view, use
    /// Swift's index manipulation methods. The following example accesses the
    /// fourth code unit in both the `flowers` and `nsflowers` strings:
    ///
    ///     print(nsflowers.character(at: 3))
    ///     // Prints "119"
    ///
    ///     let i = flowers.utf16.index(flowers.utf16.startIndex, offsetBy: 3)
    ///     print(flowers.utf16[i])
    ///     // Prints "119"
    ///
    /// Although the Swift overlay updates many Objective-C methods to return
    /// native Swift indices and index ranges, some still return instances of
    /// `NSRange`. To convert an `NSRange` instance to a range of
    /// `String.Index`, use the `Range(_:in:)` initializer, which takes an
    /// `NSRange` and a string as arguments.
    ///
    ///     let snowy = " Let it snow! "
    ///     let nsrange = NSRange(location: 3, length: 12)
    ///     if let range = Range(nsrange, in: snowy) {
    ///         print(snowy[range])
    ///     }
    ///     // Prints "Let it snow!"
    public struct UTF16View : BidirectionalCollection, CustomStringConvertible, CustomDebugStringConvertible {

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = String.Index

        /// The position of the first code unit if the `String` is
        /// nonempty; identical to `endIndex` otherwise.
        public var startIndex: String.UTF16View.Index { get }

        /// The "past the end" position---that is, the position one greater than
        /// the last valid subscript argument.
        ///
        /// In an empty UTF-16 view, `endIndex` is equal to `startIndex`.
        public var endIndex: String.UTF16View.Index { get }

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public struct Indices {
        }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: String.UTF16View.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: String.UTF16View.Index) -> String.UTF16View.Index

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: String.UTF16View.Index) -> String.UTF16View.Index

        /// Returns an index that is the specified distance from the given index.
        ///
        /// The following example obtains an index advanced four positions from a
        /// string's starting index and then prints the character at that position.
        ///
        ///     let s = "Swift"
        ///     let i = s.index(s.startIndex, offsetBy: 4)
        ///     print(s[i])
        ///     // Prints "t"
        ///
        /// The value passed as `n` must not offset `i` beyond the bounds of the
        /// collection.
        ///
        /// - Parameters:
        ///   - i: A valid index of the collection.
        ///   - n: The distance to offset `i`. `n` must not be negative unless the
        ///     collection conforms to the `BidirectionalCollection` protocol.
        /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
        ///   this is the same value as the result of `n` calls to `index(after:)`.
        ///   If `n` is negative, this is the same value as the result of `-n` calls
        ///   to `index(before:)`.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
        ///   value of `n`.
        public func index(_ i: String.UTF16View.Index, offsetBy n: Int) -> String.UTF16View.Index

        /// Returns an index that is the specified distance from the given index,
        /// unless that distance is beyond a given limiting index.
        ///
        /// The following example obtains an index advanced four positions from a
        /// string's starting index and then prints the character at that position.
        /// The operation doesn't require going beyond the limiting `s.endIndex`
        /// value, so it succeeds.
        ///
        ///     let s = "Swift"
        ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
        ///         print(s[i])
        ///     }
        ///     // Prints "t"
        ///
        /// The next example attempts to retrieve an index six positions from
        /// `s.startIndex` but fails, because that distance is beyond the index
        /// passed as `limit`.
        ///
        ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
        ///     print(j)
        ///     // Prints "nil"
        ///
        /// The value passed as `n` must not offset `i` beyond the bounds of the
        /// collection, unless the index passed as `limit` prevents offsetting
        /// beyond those bounds.
        ///
        /// - Parameters:
        ///   - i: A valid index of the collection.
        ///   - n: The distance to offset `i`. `n` must not be negative unless the
        ///     collection conforms to the `BidirectionalCollection` protocol.
        ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
        ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
        ///     limit that is greater than `i` has no effect.
        /// - Returns: An index offset by `n` from the index `i`, unless that index
        ///   would be beyond `limit` in the direction of movement. In that case,
        ///   the method returns `nil`.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
        ///   value of `n`.
        public func index(_ i: String.UTF16View.Index, offsetBy n: Int, limitedBy limit: String.UTF16View.Index) -> String.UTF16View.Index?

        /// Returns the distance between two indices.
        ///
        /// Unless the collection conforms to the `BidirectionalCollection` protocol,
        /// `start` must be less than or equal to `end`.
        ///
        /// - Parameters:
        ///   - start: A valid index of the collection.
        ///   - end: Another valid index of the collection. If `end` is equal to
        ///     `start`, the result is zero.
        /// - Returns: The distance between `start` and `end`. The result can be
        ///   negative only if the collection conforms to the
        ///   `BidirectionalCollection` protocol.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
        ///   resulting distance.
        public func distance(from start: String.UTF16View.Index, to end: String.UTF16View.Index) -> Int

        /// Accesses the code unit at the given position.
        ///
        /// The following example uses the subscript to print the value of a
        /// string's first UTF-16 code unit.
        ///
        ///     let greeting = "Hello, friend!"
        ///     let i = greeting.utf16.startIndex
        ///     print("First character's UTF-16 code unit: \(greeting.utf16[i])")
        ///     // Prints "First character's UTF-16 code unit: 72"
        ///
        /// - Parameter position: A valid index of the view. `position` must be
        ///   less than the view's end index.
        public subscript(i: String.UTF16View.Index) -> UTF16.CodeUnit { get }

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        public var debugDescription: String { get }
    }

    /// A UTF-16 encoding of `self`.
    public var utf16: String.UTF16View

    /// Creates a string corresponding to the given sequence of UTF-16 code units.
    @available(swift 4.0)
    public init(_ utf16: String.UTF16View)

    /// The index type for subscripting a string.
    public typealias UTF16Index = String.UTF16View.Index
}

extension String {

    /// Creates a new string from the given substring.
    ///
    /// - Parameter substring: A substring to convert to a standalone `String`
    ///   instance.
    ///
    /// - Complexity: O(*n*), where *n* is the length of `substring`.
    public init(_ substring: Substring)
}

extension String {

    /// Creates a String having the given content.
    ///
    /// If `codeUnits` is an ill-formed code unit sequence, the result is `nil`.
    ///
    /// - Complexity: O(N), where N is the length of the resulting `String`'s
    ///   UTF-16.
    public init?(_ codeUnits: Substring.UTF8View)
}

extension String {

    /// Creates a String having the given content.
    ///
    /// If `codeUnits` is an ill-formed code unit sequence, the result is `nil`.
    ///
    /// - Complexity: O(N), where N is the length of the resulting `String`'s
    ///   UTF-16.
    public init?(_ codeUnits: Substring.UTF16View)
}

extension String {

    /// Creates a String having the given content.
    ///
    /// - Complexity: O(N), where N is the length of the resulting `String`'s
    ///   UTF-16.
    public init(_ content: Substring.UnicodeScalarView)
}

extension String {

    /// Creates a String having the given content.
    ///
    /// - Complexity: O(N), where N is the length of the resulting `String`'s
    ///   UTF-16.
    @available(swift, deprecated: 3.2, message: "Please use String or Substring directly")
    public init(_ content: Substring.CharacterView)
}

/// In Swift 3.2, in the absence of type context,
///
///     someString[someString.startIndex..<someString.endIndex]
///
/// was deduced to be of type `String`.  Therefore have a more-specific
/// Swift-3-only `subscript` overload on `String` (and `Substring`) that
/// continues to produce `String`.
extension String {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    @available(swift 4)
    public subscript(r: Range<String.Index>) -> Substring { get }
}

extension String {
}

extension String : MirrorPath {
}

extension String {

    /// Creates a string representing the given value.
    ///
    /// Use this initializer to convert an instance of any type to its preferred
    /// representation as a `String` instance. The initializer creates the
    /// string representation of `instance` in one of the following ways,
    /// depending on its protocol conformance:
    ///
    /// - If `instance` conforms to the `TextOutputStreamable` protocol, the
    ///   result is obtained by calling `instance.write(to: s)` on an empty
    ///   string `s`.
    /// - If `instance` conforms to the `CustomStringConvertible` protocol, the
    ///   result is `instance.description`.
    /// - If `instance` conforms to the `CustomDebugStringConvertible` protocol,
    ///   the result is `instance.debugDescription`.
    /// - An unspecified result is supplied automatically by the Swift standard
    ///   library.
    ///
    /// For example, this custom `Point` struct uses the default representation
    /// supplied by the standard library.
    ///
    ///     struct Point {
    ///         let x: Int, y: Int
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     print(String(describing: p))
    ///     // Prints "Point(x: 21, y: 30)"
    ///
    /// After adding `CustomStringConvertible` conformance by implementing the
    /// `description` property, `Point` provides its own custom representation.
    ///
    ///     extension Point: CustomStringConvertible {
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     print(String(describing: p))
    ///     // Prints "(21, 30)"
    public init<Subject>(describing instance: Subject)

    /// Creates a string with a detailed representation of the given value,
    /// suitable for debugging.
    ///
    /// Use this initializer to convert an instance of any type to its custom
    /// debugging representation. The initializer creates the string
    /// representation of `instance` in one of the following ways, depending on
    /// its protocol conformance:
    ///
    /// - If `subject` conforms to the `CustomDebugStringConvertible` protocol,
    ///   the result is `subject.debugDescription`.
    /// - If `subject` conforms to the `CustomStringConvertible` protocol, the
    ///   result is `subject.description`.
    /// - If `subject` conforms to the `TextOutputStreamable` protocol, the
    ///   result is obtained by calling `subject.write(to: s)` on an empty
    ///   string `s`.
    /// - An unspecified result is supplied automatically by the Swift standard
    ///   library.
    ///
    /// For example, this custom `Point` struct uses the default representation
    /// supplied by the standard library.
    ///
    ///     struct Point {
    ///         let x: Int, y: Int
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     print(String(reflecting: p))
    ///     // Prints "p: Point = {
    ///     //           x = 21
    ///     //           y = 30
    ///     //         }"
    ///
    /// After adding `CustomDebugStringConvertible` conformance by implementing
    /// the `debugDescription` property, `Point` provides its own custom
    /// debugging representation.
    ///
    ///     extension Point: CustomDebugStringConvertible {
    ///         var debugDescription: String {
    ///             return "Point(x: \(x), y: \(y))"
    ///         }
    ///     }
    ///
    ///     print(String(reflecting: p))
    ///     // Prints "Point(x: 21, y: 30)"
    public init<Subject>(reflecting subject: Subject)
}

extension String.UTF8View {
}

extension String.UTF8View {

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public struct Iterator {
    }

    /// Returns an iterator over the elements of the collection.
    public func makeIterator() -> String.UTF8View.Iterator
}

extension String.UTF8View {

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }
}

extension String.UTF8View : CustomReflectable {

    /// Returns a mirror that reflects the UTF-8 view of a string.
    public var customMirror: Mirror { get }
}

extension String.UTF8View : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "UTF8View.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension String.UTF8View {
}

/// In Swift 3.2, in the absence of type context,
///
///   someString.utf8[someString.utf8.startIndex..<someString.utf8.endIndex]
///
/// was deduced to be of type `String.UTF8View`.  Provide a more-specific
/// Swift-3-only `subscript` overload that continues to produce
/// `String.UTF8View`.
extension String.UTF8View {

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = Substring.UTF8View

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    @available(swift 4)
    public subscript(r: Range<String.UTF8View.Index>) -> String.UTF8View.SubSequence { get }
}

extension String.Index : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: String.Index, rhs: String.Index) -> Bool
}

extension String.Index : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: String.Index, rhs: String.Index) -> Bool
}

extension String.Index : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }
}

extension String.Index {

    /// Creates a new index at the specified UTF-16 offset.
    ///
    /// - Parameter offset: An offset in UTF-16 code units.
    public init(encodedOffset offset: Int)

    /// The offset into a string's UTF-16 encoding for this index.
    public var encodedOffset: Int { get }
}

extension String.Index {
}

extension String.Index {

    /// Creates an index in the given string that corresponds exactly to the
    /// specified position.
    ///
    /// If the index passed as `sourcePosition` represents the start of an
    /// extended grapheme cluster---the element type of a string---then the
    /// initializer succeeds.
    ///
    /// The following example converts the position of the Unicode scalar `"e"`
    /// into its corresponding position in the string. The character at that
    /// position is the composed `""` character.
    ///
    ///     let cafe = "Cafe\u{0301}"
    ///     print(cafe)
    ///     // Prints "Caf"
    ///
    ///     let scalarsIndex = cafe.unicodeScalars.firstIndex(of: "e")!
    ///     let stringIndex = String.Index(scalarsIndex, within: cafe)!
    ///
    ///     print(cafe[...stringIndex])
    ///     // Prints "Caf"
    ///
    /// If the index passed as `sourcePosition` doesn't have an exact
    /// corresponding position in `target`, the result of the initializer is
    /// `nil`. For example, an attempt to convert the position of the combining
    /// acute accent (`"\u{0301}"`) fails. Combining Unicode scalars do not have
    /// their own position in a string.
    ///
    ///     let nextScalarsIndex = cafe.unicodeScalars.index(after: scalarsIndex)
    ///     let nextStringIndex = String.Index(nextScalarsIndex, within: cafe)
    ///
    ///     print(nextStringIndex)
    ///     // Prints "nil"
    ///
    /// - Parameters:
    ///   - sourcePosition: A position in a view of the `target` parameter.
    ///     `sourcePosition` must be a valid index of at least one of the views
    ///     of `target`.
    ///   - target: The string referenced by the resulting index.
    public init?(_ sourcePosition: String.Index, within target: String)

    /// Returns the position in the given UTF-8 view that corresponds exactly to
    /// this index.
    ///
    /// This example first finds the position of the character `""`, and then
    /// uses this method find the same position in the string's `utf8` view.
    ///
    ///     let cafe = "Caf"
    ///     if let i = cafe.firstIndex(of: "") {
    ///         let j = i.samePosition(in: cafe.utf8)!
    ///         print(Array(cafe.utf8[j...]))
    ///     }
    ///     // Prints "[195, 169]"
    ///
    /// - Parameter utf8: The view to use for the index conversion. This index
    ///   must be a valid index of at least one view of the string shared by
    ///   `utf8`.
    /// - Returns: The position in `utf8` that corresponds exactly to this index.
    ///   If this index does not have an exact corresponding position in `utf8`,
    ///   this method returns `nil`. For example, an attempt to convert the
    ///   position of a UTF-16 trailing surrogate returns `nil`.
    public func samePosition(in utf8: String.UTF8View) -> String.UTF8View.Index?

    /// Returns the position in the given UTF-16 view that corresponds exactly to
    /// this index.
    ///
    /// The index must be a valid index of `String(utf16)`.
    ///
    /// This example first finds the position of the character `""` and then
    /// uses this method find the same position in the string's `utf16` view.
    ///
    ///     let cafe = "Caf"
    ///     if let i = cafe.firstIndex(of: "") {
    ///         let j = i.samePosition(in: cafe.utf16)!
    ///         print(cafe.utf16[j])
    ///     }
    ///     // Prints "233"
    ///
    /// - Parameter utf16: The view to use for the index conversion. This index
    ///   must be a valid index of at least one view of the string shared by
    ///   `utf16`.
    /// - Returns: The position in `utf16` that corresponds exactly to this
    ///   index. If this index does not have an exact corresponding position in
    ///   `utf16`, this method returns `nil`. For example, an attempt to convert
    ///   the position of a UTF-8 continuation byte returns `nil`.
    public func samePosition(in utf16: String.UTF16View) -> String.UTF16View.Index?
}

extension String.Index {

    /// Creates an index in the given Unicode scalars view that corresponds
    /// exactly to the specified `UTF16View` position.
    ///
    /// The following example finds the position of a space in a string's `utf16`
    /// view and then converts that position to an index in the string's
    /// `unicodeScalars` view:
    ///
    ///     let cafe = "Caf "
    ///
    ///     let utf16Index = cafe.utf16.firstIndex(of: 32)!
    ///     let scalarIndex = String.Index(utf16Index, within: cafe.unicodeScalars)!
    ///
    ///     print(String(cafe.unicodeScalars[..<scalarIndex]))
    ///     // Prints "Caf"
    ///
    /// If the index passed as `sourcePosition` doesn't have an exact
    /// corresponding position in `unicodeScalars`, the result of the
    /// initializer is `nil`. For example, an attempt to convert the position of
    /// the trailing surrogate of a UTF-16 surrogate pair results in `nil`.
    ///
    /// - Parameters:
    ///   - sourcePosition: A position in the `utf16` view of a string. `utf16Index`
    ///     must be an element of `String(unicodeScalars).utf16.indices`.
    ///   - unicodeScalars: The `UnicodeScalarView` in which to find the new
    ///     position.
    public init?(_ sourcePosition: String.UTF16Index, within unicodeScalars: String.UnicodeScalarView)

    /// Returns the position in the given string that corresponds exactly to this
    /// index.
    ///
    /// This example first finds the position of a space (UTF-8 code point `32`)
    /// in a string's `utf8` view and then uses this method find the same position
    /// in the string.
    ///
    ///     let cafe = "Caf "
    ///     let i = cafe.unicodeScalars.firstIndex(of: "")
    ///     let j = i.samePosition(in: cafe)!
    ///     print(cafe[j...])
    ///     // Prints ""
    ///
    /// - Parameter characters: The string to use for the index conversion.
    ///   This index must be a valid index of at least one view of `characters`.
    /// - Returns: The position in `characters` that corresponds exactly to
    ///   this index. If this index does not have an exact corresponding
    ///   position in `characters`, this method returns `nil`. For example,
    ///   an attempt to convert the position of a UTF-8 continuation byte
    ///   returns `nil`.
    public func samePosition(in characters: String) -> String.Index?
}

extension String.Index {

    /// Creates an index in the given UTF-16 view that corresponds exactly to the
    /// specified string position.
    ///
    /// If the index passed as `sourcePosition` represents either the start of a
    /// Unicode scalar value or the position of a UTF-16 trailing surrogate,
    /// then the initializer succeeds. If `sourcePosition` does not have an
    /// exact corresponding position in `target`, then the result is `nil`. For
    /// example, an attempt to convert the position of a UTF-8 continuation byte
    /// results in `nil`.
    ///
    /// The following example finds the position of a space in a string and then
    /// converts that position to an index in the string's `utf16` view.
    ///
    ///     let cafe = "Caf "
    ///
    ///     let stringIndex = cafe.firstIndex(of: "")!
    ///     let utf16Index = String.Index(stringIndex, within: cafe.utf16)!
    ///
    ///     print(cafe.utf16[...utf16Index])
    ///     // Prints "Caf"
    ///
    /// - Parameters:
    ///   - sourcePosition: A position in at least one of the views of the string
    ///     shared by `target`.
    ///   - target: The `UTF16View` in which to find the new position.
    public init?(_ sourcePosition: String.Index, within target: String.UTF16View)

    /// Returns the position in the given view of Unicode scalars that
    /// corresponds exactly to this index.
    ///
    /// This index must be a valid index of `String(unicodeScalars).utf16`.
    ///
    /// This example first finds the position of a space (UTF-16 code point `32`)
    /// in a string's `utf16` view and then uses this method to find the same
    /// position in the string's `unicodeScalars` view.
    ///
    ///     let cafe = "Caf "
    ///     let i = cafe.utf16.firstIndex(of: 32)!
    ///     let j = i.samePosition(in: cafe.unicodeScalars)!
    ///     print(cafe.unicodeScalars[..<j])
    ///     // Prints "Caf"
    ///
    /// - Parameter unicodeScalars: The view to use for the index conversion.
    ///   This index must be a valid index of at least one view of the string
    ///   shared by `unicodeScalars`.
    /// - Returns: The position in `unicodeScalars` that corresponds exactly to
    ///   this index. If this index does not have an exact corresponding
    ///   position in `unicodeScalars`, this method returns `nil`. For example,
    ///   an attempt to convert the position of a UTF-16 trailing surrogate
    ///   returns `nil`.
    public func samePosition(in unicodeScalars: String.UnicodeScalarView) -> String.UnicodeScalarIndex?
}

extension String.Index {

    /// Creates an index in the given UTF-8 view that corresponds exactly to the
    /// specified `UTF16View` position.
    ///
    /// The following example finds the position of a space in a string's `utf16`
    /// view and then converts that position to an index in the string's
    /// `utf8` view.
    ///
    ///     let cafe = "Caf "
    ///
    ///     let utf16Index = cafe.utf16.firstIndex(of: 32)!
    ///     let utf8Index = String.UTF8View.Index(utf16Index, within: cafe.utf8)!
    ///
    ///     print(Array(cafe.utf8[..<utf8Index]))
    ///     // Prints "[67, 97, 102, 195, 169]"
    ///
    /// If the position passed in `utf16Index` doesn't have an exact
    /// corresponding position in `utf8`, the result of the initializer is
    /// `nil`. For example, because UTF-8 and UTF-16 represent high Unicode code
    /// points differently, an attempt to convert the position of the trailing
    /// surrogate of a UTF-16 surrogate pair fails.
    ///
    /// The next example attempts to convert the indices of the two UTF-16 code
    /// points that represent the teacup emoji (`""`). The index of the lead
    /// surrogate is successfully converted to a position in `utf8`, but the
    /// index of the trailing surrogate is not.
    ///
    ///     let emojiHigh = cafe.utf16.index(after: utf16Index)
    ///     print(String.UTF8View.Index(emojiHigh, within: cafe.utf8))
    ///     // Prints "Optional(String.Index(...))"
    ///
    ///     let emojiLow = cafe.utf16.index(after: emojiHigh)
    ///     print(String.UTF8View.Index(emojiLow, within: cafe.utf8))
    ///     // Prints "nil"
    ///
    /// - Parameters:
    ///   - sourcePosition: A position in a `String` or one of its views.
    ///   - target: The `UTF8View` in which to find the new position.
    public init?(_ sourcePosition: String.Index, within target: String.UTF8View)
}

extension String.UnicodeScalarView {
}

extension String.UnicodeScalarView : RangeReplaceableCollection {

    /// Creates an empty view instance.
    public init()

    /// Reserves enough space in the view's underlying storage to store the
    /// specified number of ASCII characters.
    ///
    /// Because a Unicode scalar value can require more than a single ASCII
    /// character's worth of storage, additional allocation may be necessary
    /// when adding to a Unicode scalar view after a call to
    /// `reserveCapacity(_:)`.
    ///
    /// - Parameter n: The minimum number of ASCII character's worth of storage
    ///   to allocate.
    ///
    /// - Complexity: O(*n*), where *n* is the capacity being reserved.
    public mutating func reserveCapacity(_ n: Int)

    /// Appends the given Unicode scalar to the view.
    ///
    /// - Parameter c: The character to append to the string.
    public mutating func append(_ c: Unicode.Scalar)

    /// Appends the Unicode scalar values in the given sequence to the view.
    ///
    /// - Parameter newElements: A sequence of Unicode scalar values.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the resulting view.
    public mutating func append<S>(contentsOf newElements: S) where S : Sequence, S.Element == Unicode.Scalar

    /// Replaces the elements within the specified bounds with the given Unicode
    /// scalar values.
    ///
    /// Calling this method invalidates any existing indices for use with this
    /// string.
    ///
    /// - Parameters:
    ///   - bounds: The range of elements to replace. The bounds of the range
    ///     must be valid indices of the view.
    ///   - newElements: The new Unicode scalar values to add to the string.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the view and
    ///   `newElements`. If the call to `replaceSubrange(_:with:)` simply
    ///   removes elements at the end of the string, the complexity is O(*n*),
    ///   where *n* is equal to `bounds.count`.
    public mutating func replaceSubrange<C>(_ bounds: Range<String.UnicodeScalarView.Index>, with newElements: C) where C : Collection, C.Element == Unicode.Scalar
}

extension String.UnicodeScalarView : CustomReflectable {

    /// Returns a mirror that reflects the Unicode scalars view of a string.
    public var customMirror: Mirror { get }
}

extension String.UnicodeScalarView : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "UnicodeScalarView.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension String.UnicodeScalarView {
}

/// In Swift 3.2, in the absence of type context,
///
///   someString.unicodeScalars[
///     someString.unicodeScalars.startIndex
///     ..< someString.unicodeScalars.endIndex]
///
/// was deduced to be of type `String.UnicodeScalarView`.  Provide a
/// more-specific Swift-3-only `subscript` overload that continues to produce
/// `String.UnicodeScalarView`.
extension String.UnicodeScalarView {

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = Substring.UnicodeScalarView

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    @available(swift 4)
    public subscript(r: Range<String.UnicodeScalarView.Index>) -> String.UnicodeScalarView.SubSequence { get }
}

extension String.UTF16View {
}

extension String.UTF16View : CustomReflectable {

    /// Returns a mirror that reflects the UTF-16 view of a string.
    public var customMirror: Mirror { get }
}

extension String.UTF16View : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "UTF16View.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension String.UTF16View {
}

/// In Swift 3.2, in the absence of type context,
///
///   someString.utf16[someString.utf16.startIndex..<someString.utf16.endIndex]
///
/// was deduced to be of type `String.UTF16View`.  Provide a more-specific
/// Swift-3-only `subscript` overload that continues to produce
/// `String.UTF16View`.
extension String.UTF16View {

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = Substring.UTF16View

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    @available(swift 4)
    public subscript(r: Range<String.UTF16View.Index>) -> String.UTF16View.SubSequence { get }
}

extension String.UTF8View.Iterator : IteratorProtocol {

    /// The type of element traversed by the iterator.
    public typealias Element = UTF8.CodeUnit

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> Unicode.UTF8.CodeUnit?
}

extension String.UTF16View.Indices : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.UTF16View.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = String.UTF16View.Indices

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = String.UTF16View.Indices

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: String.UTF16View.Indices.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: String.UTF16View.Indices.Index { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be non-uniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can cause an unexpected copy of the collection. To avoid the
    /// unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: String.UTF16View.Indices.Indices { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(i: String.UTF16View.Indices.Index) -> String.UTF16View.Indices.Index { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(bounds: Range<String.UTF16View.Indices.Index>) -> String.UTF16View.Indices { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: String.UTF16View.Indices.Index) -> String.UTF16View.Indices.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout String.UTF16View.Indices.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: String.UTF16View.Indices.Index) -> String.UTF16View.Indices.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout String.UTF16View.Indices.Index)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: String.UTF16View.Indices.Index, offsetBy n: Int) -> String.UTF16View.Indices.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: String.UTF16View.Indices.Index, offsetBy n: Int, limitedBy limit: String.UTF16View.Indices.Index) -> String.UTF16View.Indices.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: String.UTF16View.Indices.Index, to end: String.UTF16View.Indices.Index) -> Int
}

@available(*, deprecated, message: "it will be replaced or redesigned in Swift 4.0.  Instead of conforming to 'StringInterpolationConvertible', consider adding an 'init(_:String)'")
public typealias StringInterpolationConvertible

@available(*, deprecated, renamed: "ExpressibleByStringLiteral")
public typealias StringLiteralConvertible = ExpressibleByStringLiteral

/// The default type for an otherwise-unconstrained string literal.
public typealias StringLiteralType = String

/// A type that can represent a string as a collection of characters.
///
/// Do not declare new conformances to `StringProtocol`. Only the `String` and
/// `Substring` types in the standard library are valid conforming types.
public protocol StringProtocol : BidirectionalCollection, Comparable, ExpressibleByStringLiteral, Hashable, LosslessStringConvertible, TextOutputStream, TextOutputStreamable where Self.Element == Character, Self.SubSequence : StringProtocol {

    associatedtype UTF8View : Collection where Self.UTF8View.Element == UInt8

    associatedtype UTF16View : BidirectionalCollection where Self.UTF16View.Element == UInt16

    associatedtype UnicodeScalarView : BidirectionalCollection where Self.UnicodeScalarView.Element == Unicode.Scalar

    public var utf8: Self.UTF8View { get }

    public var utf16: Self.UTF16View { get }

    public var unicodeScalars: Self.UnicodeScalarView { get }

    public func hasPrefix(_ prefix: String) -> Bool

    public func hasSuffix(_ prefix: String) -> Bool

    public func lowercased() -> String

    public func uppercased() -> String

    /// Creates a string from the given Unicode code units in the specified
    /// encoding.
    ///
    /// - Parameters:
    ///   - codeUnits: A collection of code units encoded in the encoding
    ///     specified in `sourceEncoding`.
    ///   - sourceEncoding: The encoding in which `codeUnits` should be
    ///     interpreted.
    public init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Collection, Encoding : _UnicodeEncoding, C.Element == Encoding.CodeUnit

    /// Creates a string from the null-terminated, UTF-8 encoded sequence of
    /// bytes at the given pointer.
    ///
    /// - Parameter nullTerminatedUTF8: A pointer to a sequence of contiguous,
    ///   UTF-8 encoded bytes ending just before the first zero byte.
    public init(cString nullTerminatedUTF8: UnsafePointer<CChar>)

    /// Creates a string from the null-terminated sequence of bytes at the given
    /// pointer.
    ///
    /// - Parameters:
    ///   - nullTerminatedCodeUnits: A pointer to a sequence of contiguous code
    ///     units in the encoding specified in `sourceEncoding`, ending just
    ///     before the first zero code unit.
    ///   - sourceEncoding: The encoding in which the code units should be
    ///     interpreted.
    public init<Encoding>(decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : _UnicodeEncoding

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of UTF-8 code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(_:)`. Do not store or return the pointer for
    /// later use.
    ///
    /// - Parameter body: A closure with a pointer parameter that points to a
    ///   null-terminated sequence of UTF-8 code units. If `body` has a return
    ///   value, that value is also used as the return value for the
    ///   `withCString(_:)` method. The pointer argument is valid only for the
    ///   duration of the method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withCString<Result>(_ body: (UnsafePointer<CChar>) throws -> Result) rethrows -> Result

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(encodedAs:_:)`. Do not store or return the
    /// pointer for later use.
    ///
    /// - Parameters:
    ///   - body: A closure with a pointer parameter that points to a
    ///     null-terminated sequence of code units. If `body` has a return
    ///     value, that value is also used as the return value for the
    ///     `withCString(encodedAs:_:)` method. The pointer argument is valid
    ///     only for the duration of the method's execution.
    ///   - targetEncoding: The encoding in which the code units should be
    ///     interpreted.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withCString<Result, Encoding>(encodedAs targetEncoding: Encoding.Type, _ body: (UnsafePointer<Encoding.CodeUnit>) throws -> Result) rethrows -> Result where Encoding : _UnicodeEncoding
}

extension StringProtocol {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public var hashValue: Int { get }

    public func hash(into hasher: inout Hasher)
}

extension StringProtocol {

    public static func == <S>(lhs: Self, rhs: S) -> Bool where S : StringProtocol

    public static func != <S>(lhs: Self, rhs: S) -> Bool where S : StringProtocol

    public static func < <R>(lhs: Self, rhs: R) -> Bool where R : StringProtocol

    public static func > <R>(lhs: Self, rhs: R) -> Bool where R : StringProtocol

    public static func <= <R>(lhs: Self, rhs: R) -> Bool where R : StringProtocol

    public static func >= <R>(lhs: Self, rhs: R) -> Bool where R : StringProtocol
}

extension StringProtocol {
}

extension StringProtocol {
}

extension StringProtocol {

    /// Returns a Boolean value indicating whether the string begins with the
    /// specified prefix.
    ///
    /// The comparison is both case sensitive and Unicode safe. The
    /// case-sensitive comparison will only match strings whose corresponding
    /// characters have the same case.
    ///
    ///     let cafe = "Caf du Monde"
    ///
    ///     // Case sensitive
    ///     print(cafe.hasPrefix("caf"))
    ///     // Prints "false"
    ///
    /// The Unicode-safe comparison matches Unicode scalar values rather than the
    /// code points used to compose them. The example below uses two strings
    /// with different forms of the `""` character---the first uses the composed
    /// form and the second uses the decomposed form.
    ///
    ///     // Unicode safe
    ///     let composedCafe = "Caf"
    ///     let decomposedCafe = "Cafe\u{0301}"
    ///
    ///     print(cafe.hasPrefix(composedCafe))
    ///     // Prints "true"
    ///     print(cafe.hasPrefix(decomposedCafe))
    ///     // Prints "true"
    ///
    /// - Parameter prefix: A possible prefix to test against this string.
    /// - Returns: `true` if the string begins with `prefix`; otherwise, `false`.
    public func hasPrefix<Prefix>(_ prefix: Prefix) -> Bool where Prefix : StringProtocol

    /// Returns a Boolean value indicating whether the string ends with the
    /// specified suffix.
    ///
    /// The comparison is both case sensitive and Unicode safe. The
    /// case-sensitive comparison will only match strings whose corresponding
    /// characters have the same case.
    ///
    ///     let plans = "Let's meet at the caf"
    ///
    ///     // Case sensitive
    ///     print(plans.hasSuffix("Caf"))
    ///     // Prints "false"
    ///
    /// The Unicode-safe comparison matches Unicode scalar values rather than the
    /// code points used to compose them. The example below uses two strings
    /// with different forms of the `""` character---the first uses the composed
    /// form and the second uses the decomposed form.
    ///
    ///     // Unicode safe
    ///     let composedCafe = "caf"
    ///     let decomposedCafe = "cafe\u{0301}"
    ///
    ///     print(plans.hasSuffix(composedCafe))
    ///     // Prints "true"
    ///     print(plans.hasSuffix(decomposedCafe))
    ///     // Prints "true"
    ///
    /// - Parameter suffix: A possible suffix to test against this string.
    /// - Returns: `true` if the string ends with `suffix`; otherwise, `false`.
    public func hasSuffix<Suffix>(_ suffix: Suffix) -> Bool where Suffix : StringProtocol
}

/// A slice of a string.
///
/// When you create a slice of a string, a `Substring` instance is the result.
/// Operating on substrings is fast and efficient because a substring shares
/// its storage with the original string. The `Substring` type presents the
/// same interface as `String`, so you can avoid or defer any copying of the
/// string's contents.
///
/// The following example creates a `greeting` string, and then finds the
/// substring of the first sentence:
///
///     let greeting = "Hi there! It's nice to meet you! "
///     let endOfSentence = greeting.firstIndex(of: "!")!
///     let firstSentence = greeting[...endOfSentence]
///     // firstSentence == "Hi there!"
///
/// You can perform many string operations on a substring. Here, we find the
/// length of the first sentence and create an uppercase version.
///
///     print("'\(firstSentence)' is \(firstSentence.count) characters long.")
///     // Prints "'Hi there!' is 9 characters long."
///
///     let shoutingSentence = firstSentence.uppercased()
///     // shoutingSentence == "HI THERE!"
///
/// Converting a Substring to a String
/// ==================================
///
/// This example defines a `rawData` string with some unstructured data, and
/// then uses the string's `prefix(while:)` method to create a substring of
/// the numeric prefix:
///
///     let rawInput = "126 a.b 22219 zzzzzz"
///     let numericPrefix = rawInput.prefix(while: { "0"..."9" ~= $0 })
///     // numericPrefix is the substring "126"
///
/// When you need to store a substring or pass it to a function that requires a
/// `String` instance, you can convert it to a `String` by using the
/// `String(_:)` initializer. Calling this initializer copies the contents of
/// the substring to a new string.
///
///     func parseAndAddOne(_ s: String) -> Int {
///         return Int(s, radix: 10)! + 1
///     }
///     _ = parseAndAddOne(numericPrefix)
///     // error: cannot convert value...
///     let incrementedPrefix = parseAndAddOne(String(numericPrefix))
///     // incrementedPrefix == 127
///
/// Alternatively, you can convert the function that takes a `String` to one
/// that is generic over the `StringProtocol` protocol. The following code
/// declares a generic version of the `parseAndAddOne(_:)` function:
///
///     func genericParseAndAddOne<S: StringProtocol>(_ s: S) -> Int {
///         return Int(s, radix: 10)! + 1
///     }
///     let genericallyIncremented = genericParseAndAddOne(numericPrefix)
///     // genericallyIncremented == 127
///
/// You can call this generic function with an instance of either `String` or
/// `Substring`.
///
/// - Important: Don't store substrings longer than you need them to perform a
///   specific operation. A substring holds a reference to the entire storage
///   of the string it comes from, not just to the portion it presents, even
///   when there is no other reference to the original string. Storing
///   substrings may, therefore, prolong the lifetime of string data that is
///   no longer otherwise accessible, which can appear to be memory leakage.
public struct Substring : StringProtocol {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.Index

    /// A sequence that represents a contiguous subrange of the collection's
    /// elements.
    ///
    /// This associated type appears as a requirement in the `Sequence`
    /// protocol, but it is restated here with stricter constraints. In a
    /// collection, the subsequence should also conform to `Collection`.
    public typealias SubSequence = Substring

    /// Creates an empty substring.
    public init()

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Substring.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Substring.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Substring.Index) -> Substring.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Substring.Index) -> Substring.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Substring.Index, offsetBy n: Int) -> Substring.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Substring.Index, offsetBy n: Int, limitedBy limit: Substring.Index) -> Substring.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Substring.Index, to end: Substring.Index) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(i: Substring.Index) -> Character { get }

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C>(_ bounds: Range<Substring.Index>, with newElements: C) where C : Collection, C.Element == Character

    public mutating func replaceSubrange(_ bounds: Range<Substring.Index>, with newElements: Substring)

    /// Creates a string from the given Unicode code units in the specified
    /// encoding.
    ///
    /// - Parameters:
    ///   - codeUnits: A collection of code units encoded in the encoding
    ///     specified in `sourceEncoding`.
    ///   - sourceEncoding: The encoding in which `codeUnits` should be
    ///     interpreted.
    public init<C, Encoding>(decoding codeUnits: C, as sourceEncoding: Encoding.Type) where C : Collection, Encoding : _UnicodeEncoding, C.Element == Encoding.CodeUnit

    /// Creates a string from the null-terminated, UTF-8 encoded sequence of
    /// bytes at the given pointer.
    ///
    /// - Parameter nullTerminatedUTF8: A pointer to a sequence of contiguous,
    ///   UTF-8 encoded bytes ending just before the first zero byte.
    public init(cString nullTerminatedUTF8: UnsafePointer<CChar>)

    /// Creates a string from the null-terminated sequence of bytes at the given
    /// pointer.
    ///
    /// - Parameters:
    ///   - nullTerminatedCodeUnits: A pointer to a sequence of contiguous code
    ///     units in the encoding specified in `sourceEncoding`, ending just
    ///     before the first zero code unit.
    ///   - sourceEncoding: The encoding in which the code units should be
    ///     interpreted.
    public init<Encoding>(decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>, as sourceEncoding: Encoding.Type) where Encoding : _UnicodeEncoding

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of UTF-8 code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(_:)`. Do not store or return the pointer for
    /// later use.
    ///
    /// - Parameter body: A closure with a pointer parameter that points to a
    ///   null-terminated sequence of UTF-8 code units. If `body` has a return
    ///   value, that value is also used as the return value for the
    ///   `withCString(_:)` method. The pointer argument is valid only for the
    ///   duration of the method's execution.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withCString<Result>(_ body: (UnsafePointer<CChar>) throws -> Result) rethrows -> Result

    /// Calls the given closure with a pointer to the contents of the string,
    /// represented as a null-terminated sequence of code units.
    ///
    /// The pointer passed as an argument to `body` is valid only during the
    /// execution of `withCString(encodedAs:_:)`. Do not store or return the
    /// pointer for later use.
    ///
    /// - Parameters:
    ///   - body: A closure with a pointer parameter that points to a
    ///     null-terminated sequence of code units. If `body` has a return
    ///     value, that value is also used as the return value for the
    ///     `withCString(encodedAs:_:)` method. The pointer argument is valid
    ///     only for the duration of the method's execution.
    ///   - targetEncoding: The encoding in which the code units should be
    ///     interpreted.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withCString<Result, TargetEncoding>(encodedAs targetEncoding: TargetEncoding.Type, _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result) rethrows -> Result where TargetEncoding : _UnicodeEncoding
}

extension Substring {

    public struct UTF8View {
    }
}

extension Substring : Equatable {
}

extension Substring {
}

extension Substring : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension Substring : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "Substring.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Substring : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension Substring : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

extension Substring : LosslessStringConvertible {

    /// Instantiates an instance of the conforming type from a string
    /// representation.
    public init(_ content: String)
}

extension Substring {

    public var utf8: Substring.UTF8View

    /// Creates a Substring having the given content.
    ///
    /// - Complexity: O(1)
    public init(_ content: Substring.UTF8View)
}

extension Substring {

    public struct UTF16View {
    }
}

extension Substring {

    public var utf16: Substring.UTF16View

    /// Creates a Substring having the given content.
    ///
    /// - Complexity: O(1)
    public init(_ content: Substring.UTF16View)
}

extension Substring {

    public struct UnicodeScalarView {
    }
}

extension Substring {

    public var unicodeScalars: Substring.UnicodeScalarView

    /// Creates a Substring having the given content.
    ///
    /// - Complexity: O(1)
    public init(_ content: Substring.UnicodeScalarView)
}

extension Substring {

    @available(swift, deprecated: 3.2, message: "Please use String or Substring directly")
    public typealias CharacterView
}

extension Substring {

    @available(swift, deprecated: 3.2, message: "Please use String or Substring directly")
    public var characters: Substring.CharacterView

    /// Creates a Substring having the given content.
    ///
    /// - Complexity: O(1)
    public init(_ content: Substring.CharacterView)
}

extension Substring : RangeReplaceableCollection {

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    public init<S>(_ elements: S) where S : Sequence, S.Element == Character

    public mutating func append<S>(contentsOf elements: S) where S : Sequence, S.Element == Character
}

extension Substring {

    public func lowercased() -> String

    public func uppercased() -> String

    public func filter(_ isIncluded: (Substring.Element) throws -> Bool) rethrows -> String
}

extension Substring : TextOutputStream {

    /// Appends the given string to the stream.
    public mutating func write(_ other: String)
}

extension Substring : TextOutputStreamable {

    /// Writes a textual representation of this instance into the given output
    /// stream.
    public func write<Target>(to target: inout Target) where Target : TextOutputStream
}

extension Substring : ExpressibleByUnicodeScalarLiteral {

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(unicodeScalarLiteral value: String)
}

extension Substring : ExpressibleByExtendedGraphemeClusterLiteral {

    /// Creates an instance initialized to the given value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(extendedGraphemeClusterLiteral value: String)
}

extension Substring : ExpressibleByStringLiteral {

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral value: String)
}

extension Substring {

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    @available(swift 4)
    public subscript(r: Range<Substring.Index>) -> Substring { get }
}

extension Substring.UTF8View : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Substring.UTF8View.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Substring.UTF8View.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Substring.UTF8View.Index) -> Substring.UTF8View.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Substring.UTF8View.Index) -> Substring.UTF8View.Index

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(i: Substring.UTF8View.Index) -> String.UTF8View.Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(r: Range<Substring.UTF8View.Index>) -> Substring.UTF8View { get }
}

extension Substring.UTF16View : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Substring.UTF16View.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Substring.UTF16View.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Substring.UTF16View.Index) -> Substring.UTF16View.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Substring.UTF16View.Index) -> Substring.UTF16View.Index

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(i: Substring.UTF16View.Index) -> UTF16.CodeUnit { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(r: Range<Substring.UTF16View.Index>) -> Substring.UTF16View { get }
}

extension Substring.UnicodeScalarView : BidirectionalCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = String.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Substring.UnicodeScalarView.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Substring.UnicodeScalarView.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Substring.UnicodeScalarView.Index) -> Substring.UnicodeScalarView.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Substring.UnicodeScalarView.Index) -> Substring.UnicodeScalarView.Index

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(i: Substring.UnicodeScalarView.Index) -> Unicode.Scalar { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    public subscript(r: Range<Substring.UnicodeScalarView.Index>) -> Substring.UnicodeScalarView { get }
}

extension Substring.UnicodeScalarView : RangeReplaceableCollection {

    /// Creates a new, empty collection.
    public init()

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the combined length of the collection
    ///   and `newElements`. If the call to `replaceSubrange` simply appends the
    ///   contents of `newElements` to the collection, the complexity is O(*n*),
    ///   where *n* is the length of `newElements`.
    public mutating func replaceSubrange<C>(_ target: Range<Substring.UnicodeScalarView.Index>, with replacement: C) where C : Collection, C.Element == Substring.UnicodeScalarView.Element
}

/// A type that can be the target of text-streaming operations.
///
/// You can send the output of the standard library's `print(_:to:)` and
/// `dump(_:to:)` functions to an instance of a type that conforms to the
/// `TextOutputStream` protocol instead of to standard output. Swift's
/// `String` type conforms to `TextOutputStream` already, so you can capture
/// the output from `print(_:to:)` and `dump(_:to:)` in a string instead of
/// logging it to standard output.
///
///     var s = ""
///     for n in 1...5 {
///         print(n, terminator: "", to: &s)
///     }
///     // s == "12345"
///
/// Conforming to the TextOutputStream Protocol
/// ===========================================
///
/// To make your custom type conform to the `TextOutputStream` protocol,
/// implement the required `write(_:)` method. Functions that use a
/// `TextOutputStream` target may call `write(_:)` multiple times per writing
/// operation.
///
/// As an example, here's an implementation of an output stream that converts
/// any input to its plain ASCII representation before sending it to standard
/// output.
///
///     struct ASCIILogger: TextOutputStream {
///         mutating func write(_ string: String) {
///             let ascii = string.unicodeScalars.lazy.map { scalar in
///                 scalar == "\n"
///                   ? "\n"
///                   : scalar.escaped(asASCII: true)
///             }
///             print(ascii.joined(separator: ""), terminator: "")
///         }
///     }
///
/// The `ASCIILogger` type's `write(_:)` method processes its string input by
/// escaping each Unicode scalar, with the exception of `"\n"` line returns.
/// By sending the output of the `print(_:to:)` function to an instance of
/// `ASCIILogger`, you invoke its `write(_:)` method.
///
///     let s = "Hearts  and Diamonds "
///     print(s)
///     // Prints "Hearts  and Diamonds "
///
///     var asciiLogger = ASCIILogger()
///     print(s, to: &asciiLogger)
///     // Prints "Hearts \u{2661} and Diamonds \u{2662}"
public protocol TextOutputStream {

    /// Appends the given string to the stream.
    public mutating func write(_ string: String)
}

/// A source of text-streaming operations.
///
/// Instances of types that conform to the `TextOutputStreamable` protocol can
/// write their value to instances of any type that conforms to the
/// `TextOutputStream` protocol. The Swift standard library's text-related
/// types, `String`, `Character`, and `Unicode.Scalar`, all conform to
/// `TextOutputStreamable`.
///
/// Conforming to the TextOutputStreamable Protocol
/// =====================================
///
/// To add `TextOutputStreamable` conformance to a custom type, implement the
/// required `write(to:)` method. Call the given output stream's `write(_:)`
/// method in your implementation.
public protocol TextOutputStreamable {

    /// Writes a textual representation of this instance into the given output
    /// stream.
    public func write<Target>(to target: inout Target) where Target : TextOutputStream
}

/// An unsigned integer value type.
///
/// On 32-bit platforms, `UInt` is the same size as `UInt32`, and
/// on 64-bit platforms, `UInt` is the same size as `UInt64`.
public struct UInt : FixedWidthInteger, UnsignedInteger {

    /// A type that represents an integer literal.
    public typealias IntegerLiteralType = UInt

    /// Creates a new instance with the same memory representation as the given
    /// value.
    ///
    /// This initializer does not perform any range or overflow checking. The
    /// resulting instance may not have the same numeric value as
    /// `bitPattern`---it is only guaranteed to use the same pattern of bits in
    /// its binary representation.
    ///
    /// - Parameter x: A value to use as the source of the new instance's binary
    ///   representation.
    public init(bitPattern x: Int)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Double)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Double)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float80)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float80)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UInt, rhs: UInt) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: UInt, rhs: UInt) -> Bool

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x += 120
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout UInt, rhs: UInt)

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     var x: UInt8 = 21
    ///     x - 50
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout UInt, rhs: UInt)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x * 21
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout UInt, rhs: UInt)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     var x = 21
    ///     x /= 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func /= (lhs: inout UInt, rhs: UInt)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.dividedReportingOverflow(by: 0)` is `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the division along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   quotient. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains either the truncated quotient
    ///   or, if the quotient is undefined, the dividend.
    public func dividedReportingOverflow(by other: UInt) -> (partialValue: UInt, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.remainderReportingOverflow(dividingBy: 0)` is
    /// `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the operation along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   remainder. If the `overflow` component is `true`, an overflow occurred
    ///   during division and the `partialValue` component contains either the
    ///   entire remainder or, if the remainder is undefined, the dividend.
    public func remainderReportingOverflow(dividingBy other: UInt) -> (partialValue: UInt, overflow: Bool)

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: A tuple containing the result of the addition along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   sum. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated sum of this value
    ///   and `rhs`.
    public func addingReportingOverflow(_ other: UInt) -> (partialValue: UInt, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    /// the operation.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: A tuple containing the result of the subtraction along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   difference. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains the truncated result of `rhs`
    ///   subtracted from this value.
    public func subtractingReportingOverflow(_ other: UInt) -> (partialValue: UInt, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: A tuple containing the result of the multiplication along with
    ///   a Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   product. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated product of this
    ///   value and `rhs`.
    public func multipliedReportingOverflow(by other: UInt) -> (partialValue: UInt, overflow: Bool)

    /// Divides the first value by the second and stores the remainder in the
    /// left-hand-side variable.
    ///
    /// The result has the same sign as `lhs` and is less than `rhs.magnitude`.
    ///
    ///     var x = 22
    ///     x %= 5
    ///     // x == 2
    ///
    ///     var y = 22
    ///     y %= -5
    ///     // y == 2
    ///
    ///     var z = -22
    ///     z %= -5
    ///     // z == -2
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func %= (lhs: inout UInt, rhs: UInt)

    /// Stores the result of performing a bitwise AND operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x &= y                    // 0b00000100
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func &= (lhs: inout UInt, rhs: UInt)

    /// Stores the result of performing a bitwise OR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x |= y                    // 0b00001111
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func |= (lhs: inout UInt, rhs: UInt)

    /// Stores the result of performing a bitwise XOR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x ^= y                    // 0b00001011
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^= (lhs: inout UInt, rhs: UInt)

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= (lhs: inout UInt, rhs: UInt)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= (lhs: inout UInt, rhs: UInt)

    /// The number of bits used for the underlying binary representation of
    /// values of this type.
    ///
    /// The bit width of a `UInt` instance is 32 on 32-bit
    /// platforms and 64 on 64-bit platforms.
    public static var bitWidth: Int { get }

    /// The number of leading zeros in this value's binary representation.
    ///
    /// For example, in an integer type with a `bitWidth` value of 8,
    /// the number *31* has three leading zeros.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.leadingZeroBitCount == 3
    public var leadingZeroBitCount: Int { get }

    /// The number of trailing zeros in this value's binary representation.
    ///
    /// For example, the number *-8* has three trailing zeros.
    ///
    ///     let x = Int8(bitPattern: 0b1111_1000)
    ///     // x == -8
    ///     // x.trailingZeroBitCount == 3
    public var trailingZeroBitCount: Int { get }

    /// The number of bits equal to 1 in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has five bits equal to *1*.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.nonzeroBitCount == 5
    public var nonzeroBitCount: Int { get }

    /// A type that represents the words of this integer.
    public struct Words : BidirectionalCollection {

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = Range<Int>

        /// A type that represents a subsequence of some of the sequence's elements.
        public typealias SubSequence = Slice<UInt.Words>

        public init(_ value: UInt)

        /// The number of elements in the collection.
        ///
        /// To check whether a collection is empty, use its `isEmpty` property
        /// instead of comparing `count` to zero. Unless the collection guarantees
        /// random-access performance, calculating `count` can be an O(*n*)
        /// operation.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
        ///   of the collection.
        public var count: Int { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: UInt.Words.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Int) -> Int

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: Int) -> Int

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> UInt { get }
    }

    /// A collection containing the words of this value's binary
    /// representation, in order from the least significant to most significant.
    public var words: UInt.Words { get }

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = UInt

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    ///
    /// Use this method to calculate the full result of a product that would
    /// otherwise overflow. Unlike traditional truncating multiplication, the
    /// `multipliedFullWidth(by:)` method returns a tuple
    /// containing both the `high` and `low` parts of the product of this value and
    /// `other`. The following example uses this method to multiply two `UInt8`
    /// values that normally overflow when multiplied:
    ///
    ///     let x: UInt8 = 100
    ///     let y: UInt8 = 20
    ///     let result = x.multipliedFullWidth(by: y)
    ///     // result.high == 0b00000111
    ///     // result.low  == 0b11010000
    ///
    /// The product of `x` and `y` is 2000, which is too large to represent in a
    /// `UInt8` instance. The `high` and `low` properties of the `result` value
    /// represent 2000 when concatenated to form a double-width integer; that
    /// is, using `result.high` as the high byte and `result.low` as the low byte
    /// of a `UInt16` instance.
    ///
    ///     let z = UInt16(result.high) << 8 | UInt16(result.low)
    ///     // z == 2000
    ///
    /// - Parameter other: The value to multiply this value by.
    /// - Returns: A tuple containing the high and low parts of the result of
    ///   multiplying this value and `other`.
    public func multipliedFullWidth(by other: UInt) -> (high: UInt, low: UInt.Magnitude)

    /// Returns a tuple containing the quotient and remainder of dividing the
    /// given value by this value.
    ///
    /// The resulting quotient must be representable within the bounds of the
    /// type. If the quotient of dividing `dividend` by this value is too large
    /// to represent in the type, a runtime error may occur.
    ///
    /// - Parameter dividend: A tuple containing the high and low parts of a
    ///   double-width integer. The `high` component of the value carries the
    ///   sign, if the type is signed.
    /// - Returns: A tuple containing the quotient and remainder of `dividend`
    ///   divided by this value.
    public func dividingFullWidth(_ dividend: (high: UInt, low: UInt.Magnitude)) -> (quotient: UInt, remainder: UInt)

    /// A representation of this integer with the byte order swapped.
    public var byteSwapped: UInt { get }

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> UInt
}

extension UInt : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension UInt {

    /// Creates a new value with the bit pattern of the given pointer.
    ///
    /// The new value represents the address of the pointer passed as `pointer`.
    /// If `pointer` is `nil`, the result is `0`.
    ///
    /// - Parameter pointer: The pointer to use as the source for the new
    ///   integer.
    public init(bitPattern pointer: OpaquePointer?)
}

extension UInt : Hashable {

    /// The integer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program. Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension UInt {

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: UInt, rhs: UInt) -> UInt

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: UInt, rhs: UInt) -> UInt

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: UInt, rhs: UInt) -> UInt

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: UInt, rhs: UInt) -> UInt

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: UInt, rhs: UInt) -> UInt

    /// Returns the quotient of dividing the first value by the second.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     let x = 21 / 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func / (lhs: UInt, rhs: UInt) -> UInt

    /// Returns the remainder of dividing the first value by the second.
    ///
    /// The result of the modulo operator (`%`) has the same sign as `lhs` and is
    /// less than `rhs.magnitude`.
    ///
    ///     let x = 22 % 5
    ///     // x == 2
    ///     let y = 22 % -5
    ///     // y == 2
    ///     let z = -22 % -5
    ///     // z == -2
    ///
    /// For any two integers `a` and `b`, their quotient `q`, and their remainder
    /// `r`, `a == b * q + r`.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func % (lhs: UInt, rhs: UInt) -> UInt

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x + 120                 // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow addition operator (`&+`).
    ///
    ///     x &+ 120                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: UInt, rhs: UInt) -> UInt

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     x - 50                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow subtraction operator (`&-`).
    ///
    ///     x &- 50                // 227
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: UInt, rhs: UInt) -> UInt

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x * 21                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow multiplication operator (`&*`).
    ///
    ///     x &* 21                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: UInt, rhs: UInt) -> UInt

    public static func != (lhs: UInt, rhs: UInt) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: UInt, rhs: UInt) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: UInt, rhs: UInt) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: UInt, rhs: UInt) -> Bool
}

extension UInt : CustomReflectable {

    /// A mirror that reflects the `UInt` instance.
    public var customMirror: Mirror { get }
}

extension UInt : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `UInt` instance.
    @available(*, deprecated, message: "UInt.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UInt {

    /// Creates an integer that captures the full value of the given object
    /// identifier.
    public init(bitPattern objectID: ObjectIdentifier)
}

extension UInt {

    /// Creates a new value with the bit pattern of the given pointer.
    ///
    /// The new value represents the address of the pointer passed as `pointer`.
    /// If `pointer` is `nil`, the result is `0`.
    ///
    /// - Parameter pointer: The pointer to use as the source for the new
    ///   integer.
    public init<U>(bitPattern pointer: UnsafeMutablePointer<U>?)
}

extension UInt {

    /// Creates a new value with the bit pattern of the given pointer.
    ///
    /// The new value represents the address of the pointer passed as `pointer`.
    /// If `pointer` is `nil`, the result is `0`.
    ///
    /// - Parameter pointer: The pointer to use as the source for the new
    ///   integer.
    public init<U>(bitPattern pointer: UnsafePointer<U>?)
}

extension UInt {

    /// Creates a new value with the bit pattern of the given pointer.
    ///
    /// The new value represents the address of the pointer passed as `pointer`.
    /// If `pointer` is `nil`, the result is `0`.
    ///
    /// - Parameter pointer: The pointer to use as the source for the new
    ///   integer.
    public init(bitPattern pointer: UnsafeMutableRawPointer?)
}

extension UInt {

    /// Creates a new value with the bit pattern of the given pointer.
    ///
    /// The new value represents the address of the pointer passed as `pointer`.
    /// If `pointer` is `nil`, the result is `0`.
    ///
    /// - Parameter pointer: The pointer to use as the source for the new
    ///   integer.
    public init(bitPattern pointer: UnsafeRawPointer?)
}

extension UInt : CVarArg {
}

/// A 16-bit unsigned integer value
/// type.
public struct UInt16 : FixedWidthInteger, UnsignedInteger {

    /// A type that represents an integer literal.
    public typealias IntegerLiteralType = UInt16

    /// Creates a new instance with the same memory representation as the given
    /// value.
    ///
    /// This initializer does not perform any range or overflow checking. The
    /// resulting instance may not have the same numeric value as
    /// `bitPattern`---it is only guaranteed to use the same pattern of bits in
    /// its binary representation.
    ///
    /// - Parameter x: A value to use as the source of the new instance's binary
    ///   representation.
    public init(bitPattern x: Int16)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Double)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Double)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float80)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float80)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UInt16, rhs: UInt16) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: UInt16, rhs: UInt16) -> Bool

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x += 120
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout UInt16, rhs: UInt16)

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     var x: UInt8 = 21
    ///     x - 50
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout UInt16, rhs: UInt16)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x * 21
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout UInt16, rhs: UInt16)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     var x = 21
    ///     x /= 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func /= (lhs: inout UInt16, rhs: UInt16)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.dividedReportingOverflow(by: 0)` is `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the division along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   quotient. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains either the truncated quotient
    ///   or, if the quotient is undefined, the dividend.
    public func dividedReportingOverflow(by other: UInt16) -> (partialValue: UInt16, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.remainderReportingOverflow(dividingBy: 0)` is
    /// `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the operation along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   remainder. If the `overflow` component is `true`, an overflow occurred
    ///   during division and the `partialValue` component contains either the
    ///   entire remainder or, if the remainder is undefined, the dividend.
    public func remainderReportingOverflow(dividingBy other: UInt16) -> (partialValue: UInt16, overflow: Bool)

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: A tuple containing the result of the addition along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   sum. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated sum of this value
    ///   and `rhs`.
    public func addingReportingOverflow(_ other: UInt16) -> (partialValue: UInt16, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    /// the operation.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: A tuple containing the result of the subtraction along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   difference. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains the truncated result of `rhs`
    ///   subtracted from this value.
    public func subtractingReportingOverflow(_ other: UInt16) -> (partialValue: UInt16, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: A tuple containing the result of the multiplication along with
    ///   a Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   product. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated product of this
    ///   value and `rhs`.
    public func multipliedReportingOverflow(by other: UInt16) -> (partialValue: UInt16, overflow: Bool)

    /// Divides the first value by the second and stores the remainder in the
    /// left-hand-side variable.
    ///
    /// The result has the same sign as `lhs` and is less than `rhs.magnitude`.
    ///
    ///     var x = 22
    ///     x %= 5
    ///     // x == 2
    ///
    ///     var y = 22
    ///     y %= -5
    ///     // y == 2
    ///
    ///     var z = -22
    ///     z %= -5
    ///     // z == -2
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func %= (lhs: inout UInt16, rhs: UInt16)

    /// Stores the result of performing a bitwise AND operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x &= y                    // 0b00000100
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func &= (lhs: inout UInt16, rhs: UInt16)

    /// Stores the result of performing a bitwise OR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x |= y                    // 0b00001111
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func |= (lhs: inout UInt16, rhs: UInt16)

    /// Stores the result of performing a bitwise XOR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x ^= y                    // 0b00001011
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^= (lhs: inout UInt16, rhs: UInt16)

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= (lhs: inout UInt16, rhs: UInt16)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= (lhs: inout UInt16, rhs: UInt16)

    /// The number of bits used for the underlying binary representation of
    /// values of this type.
    ///
    /// The bit width of a `UInt16` instance is 16.
    public static var bitWidth: Int { get }

    /// The number of leading zeros in this value's binary representation.
    ///
    /// For example, in an integer type with a `bitWidth` value of 8,
    /// the number *31* has three leading zeros.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.leadingZeroBitCount == 3
    public var leadingZeroBitCount: Int { get }

    /// The number of trailing zeros in this value's binary representation.
    ///
    /// For example, the number *-8* has three trailing zeros.
    ///
    ///     let x = Int8(bitPattern: 0b1111_1000)
    ///     // x == -8
    ///     // x.trailingZeroBitCount == 3
    public var trailingZeroBitCount: Int { get }

    /// The number of bits equal to 1 in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has five bits equal to *1*.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.nonzeroBitCount == 5
    public var nonzeroBitCount: Int { get }

    /// A type that represents the words of this integer.
    public struct Words : BidirectionalCollection {

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = Range<Int>

        /// A type that represents a subsequence of some of the sequence's elements.
        public typealias SubSequence = Slice<UInt16.Words>

        public init(_ value: UInt16)

        /// The number of elements in the collection.
        ///
        /// To check whether a collection is empty, use its `isEmpty` property
        /// instead of comparing `count` to zero. Unless the collection guarantees
        /// random-access performance, calculating `count` can be an O(*n*)
        /// operation.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
        ///   of the collection.
        public var count: Int { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: UInt16.Words.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Int) -> Int

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: Int) -> Int

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> UInt { get }
    }

    /// A collection containing the words of this value's binary
    /// representation, in order from the least significant to most significant.
    public var words: UInt16.Words { get }

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = UInt16

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    ///
    /// Use this method to calculate the full result of a product that would
    /// otherwise overflow. Unlike traditional truncating multiplication, the
    /// `multipliedFullWidth(by:)` method returns a tuple
    /// containing both the `high` and `low` parts of the product of this value and
    /// `other`. The following example uses this method to multiply two `UInt8`
    /// values that normally overflow when multiplied:
    ///
    ///     let x: UInt8 = 100
    ///     let y: UInt8 = 20
    ///     let result = x.multipliedFullWidth(by: y)
    ///     // result.high == 0b00000111
    ///     // result.low  == 0b11010000
    ///
    /// The product of `x` and `y` is 2000, which is too large to represent in a
    /// `UInt8` instance. The `high` and `low` properties of the `result` value
    /// represent 2000 when concatenated to form a double-width integer; that
    /// is, using `result.high` as the high byte and `result.low` as the low byte
    /// of a `UInt16` instance.
    ///
    ///     let z = UInt16(result.high) << 8 | UInt16(result.low)
    ///     // z == 2000
    ///
    /// - Parameter other: The value to multiply this value by.
    /// - Returns: A tuple containing the high and low parts of the result of
    ///   multiplying this value and `other`.
    public func multipliedFullWidth(by other: UInt16) -> (high: UInt16, low: UInt16.Magnitude)

    /// Returns a tuple containing the quotient and remainder of dividing the
    /// given value by this value.
    ///
    /// The resulting quotient must be representable within the bounds of the
    /// type. If the quotient of dividing `dividend` by this value is too large
    /// to represent in the type, a runtime error may occur.
    ///
    /// - Parameter dividend: A tuple containing the high and low parts of a
    ///   double-width integer. The `high` component of the value carries the
    ///   sign, if the type is signed.
    /// - Returns: A tuple containing the quotient and remainder of `dividend`
    ///   divided by this value.
    public func dividingFullWidth(_ dividend: (high: UInt16, low: UInt16.Magnitude)) -> (quotient: UInt16, remainder: UInt16)

    /// A representation of this integer with the byte order swapped.
    public var byteSwapped: UInt16 { get }

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> UInt16
}

extension UInt16 : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension UInt16 : Hashable {

    /// The integer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program. Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension UInt16 {

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: UInt16, rhs: UInt16) -> UInt16

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: UInt16, rhs: UInt16) -> UInt16

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: UInt16, rhs: UInt16) -> UInt16

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: UInt16, rhs: UInt16) -> UInt16

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: UInt16, rhs: UInt16) -> UInt16

    /// Returns the quotient of dividing the first value by the second.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     let x = 21 / 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func / (lhs: UInt16, rhs: UInt16) -> UInt16

    /// Returns the remainder of dividing the first value by the second.
    ///
    /// The result of the modulo operator (`%`) has the same sign as `lhs` and is
    /// less than `rhs.magnitude`.
    ///
    ///     let x = 22 % 5
    ///     // x == 2
    ///     let y = 22 % -5
    ///     // y == 2
    ///     let z = -22 % -5
    ///     // z == -2
    ///
    /// For any two integers `a` and `b`, their quotient `q`, and their remainder
    /// `r`, `a == b * q + r`.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func % (lhs: UInt16, rhs: UInt16) -> UInt16

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x + 120                 // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow addition operator (`&+`).
    ///
    ///     x &+ 120                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: UInt16, rhs: UInt16) -> UInt16

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     x - 50                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow subtraction operator (`&-`).
    ///
    ///     x &- 50                // 227
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: UInt16, rhs: UInt16) -> UInt16

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x * 21                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow multiplication operator (`&*`).
    ///
    ///     x &* 21                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: UInt16, rhs: UInt16) -> UInt16

    public static func != (lhs: UInt16, rhs: UInt16) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: UInt16, rhs: UInt16) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: UInt16, rhs: UInt16) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: UInt16, rhs: UInt16) -> Bool
}

extension UInt16 : CustomReflectable {

    /// A mirror that reflects the `UInt16` instance.
    public var customMirror: Mirror { get }
}

extension UInt16 : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `UInt16` instance.
    @available(*, deprecated, message: "UInt16.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UInt16 {
}

extension UInt16 : CVarArg {
}

/// A 32-bit unsigned integer value
/// type.
public struct UInt32 : FixedWidthInteger, UnsignedInteger {

    /// A type that represents an integer literal.
    public typealias IntegerLiteralType = UInt32

    /// Creates a new instance with the same memory representation as the given
    /// value.
    ///
    /// This initializer does not perform any range or overflow checking. The
    /// resulting instance may not have the same numeric value as
    /// `bitPattern`---it is only guaranteed to use the same pattern of bits in
    /// its binary representation.
    ///
    /// - Parameter x: A value to use as the source of the new instance's binary
    ///   representation.
    public init(bitPattern x: Int32)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Double)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Double)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float80)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float80)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UInt32, rhs: UInt32) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: UInt32, rhs: UInt32) -> Bool

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x += 120
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout UInt32, rhs: UInt32)

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     var x: UInt8 = 21
    ///     x - 50
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout UInt32, rhs: UInt32)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x * 21
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout UInt32, rhs: UInt32)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     var x = 21
    ///     x /= 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func /= (lhs: inout UInt32, rhs: UInt32)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.dividedReportingOverflow(by: 0)` is `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the division along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   quotient. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains either the truncated quotient
    ///   or, if the quotient is undefined, the dividend.
    public func dividedReportingOverflow(by other: UInt32) -> (partialValue: UInt32, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.remainderReportingOverflow(dividingBy: 0)` is
    /// `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the operation along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   remainder. If the `overflow` component is `true`, an overflow occurred
    ///   during division and the `partialValue` component contains either the
    ///   entire remainder or, if the remainder is undefined, the dividend.
    public func remainderReportingOverflow(dividingBy other: UInt32) -> (partialValue: UInt32, overflow: Bool)

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: A tuple containing the result of the addition along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   sum. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated sum of this value
    ///   and `rhs`.
    public func addingReportingOverflow(_ other: UInt32) -> (partialValue: UInt32, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    /// the operation.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: A tuple containing the result of the subtraction along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   difference. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains the truncated result of `rhs`
    ///   subtracted from this value.
    public func subtractingReportingOverflow(_ other: UInt32) -> (partialValue: UInt32, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: A tuple containing the result of the multiplication along with
    ///   a Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   product. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated product of this
    ///   value and `rhs`.
    public func multipliedReportingOverflow(by other: UInt32) -> (partialValue: UInt32, overflow: Bool)

    /// Divides the first value by the second and stores the remainder in the
    /// left-hand-side variable.
    ///
    /// The result has the same sign as `lhs` and is less than `rhs.magnitude`.
    ///
    ///     var x = 22
    ///     x %= 5
    ///     // x == 2
    ///
    ///     var y = 22
    ///     y %= -5
    ///     // y == 2
    ///
    ///     var z = -22
    ///     z %= -5
    ///     // z == -2
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func %= (lhs: inout UInt32, rhs: UInt32)

    /// Stores the result of performing a bitwise AND operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x &= y                    // 0b00000100
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func &= (lhs: inout UInt32, rhs: UInt32)

    /// Stores the result of performing a bitwise OR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x |= y                    // 0b00001111
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func |= (lhs: inout UInt32, rhs: UInt32)

    /// Stores the result of performing a bitwise XOR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x ^= y                    // 0b00001011
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^= (lhs: inout UInt32, rhs: UInt32)

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= (lhs: inout UInt32, rhs: UInt32)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= (lhs: inout UInt32, rhs: UInt32)

    /// The number of bits used for the underlying binary representation of
    /// values of this type.
    ///
    /// The bit width of a `UInt32` instance is 32.
    public static var bitWidth: Int { get }

    /// The number of leading zeros in this value's binary representation.
    ///
    /// For example, in an integer type with a `bitWidth` value of 8,
    /// the number *31* has three leading zeros.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.leadingZeroBitCount == 3
    public var leadingZeroBitCount: Int { get }

    /// The number of trailing zeros in this value's binary representation.
    ///
    /// For example, the number *-8* has three trailing zeros.
    ///
    ///     let x = Int8(bitPattern: 0b1111_1000)
    ///     // x == -8
    ///     // x.trailingZeroBitCount == 3
    public var trailingZeroBitCount: Int { get }

    /// The number of bits equal to 1 in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has five bits equal to *1*.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.nonzeroBitCount == 5
    public var nonzeroBitCount: Int { get }

    /// A type that represents the words of this integer.
    public struct Words : BidirectionalCollection {

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = Range<Int>

        /// A type that represents a subsequence of some of the sequence's elements.
        public typealias SubSequence = Slice<UInt32.Words>

        public init(_ value: UInt32)

        /// The number of elements in the collection.
        ///
        /// To check whether a collection is empty, use its `isEmpty` property
        /// instead of comparing `count` to zero. Unless the collection guarantees
        /// random-access performance, calculating `count` can be an O(*n*)
        /// operation.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
        ///   of the collection.
        public var count: Int { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: UInt32.Words.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Int) -> Int

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: Int) -> Int

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> UInt { get }
    }

    /// A collection containing the words of this value's binary
    /// representation, in order from the least significant to most significant.
    public var words: UInt32.Words { get }

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = UInt32

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    ///
    /// Use this method to calculate the full result of a product that would
    /// otherwise overflow. Unlike traditional truncating multiplication, the
    /// `multipliedFullWidth(by:)` method returns a tuple
    /// containing both the `high` and `low` parts of the product of this value and
    /// `other`. The following example uses this method to multiply two `UInt8`
    /// values that normally overflow when multiplied:
    ///
    ///     let x: UInt8 = 100
    ///     let y: UInt8 = 20
    ///     let result = x.multipliedFullWidth(by: y)
    ///     // result.high == 0b00000111
    ///     // result.low  == 0b11010000
    ///
    /// The product of `x` and `y` is 2000, which is too large to represent in a
    /// `UInt8` instance. The `high` and `low` properties of the `result` value
    /// represent 2000 when concatenated to form a double-width integer; that
    /// is, using `result.high` as the high byte and `result.low` as the low byte
    /// of a `UInt16` instance.
    ///
    ///     let z = UInt16(result.high) << 8 | UInt16(result.low)
    ///     // z == 2000
    ///
    /// - Parameter other: The value to multiply this value by.
    /// - Returns: A tuple containing the high and low parts of the result of
    ///   multiplying this value and `other`.
    public func multipliedFullWidth(by other: UInt32) -> (high: UInt32, low: UInt32.Magnitude)

    /// Returns a tuple containing the quotient and remainder of dividing the
    /// given value by this value.
    ///
    /// The resulting quotient must be representable within the bounds of the
    /// type. If the quotient of dividing `dividend` by this value is too large
    /// to represent in the type, a runtime error may occur.
    ///
    /// - Parameter dividend: A tuple containing the high and low parts of a
    ///   double-width integer. The `high` component of the value carries the
    ///   sign, if the type is signed.
    /// - Returns: A tuple containing the quotient and remainder of `dividend`
    ///   divided by this value.
    public func dividingFullWidth(_ dividend: (high: UInt32, low: UInt32.Magnitude)) -> (quotient: UInt32, remainder: UInt32)

    /// A representation of this integer with the byte order swapped.
    public var byteSwapped: UInt32 { get }

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> UInt32
}

extension UInt32 : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension UInt32 : Hashable {

    /// The integer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program. Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension UInt32 {

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: UInt32, rhs: UInt32) -> UInt32

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: UInt32, rhs: UInt32) -> UInt32

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: UInt32, rhs: UInt32) -> UInt32

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: UInt32, rhs: UInt32) -> UInt32

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: UInt32, rhs: UInt32) -> UInt32

    /// Returns the quotient of dividing the first value by the second.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     let x = 21 / 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func / (lhs: UInt32, rhs: UInt32) -> UInt32

    /// Returns the remainder of dividing the first value by the second.
    ///
    /// The result of the modulo operator (`%`) has the same sign as `lhs` and is
    /// less than `rhs.magnitude`.
    ///
    ///     let x = 22 % 5
    ///     // x == 2
    ///     let y = 22 % -5
    ///     // y == 2
    ///     let z = -22 % -5
    ///     // z == -2
    ///
    /// For any two integers `a` and `b`, their quotient `q`, and their remainder
    /// `r`, `a == b * q + r`.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func % (lhs: UInt32, rhs: UInt32) -> UInt32

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x + 120                 // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow addition operator (`&+`).
    ///
    ///     x &+ 120                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: UInt32, rhs: UInt32) -> UInt32

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     x - 50                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow subtraction operator (`&-`).
    ///
    ///     x &- 50                // 227
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: UInt32, rhs: UInt32) -> UInt32

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x * 21                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow multiplication operator (`&*`).
    ///
    ///     x &* 21                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: UInt32, rhs: UInt32) -> UInt32

    public static func != (lhs: UInt32, rhs: UInt32) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: UInt32, rhs: UInt32) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: UInt32, rhs: UInt32) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: UInt32, rhs: UInt32) -> Bool
}

extension UInt32 {

    /// Construct with value `v.value`.
    public init(_ v: Unicode.Scalar)
}

extension UInt32 : CustomReflectable {

    /// A mirror that reflects the `UInt32` instance.
    public var customMirror: Mirror { get }
}

extension UInt32 : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `UInt32` instance.
    @available(*, deprecated, message: "UInt32.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UInt32 : CVarArg {
}

/// A 64-bit unsigned integer value
/// type.
public struct UInt64 : FixedWidthInteger, UnsignedInteger {

    /// A type that represents an integer literal.
    public typealias IntegerLiteralType = UInt64

    /// Creates a new instance with the same memory representation as the given
    /// value.
    ///
    /// This initializer does not perform any range or overflow checking. The
    /// resulting instance may not have the same numeric value as
    /// `bitPattern`---it is only guaranteed to use the same pattern of bits in
    /// its binary representation.
    ///
    /// - Parameter x: A value to use as the source of the new instance's binary
    ///   representation.
    public init(bitPattern x: Int64)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Double)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Double)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float80)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float80)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UInt64, rhs: UInt64) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: UInt64, rhs: UInt64) -> Bool

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x += 120
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout UInt64, rhs: UInt64)

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     var x: UInt8 = 21
    ///     x - 50
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout UInt64, rhs: UInt64)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x * 21
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout UInt64, rhs: UInt64)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     var x = 21
    ///     x /= 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func /= (lhs: inout UInt64, rhs: UInt64)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.dividedReportingOverflow(by: 0)` is `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the division along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   quotient. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains either the truncated quotient
    ///   or, if the quotient is undefined, the dividend.
    public func dividedReportingOverflow(by other: UInt64) -> (partialValue: UInt64, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.remainderReportingOverflow(dividingBy: 0)` is
    /// `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the operation along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   remainder. If the `overflow` component is `true`, an overflow occurred
    ///   during division and the `partialValue` component contains either the
    ///   entire remainder or, if the remainder is undefined, the dividend.
    public func remainderReportingOverflow(dividingBy other: UInt64) -> (partialValue: UInt64, overflow: Bool)

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: A tuple containing the result of the addition along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   sum. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated sum of this value
    ///   and `rhs`.
    public func addingReportingOverflow(_ other: UInt64) -> (partialValue: UInt64, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    /// the operation.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: A tuple containing the result of the subtraction along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   difference. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains the truncated result of `rhs`
    ///   subtracted from this value.
    public func subtractingReportingOverflow(_ other: UInt64) -> (partialValue: UInt64, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: A tuple containing the result of the multiplication along with
    ///   a Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   product. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated product of this
    ///   value and `rhs`.
    public func multipliedReportingOverflow(by other: UInt64) -> (partialValue: UInt64, overflow: Bool)

    /// Divides the first value by the second and stores the remainder in the
    /// left-hand-side variable.
    ///
    /// The result has the same sign as `lhs` and is less than `rhs.magnitude`.
    ///
    ///     var x = 22
    ///     x %= 5
    ///     // x == 2
    ///
    ///     var y = 22
    ///     y %= -5
    ///     // y == 2
    ///
    ///     var z = -22
    ///     z %= -5
    ///     // z == -2
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func %= (lhs: inout UInt64, rhs: UInt64)

    /// Stores the result of performing a bitwise AND operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x &= y                    // 0b00000100
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func &= (lhs: inout UInt64, rhs: UInt64)

    /// Stores the result of performing a bitwise OR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x |= y                    // 0b00001111
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func |= (lhs: inout UInt64, rhs: UInt64)

    /// Stores the result of performing a bitwise XOR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x ^= y                    // 0b00001011
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^= (lhs: inout UInt64, rhs: UInt64)

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= (lhs: inout UInt64, rhs: UInt64)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= (lhs: inout UInt64, rhs: UInt64)

    /// The number of bits used for the underlying binary representation of
    /// values of this type.
    ///
    /// The bit width of a `UInt64` instance is 64.
    public static var bitWidth: Int { get }

    /// The number of leading zeros in this value's binary representation.
    ///
    /// For example, in an integer type with a `bitWidth` value of 8,
    /// the number *31* has three leading zeros.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.leadingZeroBitCount == 3
    public var leadingZeroBitCount: Int { get }

    /// The number of trailing zeros in this value's binary representation.
    ///
    /// For example, the number *-8* has three trailing zeros.
    ///
    ///     let x = Int8(bitPattern: 0b1111_1000)
    ///     // x == -8
    ///     // x.trailingZeroBitCount == 3
    public var trailingZeroBitCount: Int { get }

    /// The number of bits equal to 1 in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has five bits equal to *1*.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.nonzeroBitCount == 5
    public var nonzeroBitCount: Int { get }

    /// A type that represents the words of this integer.
    public struct Words : BidirectionalCollection {

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = Range<Int>

        /// A type that represents a subsequence of some of the sequence's elements.
        public typealias SubSequence = Slice<UInt64.Words>

        public init(_ value: UInt64)

        /// The number of elements in the collection.
        ///
        /// To check whether a collection is empty, use its `isEmpty` property
        /// instead of comparing `count` to zero. Unless the collection guarantees
        /// random-access performance, calculating `count` can be an O(*n*)
        /// operation.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
        ///   of the collection.
        public var count: Int { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: UInt64.Words.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Int) -> Int

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: Int) -> Int

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> UInt { get }
    }

    /// A collection containing the words of this value's binary
    /// representation, in order from the least significant to most significant.
    public var words: UInt64.Words { get }

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = UInt64

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    ///
    /// Use this method to calculate the full result of a product that would
    /// otherwise overflow. Unlike traditional truncating multiplication, the
    /// `multipliedFullWidth(by:)` method returns a tuple
    /// containing both the `high` and `low` parts of the product of this value and
    /// `other`. The following example uses this method to multiply two `UInt8`
    /// values that normally overflow when multiplied:
    ///
    ///     let x: UInt8 = 100
    ///     let y: UInt8 = 20
    ///     let result = x.multipliedFullWidth(by: y)
    ///     // result.high == 0b00000111
    ///     // result.low  == 0b11010000
    ///
    /// The product of `x` and `y` is 2000, which is too large to represent in a
    /// `UInt8` instance. The `high` and `low` properties of the `result` value
    /// represent 2000 when concatenated to form a double-width integer; that
    /// is, using `result.high` as the high byte and `result.low` as the low byte
    /// of a `UInt16` instance.
    ///
    ///     let z = UInt16(result.high) << 8 | UInt16(result.low)
    ///     // z == 2000
    ///
    /// - Parameter other: The value to multiply this value by.
    /// - Returns: A tuple containing the high and low parts of the result of
    ///   multiplying this value and `other`.
    public func multipliedFullWidth(by other: UInt64) -> (high: UInt64, low: UInt64.Magnitude)

    /// Returns a tuple containing the quotient and remainder of dividing the
    /// given value by this value.
    ///
    /// The resulting quotient must be representable within the bounds of the
    /// type. If the quotient of dividing `dividend` by this value is too large
    /// to represent in the type, a runtime error may occur.
    ///
    /// - Parameter dividend: A tuple containing the high and low parts of a
    ///   double-width integer. The `high` component of the value carries the
    ///   sign, if the type is signed.
    /// - Returns: A tuple containing the quotient and remainder of `dividend`
    ///   divided by this value.
    public func dividingFullWidth(_ dividend: (high: UInt64, low: UInt64.Magnitude)) -> (quotient: UInt64, remainder: UInt64)

    /// A representation of this integer with the byte order swapped.
    public var byteSwapped: UInt64 { get }

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> UInt64
}

extension UInt64 : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension UInt64 : Hashable {

    /// The integer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program. Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension UInt64 {

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: UInt64, rhs: UInt64) -> UInt64

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: UInt64, rhs: UInt64) -> UInt64

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: UInt64, rhs: UInt64) -> UInt64

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: UInt64, rhs: UInt64) -> UInt64

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: UInt64, rhs: UInt64) -> UInt64

    /// Returns the quotient of dividing the first value by the second.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     let x = 21 / 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func / (lhs: UInt64, rhs: UInt64) -> UInt64

    /// Returns the remainder of dividing the first value by the second.
    ///
    /// The result of the modulo operator (`%`) has the same sign as `lhs` and is
    /// less than `rhs.magnitude`.
    ///
    ///     let x = 22 % 5
    ///     // x == 2
    ///     let y = 22 % -5
    ///     // y == 2
    ///     let z = -22 % -5
    ///     // z == -2
    ///
    /// For any two integers `a` and `b`, their quotient `q`, and their remainder
    /// `r`, `a == b * q + r`.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func % (lhs: UInt64, rhs: UInt64) -> UInt64

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x + 120                 // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow addition operator (`&+`).
    ///
    ///     x &+ 120                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: UInt64, rhs: UInt64) -> UInt64

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     x - 50                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow subtraction operator (`&-`).
    ///
    ///     x &- 50                // 227
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: UInt64, rhs: UInt64) -> UInt64

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x * 21                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow multiplication operator (`&*`).
    ///
    ///     x &* 21                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: UInt64, rhs: UInt64) -> UInt64

    public static func != (lhs: UInt64, rhs: UInt64) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: UInt64, rhs: UInt64) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: UInt64, rhs: UInt64) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: UInt64, rhs: UInt64) -> Bool
}

extension UInt64 {

    /// Construct with value `v.value`.
    public init(_ v: Unicode.Scalar)
}

extension UInt64 : CustomReflectable {

    /// A mirror that reflects the `UInt64` instance.
    public var customMirror: Mirror { get }
}

extension UInt64 : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `UInt64` instance.
    @available(*, deprecated, message: "UInt64.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UInt64 : CVarArg {
}

/// An 8-bit unsigned integer value
/// type.
public struct UInt8 : FixedWidthInteger, UnsignedInteger {

    /// A type that represents an integer literal.
    public typealias IntegerLiteralType = UInt8

    /// Creates a new instance with the same memory representation as the given
    /// value.
    ///
    /// This initializer does not perform any range or overflow checking. The
    /// resulting instance may not have the same numeric value as
    /// `bitPattern`---it is only guaranteed to use the same pattern of bits in
    /// its binary representation.
    ///
    /// - Parameter x: A value to use as the source of the new instance's binary
    ///   representation.
    public init(bitPattern x: Int8)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Double)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Double)

    /// Creates an integer from the given floating-point value, rounding toward
    /// zero.
    ///
    /// Any fractional part of the value passed as `source` is removed, rounding
    /// the value toward zero.
    ///
    ///     let x = Int(21.5)
    ///     // x == 21
    ///     let y = Int(-21.5)
    ///     // y == -21
    ///
    /// If `source` is outside the bounds of this type after rounding toward
    /// zero, a runtime error may occur.
    ///
    ///     let z = UInt(-21.5)
    ///     // Error: ...the result would be less than UInt.min
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    ///   `source` must be representable in this type after rounding toward
    ///   zero.
    public init(_ source: Float80)

    /// Creates an integer from the given floating-point value, if it can be
    /// represented exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `21.0`, while the attempt to initialize the
    /// constant `y` from `21.5` fails:
    ///
    ///     let x = Int(exactly: 21.0)
    ///     // x == Optional(21)
    ///     let y = Int(exactly: 21.5)
    ///     // y == nil
    ///
    /// - Parameter source: A floating-point value to convert to an integer.
    public init?(exactly source: Float80)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UInt8, rhs: UInt8) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: UInt8, rhs: UInt8) -> Bool

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x += 120
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout UInt8, rhs: UInt8)

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     var x: UInt8 = 21
    ///     x - 50
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout UInt8, rhs: UInt8)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     var x: Int8 = 21
    ///     x * 21
    ///     // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout UInt8, rhs: UInt8)

    /// Divides the first value by the second and stores the quotient in the
    /// left-hand-side variable.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     var x = 21
    ///     x /= 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func /= (lhs: inout UInt8, rhs: UInt8)

    /// Returns the quotient obtained by dividing this value by the given value,
    /// along with a Boolean value indicating whether overflow occurred in the
    /// operation.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.dividedReportingOverflow(by: 0)` is `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the division along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   quotient. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains either the truncated quotient
    ///   or, if the quotient is undefined, the dividend.
    public func dividedReportingOverflow(by other: UInt8) -> (partialValue: UInt8, overflow: Bool)

    /// Returns the remainder after dividing this value by the given value, along
    /// with a Boolean value indicating whether overflow occurred during division.
    ///
    /// Dividing by zero is not an error when using this method. For a value `x`,
    /// the result of `x.remainderReportingOverflow(dividingBy: 0)` is
    /// `(x, true)`.
    ///
    /// - Parameter rhs: The value to divide this value by.
    /// - Returns: A tuple containing the result of the operation along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   remainder. If the `overflow` component is `true`, an overflow occurred
    ///   during division and the `partialValue` component contains either the
    ///   entire remainder or, if the remainder is undefined, the dividend.
    public func remainderReportingOverflow(dividingBy other: UInt8) -> (partialValue: UInt8, overflow: Bool)

    /// Returns the sum of this value and the given value, along with a Boolean
    /// value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to add to this value.
    /// - Returns: A tuple containing the result of the addition along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   sum. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated sum of this value
    ///   and `rhs`.
    public func addingReportingOverflow(_ other: UInt8) -> (partialValue: UInt8, overflow: Bool)

    /// Returns the difference obtained by subtracting the given value from this
    /// value, along with a Boolean value indicating whether overflow occurred in
    /// the operation.
    ///
    /// - Parameter rhs: The value to subtract from this value.
    /// - Returns: A tuple containing the result of the subtraction along with a
    ///   Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   difference. If the `overflow` component is `true`, an overflow occurred
    ///   and the `partialValue` component contains the truncated result of `rhs`
    ///   subtracted from this value.
    public func subtractingReportingOverflow(_ other: UInt8) -> (partialValue: UInt8, overflow: Bool)

    /// Returns the product of this value and the given value, along with a
    /// Boolean value indicating whether overflow occurred in the operation.
    ///
    /// - Parameter rhs: The value to multiply by this value.
    /// - Returns: A tuple containing the result of the multiplication along with
    ///   a Boolean value indicating whether overflow occurred. If the `overflow`
    ///   component is `false`, the `partialValue` component contains the entire
    ///   product. If the `overflow` component is `true`, an overflow occurred and
    ///   the `partialValue` component contains the truncated product of this
    ///   value and `rhs`.
    public func multipliedReportingOverflow(by other: UInt8) -> (partialValue: UInt8, overflow: Bool)

    /// Divides the first value by the second and stores the remainder in the
    /// left-hand-side variable.
    ///
    /// The result has the same sign as `lhs` and is less than `rhs.magnitude`.
    ///
    ///     var x = 22
    ///     x %= 5
    ///     // x == 2
    ///
    ///     var y = 22
    ///     y %= -5
    ///     // y == 2
    ///
    ///     var z = -22
    ///     z %= -5
    ///     // z == -2
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func %= (lhs: inout UInt8, rhs: UInt8)

    /// Stores the result of performing a bitwise AND operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x &= y                    // 0b00000100
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func &= (lhs: inout UInt8, rhs: UInt8)

    /// Stores the result of performing a bitwise OR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x |= y                    // 0b00001111
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func |= (lhs: inout UInt8, rhs: UInt8)

    /// Stores the result of performing a bitwise XOR operation on the two given
    /// values in the left-hand-side variable.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     var x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     x ^= y                    // 0b00001011
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^= (lhs: inout UInt8, rhs: UInt8)

    /// Calculates the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&>>=` operator performs a *masking shift*, where the value passed as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &>>= 2
    ///     // x == 7                         // 0b00000111
    ///
    /// However, if you use `19` as `rhs`, the operation first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &>>= 19
    ///     // y == 3                         // 0b00000011
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>>= (lhs: inout UInt8, rhs: UInt8)

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width, and stores the result in the left-hand-side variable.
    ///
    /// The `&<<=` operator performs a *masking shift*, where the value used as
    /// `rhs` is masked to produce a value in the range `0..<lhs.bitWidth`. The
    /// shift is performed using this masked value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     var x: UInt8 = 30                 // 0b00011110
    ///     x &<<= 2
    ///     // x == 120                       // 0b01111000
    ///
    /// However, if you pass `19` as `rhs`, the method first bitmasks `rhs` to
    /// `3`, and then uses that masked value as the number of bits to shift `lhs`.
    ///
    ///     var y: UInt8 = 30                 // 0b00011110
    ///     y &<<= 19
    ///     // y == 240                       // 0b11110000
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<<= (lhs: inout UInt8, rhs: UInt8)

    /// The number of bits used for the underlying binary representation of
    /// values of this type.
    ///
    /// The bit width of an `UInt8` instance is 8.
    public static var bitWidth: Int { get }

    /// The number of leading zeros in this value's binary representation.
    ///
    /// For example, in an integer type with a `bitWidth` value of 8,
    /// the number *31* has three leading zeros.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.leadingZeroBitCount == 3
    public var leadingZeroBitCount: Int { get }

    /// The number of trailing zeros in this value's binary representation.
    ///
    /// For example, the number *-8* has three trailing zeros.
    ///
    ///     let x = Int8(bitPattern: 0b1111_1000)
    ///     // x == -8
    ///     // x.trailingZeroBitCount == 3
    public var trailingZeroBitCount: Int { get }

    /// The number of bits equal to 1 in this value's binary representation.
    ///
    /// For example, in a fixed-width integer type with a `bitWidth` value of 8,
    /// the number *31* has five bits equal to *1*.
    ///
    ///     let x: Int8 = 0b0001_1111
    ///     // x == 31
    ///     // x.nonzeroBitCount == 5
    public var nonzeroBitCount: Int { get }

    /// A type that represents the words of this integer.
    public struct Words : BidirectionalCollection {

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        public typealias Indices = Range<Int>

        /// A type that represents a subsequence of some of the sequence's elements.
        public typealias SubSequence = Slice<UInt8.Words>

        public init(_ value: UInt8)

        /// The number of elements in the collection.
        ///
        /// To check whether a collection is empty, use its `isEmpty` property
        /// instead of comparing `count` to zero. Unless the collection guarantees
        /// random-access performance, calculating `count` can be an O(*n*)
        /// operation.
        ///
        /// - Complexity: O(1) if the collection conforms to
        ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
        ///   of the collection.
        public var count: Int { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// The indices that are valid for subscripting the collection, in ascending
        /// order.
        ///
        /// A collection's `indices` property can hold a strong reference to the
        /// collection itself, causing the collection to be non-uniquely referenced.
        /// If you mutate the collection while iterating over its indices, a strong
        /// reference can cause an unexpected copy of the collection. To avoid the
        /// unexpected copy, use the `index(after:)` method starting with
        /// `startIndex` to produce indices instead.
        ///
        ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
        ///     var i = c.startIndex
        ///     while i != c.endIndex {
        ///         c[i] /= 5
        ///         i = c.index(after: i)
        ///     }
        ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
        public var indices: UInt8.Words.Indices { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Int) -> Int

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: Int) -> Int

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> UInt { get }
    }

    /// A collection containing the words of this value's binary
    /// representation, in order from the least significant to most significant.
    public var words: UInt8.Words { get }

    /// A type that can represent the absolute value of any possible value of
    /// this type.
    public typealias Magnitude = UInt8

    /// Returns a tuple containing the high and low parts of the result of
    /// multiplying this value by the given value.
    ///
    /// Use this method to calculate the full result of a product that would
    /// otherwise overflow. Unlike traditional truncating multiplication, the
    /// `multipliedFullWidth(by:)` method returns a tuple
    /// containing both the `high` and `low` parts of the product of this value and
    /// `other`. The following example uses this method to multiply two `UInt8`
    /// values that normally overflow when multiplied:
    ///
    ///     let x: UInt8 = 100
    ///     let y: UInt8 = 20
    ///     let result = x.multipliedFullWidth(by: y)
    ///     // result.high == 0b00000111
    ///     // result.low  == 0b11010000
    ///
    /// The product of `x` and `y` is 2000, which is too large to represent in a
    /// `UInt8` instance. The `high` and `low` properties of the `result` value
    /// represent 2000 when concatenated to form a double-width integer; that
    /// is, using `result.high` as the high byte and `result.low` as the low byte
    /// of a `UInt16` instance.
    ///
    ///     let z = UInt16(result.high) << 8 | UInt16(result.low)
    ///     // z == 2000
    ///
    /// - Parameter other: The value to multiply this value by.
    /// - Returns: A tuple containing the high and low parts of the result of
    ///   multiplying this value and `other`.
    public func multipliedFullWidth(by other: UInt8) -> (high: UInt8, low: UInt8.Magnitude)

    /// Returns a tuple containing the quotient and remainder of dividing the
    /// given value by this value.
    ///
    /// The resulting quotient must be representable within the bounds of the
    /// type. If the quotient of dividing `dividend` by this value is too large
    /// to represent in the type, a runtime error may occur.
    ///
    /// - Parameter dividend: A tuple containing the high and low parts of a
    ///   double-width integer. The `high` component of the value carries the
    ///   sign, if the type is signed.
    /// - Returns: A tuple containing the quotient and remainder of `dividend`
    ///   divided by this value.
    public func dividingFullWidth(_ dividend: (high: UInt8, low: UInt8.Magnitude)) -> (quotient: UInt8, remainder: UInt8)

    /// A representation of this integer with the byte order swapped.
    public var byteSwapped: UInt8 { get }

    /// Returns `-1` if this value is negative and `1` if it's positive;
    /// otherwise, `0`.
    ///
    /// - Returns: The sign of this number, expressed as an integer of the same
    ///   type.
    public func signum() -> UInt8
}

extension UInt8 : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: Encoder) throws
}

extension UInt8 : Hashable {

    /// The integer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program. Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension UInt8 {

    /// Returns the result of performing a bitwise AND operation on the two given
    /// values.
    ///
    /// A bitwise AND operation results in a value that has each bit set to `1`
    /// where *both* of its arguments have that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x & y             // 0b00000100
    ///     // z == 4
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func & (lhs: UInt8, rhs: UInt8) -> UInt8

    /// Returns the result of performing a bitwise OR operation on the two given
    /// values.
    ///
    /// A bitwise OR operation results in a value that has each bit set to `1`
    /// where *one or both* of its arguments have that bit set to `1`. For
    /// example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x | y             // 0b00001111
    ///     // z == 15
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func | (lhs: UInt8, rhs: UInt8) -> UInt8

    /// Returns the result of performing a bitwise XOR operation on the two given
    /// values.
    ///
    /// A bitwise XOR operation, also known as an exclusive OR operation, results
    /// in a value that has each bit set to `1` where *one or the other but not
    /// both* of its arguments had that bit set to `1`. For example:
    ///
    ///     let x: UInt8 = 5          // 0b00000101
    ///     let y: UInt8 = 14         // 0b00001110
    ///     let z = x ^ y             // 0b00001011
    ///     // z == 11
    ///
    /// - Parameters:
    ///   - lhs: An integer value.
    ///   - rhs: Another integer value.
    public static func ^ (lhs: UInt8, rhs: UInt8) -> UInt8

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the right, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking right shift operator (`&>>`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking right shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &>> 2
    ///     // y == 7                         // 0b00000111
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &>> 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the right. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &>> (lhs: UInt8, rhs: UInt8) -> UInt8

    /// Returns the result of shifting a value's binary representation the
    /// specified number of digits to the left, masking the shift amount to the
    /// type's bit width.
    ///
    /// Use the masking left shift operator (`&<<`) when you need to perform a
    /// shift and are sure that the shift amount is in the range
    /// `0..<lhs.bitWidth`. Before shifting, the masking left shift operator
    /// masks the shift to this range. The shift is performed using this masked
    /// value.
    ///
    /// The following example defines `x` as an instance of `UInt8`, an 8-bit,
    /// unsigned integer type. If you use `2` as the right-hand-side value in an
    /// operation on `x`, the shift amount requires no masking.
    ///
    ///     let x: UInt8 = 30                 // 0b00011110
    ///     let y = x &<< 2
    ///     // y == 120                       // 0b01111000
    ///
    /// However, if you use `8` as the shift amount, the method first masks the
    /// shift amount to zero, and then performs the shift, resulting in no change
    /// to the original value.
    ///
    ///     let z = x &<< 8
    ///     // z == 30                        // 0b00011110
    ///
    /// If the bit width of the shifted integer type is a power of two, masking
    /// is performed using a bitmask; otherwise, masking is performed using a
    /// modulo operation.
    ///
    /// - Parameters:
    ///   - lhs: The value to shift.
    ///   - rhs: The number of bits to shift `lhs` to the left. If `rhs` is
    ///     outside the range `0..<lhs.bitWidth`, it is masked to produce a
    ///     value within that range.
    public static func &<< (lhs: UInt8, rhs: UInt8) -> UInt8

    /// Returns the quotient of dividing the first value by the second.
    ///
    /// For integer types, any remainder of the division is discarded.
    ///
    ///     let x = 21 / 5
    ///     // x == 4
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func / (lhs: UInt8, rhs: UInt8) -> UInt8

    /// Returns the remainder of dividing the first value by the second.
    ///
    /// The result of the modulo operator (`%`) has the same sign as `lhs` and is
    /// less than `rhs.magnitude`.
    ///
    ///     let x = 22 % 5
    ///     // x == 2
    ///     let y = 22 % -5
    ///     // y == 2
    ///     let z = -22 % -5
    ///     // z == -2
    ///
    /// For any two integers `a` and `b`, their quotient `q`, and their remainder
    /// `r`, `a == b * q + r`.
    ///
    /// - Parameters:
    ///   - lhs: The value to divide.
    ///   - rhs: The value to divide `lhs` by. `rhs` must not be zero.
    public static func % (lhs: UInt8, rhs: UInt8) -> UInt8

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// The sum of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 + 120` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x + 120                 // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow addition operator (`&+`).
    ///
    ///     x &+ 120                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: UInt8, rhs: UInt8) -> UInt8

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// The difference of the two arguments must be representable in the
    /// arguments' type. In the following example, the result of `21 - 50` is
    /// less than zero, the minimum representable `UInt8` value:
    ///
    ///     x - 50                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow subtraction operator (`&-`).
    ///
    ///     x &- 50                // 227
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: UInt8, rhs: UInt8) -> UInt8

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// The product of the two arguments must be representable in the arguments'
    /// type. In the following example, the result of `21 * 21` is greater than
    /// the maximum representable `Int8` value:
    ///
    ///     x * 21                  // Overflow error
    ///
    /// - Note: Overflow checking is not performed in `-Ounchecked` builds.
    ///
    /// If you want to opt out of overflow checking and ignore any overflow, use
    /// the overflow multiplication operator (`&*`).
    ///
    ///     x &* 21                // -115
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: UInt8, rhs: UInt8) -> UInt8

    public static func != (lhs: UInt8, rhs: UInt8) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: UInt8, rhs: UInt8) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: UInt8, rhs: UInt8) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: UInt8, rhs: UInt8) -> Bool
}

extension UInt8 {

    /// Construct with value `v.value`.
    ///
    /// - Precondition: `v.value` can be represented as ASCII (0..<128).
    public init(ascii v: Unicode.Scalar)
}

extension UInt8 : CustomReflectable {

    /// A mirror that reflects the `UInt8` instance.
    public var customMirror: Mirror { get }
}

extension UInt8 : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `UInt8` instance.
    @available(*, deprecated, message: "UInt8.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UInt8 {
}

extension UInt8 : CVarArg {
}

public typealias UTF16 = Unicode.UTF16

public typealias UTF32 = Unicode.UTF32

public typealias UTF8 = Unicode.UTF8

/// The type of an unbounded range operator.
public typealias UnboundedRange = (UnboundedRange_) -> ()

/// A range expression that represents the entire range of a collection.
///
/// You can use the unbounded range operator (`...`) to create a slice of a
/// collection that contains all of the collection's elements. Slicing with an
/// unbounded range is essentially a conversion of a collection instance into
/// its slice type.
///
/// For example, the following code declares `countLetterChanges(_:_:)`, a
/// function that finds the number of changes required to change one
/// word or phrase into another. The function uses a recursive approach to
/// perform the same comparisons on smaller and smaller pieces of the original
/// strings. In order to use recursion without making copies of the strings at
/// each step, `countLetterChanges(_:_:)` uses `Substring`, a string's slice
/// type, for its parameters.
///
///     func countLetterChanges(_ s1: Substring, _ s2: Substring) -> Int {
///         if s1.isEmpty { return s2.count }
///         if s2.isEmpty { return s1.count }
///
///         let cost = s1.first == s2.first ? 0 : 1
///
///         return min(
///             countLetterChanges(s1.dropFirst(), s2) + 1,
///             countLetterChanges(s1, s2.dropFirst()) + 1,
///             countLetterChanges(s1.dropFirst(), s2.dropFirst()) + cost)
///     }
///
/// To call `countLetterChanges(_:_:)` with two strings, use an unbounded
/// range in each string's subscript.
///
///     let word1 = "grizzly"
///     let word2 = "grisly"
///     let changes = countLetterChanges(word1[...], word2[...])
///     // changes == 2
public enum UnboundedRange_ {

    /// Creates an unbounded range expression.
    ///
    /// The unbounded range operator (`...`) is valid only within a collection's
    /// subscript.
    postfix public static func ... (_: UnboundedRange_)
}

/// The return type of `sequence(first:next:)`.
public typealias UnfoldFirstSequence<T> = UnfoldSequence<T, (T?, Bool)>

/// A sequence whose elements are produced via repeated applications of a
/// closure to some mutable state.
///
/// The elements of the sequence are computed lazily and the sequence may
/// potentially be infinite in length.
///
/// Instances of `UnfoldSequence` are created with the functions
/// `sequence(first:next:)` and `sequence(state:next:)`.
public struct UnfoldSequence<Element, State> : Sequence, IteratorProtocol {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> Element?
}

/// A namespace for Unicode utilities.
public enum Unicode {
}

extension Unicode {

    public enum UTF8 {

        case _swift3Buffer(Unicode.UTF8.ForwardParser)
    }
}

extension Unicode {

    public enum UTF16 {

        case _swift3Buffer(Unicode.UTF16.ForwardParser)
    }
}

extension Unicode {

    public typealias Encoding = _UnicodeEncoding
}

extension Unicode {

    /// A Unicode scalar value.
    ///
    /// The `Unicode.Scalar` type, representing a single Unicode scalar value, is
    /// the element type of a string's `unicodeScalars` collection.
    ///
    /// You can create a `Unicode.Scalar` instance by using a string literal that
    /// contains a single character representing exactly one Unicode scalar value.
    ///
    ///     let letterK: Unicode.Scalar = "K"
    ///     let kim: Unicode.Scalar = ""
    ///     print(letterK, kim)
    ///     // Prints "K "
    ///
    /// You can also create Unicode scalar values directly from their numeric
    /// representation.
    ///
    ///     let airplane = Unicode.Scalar(9992)
    ///     print(airplane)
    ///     // Prints ""
    public struct Scalar {
    }
}

extension Unicode {

    public enum UTF32 {

        case _swift3Codec
    }
}

extension Unicode {

    public enum ASCII {
    }
}

extension Unicode {

    public typealias Parser = _UnicodeParser
}

extension Unicode {

    /// The result of attempting to parse a `T` from some input.
    public enum ParseResult<T> {

        /// A `T` was parsed successfully
        case valid(T)

        /// The input was entirely consumed.
        case emptyInput

        /// An encoding error was detected.
        ///
        /// `length` is the number of underlying code units consumed by this
        /// error (the length of the longest prefix of a valid encoding
        /// sequence that could be recognized).
        case error(length: Int)
    }
}

extension Unicode.UTF8 {

    /// The basic unit of encoding
    public typealias CodeUnit = UInt8

    /// A valid scalar value as represented in this encoding
    public typealias EncodedScalar

    /// A unicode scalar value to be used when repairing
    /// encoding/decoding errors, as represented in this encoding.
    ///
    /// If the Unicode replacement character U+FFFD is representable in this
    /// encoding, `encodedReplacementCharacter` encodes that scalar value.
    public static var encodedReplacementCharacter: Unicode.UTF8.EncodedScalar { get }

    /// Converts from encoded to encoding-independent representation
    public static func decode(_ source: Unicode.UTF8.EncodedScalar) -> Unicode.Scalar

    /// Converts from encoding-independent to encoded representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    public static func encode(_ source: Unicode.Scalar) -> Unicode.UTF8.EncodedScalar?

    /// Converts a scalar from another encoding's representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    ///
    /// A default implementation of this method will be provided 
    /// automatically for any conforming type that does not implement one.
    public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Unicode.UTF8.EncodedScalar? where FromEncoding : _UnicodeEncoding

    /// A type that can be used to parse `CodeUnits` into
    /// `EncodedScalar`s.
    public struct ForwardParser {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        public init()
    }

    /// A type that can be used to parse a reversed sequence of
    /// `CodeUnits` into `EncodedScalar`s.
    public struct ReverseParser {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        public init()
    }
}

/// A codec for translating between Unicode scalar values and UTF-8 code
/// units.
extension Unicode.UTF8 : UnicodeCodec {

    /// Creates an instance of the UTF-8 codec.
    public init()

    /// Starts or continues decoding a UTF-8 sequence.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `Unicode.Scalar` or an error.
    ///
    /// The following example decodes the UTF-8 encoded bytes of a string into an
    /// array of `Unicode.Scalar` instances. This is a demonstration only---if
    /// you need the Unicode scalar representation of a string, use its
    /// `unicodeScalars` view.
    ///
    ///     let str = "Unicode"
    ///     print(Array(str.utf8))
    ///     // Prints "[226, 156, 168, 85, 110, 105, 99, 111, 100, 101, 226, 156, 168]"
    ///
    ///     var bytesIterator = str.utf8.makeIterator()
    ///     var scalars: [Unicode.Scalar] = []
    ///     var utf8Decoder = UTF8()
    ///     Decode: while true {
    ///         switch utf8Decoder.decode(&bytesIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter input: An iterator of code units to be decoded. `input` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    public mutating func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : IteratorProtocol, I.Element == Unicode.UTF8.CodeUnit

    /// Encodes a Unicode scalar as a series of code units by calling the given
    /// closure on each code unit.
    ///
    /// For example, the musical fermata symbol ("") is a single Unicode scalar
    /// value (`\u{1D110}`) but requires four code units for its UTF-8
    /// representation. The following code encodes a fermata in UTF-8:
    ///
    ///     var bytes: [UTF8.CodeUnit] = []
    ///     UTF8.encode("", into: { bytes.append($0) })
    ///     print(bytes)
    ///     // Prints "[240, 157, 132, 144]"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    public static func encode(_ input: Unicode.Scalar, into processCodeUnit: (Unicode.UTF8.CodeUnit) -> Void)

    /// Returns a Boolean value indicating whether the specified code unit is a
    /// UTF-8 continuation byte.
    ///
    /// Continuation bytes take the form `0b10xxxxxx`. For example, a lowercase
    /// "e" with an acute accent above it (`""`) uses 2 bytes for its UTF-8
    /// representation: `0b11000011` (195) and `0b10101001` (169). The second
    /// byte is a continuation byte.
    ///
    ///     let eAcute = ""
    ///     for codeUnit in eAcute.utf8 {
    ///         print(codeUnit, UTF8.isContinuation(codeUnit))
    ///     }
    ///     // Prints "195 false"
    ///     // Prints "169 true"
    ///
    /// - Parameter byte: A UTF-8 code unit.
    /// - Returns: `true` if `byte` is a continuation byte; otherwise, `false`.
    public static func isContinuation(_ byte: Unicode.UTF8.CodeUnit) -> Bool
}

extension Unicode.UTF16 {

    /// The basic unit of encoding
    public typealias CodeUnit = UInt16

    /// A valid scalar value as represented in this encoding
    public typealias EncodedScalar

    /// A unicode scalar value to be used when repairing
    /// encoding/decoding errors, as represented in this encoding.
    ///
    /// If the Unicode replacement character U+FFFD is representable in this
    /// encoding, `encodedReplacementCharacter` encodes that scalar value.
    public static var encodedReplacementCharacter: Unicode.UTF16.EncodedScalar { get }

    /// Converts from encoded to encoding-independent representation
    public static func decode(_ source: Unicode.UTF16.EncodedScalar) -> Unicode.Scalar

    /// Converts from encoding-independent to encoded representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    public static func encode(_ source: Unicode.Scalar) -> Unicode.UTF16.EncodedScalar?

    /// Converts a scalar from another encoding's representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    ///
    /// A default implementation of this method will be provided 
    /// automatically for any conforming type that does not implement one.
    public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Unicode.UTF16.EncodedScalar? where FromEncoding : _UnicodeEncoding

    /// A type that can be used to parse `CodeUnits` into
    /// `EncodedScalar`s.
    public struct ForwardParser {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        public init()
    }

    /// A type that can be used to parse a reversed sequence of
    /// `CodeUnits` into `EncodedScalar`s.
    public struct ReverseParser {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        public init()
    }
}

/// A codec for translating between Unicode scalar values and UTF-16 code
/// units.
extension Unicode.UTF16 : UnicodeCodec {

    /// Creates an instance of the UTF-16 codec.
    public init()

    /// Starts or continues decoding a UTF-16 sequence.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `Unicode.Scalar` or an error.
    ///
    /// The following example decodes the UTF-16 encoded bytes of a string into an
    /// array of `Unicode.Scalar` instances. This is a demonstration only---if
    /// you need the Unicode scalar representation of a string, use its
    /// `unicodeScalars` view.
    ///
    ///     let str = "Unicode"
    ///     print(Array(str.utf16))
    ///     // Prints "[10024, 85, 110, 105, 99, 111, 100, 101, 10024]"
    ///
    ///     var codeUnitIterator = str.utf16.makeIterator()
    ///     var scalars: [Unicode.Scalar] = []
    ///     var utf16Decoder = UTF16()
    ///     Decode: while true {
    ///         switch utf16Decoder.decode(&codeUnitIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter input: An iterator of code units to be decoded. `input` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    public mutating func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : IteratorProtocol, I.Element == Unicode.UTF16.CodeUnit

    /// Encodes a Unicode scalar as a series of code units by calling the given
    /// closure on each code unit.
    ///
    /// For example, the musical fermata symbol ("") is a single Unicode scalar
    /// value (`\u{1D110}`) but requires two code units for its UTF-16
    /// representation. The following code encodes a fermata in UTF-16:
    ///
    ///     var codeUnits: [UTF16.CodeUnit] = []
    ///     UTF16.encode("", into: { codeUnits.append($0) })
    ///     print(codeUnits)
    ///     // Prints "[55348, 56592]"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    public static func encode(_ input: Unicode.Scalar, into processCodeUnit: (Unicode.UTF16.CodeUnit) -> Void)
}

extension Unicode.UTF16 {

    /// Returns the number of code units required to encode the given Unicode
    /// scalar.
    ///
    /// Because a Unicode scalar value can require up to 21 bits to store its
    /// value, some Unicode scalars are represented in UTF-16 by a pair of
    /// 16-bit code units. The first and second code units of the pair,
    /// designated *leading* and *trailing* surrogates, make up a *surrogate
    /// pair*.
    ///
    ///     let anA: Unicode.Scalar = "A"
    ///     print(anA.value)
    ///     // Prints "65"
    ///     print(UTF16.width(anA))
    ///     // Prints "1"
    ///
    ///     let anApple: Unicode.Scalar = ""
    ///     print(anApple.value)
    ///     // Prints "127822"
    ///     print(UTF16.width(anApple))
    ///     // Prints "2"
    ///
    /// - Parameter x: A Unicode scalar value.
    /// - Returns: The width of `x` when encoded in UTF-16, either `1` or `2`.
    public static func width(_ x: Unicode.Scalar) -> Int

    /// Returns the high-surrogate code unit of the surrogate pair representing
    /// the specified Unicode scalar.
    ///
    /// Because a Unicode scalar value can require up to 21 bits to store its
    /// value, some Unicode scalars are represented in UTF-16 by a pair of
    /// 16-bit code units. The first and second code units of the pair,
    /// designated *leading* and *trailing* surrogates, make up a *surrogate
    /// pair*.
    ///
    ///     let apple: Unicode.Scalar = ""
    ///     print(UTF16.leadSurrogate(apple)
    ///     // Prints "55356"
    ///
    /// - Parameter x: A Unicode scalar value. `x` must be represented by a
    ///   surrogate pair when encoded in UTF-16. To check whether `x` is
    ///   represented by a surrogate pair, use `UTF16.width(x) == 2`.
    /// - Returns: The leading surrogate code unit of `x` when encoded in UTF-16.
    public static func leadSurrogate(_ x: Unicode.Scalar) -> UTF16.CodeUnit

    /// Returns the low-surrogate code unit of the surrogate pair representing
    /// the specified Unicode scalar.
    ///
    /// Because a Unicode scalar value can require up to 21 bits to store its
    /// value, some Unicode scalars are represented in UTF-16 by a pair of
    /// 16-bit code units. The first and second code units of the pair,
    /// designated *leading* and *trailing* surrogates, make up a *surrogate
    /// pair*.
    ///
    ///     let apple: Unicode.Scalar = ""
    ///     print(UTF16.trailSurrogate(apple)
    ///     // Prints "57166"
    ///
    /// - Parameter x: A Unicode scalar value. `x` must be represented by a
    ///   surrogate pair when encoded in UTF-16. To check whether `x` is
    ///   represented by a surrogate pair, use `UTF16.width(x) == 2`.
    /// - Returns: The trailing surrogate code unit of `x` when encoded in UTF-16.
    public static func trailSurrogate(_ x: Unicode.Scalar) -> UTF16.CodeUnit

    /// Returns a Boolean value indicating whether the specified code unit is a
    /// high-surrogate code unit.
    ///
    /// Here's an example of checking whether each code unit in a string's
    /// `utf16` view is a lead surrogate. The `apple` string contains a single
    /// emoji character made up of a surrogate pair when encoded in UTF-16.
    ///
    ///     let apple = ""
    ///     for unit in apple.utf16 {
    ///         print(UTF16.isLeadSurrogate(unit))
    ///     }
    ///     // Prints "true"
    ///     // Prints "false"
    ///
    /// This method does not validate the encoding of a UTF-16 sequence beyond
    /// the specified code unit. Specifically, it does not validate that a
    /// low-surrogate code unit follows `x`.
    ///
    /// - Parameter x: A UTF-16 code unit.
    /// - Returns: `true` if `x` is a high-surrogate code unit; otherwise,
    ///   `false`.
    public static func isLeadSurrogate(_ x: Unicode.UTF16.CodeUnit) -> Bool

    /// Returns a Boolean value indicating whether the specified code unit is a
    /// low-surrogate code unit.
    ///
    /// Here's an example of checking whether each code unit in a string's
    /// `utf16` view is a trailing surrogate. The `apple` string contains a
    /// single emoji character made up of a surrogate pair when encoded in
    /// UTF-16.
    ///
    ///     let apple = ""
    ///     for unit in apple.utf16 {
    ///         print(UTF16.isTrailSurrogate(unit))
    ///     }
    ///     // Prints "false"
    ///     // Prints "true"
    ///
    /// This method does not validate the encoding of a UTF-16 sequence beyond
    /// the specified code unit. Specifically, it does not validate that a
    /// high-surrogate code unit precedes `x`.
    ///
    /// - Parameter x: A UTF-16 code unit.
    /// - Returns: `true` if `x` is a low-surrogate code unit; otherwise,
    ///   `false`.
    public static func isTrailSurrogate(_ x: Unicode.UTF16.CodeUnit) -> Bool

    /// Returns the number of UTF-16 code units required for the given code unit
    /// sequence when transcoded to UTF-16, and a Boolean value indicating
    /// whether the sequence was found to contain only ASCII characters.
    ///
    /// The following example finds the length of the UTF-16 encoding of the
    /// string `"Fermata "`, starting with its UTF-8 representation.
    ///
    ///     let fermata = "Fermata "
    ///     let bytes = fermata.utf8
    ///     print(Array(bytes))
    ///     // Prints "[70, 101, 114, 109, 97, 116, 97, 32, 240, 157, 132, 144]"
    ///
    ///     let result = transcodedLength(of: bytes.makeIterator(),
    ///                                   decodedAs: UTF8.self,
    ///                                   repairingIllFormedSequences: false)
    ///     print(result)
    ///     // Prints "Optional((10, false))"
    ///
    /// - Parameters:
    ///   - input: An iterator of code units to be translated, encoded as
    ///     `sourceEncoding`. If `repairingIllFormedSequences` is `true`, the
    ///     entire iterator will be exhausted. Otherwise, iteration will stop if
    ///     an ill-formed sequence is detected.
    ///   - sourceEncoding: The Unicode encoding of `input`.
    ///   - repairingIllFormedSequences: Pass `true` to measure the length of
    ///     `input` even when `input` contains ill-formed sequences. Each
    ///     ill-formed sequence is replaced with a Unicode replacement character
    ///     (`"\u{FFFD}"`) and is measured as such. Pass `false` to immediately
    ///     stop measuring `input` when an ill-formed sequence is encountered.
    /// - Returns: A tuple containing the number of UTF-16 code units required to
    ///   encode `input` and a Boolean value that indicates whether the `input`
    ///   contained only ASCII characters. If `repairingIllFormedSequences` is
    ///   `false` and an ill-formed sequence is detected, this method returns
    ///   `nil`.
    public static func transcodedLength<Input, Encoding>(of input: Input, decodedAs sourceEncoding: Encoding.Type, repairingIllFormedSequences: Bool) -> (count: Int, isASCII: Bool)? where Input : IteratorProtocol, Encoding : _UnicodeEncoding, Input.Element == Encoding.CodeUnit
}

extension Unicode.Scalar : ExpressibleByUnicodeScalarLiteral {

    /// A numeric representation of the Unicode scalar.
    public var value: UInt32 { get }

    /// Creates a Unicode scalar with the specified value.
    ///
    /// Do not call this initializer directly. It may be used by the compiler
    /// when you use a string literal to initialize a `Unicode.Scalar` instance.
    ///
    ///     let letterK: Unicode.Scalar = "K"
    ///     print(letterK)
    ///     // Prints "K"
    ///
    /// In this example, the assignment to the `letterK` constant is handled by
    /// this initializer behind the scenes.
    public init(unicodeScalarLiteral value: Unicode.Scalar)

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// For example, the following code sample creates a `Unicode.Scalar`
    /// instance with a value of an emoji character:
    ///
    ///     let codepoint: UInt32 = 127881
    ///     let emoji = Unicode.Scalar(codepoint)
    ///     print(emoji!)
    ///     // Prints ""
    ///
    /// In case of an invalid input value, nil is returned.
    ///
    ///     let codepoint: UInt32 = extValue   // This might be an invalid value
    ///     if let emoji = Unicode.Scalar(codepoint) {
    ///       print(emoji)
    ///     } else {
    ///       // Do something else
    ///     }
    ///
    /// - Parameter v: The Unicode code point to use for the scalar. The
    ///   initializer succeeds if `v` is a valid Unicode scalar value---that is,
    ///   if `v` is in the range `0...0xD7FF` or `0xE000...0x10FFFF`. If `v` is
    ///   an invalid Unicode scalar value, the result is `nil`.
    public init?(_ v: UInt32)

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// For example, the following code sample creates a `Unicode.Scalar`
    /// instance with a value of `""`, the Korean word for rice:
    ///
    ///     let codepoint: UInt16 = 48165
    ///     let bap = Unicode.Scalar(codepoint)
    ///     print(bap!)
    ///     // Prints ""
    ///
    /// In case of an invalid input value, the result is `nil`.
    ///
    ///     let codepoint: UInt16 = extValue   // This might be an invalid value
    ///     if let bap = Unicode.Scalar(codepoint) {
    ///         print(bap)
    ///     } else {
    ///         // Do something else
    ///     }
    ///
    /// - Parameter v: The Unicode code point to use for the scalar. The
    ///   initializer succeeds if `v` is a valid Unicode scalar value, in the
    ///   range `0...0xD7FF` or `0xE000...0x10FFFF`. If `v` is an invalid
    ///   unicode scalar value, the result is `nil`.
    public init?(_ v: UInt16)

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// For example, the following code sample creates a `Unicode.Scalar`
    /// instance with a value of `"7"`:
    ///
    ///     let codepoint: UInt8 = 55
    ///     let seven = Unicode.Scalar(codepoint)
    ///     print(seven)
    ///     // Prints "7"
    ///
    /// - Parameter v: The code point to use for the scalar.
    public init(_ v: UInt8)

    /// Creates a duplicate of the given Unicode scalar.
    public init(_ v: Unicode.Scalar)

    /// Returns a string representation of the Unicode scalar.
    ///
    /// Scalar values representing characters that are normally unprintable or
    /// that otherwise require escaping are escaped with a backslash.
    ///
    ///     let tab = Unicode.Scalar(9)
    ///     print(tab)
    ///     // Prints " "
    ///     print(tab.escaped(asASCII: false))
    ///     // Prints "\t"
    ///
    /// When the `forceASCII` parameter is `true`, a `Unicode.Scalar` instance
    /// with a value greater than 127 is represented using an escaped numeric
    /// value; otherwise, non-ASCII characters are represented using their
    /// typical string value.
    ///
    ///     let bap = Unicode.Scalar(48165)
    ///     print(bap.escaped(asASCII: false))
    ///     // Prints ""
    ///     print(bap.escaped(asASCII: true))
    ///     // Prints "\u{BC25}"
    ///
    /// - Parameter forceASCII: Pass `true` if you need the result to use only
    ///   ASCII characters; otherwise, pass `false`.
    /// - Returns: A string representation of the scalar.
    public func escaped(asASCII forceASCII: Bool) -> String

    /// A Boolean value indicating whether the Unicode scalar is an ASCII
    /// character.
    ///
    /// ASCII characters have a scalar value between 0 and 127, inclusive. For
    /// example:
    ///
    ///     let canyon = "Can"
    ///     for scalar in canyon.unicodeScalars {
    ///         print(scalar, scalar.isASCII, scalar.value)
    ///     }
    ///     // Prints "C true 67"
    ///     // Prints "a true 97"
    ///     // Prints " false 241"
    ///     // Prints " false 243"
    ///     // Prints "n true 110"
    public var isASCII: Bool { get }
}

extension Unicode.Scalar : CustomStringConvertible, CustomDebugStringConvertible {

    /// A textual representation of the Unicode scalar.
    public var description: String { get }

    /// An escaped textual representation of the Unicode scalar, suitable for
    /// debugging.
    public var debugDescription: String { get }
}

extension Unicode.Scalar : LosslessStringConvertible {

    /// Instantiates an instance of the conforming type from a string
    /// representation.
    public init?(_ description: String)
}

extension Unicode.Scalar : Hashable {

    /// The Unicode scalar's hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    public var hashValue: Int { get }
}

extension Unicode.Scalar {

    /// Creates a Unicode scalar with the specified numeric value.
    ///
    /// - Parameter v: The Unicode code point to use for the scalar. `v` must be
    ///   a valid Unicode scalar value, in the ranges `0...0xD7FF` or
    ///   `0xE000...0x10FFFF`. In case of an invalid unicode scalar value, nil is
    ///   returned.
    ///
    /// For example, the following code sample creates a `Unicode.Scalar` instance
    /// with a value of an emoji character:
    ///
    ///     let codepoint = 127881
    ///     let emoji = Unicode.Scalar(codepoint)
    ///     print(emoji)
    ///     // Prints ""
    ///
    /// In case of an invalid input value, nil is returned.
    ///
    ///     let codepoint: UInt32 = extValue // This might be an invalid value. 
    ///     if let emoji = Unicode.Scalar(codepoint) {
    ///       print(emoji)
    ///     } else {
    ///       // Do something else
    ///     }
    public init?(_ v: Int)
}

extension Unicode.Scalar : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool
}

extension Unicode.Scalar : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool
}

extension Unicode.Scalar {

    public struct UTF16View {
    }

    public var utf16: Unicode.Scalar.UTF16View { get }
}

extension Unicode.Scalar : CustomReflectable {

    /// A mirror that reflects the `Unicode.Scalar` instance.
    public var customMirror: Mirror { get }
}

extension Unicode.Scalar : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for the `Unicode.Scalar` instance.
    @available(*, deprecated, message: "Unicode.Scalar.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension Unicode.Scalar : TextOutputStreamable {

    /// Writes the textual representation of the Unicode scalar into the given
    /// output stream.
    ///
    /// - Parameter target: An output stream.
    public func write<Target>(to target: inout Target) where Target : TextOutputStream
}

extension Unicode.UTF32 {

    /// The basic unit of encoding
    public typealias CodeUnit = UInt32

    /// A valid scalar value as represented in this encoding
    public typealias EncodedScalar = CollectionOfOne<UInt32>

    /// A unicode scalar value to be used when repairing
    /// encoding/decoding errors, as represented in this encoding.
    ///
    /// If the Unicode replacement character U+FFFD is representable in this
    /// encoding, `encodedReplacementCharacter` encodes that scalar value.
    public static var encodedReplacementCharacter: Unicode.UTF32.EncodedScalar { get }

    /// Converts from encoded to encoding-independent representation
    public static func decode(_ source: Unicode.UTF32.EncodedScalar) -> Unicode.Scalar

    /// Converts from encoding-independent to encoded representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    public static func encode(_ source: Unicode.Scalar) -> Unicode.UTF32.EncodedScalar?

    public struct Parser {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        public init()
    }

    /// A type that can be used to parse `CodeUnits` into
    /// `EncodedScalar`s.
    public typealias ForwardParser = Unicode.UTF32.Parser

    /// A type that can be used to parse a reversed sequence of
    /// `CodeUnits` into `EncodedScalar`s.
    public typealias ReverseParser = Unicode.UTF32.Parser
}

/// A codec for translating between Unicode scalar values and UTF-32 code
/// units.
extension Unicode.UTF32 : UnicodeCodec {

    /// Creates an instance of the UTF-32 codec.
    public init()

    /// Starts or continues decoding a UTF-32 sequence.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `Unicode.Scalar` or an error.
    ///
    /// The following example decodes the UTF-16 encoded bytes of a string
    /// into an array of `Unicode.Scalar` instances. This is a demonstration
    /// only---if you need the Unicode scalar representation of a string, use
    /// its `unicodeScalars` view.
    ///
    ///     // UTF-32 representation of "Unicode"
    ///     let codeUnits: [UTF32.CodeUnit] =
    ///             [10024, 85, 110, 105, 99, 111, 100, 101, 10024]
    ///
    ///     var codeUnitIterator = codeUnits.makeIterator()
    ///     var scalars: [Unicode.Scalar] = []
    ///     var utf32Decoder = UTF32()
    ///     Decode: while true {
    ///         switch utf32Decoder.decode(&codeUnitIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter input: An iterator of code units to be decoded. `input` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    public mutating func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : IteratorProtocol, I.Element == Unicode.UTF32.CodeUnit

    /// Encodes a Unicode scalar as a UTF-32 code unit by calling the given
    /// closure.
    ///
    /// For example, like every Unicode scalar, the musical fermata symbol ("")
    /// can be represented in UTF-32 as a single code unit. The following code
    /// encodes a fermata in UTF-32:
    ///
    ///     var codeUnit: UTF32.CodeUnit = 0
    ///     UTF32.encode("", into: { codeUnit = $0 })
    ///     print(codeUnit)
    ///     // Prints "119056"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    public static func encode(_ input: Unicode.Scalar, into processCodeUnit: (Unicode.UTF32.CodeUnit) -> Void)
}

extension Unicode.ASCII {

    /// The basic unit of encoding
    public typealias CodeUnit = UInt8

    /// A valid scalar value as represented in this encoding
    public typealias EncodedScalar = CollectionOfOne<Unicode.ASCII.CodeUnit>

    /// A unicode scalar value to be used when repairing
    /// encoding/decoding errors, as represented in this encoding.
    ///
    /// If the Unicode replacement character U+FFFD is representable in this
    /// encoding, `encodedReplacementCharacter` encodes that scalar value.
    public static var encodedReplacementCharacter: Unicode.ASCII.EncodedScalar { get }

    /// Converts from encoded to encoding-independent representation
    public static func decode(_ source: Unicode.ASCII.EncodedScalar) -> Unicode.Scalar

    /// Converts from encoding-independent to encoded representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    public static func encode(_ source: Unicode.Scalar) -> Unicode.ASCII.EncodedScalar?

    /// Converts a scalar from another encoding's representation, returning
    /// `nil` if the scalar can't be represented in this encoding.
    ///
    /// A default implementation of this method will be provided 
    /// automatically for any conforming type that does not implement one.
    public static func transcode<FromEncoding>(_ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type) -> Unicode.ASCII.EncodedScalar? where FromEncoding : _UnicodeEncoding

    public struct Parser {

        /// Constructs an instance that can be used to begin parsing `CodeUnit`s at
        /// any Unicode scalar boundary.
        public init()
    }

    /// A type that can be used to parse `CodeUnits` into
    /// `EncodedScalar`s.
    public typealias ForwardParser = Unicode.ASCII.Parser

    /// A type that can be used to parse a reversed sequence of
    /// `CodeUnits` into `EncodedScalar`s.
    public typealias ReverseParser = Unicode.ASCII.Parser
}

extension Unicode.UTF8.ForwardParser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.UTF8
}

extension Unicode.UTF8.ReverseParser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.UTF8
}

extension Unicode.UTF16.ForwardParser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.UTF16
}

extension Unicode.UTF16.ReverseParser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.UTF16
}

extension Unicode.Scalar.UTF16View : RandomAccessCollection {

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// The position of the first code unit.
    public var startIndex: Int { get }

    /// The "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Accesses the code unit at the specified position.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    public subscript(position: Int) -> UTF16.CodeUnit { get }
}

extension Unicode.UTF32.Parser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.UTF32

    /// Parses a single Unicode scalar value from `input`.
    public mutating func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<Unicode.UTF32.Parser.Encoding.EncodedScalar> where I : IteratorProtocol, I.Element == Unicode.UTF32.Parser.Encoding.CodeUnit
}

extension Unicode.ASCII.Parser {

    /// The encoding with which this parser is associated
    public typealias Encoding = Unicode.ASCII

    /// Parses a single Unicode scalar value from `input`.
    public mutating func parseScalar<I>(from input: inout I) -> Unicode.ParseResult<Unicode.ASCII.Parser.Encoding.EncodedScalar> where I : IteratorProtocol, I.Element == Unicode.ASCII.Parser.Encoding.CodeUnit
}

/// A Unicode encoding form that translates between Unicode scalar values and
/// form-specific code units.
///
/// The `UnicodeCodec` protocol declares methods that decode code unit
/// sequences into Unicode scalar values and encode Unicode scalar values
/// into code unit sequences. The standard library implements codecs for the
/// UTF-8, UTF-16, and UTF-32 encoding schemes as the `UTF8`, `UTF16`, and
/// `UTF32` types, respectively. Use the `Unicode.Scalar` type to work with
/// decoded Unicode scalar values.
public protocol UnicodeCodec : _UnicodeEncoding {

    /// Creates an instance of the codec.
    public init()

    /// Starts or continues decoding a code unit sequence into Unicode scalar
    /// values.
    ///
    /// To decode a code unit sequence completely, call this method repeatedly
    /// until it returns `UnicodeDecodingResult.emptyInput`. Checking that the
    /// iterator was exhausted is not sufficient, because the decoder can store
    /// buffered data from the input iterator.
    ///
    /// Because of buffering, it is impossible to find the corresponding position
    /// in the iterator for a given returned `Unicode.Scalar` or an error.
    ///
    /// The following example decodes the UTF-8 encoded bytes of a string into an
    /// array of `Unicode.Scalar` instances:
    ///
    ///     let str = "Unicode"
    ///     print(Array(str.utf8))
    ///     // Prints "[226, 156, 168, 85, 110, 105, 99, 111, 100, 101, 226, 156, 168]"
    ///
    ///     var bytesIterator = str.utf8.makeIterator()
    ///     var scalars: [Unicode.Scalar] = []
    ///     var utf8Decoder = UTF8()
    ///     Decode: while true {
    ///         switch utf8Decoder.decode(&bytesIterator) {
    ///         case .scalarValue(let v): scalars.append(v)
    ///         case .emptyInput: break Decode
    ///         case .error:
    ///             print("Decoding error")
    ///             break Decode
    ///         }
    ///     }
    ///     print(scalars)
    ///     // Prints "["\u{2728}", "U", "n", "i", "c", "o", "d", "e", "\u{2728}"]"
    ///
    /// - Parameter input: An iterator of code units to be decoded. `input` must be
    ///   the same iterator instance in repeated calls to this method. Do not
    ///   advance the iterator or any copies of the iterator outside this
    ///   method.
    /// - Returns: A `UnicodeDecodingResult` instance, representing the next
    ///   Unicode scalar, an indication of an error, or an indication that the
    ///   UTF sequence has been fully decoded.
    public mutating func decode<I>(_ input: inout I) -> UnicodeDecodingResult where I : IteratorProtocol, Self.CodeUnit == I.Element

    /// Encodes a Unicode scalar as a series of code units by calling the given
    /// closure on each code unit.
    ///
    /// For example, the musical fermata symbol ("") is a single Unicode scalar
    /// value (`\u{1D110}`) but requires four code units for its UTF-8
    /// representation. The following code uses the `UTF8` codec to encode a
    /// fermata in UTF-8:
    ///
    ///     var bytes: [UTF8.CodeUnit] = []
    ///     UTF8.encode("", into: { bytes.append($0) })
    ///     print(bytes)
    ///     // Prints "[240, 157, 132, 144]"
    ///
    /// - Parameters:
    ///   - input: The Unicode scalar value to encode.
    ///   - processCodeUnit: A closure that processes one code unit argument at a
    ///     time.
    public static func encode(_ input: Unicode.Scalar, into processCodeUnit: (Self.CodeUnit) -> Void)
}

/// The result of one Unicode decoding step.
///
/// Each `UnicodeDecodingResult` instance can represent a Unicode scalar value,
/// an indication that no more Unicode scalars are available, or an indication
/// of a decoding error.
public enum UnicodeDecodingResult : Equatable {

    /// A decoded Unicode scalar value.
    case scalarValue(Unicode.Scalar)

    /// An indication that no more Unicode scalars are available in the input.
    case emptyInput

    /// An indication of a decoding error.
    case error

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UnicodeDecodingResult, rhs: UnicodeDecodingResult) -> Bool
}

public typealias UnicodeScalar = Unicode.Scalar

@available(*, deprecated, renamed: "ExpressibleByUnicodeScalarLiteral")
public typealias UnicodeScalarLiteralConvertible = ExpressibleByUnicodeScalarLiteral

/// The default type for an otherwise-unconstrained unicode scalar literal.
public typealias UnicodeScalarType = String

/// A type that provides a view into a decoder's storage and is used to hold
/// the encoded properties of a decodable type sequentially, without keys.
///
/// Decoders should provide types conforming to `UnkeyedDecodingContainer` for
/// their format.
public protocol UnkeyedDecodingContainer {

    /// The path of coding keys taken to get to this point in decoding.
    public var codingPath: [CodingKey] { get }

    /// The number of elements contained within this container.
    ///
    /// If the number of elements is unknown, the value is `nil`.
    public var count: Int? { get }

    /// A Boolean value indicating whether there are no more elements left to be
    /// decoded in the container.
    public var isAtEnd: Bool { get }

    /// The current decoding index of the container (i.e. the index of the next
    /// element to be decoded.) Incremented after every successful decode call.
    public var currentIndex: Int { get }

    /// Decodes a null value.
    ///
    /// If the value is not null, does not increment currentIndex.
    ///
    /// - returns: Whether the encountered value was null.
    /// - throws: `DecodingError.valueNotFound` if there are no more values to
    ///   decode.
    public mutating func decodeNil() throws -> Bool

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: Bool.Type) throws -> Bool

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: String.Type) throws -> String

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: Double.Type) throws -> Double

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: Float.Type) throws -> Float

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: Int.Type) throws -> Int

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: Int8.Type) throws -> Int8

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: Int16.Type) throws -> Int16

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: Int32.Type) throws -> Int32

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: Int64.Type) throws -> Int64

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: UInt.Type) throws -> UInt

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: UInt8.Type) throws -> UInt8

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: UInt16.Type) throws -> UInt16

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: UInt32.Type) throws -> UInt32

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode(_ type: UInt64.Type) throws -> UInt64

    /// Decodes a value of the given type.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A value of the requested type, if present for the given key
    ///   and convertible to the requested type.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func decode<T>(_ type: T.Type) throws -> T where T : Decodable

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: Bool.Type) throws -> Bool?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: String.Type) throws -> String?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: Double.Type) throws -> Double?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: Float.Type) throws -> Float?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: Int.Type) throws -> Int?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: Int8.Type) throws -> Int8?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: Int16.Type) throws -> Int16?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: Int32.Type) throws -> Int32?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: Int64.Type) throws -> Int64?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: UInt.Type) throws -> UInt?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: UInt8.Type) throws -> UInt8?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: UInt16.Type) throws -> UInt16?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: UInt32.Type) throws -> UInt32?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent(_ type: UInt64.Type) throws -> UInt64?

    /// Decodes a value of the given type, if present.
    ///
    /// This method returns `nil` if the container has no elements left to
    /// decode, or if the value is null. The difference between these states can
    /// be distinguished by checking `isAtEnd`.
    ///
    /// - parameter type: The type of value to decode.
    /// - returns: A decoded value of the requested type, or `nil` if the value
    ///   is a null value, or if there are no more elements to decode.
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value
    ///   is not convertible to the requested type.
    public mutating func decodeIfPresent<T>(_ type: T.Type) throws -> T? where T : Decodable

    /// Decodes a nested container keyed by the given type.
    ///
    /// - parameter type: The key type to use for the container.
    /// - returns: A keyed decoding container view into `self`.
    /// - throws: `DecodingError.typeMismatch` if the encountered stored value is
    ///   not a keyed container.
    public mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey

    /// Decodes an unkeyed nested container.
    ///
    /// - returns: An unkeyed decoding container view into `self`.
    /// - throws: `DecodingError.typeMismatch` if the encountered stored value is
    ///   not an unkeyed container.
    public mutating func nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer

    /// Decodes a nested container and returns a `Decoder` instance for decoding
    /// `super` from that container.
    ///
    /// - returns: A new `Decoder` to pass to `super.init(from:)`.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value
    ///   is null, or of there are no more values to decode.
    public mutating func superDecoder() throws -> Decoder
}

extension UnkeyedDecodingContainer {

    public mutating func decodeIfPresent(_ type: Bool.Type) throws -> Bool?

    public mutating func decodeIfPresent(_ type: String.Type) throws -> String?

    public mutating func decodeIfPresent(_ type: Double.Type) throws -> Double?

    public mutating func decodeIfPresent(_ type: Float.Type) throws -> Float?

    public mutating func decodeIfPresent(_ type: Int.Type) throws -> Int?

    public mutating func decodeIfPresent(_ type: Int8.Type) throws -> Int8?

    public mutating func decodeIfPresent(_ type: Int16.Type) throws -> Int16?

    public mutating func decodeIfPresent(_ type: Int32.Type) throws -> Int32?

    public mutating func decodeIfPresent(_ type: Int64.Type) throws -> Int64?

    public mutating func decodeIfPresent(_ type: UInt.Type) throws -> UInt?

    public mutating func decodeIfPresent(_ type: UInt8.Type) throws -> UInt8?

    public mutating func decodeIfPresent(_ type: UInt16.Type) throws -> UInt16?

    public mutating func decodeIfPresent(_ type: UInt32.Type) throws -> UInt32?

    public mutating func decodeIfPresent(_ type: UInt64.Type) throws -> UInt64?

    public mutating func decodeIfPresent<T>(_ type: T.Type) throws -> T? where T : Decodable
}

/// A type that provides a view into an encoder's storage and is used to hold
/// the encoded properties of an encodable type sequentially, without keys.
///
/// Encoders should provide types conforming to `UnkeyedEncodingContainer` for
/// their format.
public protocol UnkeyedEncodingContainer {

    /// The path of coding keys taken to get to this point in encoding.
    public var codingPath: [CodingKey] { get }

    /// The number of elements encoded into the container.
    public var count: Int { get }

    /// Encodes a null value.
    ///
    /// - throws: `EncodingError.invalidValue` if a null value is invalid in the
    ///   current context for this format.
    public mutating func encodeNil() throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Bool) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: String) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Double) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Float) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int8) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int16) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int32) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: Int64) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt8) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt16) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt32) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode(_ value: UInt64) throws

    /// Encodes the given value.
    ///
    /// - parameter value: The value to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encode<T>(_ value: T) throws where T : Encodable

    /// Encodes a reference to the given object only if it is encoded
    /// unconditionally elsewhere in the payload (previously, or in the future).
    ///
    /// For encoders which don't support this feature, the default implementation
    /// encodes the given object unconditionally.
    ///
    /// For formats which don't support this feature, the default implementation
    /// encodes the given object unconditionally.
    ///
    /// - parameter object: The object to encode.
    /// - throws: `EncodingError.invalidValue` if the given value is invalid in
    ///   the current context for this format.
    public mutating func encodeConditional<T>(_ object: T) throws where T : AnyObject, T : Encodable

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Bool

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == String

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Double

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Float

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Int

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Int8

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Int16

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Int32

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Int64

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == UInt

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == UInt8

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == UInt16

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == UInt32

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == UInt64

    /// Encodes the elements of the given sequence.
    ///
    /// - parameter sequence: The sequences whose contents to encode.
    /// - throws: An error if any of the contained values throws an error.
    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element : Encodable

    /// Encodes a nested container keyed by the given type and returns it.
    ///
    /// - parameter keyType: The key type to use for the container.
    /// - returns: A new keyed encoding container.
    public mutating func nestedContainer<NestedKey>(keyedBy keyType: NestedKey.Type) -> KeyedEncodingContainer<NestedKey> where NestedKey : CodingKey

    /// Encodes an unkeyed encoding container and returns it.
    ///
    /// - returns: A new unkeyed encoding container.
    public mutating func nestedUnkeyedContainer() -> UnkeyedEncodingContainer

    /// Encodes a nested container and returns an `Encoder` instance for encoding
    /// `super` into that container.
    ///
    /// - returns: A new encoder to pass to `super.encode(to:)`.
    public mutating func superEncoder() -> Encoder
}

extension UnkeyedEncodingContainer {

    public mutating func encodeConditional<T>(_ object: T) throws where T : AnyObject, T : Encodable

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Bool

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == String

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Double

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Float

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Int

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Int8

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Int16

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Int32

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == Int64

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == UInt

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == UInt8

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == UInt16

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == UInt32

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element == UInt64

    public mutating func encode<T>(contentsOf sequence: T) throws where T : Sequence, T.Element : Encodable
}

/// A type for propagating an unmanaged object reference.
///
/// When you use this type, you become partially responsible for
/// keeping the object alive.
public struct Unmanaged<Instance> where Instance : AnyObject {

    /// Unsafely turns an opaque C pointer into an unmanaged class reference.
    ///
    /// This operation does not change reference counts.
    ///
    ///     let str: CFString = Unmanaged.fromOpaque(ptr).takeUnretainedValue()
    ///
    /// - Parameter value: An opaque C pointer.
    /// - Returns: An unmanaged class reference to `value`.
    public static func fromOpaque(_ value: UnsafeRawPointer) -> Unmanaged<Instance>

    /// Unsafely converts an unmanaged class reference to a pointer.
    ///
    /// This operation does not change reference counts.
    ///
    ///     let str0 = "boxcar" as CFString
    ///     let bits = Unmanaged.passUnretained(str0)
    ///     let ptr = bits.toOpaque()
    ///
    /// - Returns: An opaque pointer to the value of this unmanaged reference.
    public func toOpaque() -> UnsafeMutableRawPointer

    /// Creates an unmanaged reference with an unbalanced retain.
    ///
    /// The instance passed as `value` will leak if nothing eventually balances
    /// the retain.
    ///
    /// This is useful when passing an object to an API which Swift does not know
    /// the ownership rules for, but you know that the API expects you to pass
    /// the object at +1.
    ///
    /// - Parameter value: A class instance.
    /// - Returns: An unmanaged reference to the object passed as `value`.
    public static func passRetained(_ value: Instance) -> Unmanaged<Instance>

    /// Creates an unmanaged reference without performing an unbalanced
    /// retain.
    ///
    /// This is useful when passing a reference to an API which Swift
    /// does not know the ownership rules for, but you know that the
    /// API expects you to pass the object at +0.
    ///
    ///     CFArraySetValueAtIndex(.passUnretained(array), i,
    ///                            .passUnretained(object))
    ///
    /// - Parameter value: A class instance.
    /// - Returns: An unmanaged reference to the object passed as `value`.
    public static func passUnretained(_ value: Instance) -> Unmanaged<Instance>

    /// Gets the value of this unmanaged reference as a managed
    /// reference without consuming an unbalanced retain of it.
    ///
    /// This is useful when a function returns an unmanaged reference
    /// and you know that you're not responsible for releasing the result.
    ///
    /// - Returns: The object referenced by this `Unmanaged` instance.
    public func takeUnretainedValue() -> Instance

    /// Gets the value of this unmanaged reference as a managed
    /// reference and consumes an unbalanced retain of it.
    ///
    /// This is useful when a function returns an unmanaged reference
    /// and you know that you're responsible for releasing the result.
    ///
    /// - Returns: The object referenced by this `Unmanaged` instance.
    public func takeRetainedValue() -> Instance

    /// Performs an unbalanced retain of the object.
    public func retain() -> Unmanaged<Instance>

    /// Performs an unbalanced release of the object.
    public func release()

    /// Performs an unbalanced autorelease of the object.
    public func autorelease() -> Unmanaged<Instance>
}

public struct UnsafeBufferPointer<Element> {
}

extension UnsafeBufferPointer {

    /// An iterator for the elements in the buffer referenced by an
    /// `UnsafeBufferPointer` or `UnsafeMutableBufferPointer` instance.
    public struct Iterator {
    }
}

extension UnsafeBufferPointer : Sequence {

    /// Returns an iterator over the elements of this buffer.
    ///
    /// - Returns: An iterator over the elements of this buffer.
    public func makeIterator() -> UnsafeBufferPointer<Element>.Iterator
}

extension UnsafeBufferPointer : Collection, RandomAccessCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// The index of the first element in a nonempty buffer.
    ///
    /// The `startIndex` property of an `UnsafeBufferPointer` instance
    /// is always zero.
    public var startIndex: Int { get }

    /// The "past the end" position---that is, the position one greater than the
    /// last valid subscript argument.
    ///
    /// The `endIndex` property of an `UnsafeBufferPointer` instance is
    /// always identical to `count`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Int) -> Int

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Int)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Int, offsetBy n: Int) -> Int

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -> Int?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Int, to end: Int) -> Int

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: UnsafeBufferPointer<Element>.Indices { get }

    /// The number of elements in the buffer.
    ///
    /// If the `baseAddress` of this buffer is `nil`, the count is zero. However,
    /// a buffer can have a `count` of zero even with a non-`nil` base address.
    public var count: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example uses the buffer pointer's subscript to access every
    /// other element of the buffer:
    ///
    ///     let numbers = [1, 2, 3, 4, 5]
    ///     let sum = numbers.withUnsafeBufferPointer { buffer -> Int in
    ///         var result = 0
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex, by: 2) {
    ///             result += buffer[i]
    ///         }
    ///         return result
    ///     }
    ///     // 'sum' == 9
    ///
    /// - Note: Bounds checks for `i` are performed only in debug mode.
    ///
    /// - Parameter i: The position of the element to access. `i` must be in the
    ///   range `0..<count`.
    public subscript(i: Int) -> Element { get }

    /// Accesses a contiguous subrange of the buffer's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original buffer uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice from a buffer of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original buffer.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets.withUnsafeBufferPointer { buffer in
    ///         let streetSlice = buffer[2..<buffer.endIndex]
    ///         print(Array(streetSlice))
    ///         // Prints "["Channing", "Douglas", "Evarts"]"
    ///         let index = streetSlice.firstIndex(of: "Evarts")    // 4
    ///         print(buffer[index!])
    ///         // Prints "Evarts"
    ///     }
    ///
    /// - Note: Bounds checks for `bounds` are performed only in debug mode.
    ///
    /// - Parameter bounds: A range of the buffer's indices. The bounds of
    ///   the range must be valid indices of the buffer.
    public subscript(bounds: Range<Int>) -> Slice<UnsafeBufferPointer<Element>> { get }
}

extension UnsafeBufferPointer {

    /// Creates a new buffer pointer over the specified number of contiguous
    /// instances beginning at the given pointer.
    ///
    /// - Parameters:
    ///   - start: A pointer to the start of the buffer, or `nil`. If `start` is
    ///     `nil`, `count` must be zero. However, `count` may be zero even for a
    ///     non-`nil` `start`. The pointer passed as `start` must be aligned to
    ///     `MemoryLayout<Element>.alignment`.
    ///   - count: The number of instances in the buffer. `count` must not be
    ///     negative.
    public init(start: UnsafePointer<Element>?, count: Int)

    /// Creates an immutable typed buffer pointer referencing the same memory as the 
    /// given mutable buffer pointer.
    ///
    /// - Parameter other: The mutable buffer pointer to convert.
    public init(_ other: UnsafeMutableBufferPointer<Element>)

    /// Creates a buffer over the same memory as the given buffer slice.
    ///
    /// The new buffer represents the same region of memory as `slice`, but is
    /// indexed starting at zero instead of sharing indices with the original
    /// buffer. For example:
    ///
    ///     let buffer = returnsABuffer()
    ///     let n = 5
    ///     let slice = buffer[n...]
    ///     let rebased = UnsafeBufferPointer(rebasing: slice)
    ///
    /// After rebasing `slice` as the `rebased` buffer, the following are true:
    ///
    /// - `rebased.startIndex == 0`
    /// - `rebased[0] == slice[n]`
    /// - `rebased[0] == buffer[n]`
    /// - `rebased.count == slice.count`
    ///
    /// - Parameter slice: The buffer slice to rebase.
    public init(rebasing slice: Slice<UnsafeBufferPointer<Element>>)

    /// Creates a buffer over the same memory as the given buffer slice.
    ///
    /// The new buffer represents the same region of memory as `slice`, but is
    /// indexed starting at zero instead of sharing indices with the original
    /// buffer. For example:
    ///
    ///     let buffer = returnsABuffer()
    ///     let n = 5
    ///     let slice = buffer[n...]
    ///     let rebased = UnsafeBufferPointer(rebasing: slice)
    ///
    /// After rebasing `slice` as the `rebased` buffer, the following are true:
    ///
    /// - `rebased.startIndex == 0`
    /// - `rebased[0] == slice[n]`
    /// - `rebased[0] == buffer[n]`
    /// - `rebased.count == slice.count`
    ///
    /// - Parameter slice: The buffer slice to rebase.
    public init(rebasing slice: Slice<UnsafeMutableBufferPointer<Element>>)

    /// Deallocates the memory block previously allocated at this buffer pointers 
    /// base address. 
    ///
    /// This buffer pointer's `baseAddress` must be `nil` or a pointer to a memory 
    /// block previously returned by a Swift allocation method. If `baseAddress` is 
    /// `nil`, this function does nothing. Otherwise, the memory must not be initialized 
    /// or `Pointee` must be a trivial type. This buffer pointer's `count` must 
    /// be equal to the originally allocated size of the memory block.
    public func deallocate()

    /// Executes the given closure while temporarily binding the memory referenced 
    /// by this buffer to the given type.
    ///
    /// Use this method when you have a buffer of memory bound to one type and
    /// you need to access that memory as a buffer of another type. Accessing
    /// memory as type `T` requires that the memory be bound to that type. A
    /// memory location may only be bound to one type at a time, so accessing
    /// the same memory as an unrelated type without first rebinding the memory
    /// is undefined.
    ///
    /// The entire region of memory referenced by this buffer must be initialized.
    /// 
    /// Because this buffer's memory is no longer bound to its `Element` type
    /// while the `body` closure executes, do not access memory using the
    /// original buffer from within `body`. Instead, use the `body` closure's
    /// buffer argument to access the values in memory as instances of type
    /// `T`.
    ///
    /// After executing `body`, this method rebinds memory back to the original
    /// `Element` type.
    ///
    /// - Note: Only use this method to rebind the buffer's memory to a type
    ///   with the same size and stride as the currently bound `Element` type.
    ///   To bind a region of memory to a type that is a different size, convert
    ///   the buffer to a raw buffer and use the `bindMemory(to:)` method.
    ///
    /// - Parameters:
    ///   - type: The type to temporarily bind the memory referenced by this
    ///     buffer. The type `T` must have the same size and be layout compatible
    ///     with the pointer's `Element` type.
    ///   - body: A closure that takes a  typed buffer to the
    ///     same memory as this buffer, only bound to type `T`. The buffer argument 
    ///     contains the same number of complete instances of `T` as the original  
    ///     buffers `count`. The closure's buffer argument is valid only for the 
    ///     duration of the closure's execution. If `body` has a return value, that 
    ///     value is also used as the return value for the `withMemoryRebound(to:_:)` 
    ///     method.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withMemoryRebound<T, Result>(to type: T.Type, _ body: (UnsafeBufferPointer<T>) throws -> Result) rethrows -> Result

    /// A pointer to the first element of the buffer.
    ///
    /// If the `baseAddress` of this buffer is `nil`, the count is zero. However,
    /// a buffer can have a `count` of zero even with a non-`nil` base address.
    public var baseAddress: UnsafePointer<Element>? { get }
}

extension UnsafeBufferPointer : CustomDebugStringConvertible {

    /// A textual representation of the buffer, suitable for debugging.
    public var debugDescription: String { get }
}

extension UnsafeBufferPointer.Iterator : IteratorProtocol {

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    public mutating func next() -> Element?
}

@available(*, deprecated, renamed: "UnsafeBufferPointer.Iterator")
public typealias UnsafeBufferPointerIterator<T> = UnsafeBufferPointer<T>.Iterator

public struct UnsafeMutableBufferPointer<Element> {
}

extension UnsafeMutableBufferPointer : MutableCollection, RandomAccessCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// The index of the first element in a nonempty buffer.
    ///
    /// The `startIndex` property of an `UnsafeMutableBufferPointer` instance
    /// is always zero.
    public var startIndex: Int { get }

    /// The "past the end" position---that is, the position one greater than the
    /// last valid subscript argument.
    ///
    /// The `endIndex` property of an `UnsafeMutableBufferPointer` instance is
    /// always identical to `count`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout Int)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Int) -> Int

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout Int)

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    /// - Returns: An index offset by `n` from the index `i`. If `n` is positive,
    ///   this is the same value as the result of `n` calls to `index(after:)`.
    ///   If `n` is negative, this is the same value as the result of `-n` calls
    ///   to `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Int, offsetBy n: Int) -> Int

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `n` must not offset `i` beyond the bounds of the
    /// collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - n: The distance to offset `i`. `n` must not be negative unless the
    ///     collection conforms to the `BidirectionalCollection` protocol.
    ///   - limit: A valid index of the collection to use as a limit. If `n > 0`,
    ///     a limit that is less than `i` has no effect. Likewise, if `n < 0`, a
    ///     limit that is greater than `i` has no effect.
    /// - Returns: An index offset by `n` from the index `i`, unless that index
    ///   would be beyond `limit` in the direction of movement. In that case,
    ///   the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the absolute
    ///   value of `n`.
    public func index(_ i: Int, offsetBy n: Int, limitedBy limit: Int) -> Int?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the
    ///   resulting distance.
    public func distance(from start: Int, to end: Int) -> Int

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: UnsafeMutableBufferPointer<Element>.Indices { get }

    /// The number of elements in the buffer.
    ///
    /// If the `baseAddress` of this buffer is `nil`, the count is zero. However,
    /// a buffer can have a `count` of zero even with a non-`nil` base address.
    public var count: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example uses the buffer pointer's subscript to access and
    /// modify the elements of a mutable buffer pointing to the contiguous
    /// contents of an array:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.withUnsafeMutableBufferPointer { buffer in
    ///         for i in stride(from: buffer.startIndex, to: buffer.endIndex - 1, by: 2) {
    ///             let x = buffer[i]
    ///             buffer[i + 1] = buffer[i]
    ///             buffer[i] = x
    ///         }
    ///     }
    ///     print(numbers)
    ///     // Prints "[2, 1, 4, 3, 5]"
    ///
    /// - Note: Bounds checks for `i` are performed only in debug mode.
    ///
    /// - Parameter i: The position of the element to access. `i` must be in the
    ///   range `0..<count`.
    public subscript(i: Int) -> Element { get nonmutating set }

    /// Accesses a contiguous subrange of the buffer's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original buffer uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice from a buffer of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original buffer.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets.withUnsafeMutableBufferPointer { buffer in
    ///         let streetSlice = buffer[2..<buffer.endIndex]
    ///         print(Array(streetSlice))
    ///         // Prints "["Channing", "Douglas", "Evarts"]"
    ///         let index = streetSlice.firstIndex(of: "Evarts")    // 4
    ///         buffer[index!] = "Eustace"
    ///     }
    ///     print(streets.last!)
    ///     // Prints "Eustace"
    ///
    /// - Note: Bounds checks for `bounds` are performed only in debug mode.
    ///
    /// - Parameter bounds: A range of the buffer's indices. The bounds of
    ///   the range must be valid indices of the buffer.
    public subscript(bounds: Range<Int>) -> Slice<UnsafeMutableBufferPointer<Element>> { get nonmutating set }

    /// Exchanges the values at the specified indices of the buffer.
    ///
    /// Both parameters must be valid indices of the buffer, and not
    /// equal to `endIndex`. Passing the same index as both `i` and `j` has no
    /// effect.
    ///
    /// - Parameters:
    ///   - i: The index of the first value to swap.
    ///   - j: The index of the second value to swap.
    public func swapAt(_ i: Int, _ j: Int)
}

extension UnsafeMutableBufferPointer {

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public typealias Iterator = UnsafeBufferPointer<Element>.Iterator
}

extension UnsafeMutableBufferPointer : Sequence {

    /// Returns an iterator over the elements of this buffer.
    ///
    /// - Returns: An iterator over the elements of this buffer.
    public func makeIterator() -> UnsafeMutableBufferPointer<Element>.Iterator
}

extension UnsafeMutableBufferPointer {

    /// Creates a new buffer pointer over the specified number of contiguous
    /// instances beginning at the given pointer.
    ///
    /// - Parameters:
    ///   - start: A pointer to the start of the buffer, or `nil`. If `start` is
    ///     `nil`, `count` must be zero. However, `count` may be zero even for a
    ///     non-`nil` `start`. The pointer passed as `start` must be aligned to
    ///     `MemoryLayout<Element>.alignment`.
    ///   - count: The number of instances in the buffer. `count` must not be
    ///     negative.
    public init(start: UnsafeMutablePointer<Element>?, count: Int)

    /// Creates a mutable typed buffer pointer referencing the same memory as the 
    /// given immutable buffer pointer.
    ///
    /// - Parameter other: The immutable buffer pointer to convert.
    public init(mutating other: UnsafeBufferPointer<Element>)

    /// Creates a buffer over the same memory as the given buffer slice.
    ///
    /// The new buffer represents the same region of memory as `slice`, but is
    /// indexed starting at zero instead of sharing indices with the original
    /// buffer. For example:
    ///
    ///     let buffer = returnsABuffer()
    ///     let n = 5
    ///     let slice = buffer[n...]
    ///     let rebased = UnsafeMutableBufferPointer(rebasing: slice)
    ///
    /// After rebasing `slice` as the `rebased` buffer, the following are true:
    ///
    /// - `rebased.startIndex == 0`
    /// - `rebased[0] == slice[n]`
    /// - `rebased[0] == buffer[n]`
    /// - `rebased.count == slice.count`
    ///
    /// - Parameter slice: The buffer slice to rebase.
    public init(rebasing slice: Slice<UnsafeMutableBufferPointer<Element>>)

    /// Deallocates the memory block previously allocated at this buffer pointers 
    /// base address. 
    ///
    /// This buffer pointer's `baseAddress` must be `nil` or a pointer to a memory 
    /// block previously returned by a Swift allocation method. If `baseAddress` is 
    /// `nil`, this function does nothing. Otherwise, the memory must not be initialized 
    /// or `Pointee` must be a trivial type. This buffer pointer's `count` must 
    /// be equal to the originally allocated size of the memory block.
    public func deallocate()

    /// Allocates uninitialized memory for the specified number of instances of
    /// type `Element`.
    ///
    /// The resulting buffer references a region of memory that is bound to
    /// `Element` and is `count * MemoryLayout<Element>.stride` bytes in size.
    /// 
    /// The following example allocates a buffer that can store four `Int` 
    /// instances and then initializes that memory with the elements of a range:
    /// 
    ///     let buffer = UnsafeMutableBufferPointer<Int>.allocate(capacity: 4)
    ///     _ = buffer.initialize(from: 1...4)
    ///     print(buffer[2])
    ///     // Prints "3"
    ///
    /// When you allocate memory, always remember to deallocate once you're
    /// finished.
    ///
    ///     buffer.deallocate()
    ///
    /// - Parameter count: The amount of memory to allocate, counted in instances
    ///   of `Element`. 
    public static func allocate(capacity count: Int) -> UnsafeMutableBufferPointer<UnsafeMutableBufferPointer<Element>.Element>

    /// Initializes every element in this buffer's memory to a copy of the given value.
    ///
    /// The destination memory must be uninitialized or the buffer's `Element`
    /// must be a trivial type. After a call to `initialize(repeating:)`, the
    /// entire region of memory referenced by this buffer is initialized.
    ///
    /// - Parameters:
    ///   - repeatedValue: The instance to initialize this buffer's memory with.
    public func initialize(repeating repeatedValue: UnsafeMutableBufferPointer<Element>.Element)

    /// Assigns every element in this buffer's memory to a copy of the given value.
    ///
    /// The buffers memory must be initialized or the buffer's `Element`
    /// must be a trivial type. 
    ///
    /// - Parameters:
    ///   - repeatedValue: The instance to assign this buffer's memory to.
    ///
    /// Warning: All buffer elements must be initialized before calling this. 
    /// Assigning to part of the buffer must be done using the `assign(repeating:count:)`` 
    /// method on the buffers `baseAddress`. 
    public func assign(repeating repeatedValue: UnsafeMutableBufferPointer<Element>.Element)

    /// Executes the given closure while temporarily binding the memory referenced 
    /// by this buffer to the given type.
    ///
    /// Use this method when you have a buffer of memory bound to one type and
    /// you need to access that memory as a buffer of another type. Accessing
    /// memory as type `T` requires that the memory be bound to that type. A
    /// memory location may only be bound to one type at a time, so accessing
    /// the same memory as an unrelated type without first rebinding the memory
    /// is undefined.
    ///
    /// The entire region of memory referenced by this buffer must be initialized.
    /// 
    /// Because this buffer's memory is no longer bound to its `Element` type
    /// while the `body` closure executes, do not access memory using the
    /// original buffer from within `body`. Instead, use the `body` closure's
    /// buffer argument to access the values in memory as instances of type
    /// `T`.
    ///
    /// After executing `body`, this method rebinds memory back to the original
    /// `Element` type.
    ///
    /// - Note: Only use this method to rebind the buffer's memory to a type
    ///   with the same size and stride as the currently bound `Element` type.
    ///   To bind a region of memory to a type that is a different size, convert
    ///   the buffer to a raw buffer and use the `bindMemory(to:)` method.
    ///
    /// - Parameters:
    ///   - type: The type to temporarily bind the memory referenced by this
    ///     buffer. The type `T` must have the same size and be layout compatible
    ///     with the pointer's `Element` type.
    ///   - body: A closure that takes a mutable typed buffer to the
    ///     same memory as this buffer, only bound to type `T`. The buffer argument 
    ///     contains the same number of complete instances of `T` as the original  
    ///     buffers `count`. The closure's buffer argument is valid only for the 
    ///     duration of the closure's execution. If `body` has a return value, that 
    ///     value is also used as the return value for the `withMemoryRebound(to:_:)` 
    ///     method.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withMemoryRebound<T, Result>(to type: T.Type, _ body: (UnsafeMutableBufferPointer<T>) throws -> Result) rethrows -> Result

    /// A pointer to the first element of the buffer.
    ///
    /// If the `baseAddress` of this buffer is `nil`, the count is zero. However,
    /// a buffer can have a `count` of zero even with a non-`nil` base address.
    public var baseAddress: UnsafeMutablePointer<Element>? { get }
}

extension UnsafeMutableBufferPointer : CustomDebugStringConvertible {

    /// A textual representation of the buffer, suitable for debugging.
    public var debugDescription: String { get }
}

extension UnsafeMutableBufferPointer {

    /// Initializes the buffer's memory with the given elements.
    ///
    /// When calling the `initialize(from:)` method on a buffer `b`, the memory
    /// referenced by `b` must be uninitialized or the `Element` type must be a
    /// trivial type. After the call, the memory referenced by this buffer up
    /// to, but not including, the returned index is initialized. The buffer
    /// must contain sufficient memory to accommodate
    /// `source.underestimatedCount`.
    ///
    /// The returned index is the position of the element in the buffer one past
    /// the last element written. If `source` contains no elements, the returned
    /// index is equal to the buffer's `startIndex`. If `source` contains an
    /// equal or greater number of elements than the buffer can hold, the
    /// returned index is equal to the buffer's `endIndex`.
    ///
    /// - Parameter source: A sequence of elements with which to initializer the
    ///   buffer.
    /// - Returns: An iterator to any elements of `source` that didn't fit in the
    ///   buffer, and an index to the point in the buffer one past the last
    ///   element written.
    public func initialize<S>(from source: S) -> (S.Iterator, UnsafeMutableBufferPointer<Element>.Index) where Element == S.Element, S : Sequence
}

/// A pointer for accessing and manipulating data of a
/// specific type.
///
/// You use instances of the `UnsafeMutablePointer` type to access data of a
/// specific type in memory. The type of data that a pointer can access is the
/// pointer's `Pointee` type. `UnsafeMutablePointer` provides no automated
/// memory management or alignment guarantees. You are responsible for
/// handling the life cycle of any memory you work with through unsafe
/// pointers to avoid leaks or undefined behavior.
///
/// Memory that you manually manage can be either *untyped* or *bound* to a
/// specific type. You use the `UnsafeMutablePointer` type to access and
/// manage memory that has been bound to a specific type.
///
/// Understanding a Pointer's Memory State
/// ======================================
///
/// The memory referenced by an `UnsafeMutablePointer` instance can be in
/// one of several states. Many pointer operations must only be applied to
/// pointers with memory in a specific state---you must keep track of the
/// state of the memory you are working with and understand the changes to
/// that state that different operations perform. Memory can be untyped and
/// uninitialized, bound to a type and uninitialized, or bound to a type and
/// initialized to a value. Finally, memory that was allocated previously may
/// have been deallocated, leaving existing pointers referencing unallocated
/// memory.
///
/// Uninitialized Memory
/// --------------------
///
/// Memory that has just been allocated through a typed pointer or has been
/// deinitialized is in an *uninitialized* state. Uninitialized memory must be
/// initialized before it can be accessed for reading.
///
/// You can use methods like `initialize(to:count:)`, `initialize(from:)`, and
/// `moveInitialize(from:count:)` to initialize the memory referenced by a
/// pointer with a value or series of values.
///
/// Initialized Memory
/// ------------------
///
/// *Initialized* memory has a value that can be read using a pointer's
/// `pointee` property or through subscript notation. In the following
/// example, `ptr` is a pointer to memory initialized with a value of `23`:
///
///     let ptr: UnsafeMutablePointer<Int> = ...
///     // ptr.pointee == 23
///     // ptr[0] == 23
///
/// Accessing a Pointer's Memory as a Different Type
/// ================================================
///
/// When you access memory through an `UnsafeMutablePointer` instance, the
/// `Pointee` type must be consistent with the bound type of the memory. If
/// you do need to access memory that is bound to one type as a different
/// type, Swift's pointer types provide type-safe ways to temporarily or
/// permanently change the bound type of the memory, or to load typed
/// instances directly from raw memory.
///
/// An `UnsafeMutablePointer<UInt8>` instance allocated with eight bytes of
/// memory, `uint8Pointer`, will be used for the examples below.
///
///     let uint8Pointer = UnsafeMutablePointer<UInt8>.allocate(capacity: 8)
///     uint8Pointer.initialize(from: [39, 77, 111, 111, 102, 33, 39, 0])
///
/// When you only need to temporarily access a pointer's memory as a different
/// type, use the `withMemoryRebound(to:capacity:)` method. For example, you
/// can use this method to call an API that expects a pointer to a different
/// type that is layout compatible with your pointer's `Pointee`. The following
/// code temporarily rebinds the memory that `uint8Pointer` references from
/// `UInt8` to `Int8` to call the imported C `strlen` function.
///
///     // Imported from C
///     func strlen(_ __s: UnsafePointer<Int8>!) -> UInt
///
///     let length = uint8Pointer.withMemoryRebound(to: Int8.self, capacity: 8) {
///         return strlen($0)
///     }
///     // length == 7
///
/// When you need to permanently rebind memory to a different type, first
/// obtain a raw pointer to the memory and then call the
/// `bindMemory(to:capacity:)` method on the raw pointer. The following
/// example binds the memory referenced by `uint8Pointer` to one instance of
/// the `UInt64` type:
///
///     let uint64Pointer = UnsafeMutableRawPointer(uint8Pointer)
///                               .bindMemory(to: UInt64.self, capacity: 1)
///
/// After rebinding the memory referenced by `uint8Pointer` to `UInt64`,
/// accessing that pointer's referenced memory as a `UInt8` instance is
/// undefined.
///
///     var fullInteger = uint64Pointer.pointee          // OK
///     var firstByte = uint8Pointer.pointee             // undefined
///
/// Alternatively, you can access the same memory as a different type without
/// rebinding through untyped memory access, so long as the bound type and the
/// destination type are trivial types. Convert your pointer to an
/// `UnsafeMutableRawPointer` instance and then use the raw pointer's
/// `load(fromByteOffset:as:)` and `storeBytes(of:toByteOffset:as:)` methods
/// to read and write values.
///
///     let rawPointer = UnsafeMutableRawPointer(uint64Pointer)
///     fullInteger = rawPointer.load(as: UInt64.self)   // OK
///     firstByte = rawPointer.load(as: UInt8.self)      // OK
///
/// Performing Typed Pointer Arithmetic
/// ===================================
///
/// Pointer arithmetic with a typed pointer is counted in strides of the
/// pointer's `Pointee` type. When you add to or subtract from an `UnsafeMutablePointer`
/// instance, the result is a new pointer of the same type, offset by that
/// number of instances of the `Pointee` type.
///
///     // 'intPointer' points to memory initialized with [10, 20, 30, 40]
///     let intPointer: UnsafeMutablePointer<Int> = ...
///
///     // Load the first value in memory
///     let x = intPointer.pointee
///     // x == 10
///
///     // Load the third value in memory
///     let offsetPointer = intPointer + 2
///     let y = offsetPointer.pointee
///     // y == 30
///
/// You can also use subscript notation to access the value in memory at a
/// specific offset.
///
///     let z = intPointer[2]
///     // z == 30
///
/// Implicit Casting and Bridging
/// =============================
///
/// When calling a function or method with an `UnsafeMutablePointer` parameter, you can pass
/// an instance of that specific pointer type or use Swift's implicit bridging
/// to pass a compatible pointer.
///
/// For example, the `printInt(atAddress:)` function in the following code
/// sample expects an `UnsafeMutablePointer<Int>` instance as its first parameter:
///
///     func printInt(atAddress p: UnsafeMutablePointer<Int>) {
///         print(p.pointee)
///     }
///
/// As is typical in Swift, you can call the `printInt(atAddress:)` function
/// with an `UnsafeMutablePointer` instance. This example passes `intPointer`, a mutable
/// pointer to an `Int` value, to `print(address:)`.
///
///     printInt(atAddress: intPointer)
///     // Prints "42"
///
/// Alternatively, you can use Swift's *implicit bridging* to pass a pointer to
/// an instance or to the elements of an array. The following example passes a
/// pointer to the `value` variable by using inout syntax:
///
///     var value: Int = 23
///     printInt(atAddress: &value)
///     // Prints "23"
///
/// A mutable pointer to the elements of an array is implicitly created when
/// you pass the array using inout syntax. This example uses implicit bridging
/// to pass a pointer to the elements of `numbers` when calling
/// `printInt(atAddress:)`.
///
///     var numbers = [5, 10, 15, 20]
///     printInt(atAddress: &numbers)
///     // Prints "5"
///
/// No matter which way you call `printInt(atAddress:)`, Swift's type safety
/// guarantees that you can only pass a pointer to the type required by the
/// function---in this case, a pointer to an `Int`.
///
/// - Important: The pointer created through implicit bridging of an instance
///   or of an array's elements is only valid during the execution of the
///   called function. Escaping the pointer to use after the execution of the
///   function is undefined behavior. In particular, do not use implicit
///   bridging when calling an `UnsafeMutablePointer` initializer.
///
///       var number = 5
///       let numberPointer = UnsafeMutablePointer<Int>(&number)
///       // Accessing 'numberPointer' is undefined behavior.
public struct UnsafeMutablePointer<Pointee> {

    /// A type that represents the distance between two pointers.
    public typealias Distance = Int

    /// Creates a new typed pointer from the given opaque pointer.
    ///
    /// - Parameter from: The opaque pointer to convert to a typed pointer.
    public init(_ from: OpaquePointer)

    /// Creates a new typed pointer from the given opaque pointer.
    ///
    /// - Parameter from: The opaque pointer to convert to a typed pointer. If
    ///   `from` is `nil`, the result of this initializer is `nil`.
    public init?(_ from: OpaquePointer?)

    /// Creates a new typed pointer from the given address, specified as a bit
    /// pattern.
    ///
    /// The address passed as `bitPattern` must have the correct alignment for
    /// the pointer's `Pointee` type. That is,
    /// `bitPattern % MemoryLayout<Pointee>.alignment` must be `0`.
    ///
    /// - Parameter bitPattern: A bit pattern to use for the address of the new
    ///   pointer. If `bitPattern` is zero, the result is `nil`.
    public init?(bitPattern: Int)

    /// Creates a new typed pointer from the given address, specified as a bit
    /// pattern.
    ///
    /// The address passed as `bitPattern` must have the correct alignment for
    /// the pointer's `Pointee` type. That is,
    /// `bitPattern % MemoryLayout<Pointee>.alignment` must be `0`.
    ///
    /// - Parameter bitPattern: A bit pattern to use for the address of the new
    ///   pointer. If `bitPattern` is zero, the result is `nil`.
    public init?(bitPattern: UInt)

    /// Creates a new pointer from the given typed pointer.
    ///
    /// - Parameter other: The typed pointer to convert.
    public init(_ other: UnsafeMutablePointer<Pointee>)

    /// Creates a new pointer from the given typed pointer.
    ///
    /// - Parameter other: The typed pointer to convert. If `other` is `nil`, the
    ///   result is `nil`.
    public init?(_ other: UnsafeMutablePointer<Pointee>?)

    /// Creates a mutable typed pointer referencing the same memory as the given
    /// immutable pointer.
    ///
    /// - Parameter other: The immutable pointer to convert.
    public init(mutating other: UnsafePointer<Pointee>)

    /// Creates a mutable typed pointer referencing the same memory as the given
    /// immutable pointer.
    ///
    /// - Parameter other: The immutable pointer to convert. If `other` is `nil`,
    ///   the result is `nil`.
    public init?(mutating other: UnsafePointer<Pointee>?)

    /// Allocates uninitialized memory for the specified number of instances of
    /// type `Pointee`.
    ///
    /// The resulting pointer references a region of memory that is bound to
    /// `Pointee` and is `count * MemoryLayout<Pointee>.stride` bytes in size.
    ///
    /// The following example allocates enough new memory to store four `Int`
    /// instances and then initializes that memory with the elements of a range.
    ///
    ///     let intPointer = UnsafeMutablePointer<Int>.allocate(capacity: 4)
    ///     intPointer.initialize(from: 1...4)
    ///     print(intPointer.pointee)
    ///     // Prints "1"
    ///
    /// When you allocate memory, always remember to deallocate once you're
    /// finished.
    ///
    ///     intPointer.deallocate()
    ///
    /// - Parameter count: The amount of memory to allocate, counted in instances
    ///   of `Pointee`.
    public static func allocate(capacity count: Int) -> UnsafeMutablePointer<Pointee>

    @available(swift, deprecated: 4.1, obsoleted: 5.0.0, message: "Swift currently only supports freeing entire heap blocks, use deallocate() instead")
    public func deallocate(capacity _: Int)

    /// Deallocates the memory block previously allocated at this pointer.
    ///
    /// This pointer must be a pointer to the start of a previously allocated memory 
    /// block. The memory must not be initialized or `Pointee` must be a trivial type.
    public func deallocate()

    /// Accesses the instance referenced by this pointer.
    ///
    /// When reading from the `pointee` property, the instance referenced by this
    /// pointer must already be initialized. When `pointee` is used as the left
    /// side of an assignment, the instance must be initialized or this
    /// pointer's `Pointee` type must be a trivial type.
    ///
    /// Do not assign an instance of a nontrivial type through `pointee` to
    /// uninitialized memory. Instead, use an initializing method, such as
    /// `initialize(to:count:)`.
    public var pointee: Pointee { get nonmutating set }

    @available(swift, deprecated: 4.1, obsoleted: 5.0.0, renamed: "initialize(repeating:count:)")
    public func initialize(to newValue: Pointee, count: Int = default)

    /// Initializes this pointer's memory with the specified number of
    /// consecutive copies of the given value.
    ///
    /// The destination memory must be uninitialized or the pointer's `Pointee`
    /// must be a trivial type. After a call to `initialize(repeating:count:)`, the
    /// memory referenced by this pointer is initialized.
    ///
    /// - Parameters:
    ///   - repeatedValue: The instance to initialize this pointer's memory with.
    ///   - count: The number of consecutive copies of `newValue` to initialize.
    ///     `count` must not be negative. 
    public func initialize(repeating repeatedValue: Pointee, count: Int)

    /// Initializes this pointer's memory with a single instance of the given value.
    ///
    /// The destination memory must be uninitialized or the pointer's `Pointee`
    /// must be a trivial type. After a call to `initialize(to:)`, the
    /// memory referenced by this pointer is initialized. Calling this method is 
    /// roughly equivalent to calling `initialize(repeating:count:)` with a 
    /// `count` of 1.
    ///
    /// - Parameters:
    ///   - value: The instance to initialize this pointer's pointee to.
    public func initialize(to value: Pointee)

    /// Retrieves and returns the referenced instance, returning the pointer's
    /// memory to an uninitialized state.
    ///
    /// Calling the `move()` method on a pointer `p` that references memory of
    /// type `T` is equivalent to the following code, aside from any cost and
    /// incidental side effects of copying and destroying the value:
    ///
    ///     let value: T = {
    ///         defer { p.deinitialize(count: 1) }
    ///         return p.pointee
    ///     }()
    ///
    /// The memory referenced by this pointer must be initialized. After calling
    /// `move()`, the memory is uninitialized.
    ///
    /// - Returns: The instance referenced by this pointer.
    public func move() -> Pointee

    /// Replaces this pointer's memory with the specified number of
    /// consecutive copies of the given value.
    ///
    /// The region of memory starting at this pointer and covering `count`
    /// instances of the pointer's `Pointee` type must be initialized or
    /// `Pointee` must be a trivial type. After calling
    /// `assign(repeating:count:)`, the region is initialized.
    ///
    /// - Parameters:
    ///   - repeatedValue: The instance to assign this pointer's memory to.
    ///   - count: The number of consecutive copies of `newValue` to assign.
    ///     `count` must not be negative. 
    public func assign(repeating repeatedValue: Pointee, count: Int)

    /// Replaces this pointer's initialized memory with the specified number of
    /// instances from the given pointer's memory.
    ///
    /// The region of memory starting at this pointer and covering `count`
    /// instances of the pointer's `Pointee` type must be initialized or
    /// `Pointee` must be a trivial type. After calling
    /// `assign(from:count:)`, the region is initialized.
    ///
    /// - Note: Returns without performing work if `self` and `source` are equal.
    ///
    /// - Parameters:
    ///   - source: A pointer to at least `count` initialized instances of type
    ///     `Pointee`. The memory regions referenced by `source` and this
    ///     pointer may overlap.
    ///   - count: The number of instances to copy from the memory referenced by
    ///     `source` to this pointer's memory. `count` must not be negative.
    public func assign(from source: UnsafePointer<Pointee>, count: Int)

    /// Moves instances from initialized source memory into the uninitialized
    /// memory referenced by this pointer, leaving the source memory
    /// uninitialized and the memory referenced by this pointer initialized.
    ///
    /// The region of memory starting at this pointer and covering `count`
    /// instances of the pointer's `Pointee` type must be uninitialized or
    /// `Pointee` must be a trivial type. After calling
    /// `initialize(from:count:)`, the region is initialized and the memory
    /// region `source..<(source + count)` is uninitialized.
    ///
    /// - Parameters:
    ///   - source: A pointer to the values to copy. The memory region
    ///     `source..<(source + count)` must be initialized. The memory regions
    ///     referenced by `source` and this pointer may overlap.
    ///   - count: The number of instances to move from `source` to this
    ///     pointer's memory. `count` must not be negative.
    public func moveInitialize(from source: UnsafeMutablePointer<Pointee>, count: Int)

    /// Initializes the memory referenced by this pointer with the values
    /// starting at the given pointer.
    ///
    /// The region of memory starting at this pointer and covering `count`
    /// instances of the pointer's `Pointee` type must be uninitialized or
    /// `Pointee` must be a trivial type. After calling
    /// `initialize(from:count:)`, the region is initialized.
    ///
    /// - Parameters:
    ///   - source: A pointer to the values to copy. The memory region
    ///     `source..<(source + count)` must be initialized. The memory regions
    ///     referenced by `source` and this pointer must not overlap.
    ///   - count: The number of instances to move from `source` to this
    ///     pointer's memory. `count` must not be negative.
    public func initialize(from source: UnsafePointer<Pointee>, count: Int)

    @available(*, deprecated, message: "it will be removed in Swift 4.0.  Please use 'UnsafeMutableBufferPointer.initialize(from:)' instead")
    public func initialize<C>(from source: C) where Pointee == C.Element, C : Collection

    /// Replaces the memory referenced by this pointer with the values
    /// starting at the given pointer, leaving the source memory uninitialized.
    ///
    /// The region of memory starting at this pointer and covering `count`
    /// instances of the pointer's `Pointee` type must be initialized or
    /// `Pointee` must be a trivial type. After calling
    /// `initialize(from:count:)`, the region is initialized and the memory
    /// region `source..<(source + count)` is uninitialized.
    ///
    /// - Parameters:
    ///   - source: A pointer to the values to copy. The memory region
    ///     `source..<(source + count)` must be initialized. The memory regions
    ///     referenced by `source` and this pointer must not overlap.
    ///   - count: The number of instances to move from `source` to this
    ///     pointer's memory. `count` must not be negative.
    public func moveAssign(from source: UnsafeMutablePointer<Pointee>, count: Int)

    @available(swift, deprecated: 4.1, obsoleted: 5.0.0, message: "the default argument to deinitialize(count:) has been removed, please specify the count explicitly")
    public func deinitialize() -> UnsafeMutableRawPointer

    /// Deinitializes the specified number of values starting at this pointer.
    ///
    /// The region of memory starting at this pointer and covering `count`
    /// instances of the pointer's `Pointee` type must be initialized. After
    /// calling `deinitialize(count:)`, the memory is uninitialized, but still
    /// bound to the `Pointee` type.
    ///
    /// - Parameter count: The number of instances to deinitialize. `count` must
    ///   not be negative. 
    /// - Returns: A raw pointer to the same address as this pointer. The memory
    ///   referenced by the returned raw pointer is still bound to `Pointee`.
    public func deinitialize(count: Int) -> UnsafeMutableRawPointer

    /// Executes the given closure while temporarily binding the specified number
    /// of instances to the given type.
    ///
    /// Use this method when you have a pointer to memory bound to one type and
    /// you need to access that memory as instances of another type. Accessing
    /// memory as type `T` requires that the memory be bound to that type. A
    /// memory location may only be bound to one type at a time, so accessing
    /// the same memory as an unrelated type without first rebinding the memory
    /// is undefined.
    ///
    /// The region of memory starting at this pointer and covering `count`
    /// instances of the pointer's `Pointee` type must be initialized.
    ///
    /// The following example temporarily rebinds the memory of a `UInt64`
    /// pointer to `Int64`, then accesses a property on the signed integer.
    ///
    ///     let uint64Pointer: UnsafeMutablePointer<UInt64> = fetchValue()
    ///     let isNegative = uint64Pointer.withMemoryRebound(to: Int64.self) { ptr in
    ///         return ptr.pointee < 0
    ///     }
    ///
    /// Because this pointer's memory is no longer bound to its `Pointee` type
    /// while the `body` closure executes, do not access memory using the
    /// original pointer from within `body`. Instead, use the `body` closure's
    /// pointer argument to access the values in memory as instances of type
    /// `T`.
    ///
    /// After executing `body`, this method rebinds memory back to the original
    /// `Pointee` type.
    ///
    /// - Note: Only use this method to rebind the pointer's memory to a type
    ///   with the same size and stride as the currently bound `Pointee` type.
    ///   To bind a region of memory to a type that is a different size, convert
    ///   the pointer to a raw pointer and use the `bindMemory(to:capacity:)`
    ///   method.
    ///
    /// - Parameters:
    ///   - type: The type to temporarily bind the memory referenced by this
    ///     pointer. The type `T` must be the same size and be layout compatible
    ///     with the pointer's `Pointee` type.
    ///   - count: The number of instances of `T` to bind to `type`.
    ///   - body: A closure that takes a mutable typed pointer to the
    ///     same memory as this pointer, only bound to type `T`. The closure's
    ///     pointer argument is valid only for the duration of the closure's
    ///     execution. If `body` has a return value, that value is also used as
    ///     the return value for the `withMemoryRebound(to:capacity:_:)` method.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Int, _ body: (UnsafeMutablePointer<T>) throws -> Result) rethrows -> Result

    /// Accesses the pointee at the specified offset from this pointer.
    ///
    /// For a pointer `p`, the memory at `p + i` must be initialized when reading
    /// the value by using the subscript. When the subscript is used as the left
    /// side of an assignment, the memory at `p + i` must be initialized or
    /// the pointer's `Pointee` type must be a trivial type.
    ///
    /// Do not assign an instance of a nontrivial type through the subscript to
    /// uninitialized memory. Instead, use an initializing method, such as
    /// `initialize(to:count:)`.
    ///
    /// - Parameter i: The offset from this pointer at which to access an
    ///   instance, measured in strides of the pointer's `Pointee` type.
    public subscript(i: Int) -> Pointee { get nonmutating set }
}

extension UnsafeMutablePointer : Equatable {

    /// Returns a Boolean value indicating whether two pointers are equal.
    ///
    /// - Parameters:
    ///   - lhs: A pointer.
    ///   - rhs: Another pointer.
    /// - Returns: `true` if `lhs` and `rhs` reference the same memory address;
    ///   otherwise, `false`.
    public static func == (lhs: UnsafeMutablePointer<Pointee>, rhs: UnsafeMutablePointer<Pointee>) -> Bool
}

extension UnsafeMutablePointer : Comparable {

    /// Returns a Boolean value indicating whether the first pointer references
    /// an earlier memory location than the second pointer.
    ///
    /// - Parameters:
    ///   - lhs: A pointer.
    ///   - rhs: Another pointer.
    /// - Returns: `true` if `lhs` references a memory address earlier than
    ///   `rhs`; otherwise, `false`.
    public static func < (lhs: UnsafeMutablePointer<Pointee>, rhs: UnsafeMutablePointer<Pointee>) -> Bool
}

extension UnsafeMutablePointer : Hashable {

    /// The pointer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program.  Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension UnsafeMutablePointer : Strideable {

    /// Returns a pointer to the next consecutive instance.
    ///
    /// The resulting pointer must be within the bounds of the same allocation as
    /// this pointer.
    ///
    /// - Returns: A pointer advanced from this pointer by
    ///   `MemoryLayout<Pointee>.stride` bytes.
    public func successor() -> UnsafeMutablePointer<Pointee>

    /// Returns a pointer to the previous consecutive instance.
    ///
    /// The resulting pointer must be within the bounds of the same allocation as
    /// this pointer.
    ///
    /// - Returns: A pointer shifted backward from this pointer by
    ///   `MemoryLayout<Pointee>.stride` bytes.
    public func predecessor() -> UnsafeMutablePointer<Pointee>

    /// Returns the distance from this pointer to the given pointer, counted as
    /// instances of the pointer's `Pointee` type.
    ///
    /// With pointers `p` and `q`, the result of `p.distance(to: q)` is
    /// equivalent to `q - p`.
    ///
    /// Typed pointers are required to be properly aligned for their `Pointee`
    /// type. Proper alignment ensures that the result of `distance(to:)`
    /// accurately measures the distance between the two pointers, counted in
    /// strides of `Pointee`. To find the distance in bytes between two
    /// pointers, convert them to `UnsafeRawPointer` instances before calling
    /// `distance(to:)`.
    ///
    /// - Parameter end: The pointer to calculate the distance to.
    /// - Returns: The distance from this pointer to `end`, in strides of the
    ///   pointer's `Pointee` type. To access the stride, use
    ///   `MemoryLayout<Pointee>.stride`.
    public func distance(to end: UnsafeMutablePointer<Pointee>) -> Int

    /// Returns a pointer offset from this pointer by the specified number of
    /// instances.
    ///
    /// With pointer `p` and distance `n`, the result of `p.advanced(by: n)` is
    /// equivalent to `p + n`.
    ///
    /// The resulting pointer must be within the bounds of the same allocation as
    /// this pointer.
    ///
    /// - Parameter n: The number of strides of the pointer's `Pointee` type to
    ///   offset this pointer. To access the stride, use
    ///   `MemoryLayout<Pointee>.stride`. `n` may be positive, negative, or
    ///   zero.
    /// - Returns: A pointer offset from this pointer by `n` instances of the
    ///   `Pointee` type.
    public func advanced(by n: Int) -> UnsafeMutablePointer<Pointee>
}

extension UnsafeMutablePointer : CustomDebugStringConvertible {

    /// A textual representation of the pointer, suitable for debugging.
    public var debugDescription: String { get }
}

extension UnsafeMutablePointer : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension UnsafeMutablePointer : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "UnsafeMutablePointer.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UnsafeMutablePointer : CVarArg {
}

/// A mutable nonowning collection interface to the bytes in a
/// region of memory.
///
/// You can use an `UnsafeMutableRawBufferPointer` instance in low-level operations to eliminate
/// uniqueness checks and release mode bounds checks. Bounds checks are always
/// performed in debug mode.
///
/// An `UnsafeMutableRawBufferPointer` instance is a view of the raw bytes in a region of memory.
/// Each byte in memory is viewed as a `UInt8` value independent of the type
/// of values held in that memory. Reading from and writing to memory through
/// a raw buffer are untyped operations. Accessing this collection's bytes
/// does not bind the underlying memory to `UInt8`.
///
/// In addition to its collection interface, an `UnsafeMutableRawBufferPointer` instance also supports
/// the following methods provided by `UnsafeMutableRawPointer`, including
/// bounds checks in debug mode:
///
/// - `load(fromByteOffset:as:)`
/// - `storeBytes(of:toByteOffset:as:)`
/// - `copyMemory(from:)`
///
/// To access the underlying memory through typed operations, the memory must
/// be bound to a trivial type.
///
/// - Note: A *trivial type* can be copied bit for bit with no indirection
///   or reference-counting operations. Generally, native Swift types that do
///   not contain strong or weak references or other forms of indirection are
///   trivial, as are imported C structs and enums. Copying memory that
///   contains values of nontrivial types can only be done safely with a typed
///   pointer. Copying bytes directly from nontrivial, in-memory values does
///   not produce valid copies and can only be done by calling a C API, such as
///   `memmove()`.
///
/// UnsafeMutableRawBufferPointer Semantics
/// =================
///
/// An `UnsafeMutableRawBufferPointer` instance is a view into memory and does not own the memory
/// that it references. Copying a variable or constant of type `UnsafeMutableRawBufferPointer` does
/// not copy the underlying memory. However, initializing another collection
/// with an `UnsafeMutableRawBufferPointer` instance copies bytes out of the referenced memory and
/// into the new collection.
///
/// The following example uses `someBytes`, an `UnsafeMutableRawBufferPointer` instance, to
/// demonstrate the difference between assigning a buffer pointer and using a
/// buffer pointer as the source for another collection's elements. Here, the
/// assignment to `destBytes` creates a new, nonowning buffer pointer
/// covering the first `n` bytes of the memory that `someBytes`
/// references---nothing is copied:
///
///     var destBytes = someBytes[0..<n]
///
/// Next, the bytes referenced by `destBytes` are copied into `byteArray`, a
/// new `[UInt]` array, and then the remainder of `someBytes` is appended to
/// `byteArray`:
///
///     var byteArray: [UInt8] = Array(destBytes)
///     byteArray += someBytes[n..<someBytes.count]
///
/// Assigning into a ranged subscript of an `UnsafeMutableRawBufferPointer` instance copies bytes
/// into the memory. The next `n` bytes of the memory that `someBytes`
/// references are copied in this code:
///
///     destBytes[0..<n] = someBytes[n..<(n + n)]
public struct UnsafeMutableRawBufferPointer {
}

extension UnsafeMutableRawBufferPointer {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    public typealias Iterator = UnsafeRawBufferPointer.Iterator
}

extension UnsafeMutableRawBufferPointer : Sequence {

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = Slice<UnsafeMutableRawBufferPointer>

    /// Returns an iterator over the bytes of this sequence.
    public func makeIterator() -> UnsafeMutableRawBufferPointer.Iterator
}

extension UnsafeMutableRawBufferPointer : MutableCollection {

    /// A type representing the sequence's elements.
    public typealias Element = UInt8

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// Always zero, which is the index of the first byte in a nonempty buffer.
    public var startIndex: UnsafeMutableRawBufferPointer.Index { get }

    /// The "past the end" position---that is, the position one greater than the
    /// last valid subscript argument.
    ///
    /// The `endIndex` property of an `UnsafeMutableRawBufferPointer`
    /// instance is always identical to `count`.
    public var endIndex: UnsafeMutableRawBufferPointer.Index { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: UnsafeMutableRawBufferPointer.Indices { get }

    /// Accesses the byte at the given offset in the memory region as a `UInt8`
    /// value.
    ///
    /// - Parameter i: The offset of the byte to access. `i` must be in the range
    ///   `0..<count`.
    public subscript(i: Int) -> UnsafeMutableRawBufferPointer.Element { get nonmutating set }

    /// Accesses the bytes in the specified memory region.
    ///
    /// - Parameter bounds: The range of byte offsets to access. The upper and
    ///   lower bounds of the range must be in the range `0...count`.
    public subscript(bounds: Range<Int>) -> UnsafeMutableRawBufferPointer.SubSequence { get nonmutating set }

    /// Exchanges the byte values at the specified indices
    /// in this buffer's memory.
    ///
    /// Both parameters must be valid indices of the buffer, and not
    /// equal to `endIndex`. Passing the same index as both `i` and `j` has no
    /// effect.
    ///
    /// - Parameters:
    ///   - i: The index of the first byte to swap.
    ///   - j: The index of the second byte to swap.
    public func swapAt(_ i: Int, _ j: Int)

    /// The number of bytes in the buffer.
    ///
    /// If the `baseAddress` of this buffer is `nil`, the count is zero. However,
    /// a buffer can have a `count` of zero even with a non-`nil` base address.
    public var count: Int { get }
}

extension UnsafeMutableRawBufferPointer : RandomAccessCollection {
}

extension UnsafeMutableRawBufferPointer {

    @available(swift, deprecated: 4.1, obsoleted: 5.0.0, renamed: "allocate(byteCount:alignment:)")
    public static func allocate(count: Int) -> UnsafeMutableRawBufferPointer

    /// Returns a newly allocated buffer with the given size, in bytes.
    ///
    /// The memory referenced by the new buffer is allocated, but not
    /// initialized.
    ///
    /// - Parameters:
    ///   - byteCount: The number of bytes to allocate.
    ///   - alignment: The alignment of the new region of allocated memory, in
    ///     bytes.
    /// - Returns: A buffer pointer to a newly allocated region of memory aligned 
    ///     to `alignment`.
    public static func allocate(byteCount: Int, alignment: Int) -> UnsafeMutableRawBufferPointer

    /// Deallocates the memory block previously allocated at this buffer pointers 
    /// base address. 
    ///
    /// This buffer pointer's `baseAddress` must be `nil` or a pointer to a memory 
    /// block previously returned by a Swift allocation method. If `baseAddress` is 
    /// `nil`, this function does nothing. Otherwise, the memory must not be initialized 
    /// or `Pointee` must be a trivial type. This buffer pointer's byte `count` must 
    /// be equal to the originally allocated size of the memory block.
    public func deallocate()

    /// Returns a new instance of the given type, read from the buffer pointer's
    /// raw memory at the specified byte offset.
    ///
    /// You can use this method to create new values from the buffer pointer's
    /// underlying bytes. The following example creates two new `Int32`
    /// instances from the memory referenced by the buffer pointer `someBytes`.
    /// The bytes for `a` are copied from the first four bytes of `someBytes`,
    /// and the bytes for `b` are copied from the next four bytes.
    ///
    ///     let a = someBytes.load(as: Int32.self)
    ///     let b = someBytes.load(fromByteOffset: 4, as: Int32.self)
    ///
    /// The memory to read for the new instance must not extend beyond the buffer
    /// pointer's memory region---that is, `offset + MemoryLayout<T>.size` must
    /// be less than or equal to the buffer pointer's `count`.
    ///
    /// - Parameters:
    ///   - offset: The offset, in bytes, into the buffer pointer's memory at
    ///     which to begin reading data for the new instance. The buffer pointer
    ///     plus `offset` must be properly aligned for accessing an instance of
    ///     type `T`. The default is zero.
    ///   - type: The type to use for the newly constructed instance. The memory
    ///     must be initialized to a value of a type that is layout compatible
    ///     with `type`.
    /// - Returns: A new instance of type `T`, copied from the buffer pointer's
    ///   memory.
    public func load<T>(fromByteOffset offset: Int = default, as type: T.Type) -> T

    /// Stores a value's bytes into the buffer pointer's raw memory at the
    /// specified byte offset.
    ///
    /// The type `T` to be stored must be a trivial type. The memory must also be
    /// uninitialized, initialized to `T`, or initialized to another trivial
    /// type that is layout compatible with `T`.
    ///
    /// The memory written to must not extend beyond the buffer pointer's memory
    /// region---that is, `offset + MemoryLayout<T>.size` must be less than or
    /// equal to the buffer pointer's `count`.
    ///
    /// After calling `storeBytes(of:toByteOffset:as:)`, the memory is
    /// initialized to the raw bytes of `value`. If the memory is bound to a
    /// type `U` that is layout compatible with `T`, then it contains a value of
    /// type `U`. Calling `storeBytes(of:toByteOffset:as:)` does not change the
    /// bound type of the memory.
    ///
    /// - Parameters:
    ///   - offset: The offset in bytes into the buffer pointer's memory to begin
    ///     reading data for the new instance. The buffer pointer plus `offset`
    ///     must be properly aligned for accessing an instance of type `T`. The
    ///     default is zero.
    ///   - type: The type to use for the newly constructed instance. The memory
    ///     must be initialized to a value of a type that is layout compatible
    ///     with `type`.
    public func storeBytes<T>(of value: T, toByteOffset offset: Int = default, as: T.Type)

    @available(swift, deprecated: 4.1, obsoleted: 5.0.0, renamed: "copyMemory(from:)")
    public func copyBytes(from source: UnsafeRawBufferPointer)

    /// Copies the bytes from the given buffer to this buffer's memory.
    ///
    /// If the `source.count` bytes of memory referenced by this buffer are bound
    /// to a type `T`, then `T` must be a trivial type, the underlying pointer
    /// must be properly aligned for accessing `T`, and `source.count` must be a
    /// multiple of `MemoryLayout<T>.stride`.
    ///
    /// After calling `copyMemory(from:)`, the first `source.count` bytes of
    /// memory referenced by this buffer are initialized to raw bytes. If the
    /// memory is bound to type `T`, then it contains values of type `T`.
    ///
    /// - Parameter source: A buffer of raw bytes from which to copy.
    ///   `source.count` must be less than or equal to this buffer's `count`.
    public func copyMemory(from source: UnsafeRawBufferPointer)

    /// Copies from a collection of `UInt8` into this buffer's memory.
    ///
    /// If the `source.count` bytes of memory referenced by this buffer are bound
    /// to a type `T`, then `T` must be a trivial type, the underlying pointer
    /// must be properly aligned for accessing `T`, and `source.count` must be a
    /// multiple of `MemoryLayout<T>.stride`.
    ///
    /// After calling `copyBytes(from:)`, the `source.count` bytes of memory
    /// referenced by this buffer are initialized to raw bytes. If the memory is
    /// bound to type `T`, then it contains values of type `T`.
    ///
    /// - Parameter source: A collection of `UInt8` elements. `source.count` must
    ///   be less than or equal to this buffer's `count`.
    public func copyBytes<C>(from source: C) where C : Collection, C.Element == UInt8

    /// Creates a buffer over the specified number of contiguous bytes starting
    /// at the given pointer.
    ///
    /// - Parameters:
    ///   - start: The address of the memory that starts the buffer. If `starts`
    ///     is `nil`, `count` must be zero. However, `count` may be zero even
    ///     for a non-`nil` `start`.
    ///   - count: The number of bytes to include in the buffer. `count` must not
    ///     be negative.
    public init(start: UnsafeMutableRawPointer?, count: Int)

    /// Creates a new buffer over the same memory as the given buffer.
    ///
    /// - Parameter bytes: The buffer to convert.
    public init(_ bytes: UnsafeMutableRawBufferPointer)

    /// Creates a new mutable buffer over the same memory as the given buffer.
    ///
    /// - Parameter bytes: The buffer to convert.
    public init(mutating bytes: UnsafeRawBufferPointer)

    /// Creates a raw buffer over the contiguous bytes in the given typed buffer.
    ///
    /// - Parameter buffer: The typed buffer to convert to a raw buffer. The
    ///   buffer's type `T` must be a trivial type.
    public init<T>(_ buffer: UnsafeMutableBufferPointer<T>)

    /// Creates a raw buffer over the same memory as the given raw buffer slice,
    /// with the indices rebased to zero.
    ///
    /// The new buffer represents the same region of memory as the slice, but its
    /// indices start at zero instead of at the beginning of the slice in the
    /// original buffer. The following code creates `slice`, a slice covering
    /// part of an existing buffer instance, then rebases it into a new `rebased`
    /// buffer.
    ///
    ///     let slice = buffer[n...]
    ///     let rebased = UnsafeRawBufferPointer(rebasing: slice)
    ///
    /// After this code has executed, the following are true:
    ///
    /// - `rebased.startIndex == 0`
    /// - `rebased[0] == slice[n]`
    /// - `rebased[0] == buffer[n]`
    /// - `rebased.count == slice.count`
    ///
    /// - Parameter slice: The raw buffer slice to rebase.
    public init(rebasing slice: Slice<UnsafeMutableRawBufferPointer>)

    /// A pointer to the first byte of the buffer.
    ///
    /// If the `baseAddress` of this buffer is `nil`, the count is zero. However,
    /// a buffer can have a `count` of zero even with a non-`nil` base address.
    public var baseAddress: UnsafeMutableRawPointer? { get }

    /// Initializes the memory referenced by this buffer with the given value,
    /// binds the memory to the value's type, and returns a typed buffer of the
    /// initialized memory.
    ///
    /// The memory referenced by this buffer must be uninitialized or
    /// initialized to a trivial type, and must be properly aligned for
    /// accessing `T`.
    ///
    /// After calling this method on a raw buffer with non-nil `baseAddress` `b`, 
    /// the region starting at `b` and continuing up to
    /// `b + self.count - self.count % MemoryLayout<T>.stride` is bound to type `T` and
    /// initialized. If `T` is a nontrivial type, you must eventually deinitialize
    /// or move the values in this region to avoid leaks. If `baseAddress` is 
    /// `nil`, this function does nothing and returns an empty buffer pointer.
    ///
    /// - Parameters:
    ///   - type: The type to bind this buffers memory to.
    ///   - repeatedValue: The instance to copy into memory.
    /// - Returns: A typed buffer of the memory referenced by this raw buffer. 
    ///     The typed buffer contains `self.count / MemoryLayout<T>.stride` 
    ///     instances of `T`.
    public func initializeMemory<T>(as type: T.Type, repeating repeatedValue: T) -> UnsafeMutableBufferPointer<T>

    /// Initializes the buffer's memory with the given elements, binding the
    /// initialized memory to the elements' type.
    ///
    /// When calling the `initializeMemory(as:from:)` method on a buffer `b`,
    /// the memory referenced by `b` must be uninitialized or initialized to a
    /// trivial type, and must be properly aligned for accessing `S.Element`.
    /// The buffer must contain sufficient memory to accommodate
    /// `source.underestimatedCount`.
    ///
    /// This method initializes the buffer with elements from `source` until
    /// `source` is exhausted or, if `source` is a sequence but not a
    /// collection, the buffer has no more room for its elements. After calling
    /// `initializeMemory(as:from:)`, the memory referenced by the returned
    /// `UnsafeMutableBufferPointer` instance is bound and initialized to type
    /// `S.Element`.
    ///
    /// - Parameters:
    ///   - type: The type of the elements to bind the buffer's memory to.
    ///   - source: A sequence of elements with which to initialize the buffer.
    /// - Returns: An iterator to any elements of `source` that didn't fit in the
    ///   buffer, and a typed buffer of the written elements. The returned
    ///   buffer references memory starting at the same base address as this
    ///   buffer.
    public func initializeMemory<S>(as type: S.Element.Type, from source: S) -> (unwritten: S.Iterator, initialized: UnsafeMutableBufferPointer<S.Element>) where S : Sequence

    /// Binds this buffers memory to the specified type and returns a typed buffer 
    /// of the bound memory.
    ///
    /// Use the `bindMemory(to:)` method to bind the memory referenced
    /// by this buffer to the type `T`. The memory must be uninitialized or
    /// initialized to a type that is layout compatible with `T`. If the memory
    /// is uninitialized, it is still uninitialized after being bound to `T`.
    ///
    /// - Warning: A memory location may only be bound to one type at a time. The
    ///   behavior of accessing memory as a type unrelated to its bound type is
    ///   undefined.
    ///
    /// - Parameters:
    ///   - type: The type `T` to bind the memory to.
    /// - Returns: A typed buffer of the newly bound memory. The memory in this
    ///   region is bound to `T`, but has not been modified in any other way.
    ///   The typed buffer references `self.count / MemoryLayout<T>.stride` instances of `T`.
    public func bindMemory<T>(to type: T.Type) -> UnsafeMutableBufferPointer<T>
}

extension UnsafeMutableRawBufferPointer : CustomDebugStringConvertible {

    /// A textual representation of the buffer, suitable for debugging.
    public var debugDescription: String { get }
}

extension UnsafeMutableRawBufferPointer {
}

public typealias UnsafeMutableRawBufferPointerIterator<T> = UnsafeBufferPointer<T>.Iterator

/// A raw pointer for accessing and manipulating
/// untyped data.
///
/// The `UnsafeMutableRawPointer` type provides no automated memory management, no type safety,
/// and no alignment guarantees. You are responsible for handling the life
/// cycle of any memory you work with through unsafe pointers, to avoid leaks
/// or undefined behavior.
///
/// Memory that you manually manage can be either *untyped* or *bound* to a
/// specific type. You use the `UnsafeMutableRawPointer` type to access and
/// manage raw bytes in memory, whether or not that memory has been bound to a
/// specific type.
///
/// Understanding a Pointer's Memory State
/// ======================================
///
/// The memory referenced by an `UnsafeMutableRawPointer` instance can be in one of several
/// states. Many pointer operations must only be applied to pointers with
/// memory in a specific state---you must keep track of the state of the
/// memory you are working with and understand the changes to that state that
/// different operations perform. Memory can be untyped and uninitialized,
/// bound to a type and uninitialized, or bound to a type and initialized to a
/// value. Finally, memory that was allocated previously may have been
/// deallocated, leaving existing pointers referencing unallocated memory.
///
/// Raw, Uninitialized Memory
/// -------------------------
///
/// Raw memory that has just been allocated is in an *uninitialized, untyped*
/// state. Uninitialized memory must be initialized with values of a type
/// before it can be used with any typed operations.
///
/// You can use methods like `initializeMemory(as:from:)` and
/// `moveInitializeMemory(as:from:count:)` to bind raw memory to a type and
/// initialize it with a value or series of values. To bind uninitialized
/// memory to a type without initializing it, use the `bindMemory(to:count:)`
/// method. These methods all return typed pointers for further typed access
/// to the memory.
///
/// Typed Memory
/// ------------
///
/// Memory that has been bound to a type, whether it is initialized or
/// uninitialized, is typically accessed using typed pointers---instances of
/// `UnsafePointer` and `UnsafeMutablePointer`. Initialization, assignment,
/// and deinitialization can be performed using `UnsafeMutablePointer`
/// methods.
///
/// Memory that has been bound to a type can be rebound to a different type
/// only after it has been deinitialized or if the bound type is a *trivial
/// type*. Deinitializing typed memory does not unbind that memory's type. The
/// deinitialized memory can be reinitialized with values of the same type,
/// bound to a new type, or deallocated.
///
/// - Note: A trivial type can be copied bit for bit with no indirection or
///   reference-counting operations. Generally, native Swift types that do not
///   contain strong or weak references or other forms of indirection are
///   trivial, as are imported C structs and enumerations.
///
/// When reading from or writing to  memory as raw
/// bytes when that memory is bound to a type, you must ensure that you
/// satisfy any alignment requirements.
/// Writing to typed memory as raw bytes must only be performed when the bound
/// type is a trivial type.
///
/// Raw Pointer Arithmetic
/// ======================
///
/// Pointer arithmetic with raw pointers is performed at the byte level. When
/// you add to or subtract from a raw pointer, the result is a new raw pointer
/// offset by that number of bytes. The following example allocates four bytes
/// of memory and stores `0xFF` in all four bytes:
///
///     let bytesPointer = UnsafeMutableRawPointer.allocate(byteCount: 4, alignment: 1)
///     bytesPointer.storeBytes(of: 0xFFFF_FFFF, as: UInt32.self)
///
///     // Load a value from the memory referenced by 'bytesPointer'
///     let x = bytesPointer.load(as: UInt8.self)       // 255
///
///     // Load a value from the last two allocated bytes
///     let offsetPointer = bytesPointer + 2
///     let y = offsetPointer.load(as: UInt16.self)     // 65535
///
/// The code above stores the value `0xFFFF_FFFF` into the four newly allocated
/// bytes, and then loads the first byte as a `UInt8` instance and the third
/// and fourth bytes as a `UInt16` instance.
///
/// Always remember to deallocate any memory that you allocate yourself.
///
///     bytesPointer.deallocate()
///
/// Implicit Casting and Bridging
/// =============================
///
/// When calling a function or method with an `UnsafeMutableRawPointer` parameter, you can pass
/// an instance of that specific pointer type, pass an instance of a
/// compatible pointer type, or use Swift's implicit bridging to pass a
/// compatible pointer.
///
/// For example, the `print(address:as:)` function in the following code sample
/// takes an `UnsafeMutableRawPointer` instance as its first parameter:
///
///     func print<T>(address p: UnsafeMutableRawPointer, as type: T.Type) {
///         let value = p.load(as: type)
///         print(value)
///     }
///
/// As is typical in Swift, you can call the `print(address:as:)` function with
/// an `UnsafeMutableRawPointer` instance. This example passes `rawPointer` as the initial
/// parameter.
///
///     // 'rawPointer' points to memory initialized with `Int` values.
///     let rawPointer: UnsafeMutableRawPointer = ...
///     print(address: rawPointer, as: Int.self)
///     // Prints "42"
///
/// Because typed pointers can be implicitly cast to raw pointers when passed
/// as a parameter, you can also call `print(address:as:)` with any mutable
/// typed pointer instance.
///
///     let intPointer: UnsafeMutablePointer<Int> = ...
///     print(address: intPointer, as: Int.self)
///     // Prints "42"
///
/// Alternatively, you can use Swift's *implicit bridging* to pass a pointer to
/// an instance or to the elements of an array. Use inout syntax to implicitly
/// create a pointer to an instance of any type. The following example uses
/// implicit bridging to pass a pointer to `value` when calling
/// `print(address:as:)`:
///
///     var value: Int = 23
///     print(address: &value, as: Int.self)
///     // Prints "23"
///
/// A mutable pointer to the elements of an array is implicitly created when
/// you pass the array using inout syntax. This example uses implicit bridging
/// to pass a pointer to the elements of `numbers` when calling
/// `print(address:as:)`.
///
///     var numbers = [5, 10, 15, 20]
///     print(address: &numbers, as: Int.self)
///     // Prints "5"
///
/// - Important: The pointer created through implicit bridging of an instance
///   or of an array's elements is only valid during the execution of the
///   called function. Escaping the pointer to use after the execution of the
///   function is undefined behavior. In particular, do not use implicit
///   bridging when calling an `UnsafeMutableRawPointer` initializer.
///
///       var number = 5
///       let numberPointer = UnsafeMutableRawPointer(&number)
///       // Accessing 'numberPointer' is undefined behavior.
public struct UnsafeMutableRawPointer {

    /// Creates a new raw pointer from the given raw or typed pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeMutableRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The pointer to convert.
    public init(_ other: UnsafeMutableRawPointer)

    /// Creates a new raw pointer from the given raw or typed pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeMutableRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The pointer to convert. If `other` is `nil`, the
    ///   result is `nil`.
    public init?(_ other: UnsafeMutableRawPointer?)

    /// Creates a new raw pointer from the given opaque pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeMutableRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The opaque pointer to convert.
    public init(_ other: OpaquePointer)

    /// Creates a new raw pointer from the given opaque pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeMutableRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The opaque pointer to convert. If `other` is `nil`,
    ///   the result is `nil`.
    public init?(_ other: OpaquePointer?)

    /// Creates a new raw pointer from the given address, specified as a bit
    /// pattern.
    ///
    /// - Parameter bitPattern: A bit pattern to use for the address of the new
    ///   raw pointer. If `bitPattern` is zero, the result is `nil`.
    public init?(bitPattern: Int)

    /// Creates a new raw pointer from the given address, specified as a bit
    /// pattern.
    ///
    /// - Parameter bitPattern: A bit pattern to use for the address of the new
    ///   raw pointer. If `bitPattern` is zero, the result is `nil`.
    public init?(bitPattern: UInt)

    /// Creates a new raw pointer from the given typed pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeMutableRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The typed pointer to convert.
    public init<T>(_ other: UnsafeMutablePointer<T>)

    /// Creates a new raw pointer from the given typed pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeMutableRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The typed pointer to convert. If `other` is `nil`, the
    ///   result is `nil`.
    public init?<T>(_ other: UnsafeMutablePointer<T>?)

    /// Creates a new mutable raw pointer from the given immutable raw pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeMutableRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The immutable raw pointer to convert.
    public init(mutating other: UnsafeRawPointer)

    /// Creates a new mutable raw pointer from the given immutable raw pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeMutableRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The immutable raw pointer to convert. If `other` is
    ///   `nil`, the result is `nil`.
    public init?(mutating other: UnsafeRawPointer?)

    @available(swift, deprecated: 4.1, obsoleted: 5.0.0, renamed: "allocate(byteCount:alignment:)")
    public static func allocate(bytes size: Int, alignedTo alignment: Int) -> UnsafeMutableRawPointer

    /// Allocates uninitialized memory with the specified size and alignment.
    ///
    /// You are in charge of managing the allocated memory. Be sure to deallocate
    /// any memory that you manually allocate.
    ///
    /// The allocated memory is not bound to any specific type and must be bound
    /// before performing any typed operations. If you are using the memory for
    /// a specific type, allocate memory using the
    /// `UnsafeMutablePointer.allocate(capacity:)` static method instead.
    ///
    /// - Parameters:
    ///   - byteCount: The number of bytes to allocate. `byteCount` must not be negative.
    ///   - alignment: The alignment of the new region of allocated memory, in
    ///     bytes.
    /// - Returns: A pointer to a newly allocated region of memory. The memory is
    ///   allocated, but not initialized.
    public static func allocate(byteCount: Int, alignment: Int) -> UnsafeMutableRawPointer

    @available(swift, deprecated: 4.1, obsoleted: 5.0.0, message: "Swift currently only supports freeing entire heap blocks, use deallocate() instead")
    public func deallocate(bytes _: Int, alignedTo _: Int)

    /// Deallocates the previously allocated memory block referenced by this pointer.
    ///
    /// The memory to be deallocated must be uninitialized or initialized to a
    /// trivial type.
    public func deallocate()

    /// Binds the memory to the specified type and returns a typed pointer to the
    /// bound memory.
    ///
    /// Use the `bindMemory(to:capacity:)` method to bind the memory referenced
    /// by this pointer to the type `T`. The memory must be uninitialized or
    /// initialized to a type that is layout compatible with `T`. If the memory
    /// is uninitialized, it is still uninitialized after being bound to `T`.
    ///
    /// In this example, 100 bytes of raw memory are allocated for the pointer
    /// `bytesPointer`, and then the first four bytes are bound to the `Int8`
    /// type.
    ///
    ///     let count = 4
    ///     let bytesPointer = UnsafeMutableRawPointer.allocate(
    ///             bytes: 100,
    ///             alignedTo: MemoryLayout<Int8>.alignment)
    ///     let int8Pointer = bytesPointer.bindMemory(to: Int8.self, capacity: count)
    ///
    /// After calling `bindMemory(to:capacity:)`, the first four bytes of the
    /// memory referenced by `bytesPointer` are bound to the `Int8` type, though
    /// they remain uninitialized. The remainder of the allocated region is
    /// unbound raw memory. All 100 bytes of memory must eventually be
    /// deallocated.
    ///
    /// - Warning: A memory location may only be bound to one type at a time. The
    ///   behavior of accessing memory as a type unrelated to its bound type is
    ///   undefined.
    ///
    /// - Parameters:
    ///   - type: The type `T` to bind the memory to.
    ///   - count: The amount of memory to bind to type `T`, counted as instances
    ///     of `T`.
    /// - Returns: A typed pointer to the newly bound memory. The memory in this
    ///   region is bound to `T`, but has not been modified in any other way.
    ///   The number of bytes in this region is
    ///   `count * MemoryLayout<T>.stride`.
    public func bindMemory<T>(to type: T.Type, capacity count: Int) -> UnsafeMutablePointer<T>

    /// Returns a typed pointer to the memory referenced by this pointer,
    /// assuming that the memory is already bound to the specified type.
    ///
    /// Use this method when you have a raw pointer to memory that has *already*
    /// been bound to the specified type. The memory starting at this pointer
    /// must be bound to the type `T`. Accessing memory through the returned
    /// pointer is undefined if the memory has not been bound to `T`. To bind
    /// memory to `T`, use `bindMemory(to:capacity:)` instead of this method.
    ///
    /// - Parameter to: The type `T` that the memory has already been bound to.
    /// - Returns: A typed pointer to the same memory as this raw pointer.
    public func assumingMemoryBound<T>(to: T.Type) -> UnsafeMutablePointer<T>

    @available(swift, deprecated: 4.1, obsoleted: 5.0.0, renamed: "initializeMemory(as:repeating:count:)")
    public func initializeMemory<T>(as type: T.Type, at offset: Int = default, count: Int = default, to repeatedValue: T) -> UnsafeMutablePointer<T>

    /// Initializes the memory referenced by this pointer with the given value,
    /// binds the memory to the value's type, and returns a typed pointer to the
    /// initialized memory.
    ///
    /// The memory referenced by this pointer must be uninitialized or
    /// initialized to a trivial type, and must be properly aligned for
    /// accessing `T`.
    ///
    /// The following example allocates enough raw memory to hold four instances
    /// of `Int8`, and then uses the `initializeMemory(as:repeating:count:)` method
    /// to initialize the allocated memory.
    ///
    ///     let count = 4
    ///     let bytesPointer = UnsafeMutableRawPointer.allocate(
    ///             byteCount: count * MemoryLayout<Int8>.stride,
    ///             alignment: MemoryLayout<Int8>.alignment)
    ///     let int8Pointer = myBytes.initializeMemory(
    ///             as: Int8.self, repeating: 0, count: count)
    ///
    ///     // After using 'int8Pointer':
    ///     int8Pointer.deallocate()
    ///
    /// After calling this method on a raw pointer `p`, the region starting at
    /// `self` and continuing up to `p + count * MemoryLayout<T>.stride` is bound 
    /// to type `T` and initialized. If `T` is a nontrivial type, you must 
    /// eventually deinitialize or move from the values in this region to avoid leaks.
    ///
    /// - Parameters:
    ///   - type: The type to bind this memory to.
    ///   - repeatedValue: The instance to copy into memory.
    ///   - count: The number of copies of `value` to copy into memory. `count`
    ///     must not be negative. 
    /// - Returns: A typed pointer to the memory referenced by this raw pointer.
    public func initializeMemory<T>(as type: T.Type, repeating repeatedValue: T, count: Int) -> UnsafeMutablePointer<T>

    /// Initializes the memory referenced by this pointer with the values
    /// starting at the given pointer, binds the memory to the values' type, and
    /// returns a typed pointer to the initialized memory.
    ///
    /// The memory referenced by this pointer must be uninitialized or
    /// initialized to a trivial type, and must be properly aligned for
    /// accessing `T`.
    ///
    /// The following example allocates enough raw memory to hold four instances
    /// of `Int8`, and then uses the `initializeMemory(as:from:count:)` method
    /// to initialize the allocated memory.
    ///
    ///     let count = 4
    ///     let bytesPointer = UnsafeMutableRawPointer.allocate(
    ///             bytes: count * MemoryLayout<Int8>.stride,
    ///             alignedTo: MemoryLayout<Int8>.alignment)
    ///     let values: [Int8] = [1, 2, 3, 4]
    ///     let int8Pointer = values.withUnsafeBufferPointer { buffer in
    ///         return bytesPointer.initializeMemory(as: Int8.self,
    ///                   from: buffer.baseAddress!,
    ///                   count: buffer.count)
    ///     }
    ///     // int8Pointer.pointee == 1
    ///     // (int8Pointer + 3).pointee == 4
    ///
    ///     // After using 'int8Pointer':
    ///     int8Pointer.deallocate(count)
    ///
    /// After calling this method on a raw pointer `p`, the region starting at
    /// `p` and continuing up to `p + count * MemoryLayout<T>.stride` is bound
    /// to type `T` and initialized. If `T` is a nontrivial type, you must
    /// eventually deinitialize or move from the values in this region to avoid
    /// leaks. The instances in the region `source..<(source + count)` are
    /// unaffected.
    ///
    /// - Parameters:
    ///   - type: The type to bind this memory to.
    ///   - source: A pointer to the values to copy. The memory in the region
    ///     `source..<(source + count)` must be initialized to type `T` and must
    ///     not overlap the destination region.
    ///   - count: The number of copies of `value` to copy into memory. `count`
    ///     must not be negative.
    /// - Returns: A typed pointer to the memory referenced by this raw pointer.
    public func initializeMemory<T>(as type: T.Type, from source: UnsafePointer<T>, count: Int) -> UnsafeMutablePointer<T>

    @available(*, deprecated, message: "it will be removed in Swift 4.0.  Please use 'UnsafeMutableRawBufferPointer.initialize(from:)' instead")
    public func initializeMemory<C>(as type: C.Element.Type, from source: C) -> UnsafeMutablePointer<C.Element> where C : Collection

    /// Initializes the memory referenced by this pointer with the values
    /// starting at the given pointer, binds the memory to the values' type,
    /// deinitializes the source memory, and returns a typed pointer to the
    /// newly initialized memory.
    ///
    /// The memory referenced by this pointer must be uninitialized or
    /// initialized to a trivial type, and must be properly aligned for
    /// accessing `T`.
    ///
    /// The memory in the region `source..<(source + count)` may overlap with the
    /// destination region. The `moveInitializeMemory(as:from:count:)` method
    /// automatically performs a forward or backward copy of all instances from
    /// the source region to their destination.
    ///
    /// After calling this method on a raw pointer `p`, the region starting at
    /// `p` and continuing up to `p + count * MemoryLayout<T>.stride` is bound
    /// to type `T` and initialized. If `T` is a nontrivial type, you must
    /// eventually deinitialize or move from the values in this region to avoid
    /// leaks. Any memory in the region `source..<(source + count)` that does
    /// not overlap with the destination region is returned to an uninitialized
    /// state.
    ///
    /// - Parameters:
    ///   - type: The type to bind this memory to.
    ///   - source: A pointer to the values to copy. The memory in the region
    ///     `source..<(source + count)` must be initialized to type `T`.
    ///   - count: The number of copies of `value` to copy into memory. `count`
    ///     must not be negative.
    /// - Returns: A typed pointer to the memory referenced by this raw pointer.
    public func moveInitializeMemory<T>(as type: T.Type, from source: UnsafeMutablePointer<T>, count: Int) -> UnsafeMutablePointer<T>

    /// Returns a new instance of the given type, constructed from the raw memory
    /// at the specified offset.
    ///
    /// The memory at this pointer plus `offset` must be properly aligned for
    /// accessing `T` and initialized to `T` or another type that is layout
    /// compatible with `T`.
    ///
    /// - Parameters:
    ///   - offset: The offset from this pointer, in bytes. `offset` must be
    ///     nonnegative. The default is zero.
    ///   - type: The type of the instance to create.
    /// - Returns: A new instance of type `T`, read from the raw bytes at
    ///   `offset`. The returned instance is memory-managed and unassociated
    ///   with the value in the memory referenced by this pointer.
    public func load<T>(fromByteOffset offset: Int = default, as type: T.Type) -> T

    /// Stores the given value's bytes into raw memory at the specified offset.
    ///
    /// The type `T` to be stored must be a trivial type. The memory at this
    /// pointer plus `offset` must be properly aligned for accessing `T`. The
    /// memory must also be uninitialized, initialized to `T`, or initialized to
    /// another trivial type that is layout compatible with `T`.
    ///
    /// After calling `storeBytes(of:toByteOffset:as:)`, the memory is
    /// initialized to the raw bytes of `value`. If the memory is bound to a
    /// type `U` that is layout compatible with `T`, then it contains a value of
    /// type `U`. Calling `storeBytes(of:toByteOffset:as:)` does not change the
    /// bound type of the memory.
    ///
    /// - Note: A trivial type can be copied with just a bit-for-bit copy without
    ///   any indirection or reference-counting operations. Generally, native
    ///   Swift types that do not contain strong or weak references or other
    ///   forms of indirection are trivial, as are imported C structs and enums.
    ///
    /// If you need to store a copy of a nontrivial value into memory, or to
    /// store a value into memory that contains a nontrivial value, you cannot
    /// use the `storeBytes(of:toByteOffset:as:)` method. Instead, you must know
    /// the type of value previously in memory and initialize or assign the
    /// memory. For example, to replace a value stored in a raw pointer `p`,
    /// where `U` is the current type and `T` is the new type, use a typed
    /// pointer to access and deinitialize the current value before initializing
    /// the memory with a new value.
    ///
    ///     let typedPointer = p.bindMemory(to: U.self, capacity: 1)
    ///     typedPointer.deinitialize(count: 1)
    ///     p.initializeMemory(as: T.self, to: newValue)
    ///
    /// - Parameters:
    ///   - value: The value to store as raw bytes.
    ///   - offset: The offset from this pointer, in bytes. `offset` must be
    ///     nonnegative. The default is zero.
    ///   - type: The type of `value`.
    public func storeBytes<T>(of value: T, toByteOffset offset: Int = default, as type: T.Type)

    @available(swift, deprecated: 4.1, obsoleted: 5.0.0, renamed: "copyMemory(from:byteCount:)")
    public func copyBytes(from source: UnsafeRawPointer, count: Int)

    /// Copies the specified number of bytes from the given raw pointer's memory
    /// into this pointer's memory.
    ///
    /// If the `byteCount` bytes of memory referenced by this pointer are bound to 
    /// a type `T`, then `T` must be a trivial type, this pointer and `source`
    /// must be properly aligned for accessing `T`, and `byteCount` must be a
    /// multiple of `MemoryLayout<T>.stride`.
    ///
    /// After calling `copyMemory(from:byteCount:)`, the `byteCount` bytes of memory
    /// referenced by this pointer are initialized to raw bytes. If the memory
    /// is bound to type `T`, then it contains values of type `T`.
    ///
    /// - Parameters:
    ///   - source: A pointer to the memory to copy bytes from. The memory in the
    ///     region `source..<(source + byteCount)` must be initialized to a trivial
    ///     type.
    ///   - byteCount: The number of bytes to copy. `byteCount` must not be negative.
    public func copyMemory(from source: UnsafeRawPointer, byteCount: Int)
}

extension UnsafeMutableRawPointer {

    /// Creates a new raw pointer from an `AutoreleasingUnsafeMutablePointer`
    /// instance.
    ///
    /// - Parameter other: The pointer to convert.
    public init<T>(_ other: AutoreleasingUnsafeMutablePointer<T>)

    /// Creates a new raw pointer from an `AutoreleasingUnsafeMutablePointer`
    /// instance.
    ///
    /// - Parameter other: The pointer to convert. If `other` is `nil`, the
    ///   result is `nil`.
    public init?<T>(_ other: AutoreleasingUnsafeMutablePointer<T>?)
}

extension UnsafeMutableRawPointer : Strideable {

    /// Returns the distance from this pointer to the given pointer.
    ///
    /// With pointers `p` and `q`, the result of `p.distance(to: q)` is
    /// equivalent to `q - p`.
    ///
    /// - Parameter x: The pointer to calculate the distance to.
    /// - Returns: The distance from this pointer to `x`, in bytes.
    public func distance(to x: UnsafeMutableRawPointer) -> Int

    /// Returns a pointer offset from this pointer by the specified number of
    /// bytes.
    ///
    /// With pointer `p` and distance `n`, the result of `p.advanced(by: n)` is
    /// equivalent to `p + n`.
    ///
    /// The resulting pointer must be within the bounds of the same allocation as
    /// this pointer.
    ///
    /// - Parameter n: The number of bytes to offset this pointer. `n` may be
    ///   positive, negative, or zero.
    /// - Returns: A pointer offset from this pointer by `n` bytes.
    public func advanced(by n: Int) -> UnsafeMutableRawPointer
}

extension UnsafeMutableRawPointer : Equatable {

    /// Returns a Boolean value indicating whether two pointers are equal.
    ///
    /// - Parameters:
    ///   - lhs: A pointer.
    ///   - rhs: Another pointer.
    /// - Returns: `true` if `lhs` and `rhs` reference the same memory address;
    ///   otherwise, `false`.
    public static func == (lhs: UnsafeMutableRawPointer, rhs: UnsafeMutableRawPointer) -> Bool
}

extension UnsafeMutableRawPointer : Comparable {

    /// Returns a Boolean value indicating whether the first pointer references
    /// an earlier memory location than the second pointer.
    ///
    /// - Parameters:
    ///   - lhs: A pointer.
    ///   - rhs: Another pointer.
    /// - Returns: `true` if `lhs` references a memory address earlier than
    ///   `rhs`; otherwise, `false`.
    public static func < (lhs: UnsafeMutableRawPointer, rhs: UnsafeMutableRawPointer) -> Bool
}

extension UnsafeMutableRawPointer : Hashable {

    /// The pointer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program.  Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }
}

extension UnsafeMutableRawPointer : CustomDebugStringConvertible {

    /// A textual representation of the pointer, suitable for debugging.
    public var debugDescription: String { get }
}

extension UnsafeMutableRawPointer : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension UnsafeMutableRawPointer : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

/// A pointer for accessing  data of a
/// specific type.
///
/// You use instances of the `UnsafePointer` type to access data of a
/// specific type in memory. The type of data that a pointer can access is the
/// pointer's `Pointee` type. `UnsafePointer` provides no automated
/// memory management or alignment guarantees. You are responsible for
/// handling the life cycle of any memory you work with through unsafe
/// pointers to avoid leaks or undefined behavior.
///
/// Memory that you manually manage can be either *untyped* or *bound* to a
/// specific type. You use the `UnsafePointer` type to access and
/// manage memory that has been bound to a specific type.
///
/// Understanding a Pointer's Memory State
/// ======================================
///
/// The memory referenced by an `UnsafePointer` instance can be in
/// one of several states. Many pointer operations must only be applied to
/// pointers with memory in a specific state---you must keep track of the
/// state of the memory you are working with and understand the changes to
/// that state that different operations perform. Memory can be untyped and
/// uninitialized, bound to a type and uninitialized, or bound to a type and
/// initialized to a value. Finally, memory that was allocated previously may
/// have been deallocated, leaving existing pointers referencing unallocated
/// memory.
///
/// Uninitialized Memory
/// --------------------
///
/// Memory that has just been allocated through a typed pointer or has been
/// deinitialized is in an *uninitialized* state. Uninitialized memory must be
/// initialized before it can be accessed for reading.
///
/// Initialized Memory
/// ------------------
///
/// *Initialized* memory has a value that can be read using a pointer's
/// `pointee` property or through subscript notation. In the following
/// example, `ptr` is a pointer to memory initialized with a value of `23`:
///
///     let ptr: UnsafePointer<Int> = ...
///     // ptr.pointee == 23
///     // ptr[0] == 23
///
/// Accessing a Pointer's Memory as a Different Type
/// ================================================
///
/// When you access memory through an `UnsafePointer` instance, the
/// `Pointee` type must be consistent with the bound type of the memory. If
/// you do need to access memory that is bound to one type as a different
/// type, Swift's pointer types provide type-safe ways to temporarily or
/// permanently change the bound type of the memory, or to load typed
/// instances directly from raw memory.
///
/// An `UnsafePointer<UInt8>` instance allocated with eight bytes of
/// memory, `uint8Pointer`, will be used for the examples below.
///
///     let uint8Pointer: UnsafePointer<UInt8> = fetchEightBytes()
///
/// When you only need to temporarily access a pointer's memory as a different
/// type, use the `withMemoryRebound(to:capacity:)` method. For example, you
/// can use this method to call an API that expects a pointer to a different
/// type that is layout compatible with your pointer's `Pointee`. The following
/// code temporarily rebinds the memory that `uint8Pointer` references from
/// `UInt8` to `Int8` to call the imported C `strlen` function.
///
///     // Imported from C
///     func strlen(_ __s: UnsafePointer<Int8>!) -> UInt
///
///     let length = uint8Pointer.withMemoryRebound(to: Int8.self, capacity: 8) {
///         return strlen($0)
///     }
///     // length == 7
///
/// When you need to permanently rebind memory to a different type, first
/// obtain a raw pointer to the memory and then call the
/// `bindMemory(to:capacity:)` method on the raw pointer. The following
/// example binds the memory referenced by `uint8Pointer` to one instance of
/// the `UInt64` type:
///
///     let uint64Pointer = UnsafeRawPointer(uint8Pointer)
///                               .bindMemory(to: UInt64.self, capacity: 1)
///
/// After rebinding the memory referenced by `uint8Pointer` to `UInt64`,
/// accessing that pointer's referenced memory as a `UInt8` instance is
/// undefined.
///
///     var fullInteger = uint64Pointer.pointee          // OK
///     var firstByte = uint8Pointer.pointee             // undefined
///
/// Alternatively, you can access the same memory as a different type without
/// rebinding through untyped memory access, so long as the bound type and the
/// destination type are trivial types. Convert your pointer to an
/// `UnsafeRawPointer` instance and then use the raw pointer's
/// `load(fromByteOffset:as:)` method to read values.
///
///     let rawPointer = UnsafeRawPointer(uint64Pointer)
///     fullInteger = rawPointer.load(as: UInt64.self)   // OK
///     firstByte = rawPointer.load(as: UInt8.self)      // OK
///
/// Performing Typed Pointer Arithmetic
/// ===================================
///
/// Pointer arithmetic with a typed pointer is counted in strides of the
/// pointer's `Pointee` type. When you add to or subtract from an `UnsafePointer`
/// instance, the result is a new pointer of the same type, offset by that
/// number of instances of the `Pointee` type.
///
///     // 'intPointer' points to memory initialized with [10, 20, 30, 40]
///     let intPointer: UnsafePointer<Int> = ...
///
///     // Load the first value in memory
///     let x = intPointer.pointee
///     // x == 10
///
///     // Load the third value in memory
///     let offsetPointer = intPointer + 2
///     let y = offsetPointer.pointee
///     // y == 30
///
/// You can also use subscript notation to access the value in memory at a
/// specific offset.
///
///     let z = intPointer[2]
///     // z == 30
///
/// Implicit Casting and Bridging
/// =============================
///
/// When calling a function or method with an `UnsafePointer` parameter, you can pass
/// an instance of that specific pointer type, pass an instance of a
/// compatible pointer type, or use Swift's implicit bridging to pass a
/// compatible pointer.
///
/// For example, the `printInt(atAddress:)` function in the following code
/// sample expects an `UnsafePointer<Int>` instance as its first parameter:
///
///     func printInt(atAddress p: UnsafePointer<Int>) {
///         print(p.pointee)
///     }
///
/// As is typical in Swift, you can call the `printInt(atAddress:)` function
/// with an `UnsafePointer` instance. This example passes `intPointer`, a pointer to
/// an `Int` value, to `print(address:)`.
///
///     printInt(atAddress: intPointer)
///     // Prints "42"
///
/// Because a mutable typed pointer can be implicitly cast to an immutable
/// pointer with the same `Pointee` type when passed as a parameter, you can
/// also call `printInt(atAddress:)` with an `UnsafeMutablePointer` instance.
///
///     let mutableIntPointer = UnsafeMutablePointer(mutating: intPointer)
///     printInt(atAddress: mutableIntPointer)
///     // Prints "42"
///
/// Alternatively, you can use Swift's *implicit bridging* to pass a pointer to
/// an instance or to the elements of an array. The following example passes a
/// pointer to the `value` variable by using inout syntax:
///
///     var value: Int = 23
///     printInt(atAddress: &value)
///     // Prints "23"
///
/// An immutable pointer to the elements of an array is implicitly created when
/// you pass the array as an argument. This example uses implicit bridging to
/// pass a pointer to the elements of `numbers` when calling
/// `printInt(atAddress:)`.
///
///     let numbers = [5, 10, 15, 20]
///     printInt(atAddress: numbers)
///     // Prints "5"
///
/// You can also use inout syntax to pass a mutable pointer to the elements of
/// an array. Because `printInt(atAddress:)` requires an immutable pointer,
/// although this is syntactically valid, it isn't necessary.
///
///     var mutableNumbers = numbers
///     printInt(atAddress: &mutableNumbers)
///
/// No matter which way you call `printInt(atAddress:)`, Swift's type safety
/// guarantees that you can only pass a pointer to the type required by the
/// function---in this case, a pointer to an `Int`.
///
/// - Important: The pointer created through implicit bridging of an instance
///   or of an array's elements is only valid during the execution of the
///   called function. Escaping the pointer to use after the execution of the
///   function is undefined behavior. In particular, do not use implicit
///   bridging when calling an `UnsafePointer` initializer.
///
///       var number = 5
///       let numberPointer = UnsafePointer<Int>(&number)
///       // Accessing 'numberPointer' is undefined behavior.
public struct UnsafePointer<Pointee> {

    /// A type that represents the distance between two pointers.
    public typealias Distance = Int

    /// Creates a new typed pointer from the given opaque pointer.
    ///
    /// - Parameter from: The opaque pointer to convert to a typed pointer.
    public init(_ from: OpaquePointer)

    /// Creates a new typed pointer from the given opaque pointer.
    ///
    /// - Parameter from: The opaque pointer to convert to a typed pointer. If
    ///   `from` is `nil`, the result of this initializer is `nil`.
    public init?(_ from: OpaquePointer?)

    /// Creates a new typed pointer from the given address, specified as a bit
    /// pattern.
    ///
    /// The address passed as `bitPattern` must have the correct alignment for
    /// the pointer's `Pointee` type. That is,
    /// `bitPattern % MemoryLayout<Pointee>.alignment` must be `0`.
    ///
    /// - Parameter bitPattern: A bit pattern to use for the address of the new
    ///   pointer. If `bitPattern` is zero, the result is `nil`.
    public init?(bitPattern: Int)

    /// Creates a new typed pointer from the given address, specified as a bit
    /// pattern.
    ///
    /// The address passed as `bitPattern` must have the correct alignment for
    /// the pointer's `Pointee` type. That is,
    /// `bitPattern % MemoryLayout<Pointee>.alignment` must be `0`.
    ///
    /// - Parameter bitPattern: A bit pattern to use for the address of the new
    ///   pointer. If `bitPattern` is zero, the result is `nil`.
    public init?(bitPattern: UInt)

    /// Creates a new pointer from the given typed pointer.
    ///
    /// - Parameter other: The typed pointer to convert.
    public init(_ other: UnsafePointer<Pointee>)

    /// Creates a new pointer from the given typed pointer.
    ///
    /// - Parameter other: The typed pointer to convert. If `other` is `nil`, the
    ///   result is `nil`.
    public init?(_ other: UnsafePointer<Pointee>?)

    /// Creates an immutable typed pointer referencing the same memory as the
    /// given mutable pointer.
    ///
    /// - Parameter other: The pointer to convert.
    public init(_ other: UnsafeMutablePointer<Pointee>)

    /// Creates an immutable typed pointer referencing the same memory as the
    /// given mutable pointer.
    ///
    /// - Parameter other: The pointer to convert. If `other` is `nil`, the
    ///   result is `nil`.
    public init?(_ other: UnsafeMutablePointer<Pointee>?)

    /// Deallocates the memory block previously allocated at this pointer.
    ///
    /// This pointer must be a pointer to the start of a previously allocated memory 
    /// block. The memory must not be initialized or `Pointee` must be a trivial type.
    public func deallocate()

    /// Accesses the instance referenced by this pointer.
    ///
    /// When reading from the `pointee` property, the instance referenced by
    /// this pointer must already be initialized.
    public var pointee: Pointee { get }

    /// Executes the given closure while temporarily binding the specified number
    /// of instances to the given type.
    ///
    /// Use this method when you have a pointer to memory bound to one type and
    /// you need to access that memory as instances of another type. Accessing
    /// memory as type `T` requires that the memory be bound to that type. A
    /// memory location may only be bound to one type at a time, so accessing
    /// the same memory as an unrelated type without first rebinding the memory
    /// is undefined.
    ///
    /// The region of memory starting at this pointer and covering `count`
    /// instances of the pointer's `Pointee` type must be initialized.
    ///
    /// The following example temporarily rebinds the memory of a `UInt64`
    /// pointer to `Int64`, then accesses a property on the signed integer.
    ///
    ///     let uint64Pointer: UnsafePointer<UInt64> = fetchValue()
    ///     let isNegative = uint64Pointer.withMemoryRebound(to: Int64.self) { ptr in
    ///         return ptr.pointee < 0
    ///     }
    ///
    /// Because this pointer's memory is no longer bound to its `Pointee` type
    /// while the `body` closure executes, do not access memory using the
    /// original pointer from within `body`. Instead, use the `body` closure's
    /// pointer argument to access the values in memory as instances of type
    /// `T`.
    ///
    /// After executing `body`, this method rebinds memory back to the original
    /// `Pointee` type.
    ///
    /// - Note: Only use this method to rebind the pointer's memory to a type
    ///   with the same size and stride as the currently bound `Pointee` type.
    ///   To bind a region of memory to a type that is a different size, convert
    ///   the pointer to a raw pointer and use the `bindMemory(to:capacity:)`
    ///   method.
    ///
    /// - Parameters:
    ///   - type: The type to temporarily bind the memory referenced by this
    ///     pointer. The type `T` must be the same size and be layout compatible
    ///     with the pointer's `Pointee` type.
    ///   - count: The number of instances of `T` to bind to `type`.
    ///   - body: A closure that takes a  typed pointer to the
    ///     same memory as this pointer, only bound to type `T`. The closure's
    ///     pointer argument is valid only for the duration of the closure's
    ///     execution. If `body` has a return value, that value is also used as
    ///     the return value for the `withMemoryRebound(to:capacity:_:)` method.
    /// - Returns: The return value, if any, of the `body` closure parameter.
    public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Int, _ body: (UnsafePointer<T>) throws -> Result) rethrows -> Result

    /// Accesses the pointee at the specified offset from this pointer.
    ///
    ///
    /// For a pointer `p`, the memory at `p + i` must be initialized.
    ///
    /// - Parameter i: The offset from this pointer at which to access an
    ///   instance, measured in strides of the pointer's `Pointee` type.
    public subscript(i: Int) -> Pointee { get }
}

extension UnsafePointer : Equatable {

    /// Returns a Boolean value indicating whether two pointers are equal.
    ///
    /// - Parameters:
    ///   - lhs: A pointer.
    ///   - rhs: Another pointer.
    /// - Returns: `true` if `lhs` and `rhs` reference the same memory address;
    ///   otherwise, `false`.
    public static func == (lhs: UnsafePointer<Pointee>, rhs: UnsafePointer<Pointee>) -> Bool
}

extension UnsafePointer : Comparable {

    /// Returns a Boolean value indicating whether the first pointer references
    /// an earlier memory location than the second pointer.
    ///
    /// - Parameters:
    ///   - lhs: A pointer.
    ///   - rhs: Another pointer.
    /// - Returns: `true` if `lhs` references a memory address earlier than
    ///   `rhs`; otherwise, `false`.
    public static func < (lhs: UnsafePointer<Pointee>, rhs: UnsafePointer<Pointee>) -> Bool
}

extension UnsafePointer : Hashable {

    /// The pointer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program.  Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension UnsafePointer : Strideable {

    /// Returns a pointer to the next consecutive instance.
    ///
    /// The resulting pointer must be within the bounds of the same allocation as
    /// this pointer.
    ///
    /// - Returns: A pointer advanced from this pointer by
    ///   `MemoryLayout<Pointee>.stride` bytes.
    public func successor() -> UnsafePointer<Pointee>

    /// Returns a pointer to the previous consecutive instance.
    ///
    /// The resulting pointer must be within the bounds of the same allocation as
    /// this pointer.
    ///
    /// - Returns: A pointer shifted backward from this pointer by
    ///   `MemoryLayout<Pointee>.stride` bytes.
    public func predecessor() -> UnsafePointer<Pointee>

    /// Returns the distance from this pointer to the given pointer, counted as
    /// instances of the pointer's `Pointee` type.
    ///
    /// With pointers `p` and `q`, the result of `p.distance(to: q)` is
    /// equivalent to `q - p`.
    ///
    /// Typed pointers are required to be properly aligned for their `Pointee`
    /// type. Proper alignment ensures that the result of `distance(to:)`
    /// accurately measures the distance between the two pointers, counted in
    /// strides of `Pointee`. To find the distance in bytes between two
    /// pointers, convert them to `UnsafeRawPointer` instances before calling
    /// `distance(to:)`.
    ///
    /// - Parameter end: The pointer to calculate the distance to.
    /// - Returns: The distance from this pointer to `end`, in strides of the
    ///   pointer's `Pointee` type. To access the stride, use
    ///   `MemoryLayout<Pointee>.stride`.
    public func distance(to end: UnsafePointer<Pointee>) -> Int

    /// Returns a pointer offset from this pointer by the specified number of
    /// instances.
    ///
    /// With pointer `p` and distance `n`, the result of `p.advanced(by: n)` is
    /// equivalent to `p + n`.
    ///
    /// The resulting pointer must be within the bounds of the same allocation as
    /// this pointer.
    ///
    /// - Parameter n: The number of strides of the pointer's `Pointee` type to
    ///   offset this pointer. To access the stride, use
    ///   `MemoryLayout<Pointee>.stride`. `n` may be positive, negative, or
    ///   zero.
    /// - Returns: A pointer offset from this pointer by `n` instances of the
    ///   `Pointee` type.
    public func advanced(by n: Int) -> UnsafePointer<Pointee>
}

extension UnsafePointer : CustomDebugStringConvertible {

    /// A textual representation of the pointer, suitable for debugging.
    public var debugDescription: String { get }
}

extension UnsafePointer : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension UnsafePointer : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "UnsafePointer.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UnsafePointer : CVarArg {
}

/// A  nonowning collection interface to the bytes in a
/// region of memory.
///
/// You can use an `UnsafeRawBufferPointer` instance in low-level operations to eliminate
/// uniqueness checks and release mode bounds checks. Bounds checks are always
/// performed in debug mode.
///
/// An `UnsafeRawBufferPointer` instance is a view of the raw bytes in a region of memory.
/// Each byte in memory is viewed as a `UInt8` value independent of the type
/// of values held in that memory. Reading from memory through a raw buffer is
/// an untyped operation.
///
/// In addition to its collection interface, an `UnsafeRawBufferPointer` instance also supports
/// the `load(fromByteOffset:as:)` method provided by `UnsafeRawPointer`,
/// including bounds checks in debug mode.
///
/// To access the underlying memory through typed operations, the memory must
/// be bound to a trivial type.
///
/// - Note: A *trivial type* can be copied bit for bit with no indirection
///   or reference-counting operations. Generally, native Swift types that do
///   not contain strong or weak references or other forms of indirection are
///   trivial, as are imported C structs and enums. Copying memory that
///   contains values of nontrivial types can only be done safely with a typed
///   pointer. Copying bytes directly from nontrivial, in-memory values does
///   not produce valid copies and can only be done by calling a C API, such as
///   `memmove()`.
///
/// UnsafeRawBufferPointer Semantics
/// =================
///
/// An `UnsafeRawBufferPointer` instance is a view into memory and does not own the memory
/// that it references. Copying a variable or constant of type `UnsafeRawBufferPointer` does
/// not copy the underlying memory. However, initializing another collection
/// with an `UnsafeRawBufferPointer` instance copies bytes out of the referenced memory and
/// into the new collection.
///
/// The following example uses `someBytes`, an `UnsafeRawBufferPointer` instance, to
/// demonstrate the difference between assigning a buffer pointer and using a
/// buffer pointer as the source for another collection's elements. Here, the
/// assignment to `destBytes` creates a new, nonowning buffer pointer
/// covering the first `n` bytes of the memory that `someBytes`
/// references---nothing is copied:
///
///     var destBytes = someBytes[0..<n]
///
/// Next, the bytes referenced by `destBytes` are copied into `byteArray`, a
/// new `[UInt]` array, and then the remainder of `someBytes` is appended to
/// `byteArray`:
///
///     var byteArray: [UInt8] = Array(destBytes)
///     byteArray += someBytes[n..<someBytes.count]
public struct UnsafeRawBufferPointer {
}

extension UnsafeRawBufferPointer {

    /// An iterator over the bytes viewed by a raw buffer pointer.
    public struct Iterator {
    }
}

extension UnsafeRawBufferPointer : Sequence {

    /// A type that represents a subsequence of some of the sequence's elements.
    public typealias SubSequence = Slice<UnsafeRawBufferPointer>

    /// Returns an iterator over the bytes of this sequence.
    public func makeIterator() -> UnsafeRawBufferPointer.Iterator
}

extension UnsafeRawBufferPointer : Collection {

    /// A type representing the sequence's elements.
    public typealias Element = UInt8

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    /// Always zero, which is the index of the first byte in a nonempty buffer.
    public var startIndex: UnsafeRawBufferPointer.Index { get }

    /// The "past the end" position---that is, the position one greater than the
    /// last valid subscript argument.
    ///
    /// The `endIndex` property of an `UnsafeRawBufferPointer`
    /// instance is always identical to `count`.
    public var endIndex: UnsafeRawBufferPointer.Index { get }

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    public var indices: UnsafeRawBufferPointer.Indices { get }

    /// Accesses the byte at the given offset in the memory region as a `UInt8`
    /// value.
    ///
    /// - Parameter i: The offset of the byte to access. `i` must be in the range
    ///   `0..<count`.
    public subscript(i: Int) -> UnsafeRawBufferPointer.Element { get }

    /// Accesses the bytes in the specified memory region.
    ///
    /// - Parameter bounds: The range of byte offsets to access. The upper and
    ///   lower bounds of the range must be in the range `0...count`.
    public subscript(bounds: Range<Int>) -> UnsafeRawBufferPointer.SubSequence { get }

    /// The number of bytes in the buffer.
    ///
    /// If the `baseAddress` of this buffer is `nil`, the count is zero. However,
    /// a buffer can have a `count` of zero even with a non-`nil` base address.
    public var count: Int { get }
}

extension UnsafeRawBufferPointer : RandomAccessCollection {
}

extension UnsafeRawBufferPointer {

    /// Deallocates the memory block previously allocated at this buffer pointers 
    /// base address. 
    ///
    /// This buffer pointer's `baseAddress` must be `nil` or a pointer to a memory 
    /// block previously returned by a Swift allocation method. If `baseAddress` is 
    /// `nil`, this function does nothing. Otherwise, the memory must not be initialized 
    /// or `Pointee` must be a trivial type. This buffer pointer's byte `count` must 
    /// be equal to the originally allocated size of the memory block.
    public func deallocate()

    /// Returns a new instance of the given type, read from the buffer pointer's
    /// raw memory at the specified byte offset.
    ///
    /// You can use this method to create new values from the buffer pointer's
    /// underlying bytes. The following example creates two new `Int32`
    /// instances from the memory referenced by the buffer pointer `someBytes`.
    /// The bytes for `a` are copied from the first four bytes of `someBytes`,
    /// and the bytes for `b` are copied from the next four bytes.
    ///
    ///     let a = someBytes.load(as: Int32.self)
    ///     let b = someBytes.load(fromByteOffset: 4, as: Int32.self)
    ///
    /// The memory to read for the new instance must not extend beyond the buffer
    /// pointer's memory region---that is, `offset + MemoryLayout<T>.size` must
    /// be less than or equal to the buffer pointer's `count`.
    ///
    /// - Parameters:
    ///   - offset: The offset, in bytes, into the buffer pointer's memory at
    ///     which to begin reading data for the new instance. The buffer pointer
    ///     plus `offset` must be properly aligned for accessing an instance of
    ///     type `T`. The default is zero.
    ///   - type: The type to use for the newly constructed instance. The memory
    ///     must be initialized to a value of a type that is layout compatible
    ///     with `type`.
    /// - Returns: A new instance of type `T`, copied from the buffer pointer's
    ///   memory.
    public func load<T>(fromByteOffset offset: Int = default, as type: T.Type) -> T

    /// Creates a buffer over the specified number of contiguous bytes starting
    /// at the given pointer.
    ///
    /// - Parameters:
    ///   - start: The address of the memory that starts the buffer. If `starts`
    ///     is `nil`, `count` must be zero. However, `count` may be zero even
    ///     for a non-`nil` `start`.
    ///   - count: The number of bytes to include in the buffer. `count` must not
    ///     be negative.
    public init(start: UnsafeRawPointer?, count: Int)

    /// Creates a new buffer over the same memory as the given buffer.
    ///
    /// - Parameter bytes: The buffer to convert.
    public init(_ bytes: UnsafeMutableRawBufferPointer)

    /// Creates a new buffer over the same memory as the given buffer.
    ///
    /// - Parameter bytes: The buffer to convert.
    public init(_ bytes: UnsafeRawBufferPointer)

    /// Creates a raw buffer over the contiguous bytes in the given typed buffer.
    ///
    /// - Parameter buffer: The typed buffer to convert to a raw buffer. The
    ///   buffer's type `T` must be a trivial type.
    public init<T>(_ buffer: UnsafeMutableBufferPointer<T>)

    /// Creates a raw buffer over the contiguous bytes in the given typed buffer.
    ///
    /// - Parameter buffer: The typed buffer to convert to a raw buffer. The
    ///   buffer's type `T` must be a trivial type.
    public init<T>(_ buffer: UnsafeBufferPointer<T>)

    /// Creates a raw buffer over the same memory as the given raw buffer slice,
    /// with the indices rebased to zero.
    ///
    /// The new buffer represents the same region of memory as the slice, but its
    /// indices start at zero instead of at the beginning of the slice in the
    /// original buffer. The following code creates `slice`, a slice covering
    /// part of an existing buffer instance, then rebases it into a new `rebased`
    /// buffer.
    ///
    ///     let slice = buffer[n...]
    ///     let rebased = UnsafeRawBufferPointer(rebasing: slice)
    ///
    /// After this code has executed, the following are true:
    ///
    /// - `rebased.startIndex == 0`
    /// - `rebased[0] == slice[n]`
    /// - `rebased[0] == buffer[n]`
    /// - `rebased.count == slice.count`
    ///
    /// - Parameter slice: The raw buffer slice to rebase.
    public init(rebasing slice: Slice<UnsafeRawBufferPointer>)

    /// Creates a raw buffer over the same memory as the given raw buffer slice,
    /// with the indices rebased to zero.
    ///
    /// The new buffer represents the same region of memory as the slice, but its
    /// indices start at zero instead of at the beginning of the slice in the
    /// original buffer. The following code creates `slice`, a slice covering
    /// part of an existing buffer instance, then rebases it into a new `rebased`
    /// buffer.
    ///
    ///     let slice = buffer[n...]
    ///     let rebased = UnsafeRawBufferPointer(rebasing: slice)
    ///
    /// After this code has executed, the following are true:
    ///
    /// - `rebased.startIndex == 0`
    /// - `rebased[0] == slice[n]`
    /// - `rebased[0] == buffer[n]`
    /// - `rebased.count == slice.count`
    ///
    /// - Parameter slice: The raw buffer slice to rebase.
    public init(rebasing slice: Slice<UnsafeMutableRawBufferPointer>)

    /// A pointer to the first byte of the buffer.
    ///
    /// If the `baseAddress` of this buffer is `nil`, the count is zero. However,
    /// a buffer can have a `count` of zero even with a non-`nil` base address.
    public var baseAddress: UnsafeRawPointer? { get }

    /// Binds this buffers memory to the specified type and returns a typed buffer 
    /// of the bound memory.
    ///
    /// Use the `bindMemory(to:)` method to bind the memory referenced
    /// by this buffer to the type `T`. The memory must be uninitialized or
    /// initialized to a type that is layout compatible with `T`. If the memory
    /// is uninitialized, it is still uninitialized after being bound to `T`.
    ///
    /// - Warning: A memory location may only be bound to one type at a time. The
    ///   behavior of accessing memory as a type unrelated to its bound type is
    ///   undefined.
    ///
    /// - Parameters:
    ///   - type: The type `T` to bind the memory to.
    /// - Returns: A typed buffer of the newly bound memory. The memory in this
    ///   region is bound to `T`, but has not been modified in any other way.
    ///   The typed buffer references `self.count / MemoryLayout<T>.stride` instances of `T`.
    public func bindMemory<T>(to type: T.Type) -> UnsafeBufferPointer<T>
}

extension UnsafeRawBufferPointer : CustomDebugStringConvertible {

    /// A textual representation of the buffer, suitable for debugging.
    public var debugDescription: String { get }
}

extension UnsafeRawBufferPointer {
}

extension UnsafeRawBufferPointer.Iterator : IteratorProtocol, Sequence {

    /// Advances to the next byte and returns it, or `nil` if no next byte
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    ///
    /// - Returns: The next sequential byte in the raw buffer if another byte
    ///   exists; otherwise, `nil`.
    public mutating func next() -> UInt8?
}

public typealias UnsafeRawBufferPointerIterator<T> = UnsafeBufferPointer<T>.Iterator

/// A raw pointer for accessing 
/// untyped data.
///
/// The `UnsafeRawPointer` type provides no automated memory management, no type safety,
/// and no alignment guarantees. You are responsible for handling the life
/// cycle of any memory you work with through unsafe pointers, to avoid leaks
/// or undefined behavior.
///
/// Memory that you manually manage can be either *untyped* or *bound* to a
/// specific type. You use the `UnsafeRawPointer` type to access and
/// manage raw bytes in memory, whether or not that memory has been bound to a
/// specific type.
///
/// Understanding a Pointer's Memory State
/// ======================================
///
/// The memory referenced by an `UnsafeRawPointer` instance can be in one of several
/// states. Many pointer operations must only be applied to pointers with
/// memory in a specific state---you must keep track of the state of the
/// memory you are working with and understand the changes to that state that
/// different operations perform. Memory can be untyped and uninitialized,
/// bound to a type and uninitialized, or bound to a type and initialized to a
/// value. Finally, memory that was allocated previously may have been
/// deallocated, leaving existing pointers referencing unallocated memory.
///
/// Raw, Uninitialized Memory
/// -------------------------
///
/// Raw memory that has just been allocated is in an *uninitialized, untyped*
/// state. Uninitialized memory must be initialized with values of a type
/// before it can be used with any typed operations.
///
/// To bind uninitialized memory to a type without initializing it, use the
/// `bindMemory(to:count:)` method. This method returns a typed pointer
/// for further typed access to the memory.
///
/// Typed Memory
/// ------------
///
/// Memory that has been bound to a type, whether it is initialized or
/// uninitialized, is typically accessed using typed pointers---instances of
/// `UnsafePointer` and `UnsafeMutablePointer`. Initialization, assignment,
/// and deinitialization can be performed using `UnsafeMutablePointer`
/// methods.
///
/// Memory that has been bound to a type can be rebound to a different type
/// only after it has been deinitialized or if the bound type is a *trivial
/// type*. Deinitializing typed memory does not unbind that memory's type. The
/// deinitialized memory can be reinitialized with values of the same type,
/// bound to a new type, or deallocated.
///
/// - Note: A trivial type can be copied bit for bit with no indirection or
///   reference-counting operations. Generally, native Swift types that do not
///   contain strong or weak references or other forms of indirection are
///   trivial, as are imported C structs and enumerations.
///
/// When reading from  memory as raw
/// bytes when that memory is bound to a type, you must ensure that you
/// satisfy any alignment requirements.
///
/// Raw Pointer Arithmetic
/// ======================
///
/// Pointer arithmetic with raw pointers is performed at the byte level. When
/// you add to or subtract from a raw pointer, the result is a new raw pointer
/// offset by that number of bytes. The following example allocates four bytes
/// of memory and stores `0xFF` in all four bytes:
///
///     let bytesPointer = UnsafeMutableRawPointer.allocate(byteCount: 4, alignment: 1)
///     bytesPointer.storeBytes(of: 0xFFFF_FFFF, as: UInt32.self)
///
///     // Load a value from the memory referenced by 'bytesPointer'
///     let x = bytesPointer.load(as: UInt8.self)       // 255
///
///     // Load a value from the last two allocated bytes
///     let offsetPointer = bytesPointer + 2
///     let y = offsetPointer.load(as: UInt16.self)     // 65535
///
/// The code above stores the value `0xFFFF_FFFF` into the four newly allocated
/// bytes, and then loads the first byte as a `UInt8` instance and the third
/// and fourth bytes as a `UInt16` instance.
///
/// Always remember to deallocate any memory that you allocate yourself.
///
///     bytesPointer.deallocate()
///
/// Implicit Casting and Bridging
/// =============================
///
/// When calling a function or method with an `UnsafeRawPointer` parameter, you can pass
/// an instance of that specific pointer type, pass an instance of a
/// compatible pointer type, or use Swift's implicit bridging to pass a
/// compatible pointer.
///
/// For example, the `print(address:as:)` function in the following code sample
/// takes an `UnsafeRawPointer` instance as its first parameter:
///
///     func print<T>(address p: UnsafeRawPointer, as type: T.Type) {
///         let value = p.load(as: type)
///         print(value)
///     }
///
/// As is typical in Swift, you can call the `print(address:as:)` function with
/// an `UnsafeRawPointer` instance. This example passes `rawPointer` as the initial
/// parameter.
///
///     // 'rawPointer' points to memory initialized with `Int` values.
///     let rawPointer: UnsafeRawPointer = ...
///     print(address: rawPointer, as: Int.self)
///     // Prints "42"
///
/// Because typed pointers can be implicitly cast to raw pointers when passed
/// as a parameter, you can also call `print(address:as:)` with any mutable or
/// immutable typed pointer instance.
///
///     let intPointer: UnsafePointer<Int> = ...
///     print(address: intPointer, as: Int.self)
///     // Prints "42"
///
///     let mutableIntPointer = UnsafeMutablePointer(mutating: intPointer)
///     print(address: mutableIntPointer, as: Int.self)
///     // Prints "42"
///
/// Alternatively, you can use Swift's *implicit bridging* to pass a pointer to
/// an instance or to the elements of an array. Use inout syntax to implicitly
/// create a pointer to an instance of any type. The following example uses
/// implicit bridging to pass a pointer to `value` when calling
/// `print(address:as:)`:
///
///     var value: Int = 23
///     print(address: &value, as: Int.self)
///     // Prints "23"
///
/// An immutable pointer to the elements of an array is implicitly created when
/// you pass the array as an argument. This example uses implicit bridging to
/// pass a pointer to the elements of `numbers` when calling
/// `print(address:as:)`.
///
///     let numbers = [5, 10, 15, 20]
///     print(address: numbers, as: Int.self)
///     // Prints "5"
///
/// You can also use inout syntax to pass a mutable pointer to the elements of
/// an array. Because `print(address:as:)` requires an immutable pointer,
/// although this is syntactically valid, it isn't necessary.
///
///     var mutableNumbers = numbers
///     print(address: &mutableNumbers, as: Int.self)
///
/// - Important: The pointer created through implicit bridging of an instance
///   or of an array's elements is only valid during the execution of the
///   called function. Escaping the pointer to use after the execution of the
///   function is undefined behavior. In particular, do not use implicit
///   bridging when calling an `UnsafeRawPointer` initializer.
///
///       var number = 5
///       let numberPointer = UnsafeRawPointer(&number)
///       // Accessing 'numberPointer' is undefined behavior.
public struct UnsafeRawPointer {

    /// Creates a new raw pointer from the given raw or typed pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The pointer to convert.
    public init(_ other: UnsafeRawPointer)

    /// Creates a new raw pointer from the given raw or typed pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The pointer to convert. If `other` is `nil`, the
    ///   result is `nil`.
    public init?(_ other: UnsafeRawPointer?)

    /// Creates a new raw pointer from the given opaque pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The opaque pointer to convert.
    public init(_ other: OpaquePointer)

    /// Creates a new raw pointer from the given opaque pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The opaque pointer to convert. If `other` is `nil`,
    ///   the result is `nil`.
    public init?(_ other: OpaquePointer?)

    /// Creates a new raw pointer from the given address, specified as a bit
    /// pattern.
    ///
    /// - Parameter bitPattern: A bit pattern to use for the address of the new
    ///   raw pointer. If `bitPattern` is zero, the result is `nil`.
    public init?(bitPattern: Int)

    /// Creates a new raw pointer from the given address, specified as a bit
    /// pattern.
    ///
    /// - Parameter bitPattern: A bit pattern to use for the address of the new
    ///   raw pointer. If `bitPattern` is zero, the result is `nil`.
    public init?(bitPattern: UInt)

    /// Creates a new raw pointer from the given typed pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The typed pointer to convert.
    public init<T>(_ other: UnsafePointer<T>)

    /// Creates a new raw pointer from the given typed pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The typed pointer to convert. If `other` is `nil`, the
    ///   result is `nil`.
    public init?<T>(_ other: UnsafePointer<T>?)

    /// Creates a new raw pointer from the given mutable raw pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The mutable raw pointer to convert.
    public init(_ other: UnsafeMutableRawPointer)

    /// Creates a new raw pointer from the given mutable raw pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The mutable raw pointer to convert. If `other` is
    ///   `nil`, the result is `nil`.
    public init?(_ other: UnsafeMutableRawPointer?)

    /// Creates a new raw pointer from the given typed pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The typed pointer to convert.
    public init<T>(_ other: UnsafeMutablePointer<T>)

    /// Creates a new raw pointer from the given typed pointer.
    ///
    /// Use this initializer to explicitly convert `other` to an `UnsafeRawPointer`
    /// instance. This initializer creates a new pointer to the same address as
    /// `other` and performs no allocation or copying.
    ///
    /// - Parameter other: The typed pointer to convert. If `other` is `nil`, the
    ///   result is `nil`.
    public init?<T>(_ other: UnsafeMutablePointer<T>?)

    @available(swift, deprecated: 4.1, obsoleted: 5.0.0, message: "Swift currently only supports freeing entire heap blocks, use deallocate() instead")
    public func deallocate(bytes _: Int, alignedTo _: Int)

    /// Deallocates the previously allocated memory block referenced by this pointer.
    ///
    /// The memory to be deallocated must be uninitialized or initialized to a
    /// trivial type.
    public func deallocate()

    /// Binds the memory to the specified type and returns a typed pointer to the
    /// bound memory.
    ///
    /// Use the `bindMemory(to:capacity:)` method to bind the memory referenced
    /// by this pointer to the type `T`. The memory must be uninitialized or
    /// initialized to a type that is layout compatible with `T`. If the memory
    /// is uninitialized, it is still uninitialized after being bound to `T`.
    ///
    /// In this example, 100 bytes of raw memory are allocated for the pointer
    /// `bytesPointer`, and then the first four bytes are bound to the `Int8`
    /// type.
    ///
    ///     let count = 4
    ///     let bytesPointer = UnsafeMutableRawPointer.allocate(
    ///             bytes: 100,
    ///             alignedTo: MemoryLayout<Int8>.alignment)
    ///     let int8Pointer = bytesPointer.bindMemory(to: Int8.self, capacity: count)
    ///
    /// After calling `bindMemory(to:capacity:)`, the first four bytes of the
    /// memory referenced by `bytesPointer` are bound to the `Int8` type, though
    /// they remain uninitialized. The remainder of the allocated region is
    /// unbound raw memory. All 100 bytes of memory must eventually be
    /// deallocated.
    ///
    /// - Warning: A memory location may only be bound to one type at a time. The
    ///   behavior of accessing memory as a type unrelated to its bound type is
    ///   undefined.
    ///
    /// - Parameters:
    ///   - type: The type `T` to bind the memory to.
    ///   - count: The amount of memory to bind to type `T`, counted as instances
    ///     of `T`.
    /// - Returns: A typed pointer to the newly bound memory. The memory in this
    ///   region is bound to `T`, but has not been modified in any other way.
    ///   The number of bytes in this region is
    ///   `count * MemoryLayout<T>.stride`.
    public func bindMemory<T>(to type: T.Type, capacity count: Int) -> UnsafePointer<T>

    /// Returns a typed pointer to the memory referenced by this pointer,
    /// assuming that the memory is already bound to the specified type.
    ///
    /// Use this method when you have a raw pointer to memory that has *already*
    /// been bound to the specified type. The memory starting at this pointer
    /// must be bound to the type `T`. Accessing memory through the returned
    /// pointer is undefined if the memory has not been bound to `T`. To bind
    /// memory to `T`, use `bindMemory(to:capacity:)` instead of this method.
    ///
    /// - Parameter to: The type `T` that the memory has already been bound to.
    /// - Returns: A typed pointer to the same memory as this raw pointer.
    public func assumingMemoryBound<T>(to: T.Type) -> UnsafePointer<T>

    /// Returns a new instance of the given type, constructed from the raw memory
    /// at the specified offset.
    ///
    /// The memory at this pointer plus `offset` must be properly aligned for
    /// accessing `T` and initialized to `T` or another type that is layout
    /// compatible with `T`.
    ///
    /// - Parameters:
    ///   - offset: The offset from this pointer, in bytes. `offset` must be
    ///     nonnegative. The default is zero.
    ///   - type: The type of the instance to create.
    /// - Returns: A new instance of type `T`, read from the raw bytes at
    ///   `offset`. The returned instance is memory-managed and unassociated
    ///   with the value in the memory referenced by this pointer.
    public func load<T>(fromByteOffset offset: Int = default, as type: T.Type) -> T
}

extension UnsafeRawPointer {

    /// Creates a new raw pointer from an `AutoreleasingUnsafeMutablePointer`
    /// instance.
    ///
    /// - Parameter other: The pointer to convert.
    public init<T>(_ other: AutoreleasingUnsafeMutablePointer<T>)

    /// Creates a new raw pointer from an `AutoreleasingUnsafeMutablePointer`
    /// instance.
    ///
    /// - Parameter other: The pointer to convert. If `other` is `nil`, the
    ///   result is `nil`.
    public init?<T>(_ other: AutoreleasingUnsafeMutablePointer<T>?)
}

extension UnsafeRawPointer : Strideable {

    /// Returns the distance from this pointer to the given pointer.
    ///
    /// With pointers `p` and `q`, the result of `p.distance(to: q)` is
    /// equivalent to `q - p`.
    ///
    /// - Parameter x: The pointer to calculate the distance to.
    /// - Returns: The distance from this pointer to `x`, in bytes.
    public func distance(to x: UnsafeRawPointer) -> Int

    /// Returns a pointer offset from this pointer by the specified number of
    /// bytes.
    ///
    /// With pointer `p` and distance `n`, the result of `p.advanced(by: n)` is
    /// equivalent to `p + n`.
    ///
    /// The resulting pointer must be within the bounds of the same allocation as
    /// this pointer.
    ///
    /// - Parameter n: The number of bytes to offset this pointer. `n` may be
    ///   positive, negative, or zero.
    /// - Returns: A pointer offset from this pointer by `n` bytes.
    public func advanced(by n: Int) -> UnsafeRawPointer
}

extension UnsafeRawPointer : Equatable {

    /// Returns a Boolean value indicating whether two pointers are equal.
    ///
    /// - Parameters:
    ///   - lhs: A pointer.
    ///   - rhs: Another pointer.
    /// - Returns: `true` if `lhs` and `rhs` reference the same memory address;
    ///   otherwise, `false`.
    public static func == (lhs: UnsafeRawPointer, rhs: UnsafeRawPointer) -> Bool
}

extension UnsafeRawPointer : Comparable {

    /// Returns a Boolean value indicating whether the first pointer references
    /// an earlier memory location than the second pointer.
    ///
    /// - Parameters:
    ///   - lhs: A pointer.
    ///   - rhs: Another pointer.
    /// - Returns: `true` if `lhs` references a memory address earlier than
    ///   `rhs`; otherwise, `false`.
    public static func < (lhs: UnsafeRawPointer, rhs: UnsafeRawPointer) -> Bool
}

extension UnsafeRawPointer : Hashable {

    /// The pointer's hash value.
    ///
    /// The hash value is not guaranteed to be stable across different
    /// invocations of the same program.  Do not persist the hash value across
    /// program runs.
    public var hashValue: Int { get }
}

extension UnsafeRawPointer : CustomDebugStringConvertible {

    /// A textual representation of the pointer, suitable for debugging.
    public var debugDescription: String { get }
}

extension UnsafeRawPointer : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension UnsafeRawPointer : CustomPlaygroundQuickLookable {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

/// An integer type that can represent only nonnegative values.
public protocol UnsignedInteger : BinaryInteger {
}

extension UnsignedInteger {

    /// The magnitude of this value.
    ///
    /// Every unsigned integer is its own magnitude, so for any value `x`,
    /// `x == x.magnitude`.
    ///
    /// The global `abs(_:)` function provides more familiar syntax when you need
    /// to find an absolute value. In addition, because `abs(_:)` always returns
    /// a value of the same type, even in a generic context, using the function
    /// instead of the `magnitude` property is encouraged.
    public var magnitude: Self { get }

    /// A Boolean value indicating whether this type is a signed integer type.
    ///
    /// This property is always `false` for unsigned integer types.
    public static var isSigned: Bool { get }
}

extension UnsignedInteger {

    /// Creates a new instance from the given integer.
    ///
    /// Use this initializer to convert from another integer type when you know
    /// the value is within the bounds of this type. Passing a value that can't
    /// be represented in this type results in a runtime error.
    ///
    /// In the following example, the constant `y` is successfully created from
    /// `x`, an `Int` instance with a value of `100`. Because the `Int8` type
    /// can represent `127` at maximum, the attempt to create `z` with a value
    /// of `1000` results in a runtime error.
    ///
    ///     let x = 100
    ///     let y = Int8(x)
    ///     // y == 100
    ///     let z = Int8(x * 10)
    ///     // Error: Not enough bits to represent the given value
    ///
    /// - Parameter source: A value to convert to this type of integer. The value
    ///   passed as `source` must be representable in this type.
    public convenience init<T>(_ source: T) where T : BinaryInteger

    /// Creates a new instance from the given integer, if it can be represented
    /// exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `100`, while the attempt to initialize the
    /// constant `y` from `1_000` fails because the `Int8` type can represent
    /// `127` at maximum:
    ///
    ///     let x = Int8(exactly: 100)
    ///     // x == Optional(100)
    ///     let y = Int8(exactly: 1_000)
    ///     // y == nil
    ///
    /// - Parameter source: A value to convert to this type of integer.
    public convenience init?<T>(exactly source: T) where T : BinaryInteger

    /// The maximum representable integer in this type.
    ///
    /// For unsigned integer types, this value is `(2 ** bitWidth) - 1`, where
    /// `**` is exponentiation.
    public static var max: Self { get }

    /// The minimum representable integer in this type.
    ///
    /// For unsigned integer types, this value is always `0`.
    public static var min: Self { get }
}

/// The return type of functions that don't explicitly specify a return type,
/// that is, an empty tuple `()`.
///
/// When declaring a function or method, you don't need to specify a return
/// type if no value will be returned. However, the type of a function,
/// method, or closure always includes a return type, which is `Void` if
/// otherwise unspecified.
///
/// Use `Void` or an empty tuple as the return type when declaring a closure,
/// function, or method that doesn't return a value.
///
///     // No return type declared:
///     func logMessage(_ s: String) {
///         print("Message: \(s)")
///     }
///
///     let logger: (String) -> Void = logMessage
///     logger("This is a void function")
///     // Prints "Message: This is a void function"
public typealias Void = ()

/// A key path that supports reading from and writing to the resulting value.
public class WritableKeyPath<Root, Value> : KeyPath<Root, Value> {
}

public typealias Zip2Iterator<T, U> = Zip2Sequence<T, U>.Iterator

/// A sequence of pairs built out of two underlying sequences.
///
/// In a `Zip2Sequence` instance, the elements of the *i*th pair are the *i*th
/// elements of each underlying sequence. To create a `Zip2Sequence` instance,
/// use the `zip(_:_:)` function.
///
/// The following example uses the `zip(_:_:)` function to iterate over an
/// array of strings and a countable range at the same time:
///
///     let words = ["one", "two", "three", "four"]
///     let numbers = 1...4
///
///     for (word, number) in zip(words, numbers) {
///         print("\(word): \(number)")
///     }
///     // Prints "one: 1"
///     // Prints "two: 2
///     // Prints "three: 3"
///     // Prints "four: 4"
public struct Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Sequence, Sequence2 : Sequence {

    @available(*, deprecated, renamed: "Sequence1.Iterator")
    public typealias Stream1 = Sequence1.Iterator

    @available(*, deprecated, renamed: "Sequence2.Iterator")
    public typealias Stream2 = Sequence2.Iterator
}

extension Zip2Sequence where Sequence1 : Sequence, Sequence2 : Sequence {

    /// An iterator for `Zip2Sequence`.
    public struct Iterator {
    }
}

extension Zip2Sequence : Sequence where Sequence1 : Sequence, Sequence2 : Sequence {

    /// A type representing the sequence's elements.
    public typealias Element = (Sequence1.Element, Sequence2.Element)

    /// Returns an iterator over the elements of this sequence.
    public func makeIterator() -> Zip2Sequence<Sequence1, Sequence2>.Iterator
}

extension Zip2Sequence.Iterator : IteratorProtocol where Sequence1 : Sequence, Sequence2 : Sequence {

    /// The type of element returned by `next()`.
    public typealias Element = (Sequence1.Element, Sequence2.Element)

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    public mutating func next() -> Zip2Sequence<Sequence1, Sequence2>.Iterator.Element?
}

/// An implementation detail of key path expressions; do not use this protocol
/// directly.
public protocol _AppendKeyPath {
}

extension _AppendKeyPath where Self == AnyKeyPath {

    /// Returns a new key path created by appending the given key path to this
    /// one.
    ///
    /// Use this method to extend this key path to the value type of another key
    /// path. Appending the key path passed as `path` is successful only if the
    /// root type for `path` matches this key path's value type. This example
    /// creates key paths from `Array<Int>` to `String` and from `String` to
    /// `Int`, and then tries appending each to the other:
    ///
    ///     let arrayDescription: AnyKeyPath = \Array<Int>.description
    ///     let stringLength: AnyKeyPath = \String.count
    ///
    ///     // Creates a key path from `Array<Int>` to `Int`
    ///     let arrayDescriptionLength = arrayDescription.appending(path: stringLength)
    ///
    ///     let invalidKeyPath = stringLength.appending(path: arrayDescription)
    ///     // invalidKeyPath == nil
    ///
    /// The second call to `appending(path:)` returns `nil`
    /// because the root type of `arrayDescription`, `Array<Int>`, does not
    /// match the value type of `stringLength`, `Int`.
    ///
    /// - Parameter path: The key path to append.
    /// - Returns: A key path from the root of this key path and the value type
    ///   of `path`, if `path` can be appended. If `path` can't be appended,
    ///   returns `nil`.
    public func appending(path: AnyKeyPath) -> AnyKeyPath?
}

extension _AppendKeyPath {

    /// Returns a new key path created by appending the given key path to this
    /// one.
    ///
    /// Use this method to extend this key path to the value type of another key
    /// path. Appending the key path passed as `path` is successful only if the
    /// root type for `path` matches this key path's value type. This example
    /// creates key paths from `Array<Int>` to `String` and from `String` to
    /// `Int`, and then tries appending each to the other:
    ///
    ///     let arrayDescription: PartialKeyPath<Array<Int>> = \.description
    ///     let stringLength: PartialKeyPath<String> = \.count
    ///
    ///     // Creates a key path from `Array<Int>` to `Int`
    ///     let arrayDescriptionLength = arrayDescription.appending(path: stringLength)
    ///
    ///     let invalidKeyPath = stringLength.appending(path: arrayDescription)
    ///     // invalidKeyPath == nil
    ///
    /// The second call to `appending(path:)` returns `nil`
    /// because the root type of `arrayDescription`, `Array<Int>`, does not
    /// match the value type of `stringLength`, `Int`.
    ///
    /// - Parameter path: The key path to append.
    /// - Returns: A key path from the root of this key path and the value type
    ///   of `path`, if `path` can be appended. If `path` can't be appended,
    ///   returns `nil`.
    public func appending<Root>(path: AnyKeyPath) -> PartialKeyPath<Root>? where Self == PartialKeyPath<Root>

    /// Returns a new key path created by appending the given key path to this
    /// one.
    ///
    /// Use this method to extend this key path to the value type of another key
    /// path. Appending the key path passed as `path` is successful only if the
    /// root type for `path` matches this key path's value type. This example
    /// creates a key path from `Array<Int>` to `String`, and then tries
    /// appending compatible and incompatible key paths:
    ///
    ///     let arrayDescription: PartialKeyPath<Array<Int>> = \.description
    ///
    ///     // Creates a key path from `Array<Int>` to `Int`
    ///     let arrayDescriptionLength = arrayDescription.appending(path: \String.count)
    ///
    ///     let invalidKeyPath = arrayDescription.appending(path: \Double.isZero)
    ///     // invalidKeyPath == nil
    ///
    /// The second call to `appending(path:)` returns `nil` because the root type
    /// of the `path` parameter, `Double`, does not match the value type of
    /// `arrayDescription`, `String`.
    ///
    /// - Parameter path: The key path to append.
    /// - Returns: A key path from the root of this key path to the value type
    ///   of `path`, if `path` can be appended. If `path` can't be appended,
    ///   returns `nil`.
    public func appending<Root, AppendedRoot, AppendedValue>(path: KeyPath<AppendedRoot, AppendedValue>) -> KeyPath<Root, AppendedValue>? where Self == PartialKeyPath<Root>

    /// Returns a new key path created by appending the given key path to this
    /// one.
    ///
    /// Use this method to extend this key path to the value type of another key
    /// path. Appending the key path passed as `path` is successful only if the
    /// root type for `path` matches this key path's value type.
    ///
    /// - Parameter path: The reference writeable key path to append.
    /// - Returns: A key path from the root of this key path to the value type
    ///   of `path`, if `path` can be appended. If `path` can't be appended,
    ///   returns `nil`.
    public func appending<Root, AppendedRoot, AppendedValue>(path: ReferenceWritableKeyPath<AppendedRoot, AppendedValue>) -> ReferenceWritableKeyPath<Root, AppendedValue>? where Self == PartialKeyPath<Root>
}

extension _AppendKeyPath {

    /// Returns a new key path created by appending the given key path to this
    /// one.
    ///
    /// Use this method to extend this key path to the value type of another key
    /// path. Calling `appending(path:)` results in the same key path as if the
    /// given key path had been specified using dot notation. In the following
    /// example, `keyPath1` and `keyPath2` are equivalent:
    ///
    ///     let arrayDescription = \Array<Int>.description
    ///     let keyPath1 = arrayDescription.appending(path: \String.count)
    ///
    ///     let keyPath2 = \Array<Int>.description.count
    ///
    /// - Parameter path: The key path to append.
    /// - Returns: A key path from the root of this key path to the value type of
    ///   `path`.
    public func appending<Root, Value, AppendedValue>(path: KeyPath<Value, AppendedValue>) -> KeyPath<Root, AppendedValue> where Self : KeyPath<Root, Value>

    /// Returns a new key path created by appending the given key path to this
    /// one.
    ///
    /// Use this method to extend this key path to the value type of another key
    /// path. Calling `appending(path:)` results in the same key path as if the
    /// given key path had been specified using dot notation.
    ///
    /// - Parameter path: The key path to append.
    /// - Returns: A key path from the root of this key path to the value type of
    ///   `path`.
    public func appending<Root, Value, AppendedValue>(path: ReferenceWritableKeyPath<Value, AppendedValue>) -> ReferenceWritableKeyPath<Root, AppendedValue> where Self == KeyPath<Root, Value>
}

extension _AppendKeyPath {

    /// Returns a new key path created by appending the given key path to this
    /// one.
    ///
    /// Use this method to extend this key path to the value type of another key
    /// path. Calling `appending(path:)` results in the same key path as if the
    /// given key path had been specified using dot notation.
    ///
    /// - Parameter path: The key path to append.
    /// - Returns: A key path from the root of this key path to the value type of
    ///   `path`.
    public func appending<Root, Value, AppendedValue>(path: WritableKeyPath<Value, AppendedValue>) -> WritableKeyPath<Root, AppendedValue> where Self == WritableKeyPath<Root, Value>

    /// Returns a new key path created by appending the given key path to this
    /// one.
    ///
    /// Use this method to extend this key path to the value type of another key
    /// path. Calling `appending(path:)` results in the same key path as if the
    /// given key path had been specified using dot notation.
    ///
    /// - Parameter path: The key path to append.
    /// - Returns: A key path from the root of this key path to the value type of
    ///   `path`.
    public func appending<Root, Value, AppendedValue>(path: ReferenceWritableKeyPath<Value, AppendedValue>) -> ReferenceWritableKeyPath<Root, AppendedValue> where Self == WritableKeyPath<Root, Value>
}

extension _AppendKeyPath {

    /// Returns a new key path created by appending the given key path to this
    /// one.
    ///
    /// Use this method to extend this key path to the value type of another key
    /// path. Calling `appending(path:)` results in the same key path as if the
    /// given key path had been specified using dot notation.
    ///
    /// - Parameter path: The key path to append.
    /// - Returns: A key path from the root of this key path to the value type of
    ///   `path`.
    public func appending<Root, Value, AppendedValue>(path: WritableKeyPath<Value, AppendedValue>) -> ReferenceWritableKeyPath<Root, AppendedValue> where Self == ReferenceWritableKeyPath<Root, Value>
}

/// A type that is just a wrapper over some base Sequence
public protocol _SequenceWrapper : Sequence {

    associatedtype Base : Sequence where Self.Element == Self.Base.Element

    associatedtype Iterator = Self.Base.Iterator

    associatedtype SubSequence = Self.Base.SubSequence
}

extension _SequenceWrapper {

    public var underestimatedCount: Int { get }
}

extension _SequenceWrapper where Self.Iterator == Self.Base.Iterator {

    public func makeIterator() -> Self.Iterator
}

extension _SequenceWrapper {

    public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]

    public func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> [Self.Element]

    public func forEach(_ body: (Self.Element) throws -> Void) rethrows
}

extension _SequenceWrapper where Self.SubSequence == Self.Base.SubSequence {

    public func dropFirst(_ n: Int) -> Self.SubSequence

    public func dropLast(_ n: Int) -> Self.SubSequence

    public func prefix(_ maxLength: Int) -> Self.SubSequence

    public func suffix(_ maxLength: Int) -> Self.SubSequence

    public func drop(while predicate: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence

    public func prefix(while predicate: (Self.Element) throws -> Bool) rethrows -> Self.SubSequence

    public func split(maxSplits: Int, omittingEmptySubsequences: Bool, whereSeparator isSeparator: (Self.Element) throws -> Bool) rethrows -> [Self.SubSequence]
}

/// Returns the absolute value of the given number.
///
/// The absolute value of `x` must be representable in the same type. In
/// particular, the absolute value of a signed, fixed-width integer type's
/// minimum cannot be represented.
///
///     let x = Int8.min
///     // x == -128
///     let y = abs(x)
///     // Overflow error
///
/// - Parameter x: A signed number.
/// - Returns: The absolute value of `x`.
public func abs<T>(_ x: T) -> T where T : Comparable, T : SignedNumeric

/// Returns the absolute value of the given number.
///
/// - Parameter x: A signed number.
/// - Returns: The absolute value of `x`.
public func abs<T>(_ x: T) -> T where T : SignedNumeric, T == T.Magnitude

/// Returns the absolute value of `x`.
public func abs<T>(_ x: T) -> T where T : FloatingPoint, T == T.Magnitude

/// Performs a traditional C-style assert with an optional message.
///
/// Use this function for internal sanity checks that are active during testing
/// but do not impact performance of shipping code. To check for invalid usage
/// in Release builds, see `precondition(_:_:file:line:)`.
///
/// * In playgrounds and `-Onone` builds (the default for Xcode's Debug
///   configuration): If `condition` evaluates to `false`, stop program
///   execution in a debuggable state after printing `message`.
///
/// * In `-O` builds (the default for Xcode's Release configuration),
///   `condition` is not evaluated, and there are no effects.
///
/// * In `-Ounchecked` builds, `condition` is not evaluated, but the optimizer
///   may assume that it *always* evaluates to `true`. Failure to satisfy that
///   assumption is a serious programming error.
///
/// - Parameters:
///   - condition: The condition to test. `condition` is only evaluated in
///     playgrounds and `-Onone` builds.
///   - message: A string to print if `condition` is evaluated to `false`. The
///     default is an empty string.
///   - file: The file name to print with `message` if the assertion fails. The
///     default is the file where `assert(_:_:file:line:)` is called.
///   - line: The line number to print along with `message` if the assertion
///     fails. The default is the line number where `assert(_:_:file:line:)`
///     is called.
public func assert(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)

/// Indicates that an internal sanity check failed.
///
/// Use this function to stop the program, without impacting the performance of
/// shipping code, when control flow is not expected to reach the call---for
/// example, in the `default` case of a `switch` where you have knowledge that
/// one of the other cases must be satisfied. To protect code from invalid
/// usage in Release builds, see `preconditionFailure(_:file:line:)`.
///
/// * In playgrounds and -Onone builds (the default for Xcode's Debug
///   configuration), stop program execution in a debuggable state after
///   printing `message`.
///
/// * In -O builds, has no effect.
///
/// * In -Ounchecked builds, the optimizer may assume that this function is
///   never called. Failure to satisfy that assumption is a serious
///   programming error.
///
/// - Parameters:
///   - message: A string to print in a playground or `-Onone` build. The
///     default is an empty string.
///   - file: The file name to print with `message`. The default is the file
///     where `assertionFailure(_:file:line:)` is called.
///   - line: The line number to print along with `message`. The default is the
///     line number where `assertionFailure(_:file:line:)` is called.
public func assertionFailure(_ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)

/// Writes the textual representations of the given items most suitable for
/// debugging into the given output stream.
///
/// You can pass zero or more items to the
/// `debugPrint(_:separator:terminator:to:)` function. The textual
/// representation for each item is the same as that obtained by calling
/// `String(reflecting: item)`. The following example prints a closed range of
/// integers to a string:
///
///     var range = "My range: "
///     debugPrint(1...5, to: &range)
///     // range == "My range: ClosedRange(1...5)\n"
///
/// To print the items separated by something other than a space, pass a string
/// as `separator`.
///
///     var separated = ""
///     debugPrint(1.0, 2.0, 3.0, 4.0, 5.0, separator: " ... ", to: &separated)
///     // separated == "1.0 ... 2.0 ... 3.0 ... 4.0 ... 5.0\n"
///
/// The output from each call to `debugPrint(_:separator:terminator:to:)`
/// includes a newline by default. To print the items without a trailing
/// newline, pass an empty string as `terminator`.
///
///     var numbers = ""
///     for n in 1...5 {
///         debugPrint(n, terminator: "", to: &numbers)
///     }
///     // numbers == "12345"
///
/// - Parameters:
///   - items: Zero or more items to print.
///   - separator: A string to print between each item. The default is a single
///     space (`" "`).
///   - terminator: The string to print after all items have been printed. The
///     default is a newline (`"\n"`).
///   - output: An output stream to receive the text representation of each
///     item.
public func debugPrint<Target>(_ items: Any..., separator: String = default, terminator: String = default, to output: inout Target) where Target : TextOutputStream

/// Writes the textual representations of the given items most suitable for
/// debugging into the standard output.
///
/// You can pass zero or more items to the
/// `debugPrint(_:separator:terminator:)` function. The textual representation
/// for each item is the same as that obtained by calling
/// `String(reflecting: item)`. The following example prints the debugging
/// representation of a string, a closed range of integers, and a group of
/// floating-point values to standard output:
///
///     debugPrint("One two three four five")
///     // Prints "One two three four five"
///
///     debugPrint(1...5)
///     // Prints "ClosedRange(1...5)"
///
///     debugPrint(1.0, 2.0, 3.0, 4.0, 5.0)
///     // Prints "1.0 2.0 3.0 4.0 5.0"
///
/// To print the items separated by something other than a space, pass a string
/// as `separator`.
///
///     debugPrint(1.0, 2.0, 3.0, 4.0, 5.0, separator: " ... ")
///     // Prints "1.0 ... 2.0 ... 3.0 ... 4.0 ... 5.0"
///
/// The output from each call to `debugPrint(_:separator:terminator:)` includes
/// a newline by default. To print the items without a trailing newline, pass
/// an empty string as `terminator`.
///
///     for n in 1...5 {
///         debugPrint(n, terminator: "")
///     }
///     // Prints "12345"
///
/// - Parameters:
///   - items: Zero or more items to print.
///   - separator: A string to print between each item. The default is a single
///     space (`" "`).
///   - terminator: The string to print after all items have been printed. The
///     default is a newline (`"\n"`).
public func debugPrint(_ items: Any..., separator: String = default, terminator: String = default)

/// Dumps the given object's contents using its mirror to standard output.
///
/// - Parameters:
///   - value: The value to output to the `target` stream.
///   - name: A label to use when writing the contents of `value`. When `nil`
///     is passed, the label is omitted. The default is `nil`.
///   - indent: The number of spaces to use as an indent for each line of the
///     output. The default is `0`.
///   - maxDepth: The maximum depth to descend when writing the contents of a
///     value that has nested components. The default is `Int.max`.
///   - maxItems: The maximum number of elements for which to write the full
///     contents. The default is `Int.max`.
/// - Returns: The instance passed as `value`.
public func dump<T>(_ value: T, name: String? = default, indent: Int = default, maxDepth: Int = default, maxItems: Int = default) -> T

/// Dumps the given object's contents using its mirror to the specified output
/// stream.
///
/// - Parameters:
///   - value: The value to output to the `target` stream.
///   - target: The stream to use for writing the contents of `value`.
///   - name: A label to use when writing the contents of `value`. When `nil`
///     is passed, the label is omitted. The default is `nil`.
///   - indent: The number of spaces to use as an indent for each line of the
///     output. The default is `0`.
///   - maxDepth: The maximum depth to descend when writing the contents of a
///     value that has nested components. The default is `Int.max`.
///   - maxItems: The maximum number of elements for which to write the full
///     contents. The default is `Int.max`.
/// - Returns: The instance passed as `value`.
public func dump<T, TargetStream>(_ value: T, to target: inout TargetStream, name: String? = default, indent: Int = default, maxDepth: Int = default, maxItems: Int = default) -> T where TargetStream : TextOutputStream

/// Unconditionally prints a given message and stops execution.
///
/// - Parameters:
///   - message: The string to print. The default is an empty string.
///   - file: The file name to print with `message`. The default is the file
///     where `fatalError(_:file:line:)` is called.
///   - line: The line number to print along with `message`. The default is the
///     line number where `fatalError(_:file:line:)` is called.
public func fatalError(_ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line) -> Never

/// Returns a `CVaListPointer` that is backed by autoreleased storage, built
/// from the given array of arguments.
///
/// You should prefer `withVaList(_:_:)` instead of this function. In some
/// uses, such as in a `class` initializer, you may find that the language
/// rules do not allow you to use `withVaList(_:_:)` as intended.
///
/// If you need to pass an optional pointer as a `CVarArg` argument, use the
/// `Int(bitPattern:)` initializer to interpret the optional pointer as an
/// `Int` value, which has the same C variadic calling conventions as a pointer
/// on all supported platforms.
///
/// - Parameter args: An array of arguments to convert to a C `va_list`
///   pointer.
/// - Returns: A pointer that can be used with C functions that take a
///   `va_list` argument.
public func getVaList(_ args: [CVarArg]) -> CVaListPointer

/// Returns a Boolean value indicating whether the given object is known to
/// have a single strong reference.
///
/// The `isKnownUniquelyReferenced(_:)` function is useful for implementing the
/// copy-on-write optimization for the deep storage of value types:
///
///     mutating func update(withValue value: T) {
///         if !isKnownUniquelyReferenced(&myStorage) {
///             myStorage = self.copiedStorage()
///         }
///         myStorage.update(withValue: value)
///     }
///
/// Use care when calling `isKnownUniquelyReferenced(_:)` from within a Boolean
/// expression. In debug builds, an instance in the left-hand side of a `&&`
/// or `||` expression may still be referenced when evaluating the right-hand
/// side, inflating the instance's reference count. For example, this version
/// of the `update(withValue)` method will re-copy `myStorage` on every call:
///
///     // Copies too frequently:
///     mutating func badUpdate(withValue value: T) {
///         if myStorage.shouldCopy || !isKnownUniquelyReferenced(&myStorage) {
///             myStorage = self.copiedStorage()
///         }
///         myStorage.update(withValue: value)
///     }
///
/// To avoid this behavior, swap the call `isKnownUniquelyReferenced(_:)` to
/// the left-hand side or store the result of the first expression in a local
/// constant:
///
///     mutating func goodUpdate(withValue value: T) {
///         let shouldCopy = myStorage.shouldCopy
///         if shouldCopy || !isKnownUniquelyReferenced(&myStorage) {
///             myStorage = self.copiedStorage()
///         }
///         myStorage.update(withValue: value)
///     }
///
/// `isKnownUniquelyReferenced(_:)` checks only for strong references to the
/// given object---if `object` has additional weak or unowned references, the
/// result may still be `true`. Because weak and unowned references cannot be
/// the only reference to an object, passing a weak or unowned reference as
/// `object` always results in `false`.
///
/// If the instance passed as `object` is being accessed by multiple threads
/// simultaneously, this function may still return `true`. Therefore, you must
/// only call this function from mutating methods with appropriate thread
/// synchronization. That will ensure that `isKnownUniquelyReferenced(_:)`
/// only returns `true` when there is really one accessor, or when there is a
/// race condition, which is already undefined behavior.
///
/// - Parameter object: An instance of a class. This function does *not* modify
///   `object`; the use of `inout` is an implementation artifact.
/// - Returns: `true` if `object` is known to have a single strong reference;
///   otherwise, `false`.
public func isKnownUniquelyReferenced<T>(_ object: inout T) -> Bool where T : AnyObject

/// Returns a Boolean value indicating whether the given object is known to
/// have a single strong reference.
///
/// The `isKnownUniquelyReferenced(_:)` function is useful for implementing the
/// copy-on-write optimization for the deep storage of value types:
///
///     mutating func update(withValue value: T) {
///         if !isKnownUniquelyReferenced(&myStorage) {
///             myStorage = self.copiedStorage()
///         }
///         myStorage.update(withValue: value)
///     }
///
/// `isKnownUniquelyReferenced(_:)` checks only for strong references to the
/// given object---if `object` has additional weak or unowned references, the
/// result may still be `true`. Because weak and unowned references cannot be
/// the only reference to an object, passing a weak or unowned reference as
/// `object` always results in `false`.
///
/// If the instance passed as `object` is being accessed by multiple threads
/// simultaneously, this function may still return `true`. Therefore, you must
/// only call this function from mutating methods with appropriate thread
/// synchronization. That will ensure that `isKnownUniquelyReferenced(_:)`
/// only returns `true` when there is really one accessor, or when there is a
/// race condition, which is already undefined behavior.
///
/// - Parameter object: An instance of a class. This function does *not* modify
///   `object`; the use of `inout` is an implementation artifact.
/// - Returns: `true` if `object` is known to have a single strong reference;
///   otherwise, `false`. If `object` is `nil`, the return value is `false`.
public func isKnownUniquelyReferenced<T>(_ object: inout T?) -> Bool where T : AnyObject

/// Returns the greater of two comparable values.
///
/// - Parameters:
///   - x: A value to compare.
///   - y: Another value to compare.
/// - Returns: The greater of `x` and `y`. If `x` is equal to `y`, returns `y`.
public func max<T>(_ x: T, _ y: T) -> T where T : Comparable

/// Returns the greatest argument passed.
///
/// - Parameters:
///   - x: A value to compare.
///   - y: Another value to compare.
///   - z: A third value to compare.
///   - rest: Zero or more additional values.
/// - Returns: The greatest of all the arguments. If there are multiple equal
///   greatest arguments, the result is the last one.
public func max<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Comparable

/// Returns the least argument passed.
///
/// - Parameters:
///   - x: A value to compare.
///   - y: Another value to compare.
///   - z: A third value to compare.
///   - rest: Zero or more additional values.
/// - Returns: The least of all the arguments. If there are multiple equal
///   least arguments, the result is the first one.
public func min<T>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T where T : Comparable

/// Returns the lesser of two comparable values.
///
/// - Parameters:
///   - x: A value to compare.
///   - y: Another value to compare.
/// - Returns: The lesser of `x` and `y`. If `x` is equal to `y`, returns `x`.
public func min<T>(_ x: T, _ y: T) -> T where T : Comparable

/// Returns the given integer as the equivalent value in a different integer
/// type.
///
/// The `numericCast(_:)` function traps on overflow in `-O` and `-Onone`
/// builds.
///
/// You can use `numericCast(_:)` to convert a value when the destination type
/// can be inferred from the context. In the following example, the
/// `random(in:)` function uses `numericCast(_:)` twice to convert the
/// argument and return value of the `arc4random_uniform(_:)` function to the
/// appropriate type.
///
///     func random(in range: Range<Int>) -> Int {
///         return numericCast(arc4random_uniform(numericCast(range.count)))
///             + range.lowerBound
///     }
///
///     let number = random(in: -10...<10)
///     // number == -3, perhaps
///
/// - Parameter x: The integer to convert, and instance of type `T`.
/// - Returns: The value of `x` converted to type `U`.
public func numericCast<T, U>(_ x: T) -> U where T : BinaryInteger, U : BinaryInteger

/// Checks a necessary condition for making forward progress.
///
/// Use this function to detect conditions that must prevent the program from
/// proceeding, even in shipping code.
///
/// * In playgrounds and `-Onone` builds (the default for Xcode's Debug
///   configuration): If `condition` evaluates to `false`, stop program
///   execution in a debuggable state after printing `message`.
///
/// * In `-O` builds (the default for Xcode's Release configuration): If
///   `condition` evaluates to `false`, stop program execution.
///
/// * In `-Ounchecked` builds, `condition` is not evaluated, but the optimizer
///   may assume that it *always* evaluates to `true`. Failure to satisfy that
///   assumption is a serious programming error.
///
/// - Parameters:
///   - condition: The condition to test. `condition` is not evaluated in
///     `-Ounchecked` builds.
///   - message: A string to print if `condition` is evaluated to `false` in a
///     playground or `-Onone` build. The default is an empty string.
///   - file: The file name to print with `message` if the precondition fails.
///     The default is the file where `precondition(_:_:file:line:)` is
///     called.
///   - line: The line number to print along with `message` if the assertion
///     fails. The default is the line number where
///     `precondition(_:_:file:line:)` is called.
public func precondition(_ condition: @autoclosure () -> Bool, _ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line)

/// Indicates that a precondition was violated.
///
/// Use this function to stop the program when control flow can only reach the
/// call if your API was improperly used. This function's effects vary
/// depending on the build flag used:
///
/// * In playgrounds and `-Onone` builds (the default for Xcode's Debug
///   configuration), stops program execution in a debuggable state after
///   printing `message`.
///
/// * In `-O` builds (the default for Xcode's Release configuration), stops
///   program execution.
///
/// * In `-Ounchecked` builds, the optimizer may assume that this function is
///   never called. Failure to satisfy that assumption is a serious
///   programming error.
///
/// - Parameters:
///   - message: A string to print in a playground or `-Onone` build. The
///     default is an empty string.
///   - file: The file name to print with `message`. The default is the file
///     where `preconditionFailure(_:file:line:)` is called.
///   - line: The line number to print along with `message`. The default is the
///     line number where `preconditionFailure(_:file:line:)` is called.
public func preconditionFailure(_ message: @autoclosure () -> String = default, file: StaticString = #file, line: UInt = #line) -> Never

/// Writes the textual representations of the given items into the given output
/// stream.
///
/// You can pass zero or more items to the `print(_:separator:terminator:to:)`
/// function. The textual representation for each item is the same as that
/// obtained by calling `String(item)`. The following example prints a closed
/// range of integers to a string:
///
///     var range = "My range: "
///     print(1...5, to: &range)
///     // range == "My range: 1...5\n"
///
/// To print the items separated by something other than a space, pass a string
/// as `separator`.
///
///     var separated = ""
///     print(1.0, 2.0, 3.0, 4.0, 5.0, separator: " ... ", to: &separated)
///     // separated == "1.0 ... 2.0 ... 3.0 ... 4.0 ... 5.0\n"
///
/// The output from each call to `print(_:separator:terminator:to:)` includes a
/// newline by default. To print the items without a trailing newline, pass an
/// empty string as `terminator`.
///
///     var numbers = ""
///     for n in 1...5 {
///         print(n, terminator: "", to: &numbers)
///     }
///     // numbers == "12345"
///
/// - Parameters:
///   - items: Zero or more items to print.
///   - separator: A string to print between each item. The default is a single
///     space (`" "`).
///   - terminator: The string to print after all items have been printed. The
///     default is a newline (`"\n"`).
///   - output: An output stream to receive the text representation of each
///     item.
public func print<Target>(_ items: Any..., separator: String = default, terminator: String = default, to output: inout Target) where Target : TextOutputStream

/// Writes the textual representations of the given items into the standard
/// output.
///
/// You can pass zero or more items to the `print(_:separator:terminator:)`
/// function. The textual representation for each item is the same as that
/// obtained by calling `String(item)`. The following example prints a string,
/// a closed range of integers, and a group of floating-point values to
/// standard output:
///
///     print("One two three four five")
///     // Prints "One two three four five"
///
///     print(1...5)
///     // Prints "1...5"
///
///     print(1.0, 2.0, 3.0, 4.0, 5.0)
///     // Prints "1.0 2.0 3.0 4.0 5.0"
///
/// To print the items separated by something other than a space, pass a string
/// as `separator`.
///
///     print(1.0, 2.0, 3.0, 4.0, 5.0, separator: " ... ")
///     // Prints "1.0 ... 2.0 ... 3.0 ... 4.0 ... 5.0"
///
/// The output from each call to `print(_:separator:terminator:)` includes a
/// newline by default. To print the items without a trailing newline, pass an
/// empty string as `terminator`.
///
///     for n in 1...5 {
///         print(n, terminator: "")
///     }
///     // Prints "12345"
///
/// - Parameters:
///   - items: Zero or more items to print.
///   - separator: A string to print between each item. The default is a single
///     space (`" "`).
///   - terminator: The string to print after all items have been printed. The
///     default is a newline (`"\n"`).
public func print(_ items: Any..., separator: String = default, terminator: String = default)

/// Returns a string read from standard input through the end of the current
/// line or until EOF is reached.
///
/// Standard input is interpreted as `UTF-8`. Invalid bytes are replaced by
/// Unicode [replacement characters][rc].
///
/// [rc]:
/// http://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character
///
/// - Parameter strippingNewline: If `true`, newline characters and character
///   combinations are stripped from the result; otherwise, newline characters
///   or character combinations are preserved. The default is `true`.
/// - Returns: The string of characters read from standard input. If EOF has
///   already been reached when `readLine()` is called, the result is `nil`.
public func readLine(strippingNewline: Bool = default) -> String?

/// Creates a collection containing the specified number of the given element.
///
/// The following example creates a `Repeated<Int>` collection containing five
/// zeroes:
///
///     let zeroes = repeatElement(0, count: 5)
///     for x in zeroes {
///         print(x)
///     }
///     // 0
///     // 0
///     // 0
///     // 0
///     // 0
///
/// - Parameters:
///   - element: The element to repeat.
///   - count: The number of times to repeat `element`.
/// - Returns: A collection that contains `count` elements that are all
///   `element`.
public func repeatElement<T>(_ element: T, count n: Int) -> Repeated<T>

/// Returns a sequence formed from repeated lazy applications of `next` to a
/// mutable `state`.
///
/// The elements of the sequence are obtained by invoking `next` with a mutable
/// state. The same state is passed to all invocations of `next`, so subsequent
/// calls will see any mutations made by previous calls. The sequence ends when
/// `next` returns `nil`. If `next` never returns `nil`, the sequence is
/// infinite.
///
/// This function can be used to replace many instances of `AnyIterator` that
/// wrap a closure.
///
/// Example:
///
///     // Interleave two sequences that yield the same element type
///     sequence(state: (false, seq1.makeIterator(), seq2.makeIterator()), next: { iters in
///       iters.0 = !iters.0
///       return iters.0 ? iters.1.next() : iters.2.next()
///     })
///
/// - Parameter state: The initial state that will be passed to the closure.
/// - Parameter next: A closure that accepts an `inout` state and returns the
///   next element of the sequence.
/// - Returns: A sequence that yields each successive value from `next`.
public func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> UnfoldSequence<T, State>

/// Returns a sequence formed from `first` and repeated lazy applications of
/// `next`.
///
/// The first element in the sequence is always `first`, and each successive
/// element is the result of invoking `next` with the previous element. The
/// sequence ends when `next` returns `nil`. If `next` never returns `nil`, the
/// sequence is infinite.
///
/// This function can be used to replace many cases that were previously handled
/// using C-style `for` loops.
///
/// Example:
///
///     // Walk the elements of a tree from a node up to the root
///     for node in sequence(first: leaf, next: { $0.parent }) {
///       // node is leaf, then leaf.parent, then leaf.parent.parent, etc.
///     }
///
///     // Iterate over all powers of two (ignoring overflow)
///     for value in sequence(first: 1, next: { $0 * 2 }) {
///       // value is 1, then 2, then 4, then 8, etc.
///     }
///
/// - Parameter first: The first element to be returned from the sequence.
/// - Parameter next: A closure that accepts the previous sequence element and
///   returns the next element.
/// - Returns: A sequence that starts with `first` and continues with every
///   value returned by passing the previous element to `next`.
public func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldFirstSequence<T>

/// Returns a sequence from a starting value to, but not including, an end
/// value, stepping by the specified amount.
///
/// You can use this function to stride over values of any type that conforms
/// to the `Strideable` protocol, such as integers or floating-point types.
/// Starting with `start`, each successive value of the sequence adds `stride`
/// until the next value would be equal to or beyond `end`.
///
///     for radians in stride(from: 0.0, to: .pi * 2, by: .pi / 2) {
///         let degrees = Int(radians * 180 / .pi)
///         print("Degrees: \(degrees), radians: \(radians)")
///     }
///     // Degrees: 0, radians: 0.0
///     // Degrees: 90, radians: 1.5707963267949
///     // Degrees: 180, radians: 3.14159265358979
///     // Degrees: 270, radians: 4.71238898038469
///
/// You can use `stride(from:to:by:)` to create a sequence that strides upward
/// or downward. Pass a negative value as `stride` to create a sequence from a
/// higher start to a lower end:
///
///     for countdown in stride(from: 3, to: 0, by: -1) {
///         print("\(countdown)...")
///     }
///     // 3...
///     // 2...
///     // 1...
///
/// If you pass a value as `stride` that moves away from `end`, the sequence
/// contains no values.
///
///     for x in stride(from: 0, to: 10, by: -1) {
///         print(x)
///     }
///     // Nothing is printed.
///
/// - Parameters:
///   - start: The starting value to use for the sequence. If the sequence
///     contains any values, the first one is `start`.
///   - end: An end value to limit the sequence. `end` is never an element of
///     the resulting sequence.
///   - stride: The amount to step by with each iteration. A positive `stride`
///     iterates upward; a negative `stride` iterates downward.
/// - Returns: A sequence from `start` toward, but not including, `end`. Each
///   value in the sequence steps by `stride`.
public func stride<T>(from start: T, to end: T, by stride: T.Stride) -> StrideTo<T> where T : Strideable

/// Returns a sequence from a starting value toward, and possibly including, an end
/// value, stepping by the specified amount.
///
/// You can use this function to stride over values of any type that conforms
/// to the `Strideable` protocol, such as integers or floating-point types.
/// Starting with `start`, each successive value of the sequence adds `stride`
/// until the next value would be beyond `end`.
///
///     for radians in stride(from: 0.0, through: .pi * 2, by: .pi / 2) {
///         let degrees = Int(radians * 180 / .pi)
///         print("Degrees: \(degrees), radians: \(radians)")
///     }
///     // Degrees: 0, radians: 0.0
///     // Degrees: 90, radians: 1.5707963267949
///     // Degrees: 180, radians: 3.14159265358979
///     // Degrees: 270, radians: 4.71238898038469
///     // Degrees: 360, radians: 6.28318530717959
///
/// You can use `stride(from:through:by:)` to create a sequence that strides 
/// upward or downward. Pass a negative value as `stride` to create a sequence 
/// from a higher start to a lower end:
///
///     for countdown in stride(from: 3, through: 1, by: -1) {
///         print("\(countdown)...")
///     }
///     // 3...
///     // 2...
///     // 1...
///
/// The value you pass as `end` is not guaranteed to be included in the 
/// sequence. If stepping from `start` by `stride` does not produce `end`, 
/// the last value in the sequence will be one step before going beyond `end`.
///
///     for multipleOfThree in stride(from: 3, through: 10, by: 3) {
///         print(multipleOfThree)
///     }
///     // 3
///     // 6
///     // 9
///
/// If you pass a value as `stride` that moves away from `end`, the sequence 
/// contains no values.
///
///     for x in stride(from: 0, through: 10, by: -1) {
///         print(x)
///     }
///     // Nothing is printed.
///
/// - Parameters:
///   - start: The starting value to use for the sequence. If the sequence
///     contains any values, the first one is `start`.
///   - end: An end value to limit the sequence. `end` is an element of
///     the resulting sequence if and only if it can be produced from `start` 
///     using steps of `stride`.
///   - stride: The amount to step by with each iteration. A positive `stride`
///     iterates upward; a negative `stride` iterates downward.
/// - Returns: A sequence from `start` toward, and possibly including, `end`. 
///   Each value in the sequence is separated by `stride`.
public func stride<T>(from start: T, through end: T, by stride: T.Stride) -> StrideThrough<T> where T : Strideable

/// Exchanges the values of the two arguments.
///
/// The two arguments must not alias each other. To swap two elements of a
/// mutable collection, use the `swapAt(_:_:)` method of that collection
/// instead of this function.
///
/// - Parameters:
///   - a: The first value to swap.
///   - b: The second value to swap.
public func swap<T>(_ a: inout T, _ b: inout T)

/// Translates the given input from one Unicode encoding to another by calling
/// the given closure.
///
/// The following example transcodes the UTF-8 representation of the string
/// `"Fermata "` into UTF-32.
///
///     let fermata = "Fermata "
///     let bytes = fermata.utf8
///     print(Array(bytes))
///     // Prints "[70, 101, 114, 109, 97, 116, 97, 32, 240, 157, 132, 144]"
///
///     var codeUnits: [UTF32.CodeUnit] = []
///     let sink = { codeUnits.append($0) }
///     transcode(bytes.makeIterator(), from: UTF8.self, to: UTF32.self,
///               stoppingOnError: false, into: sink)
///     print(codeUnits)
///     // Prints "[70, 101, 114, 109, 97, 116, 97, 32, 119056]"
///
/// The `sink` closure is called with each resulting UTF-32 code unit as the
/// function iterates over its input.
///
/// - Parameters:
///   - input: An iterator of code units to be translated, encoded as
///     `inputEncoding`. If `stopOnError` is `false`, the entire iterator will
///     be exhausted. Otherwise, iteration will stop if an encoding error is
///     detected.
///   - inputEncoding: The Unicode encoding of `input`.
///   - outputEncoding: The destination Unicode encoding.
///   - stopOnError: Pass `true` to stop translation when an encoding error is
///     detected in `input`. Otherwise, a Unicode replacement character
///     (`"\u{FFFD}"`) is inserted for each detected error.
///   - processCodeUnit: A closure that processes one `outputEncoding` code
///     unit at a time.
/// - Returns: `true` if the translation detected encoding errors in `input`;
///   otherwise, `false`.
public func transcode<Input, InputEncoding, OutputEncoding>(_ input: Input, from inputEncoding: InputEncoding.Type, to outputEncoding: OutputEncoding.Type, stoppingOnError stopOnError: Bool, into processCodeUnit: (OutputEncoding.CodeUnit) -> Void) -> Bool where Input : IteratorProtocol, InputEncoding : _UnicodeEncoding, OutputEncoding : _UnicodeEncoding, Input.Element == InputEncoding.CodeUnit

/// Returns the dynamic type of a value.
///
/// You can use the `type(of:)` function to find the dynamic type of a value,
/// particularly when the dynamic type is different from the static type. The
/// *static type* of a value is the known, compile-time type of the value. The
/// *dynamic type* of a value is the value's actual type at run-time, which
/// can be nested inside its concrete type.
///
/// In the following code, the `count` variable has the same static and dynamic
/// type: `Int`. When `count` is passed to the `printInfo(_:)` function,
/// however, the `value` parameter has a static type of `Any` (the type
/// declared for the parameter) and a dynamic type of `Int`.
///
///     func printInfo(_ value: Any) {
///         let type = type(of: value)
///         print("'\(value)' of type '\(type)'")
///     }
///
///     let count: Int = 5
///     printInfo(count)
///     // '5' of type 'Int'
///
/// The dynamic type returned from `type(of:)` is a *concrete metatype*
/// (`T.Type`) for a class, structure, enumeration, or other nonprotocol type
/// `T`, or an *existential metatype* (`P.Type`) for a protocol or protocol
/// composition `P`. When the static type of the value passed to `type(of:)`
/// is constrained to a class or protocol, you can use that metatype to access
/// initializers or other static members of the class or protocol.
///
/// For example, the parameter passed as `value` to the `printSmileyInfo(_:)`
/// function in the example below is an instance of the `Smiley` class or one
/// of its subclasses. The function uses `type(of:)` to find the dynamic type
/// of `value`, which itself is an instance of the `Smiley.Type` metatype.
///
///     class Smiley {
///         class var text: String {
///             return ":)"
///         }
///     }
///
///     class EmojiSmiley : Smiley {
///          override class var text: String {
///             return ""
///         }
///     }
///
///     func printSmileyInfo(_ value: Smiley) {
///         let smileyType = type(of: value)
///         print("Smile!", smileyType.text)
///     }
///
///     let emojiSmiley = EmojiSmiley()
///     printSmileyInfo(emojiSmiley)
///     // Smile! 
///
/// In this example, accessing the `text` property of the `smileyType` metatype
/// retrieves the overridden value from the `EmojiSmiley` subclass, instead of
/// the `Smiley` class's original definition.
///
/// Finding the Dynamic Type in a Generic Context
/// =============================================
///
/// Normally, you don't need to be aware of the difference between concrete and
/// existential metatypes, but calling `type(of:)` can yield unexpected
/// results in a generic context with a type parameter bound to a protocol. In
/// a case like this, where a generic parameter `T` is bound to a protocol
/// `P`, the type parameter is not statically known to be a protocol type in
/// the body of the generic function. As a result, `type(of:)` can only
/// produce the concrete metatype `P.Protocol`.
///
/// The following example defines a `printGenericInfo(_:)` function that takes
/// a generic parameter and declares the `String` type's conformance to a new
/// protocol `P`. When `printGenericInfo(_:)` is called with a string that has
/// `P` as its static type, the call to `type(of:)` returns `P.self` instead
/// of `String.self` (the dynamic type inside the parameter).
///
///     func printGenericInfo<T>(_ value: T) {
///         let type = type(of: value)
///         print("'\(value)' of type '\(type)'")
///     }
///
///     protocol P {}
///     extension String: P {}
///
///     let stringAsP: P = "Hello!"
///     printGenericInfo(stringAsP)
///     // 'Hello!' of type 'P'
///
/// This unexpected result occurs because the call to `type(of: value)` inside
/// `printGenericInfo(_:)` must return a metatype that is an instance of
/// `T.Type`, but `String.self` (the expected dynamic type) is not an instance
/// of `P.Type` (the concrete metatype of `value`). To get the dynamic type
/// inside `value` in this generic context, cast the parameter to `Any` when
/// calling `type(of:)`.
///
///     func betterPrintGenericInfo<T>(_ value: T) {
///         let type = type(of: value as Any)
///         print("'\(value)' of type '\(type)'")
///     }
///
///     betterPrintGenericInfo(stringAsP)
///     // 'Hello!' of type 'String'
///
/// - Parameter value: The value for which to find the dynamic type.
/// - Returns: The dynamic type, which is a metatype instance.
public func type<T, Metatype>(of value: T) -> Metatype

/// Returns the bits of the given instance, interpreted as having the specified
/// type.
///
/// Use this function only to convert the instance passed as `x` to a
/// layout-compatible type when conversion through other means is not
/// possible. Common conversions supported by the Swift standard library
/// include the following:
///
/// - Value conversion from one integer type to another. Use the destination
///   type's initializer or the `numericCast(_:)` function.
/// - Bitwise conversion from one integer type to another. Use the destination
///   type's `init(truncatingIfNeeded:)` or `init(bitPattern:)` initializer.
/// - Conversion from a pointer to an integer value with the bit pattern of the
///   pointer's address in memory, or vice versa. Use the `init(bitPattern:)`
///   initializer for the destination type.
/// - Casting an instance of a reference type. Use the casting operators (`as`,
///   `as!`, or `as?`) or the `unsafeDowncast(_:to:)` function. Do not use
///   `unsafeBitCast(_:to:)` with class or pointer types; doing so may
///   introduce undefined behavior.
///
/// - Warning: Calling this function breaks the guarantees of the Swift type
///   system; use with extreme care.
///
/// - Parameters:
///   - x: The instance to cast to `type`.
///   - type: The type to cast `x` to. `type` and the type of `x` must have the
///     same size of memory representation and compatible memory layout.
/// - Returns: A new instance of type `U`, cast from `x`.
public func unsafeBitCast<T, U>(_ x: T, to type: U.Type) -> U

/// Returns the given instance cast unconditionally to the specified type.
///
/// The instance passed as `x` must be an instance of type `T`.
///
/// Use this function instead of `unsafeBitcast(_:to:)` because this function
/// is more restrictive and still performs a check in debug builds. In -O
/// builds, no test is performed to ensure that `x` actually has the dynamic
/// type `T`.
///
/// - Warning: This function trades safety for performance. Use
///   `unsafeDowncast(_:to:)` only when you are confident that `x is T` always
///   evaluates to `true`, and only after `x as! T` has proven to be a
///   performance problem.
///
/// - Parameters:
///   - x: An instance to cast to type `T`.
///   - type: The type `T` to which `x` is cast.
/// - Returns: The instance `x`, cast to type `T`.
public func unsafeDowncast<T>(_ x: AnyObject, to type: T.Type) -> T where T : AnyObject

/// Evaluates a closure while ensuring that the given instance is not destroyed
/// before the closure returns.
///
/// - Parameters:
///   - x: An instance to preserve until the execution of `body` is completed.
///   - body: A closure to execute that depends on the lifetime of `x` being
///     extended. If `body` has a return value, that value is also used as the
///     return value for the `withExtendedLifetime(_:_:)` method.
/// - Returns: The return value, if any, of the `body` closure parameter.
public func withExtendedLifetime<T, Result>(_ x: T, _ body: () throws -> Result) rethrows -> Result

/// Evaluates a closure while ensuring that the given instance is not destroyed
/// before the closure returns.
///
/// - Parameters:
///   - x: An instance to preserve until the execution of `body` is completed.
///   - body: A closure to execute that depends on the lifetime of `x` being
///     extended. If `body` has a return value, that value is also used as the
///     return value for the `withExtendedLifetime(_:_:)` method.
/// - Returns: The return value, if any, of the `body` closure parameter.
public func withExtendedLifetime<T, Result>(_ x: T, _ body: (T) throws -> Result) rethrows -> Result

/// Invokes the given closure with a buffer pointer covering the raw bytes of
/// the given argument.
///
/// The buffer pointer argument to the `body` closure provides a collection
/// interface to the raw bytes of `value`. The buffer is the size of the
/// instance passed as `value` and does not include any remote storage.
///
/// - Parameters:
///   - value: An instance to temporarily access through a raw buffer pointer.
///   - body: A closure that takes a raw buffer pointer to the bytes of `value`
///     as its sole argument. If the closure has a return value, that value is
///     also used as the return value of the `withUnsafeBytes(of:_:)`
///     function. The buffer pointer argument is valid only for the duration
///     of the closure's execution. It is undefined behavior to attempt to
///     mutate through the pointer by conversion to
///     `UnsafeMutableRawBufferPointer` or any other mutable pointer type.
///     If you want to mutate a value by writing through a pointer, use
///     `withUnsafeMutableBytes(of:_:)` instead.
/// - Returns: The return value, if any, of the `body` closure.
public func withUnsafeBytes<T, Result>(of value: T, _ body: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result

/// Invokes the given closure with a buffer pointer covering the raw bytes of
/// the given argument.
///
/// The buffer pointer argument to the `body` closure provides a collection
/// interface to the raw bytes of `value`. The buffer is the size of the
/// instance passed as `value` and does not include any remote storage.
///
/// - Parameters:
///   - value: An instance to temporarily access through a raw buffer pointer.
///     Note that the `inout` exclusivity rules mean that, like any other
///     `inout` argument, `value` cannot be directly accessed by other code
///     for the duration of `body`. Access must only occur through the pointer
///     argument to `body` until `body` returns.
///   - body: A closure that takes a raw buffer pointer to the bytes of `value`
///     as its sole argument. If the closure has a return value, that value is
///     also used as the return value of the `withUnsafeBytes(of:_:)`
///     function. The buffer pointer argument is valid only for the duration
///     of the closure's execution. It is undefined behavior to attempt to
///     mutate through the pointer by conversion to
///     `UnsafeMutableRawBufferPointer` or any other mutable pointer type.
///     If you want to mutate a value by writing through a pointer, use
///     `withUnsafeMutableBytes(of:_:)` instead.
/// - Returns: The return value, if any, of the `body` closure.
public func withUnsafeBytes<T, Result>(of value: inout T, _ body: (UnsafeRawBufferPointer) throws -> Result) rethrows -> Result

/// Invokes the given closure with a mutable buffer pointer covering the raw
/// bytes of the given argument.
///
/// The buffer pointer argument to the `body` closure provides a collection
/// interface to the raw bytes of `value`. The buffer is the size of the
/// instance passed as `value` and does not include any remote storage.
///
/// - Parameters:
///   - value: An instance to temporarily access through a mutable raw buffer
///     pointer.
///     Note that the `inout` exclusivity rules mean that, like any other
///     `inout` argument, `value` cannot be directly accessed by other code
///     for the duration of `body`. Access must only occur through the pointer
///     argument to `body` until `body` returns.
///   - body: A closure that takes a raw buffer pointer to the bytes of `value`
///     as its sole argument. If the closure has a return value, that value is
///     also used as the return value of the `withUnsafeMutableBytes(of:_:)`
///     function. The buffer pointer argument is valid only for the duration
///     of the closure's execution.
/// - Returns: The return value, if any, of the `body` closure.
public func withUnsafeMutableBytes<T, Result>(of value: inout T, _ body: (UnsafeMutableRawBufferPointer) throws -> Result) rethrows -> Result

/// Calls the given closure with a mutable pointer to the given argument.
///
/// The `withUnsafeMutablePointer(to:_:)` function is useful for calling
/// Objective-C APIs that take in/out parameters (and default-constructible
/// out parameters) by pointer.
///
/// The pointer argument to `body` is valid only during the execution of
/// `withUnsafeMutablePointer(to:_:)`. Do not store or return the pointer for
/// later use.
///
/// - Parameters:
///   - value: An instance to temporarily use via pointer. Note that the `inout`
///     exclusivity rules mean that, like any other `inout` argument, `value`
///     cannot be directly accessed by other code for the duration of `body`.
///     Access must only occur through the pointer argument to `body` until
///     `body` returns.
///   - body: A closure that takes a mutable pointer to `value` as its sole
///     argument. If the closure has a return value, that value is also used
///     as the return value of the `withUnsafeMutablePointer(to:_:)` function.
///     The pointer argument is valid only for the duration of the function's
///     execution.
/// - Returns: The return value, if any, of the `body` closure.
public func withUnsafeMutablePointer<T, Result>(to value: inout T, _ body: (UnsafeMutablePointer<T>) throws -> Result) rethrows -> Result

/// Invokes the given closure with a pointer to the given argument.
///
/// The `withUnsafePointer(to:_:)` function is useful for calling Objective-C
/// APIs that take in parameters by const pointer.
///
/// The pointer argument to `body` is valid only during the execution of
/// `withUnsafePointer(to:_:)`. Do not store or return the pointer for later
/// use.
///
/// - Parameters:
///   - value: An instance to temporarily use via pointer. Note that the `inout`
///     exclusivity rules mean that, like any other `inout` argument, `value`
///     cannot be directly accessed by other code for the duration of `body`.
///     Access must only occur through the pointer argument to `body` until
///     `body` returns.
///   - body: A closure that takes a pointer to `value` as its sole argument. If
///     the closure has a return value, that value is also used as the return
///     value of the `withUnsafePointer(to:_:)` function. The pointer argument
///     is valid only for the duration of the function's execution.
///     It is undefined behavior to try to mutate through the pointer argument
///     by converting it to `UnsafeMutablePointer` or any other mutable pointer
///     type. If you need to mutate the argument through the pointer, use
///     `withUnsafeMutablePointer(to:_:)` instead.
/// - Returns: The return value, if any, of the `body` closure.
public func withUnsafePointer<T, Result>(to value: inout T, _ body: (UnsafePointer<T>) throws -> Result) rethrows -> Result

/// Invokes the given closure with a pointer to the given argument.
///
/// The `withUnsafePointer(to:_:)` function is useful for calling Objective-C
/// APIs that take in parameters by const pointer.
///
/// The pointer argument to `body` is valid only during the execution of
/// `withUnsafePointer(to:_:)`. Do not store or return the pointer for later
/// use.
///
/// - Parameters:
///   - value: An instance to temporarily use via pointer.
///   - body: A closure that takes a pointer to `value` as its sole argument. If
///     the closure has a return value, that value is also used as the return
///     value of the `withUnsafePointer(to:_:)` function. The pointer argument
///     is valid only for the duration of the function's execution.
///     It is undefined behavior to try to mutate through the pointer argument
///     by converting it to `UnsafeMutablePointer` or any other mutable pointer
///     type. If you need to mutate the argument through the pointer, use
///     `withUnsafeMutablePointer(to:_:)` instead.
/// - Returns: The return value, if any, of the `body` closure.
public func withUnsafePointer<T, Result>(to value: T, _ body: (UnsafePointer<T>) throws -> Result) rethrows -> Result

/// Invokes the given closure with a C `va_list` argument derived from the
/// given array of arguments.
///
/// The pointer passed as an argument to `body` is valid only during the
/// execution of `withVaList(_:_:)`. Do not store or return the pointer for
/// later use.
///
/// If you need to pass an optional pointer as a `CVarArg` argument, use the
/// `Int(bitPattern:)` initializer to interpret the optional pointer as an
/// `Int` value, which has the same C variadic calling conventions as a pointer
/// on all supported platforms.
///
/// - Parameters:
///   - args: An array of arguments to convert to a C `va_list` pointer.
///   - body: A closure with a `CVaListPointer` parameter that references the
///     arguments passed as `args`. If `body` has a return value, that value
///     is also used as the return value for the `withVaList(_:)` function.
///     The pointer argument is valid only for the duration of the function's
///     execution.
/// - Returns: The return value, if any, of the `body` closure parameter.
public func withVaList<R>(_ args: [CVarArg], _ body: (CVaListPointer) -> R) -> R

/// Allows a nonescaping closure to temporarily be used as if it were allowed
/// to escape.
///
/// You can use this function to call an API that takes an escaping closure in
/// a way that doesn't allow the closure to escape in practice. The examples
/// below demonstrate how to use `withoutActuallyEscaping(_:do:)` in
/// conjunction with two common APIs that use escaping closures: lazy
/// collection views and asynchronous operations.
///
/// The following code declares an `allValues(in:match:)` function that checks
/// whether all the elements in an array match a predicate. The function won't
/// compile as written, because a lazy collection's `filter(_:)` method
/// requires an escaping closure. The lazy collection isn't persisted, so the
/// `predicate` closure won't actually escape the body of the function;
/// nevertheless, it can't be used in this way.
///
///     func allValues(in array: [Int], match predicate: (Int) -> Bool) -> Bool {
///         return array.lazy.filter { !predicate($0) }.isEmpty
///     }
///     // error: closure use of non-escaping parameter 'predicate'...
///
/// `withoutActuallyEscaping(_:do:)` provides a temporarily escapable copy of
/// `predicate` that _can_ be used in a call to the lazy view's `filter(_:)`
/// method. The second version of `allValues(in:match:)` compiles without
/// error, with the compiler guaranteeing that the `escapablePredicate`
/// closure doesn't last beyond the call to `withoutActuallyEscaping(_:do:)`.
///
///     func allValues(in array: [Int], match predicate: (Int) -> Bool) -> Bool {
///         return withoutActuallyEscaping(predicate) { escapablePredicate in
///             array.lazy.filter { !escapablePredicate($0) }.isEmpty
///         }
///     }
///
/// Asynchronous calls are another type of API that typically escape their
/// closure arguments. The following code declares a
/// `perform(_:simultaneouslyWith:)` function that uses a dispatch queue to
/// execute two closures concurrently.
///
///     func perform(_ f: () -> Void, simultaneouslyWith g: () -> Void) {
///         let queue = DispatchQueue(label: "perform", attributes: .concurrent)
///         queue.async(execute: f)
///         queue.async(execute: g)
///         queue.sync(flags: .barrier) {}
///     }
///     // error: passing non-escaping parameter 'f'...
///     // error: passing non-escaping parameter 'g'...
///
/// The `perform(_:simultaneouslyWith:)` function ends with a call to the
/// `sync(flags:execute:)` method using the `.barrier` flag, which forces the
/// function to wait until both closures have completed running before
/// returning. Even though the barrier guarantees that neither closure will
/// escape the function, the `async(execute:)` method still requires that the
/// closures passed be marked as `@escaping`, so the first version of the
/// function does not compile. To resolve these errors, you can use
/// `withoutActuallyEscaping(_:do:)` to get copies of `f` and `g` that can be
/// passed to `async(execute:)`.
///
///     func perform(_ f: () -> Void, simultaneouslyWith g: () -> Void) {
///         withoutActuallyEscaping(f) { escapableF in
///             withoutActuallyEscaping(g) { escapableG in
///                 let queue = DispatchQueue(label: "perform", attributes: .concurrent)
///                 queue.async(execute: escapableF)
///                 queue.async(execute: escapableG)
///                 queue.sync(flags: .barrier) {}
///             }
///         }
///     }
///
/// - Important: The escapable copy of `closure` passed to `body` is only valid
///   during the call to `withoutActuallyEscaping(_:do:)`. It is undefined
///   behavior for the escapable closure to be stored, referenced, or executed
///   after the function returns.
///
/// - Parameters:
///   - closure: A nonescaping closure value that is made escapable for the
///     duration of the execution of the `body` closure. If `body` has a
///     return value, that value is also used as the return value for the
///     `withoutActuallyEscaping(_:do:)` function.
///   - body: A closure that is executed immediately with an escapable copy of
///     `closure` as its argument.
/// - Returns: The return value, if any, of the `body` closure.
public func withoutActuallyEscaping<ClosureType, ResultType>(_ closure: ClosureType, do body: (ClosureType) throws -> ResultType) rethrows -> ResultType

/// Creates a sequence of pairs built out of two underlying sequences.
///
/// In the `Zip2Sequence` instance returned by this function, the elements of
/// the *i*th pair are the *i*th elements of each underlying sequence. The
/// following example uses the `zip(_:_:)` function to iterate over an array
/// of strings and a countable range at the same time:
///
///     let words = ["one", "two", "three", "four"]
///     let numbers = 1...4
///
///     for (word, number) in zip(words, numbers) {
///         print("\(word): \(number)")
///     }
///     // Prints "one: 1"
///     // Prints "two: 2
///     // Prints "three: 3"
///     // Prints "four: 4"
///
/// If the two sequences passed to `zip(_:_:)` are different lengths, the
/// resulting sequence is the same length as the shorter sequence. In this
/// example, the resulting array is the same length as `words`:
///
///     let naturalNumbers = 1...Int.max
///     let zipped = Array(zip(words, naturalNumbers))
///     // zipped == [("one", 1), ("two", 2), ("three", 3), ("four", 4)]
///
/// - Parameters:
///   - sequence1: The first sequence or collection to zip.
///   - sequence2: The second sequence or collection to zip.
/// - Returns: A sequence of tuple pairs, where the elements of each pair are
///   corresponding elements of `sequence1` and `sequence2`.
public func zip<Sequence1, Sequence2>(_ sequence1: Sequence1, _ sequence2: Sequence2) -> Zip2Sequence<Sequence1, Sequence2> where Sequence1 : Sequence, Sequence2 : Sequence

/// Returns a Boolean value indicating whether two arguments match by value
/// equality.
///
/// The pattern-matching operator (`~=`) is used internally in `case`
/// statements for pattern matching. When you match against an `Equatable`
/// value in a `case` statement, this operator is called behind the scenes.
///
///     let weekday = 3
///     let lunch: String
///     switch weekday {
///     case 3:
///         lunch = "Taco Tuesday!"
///     default:
///         lunch = "Pizza again."
///     }
///     // lunch == "Taco Tuesday!"
///
/// In this example, the `case 3` expression uses this pattern-matching
/// operator to test whether `weekday` is equal to the value `3`.
///
/// - Note: In most cases, you should use the equal-to operator (`==`) to test
///   whether two instances are equal. The pattern-matching operator is
///   primarily intended to enable `case` statement pattern matching.
///
/// - Parameters:
///   - lhs: A value to compare.
///   - rhs: Another value to compare.
public func ~= <T>(a: T, b: T) -> Bool where T : Equatable

precedencegroup BitwiseShiftPrecedence {
    higherThan: MultiplicationPrecedence
}

precedencegroup AssignmentPrecedence {
    associativity: right
    assignment: true
}

precedencegroup ComparisonPrecedence {
    higherThan: LogicalConjunctionPrecedence
}

precedencegroup NilCoalescingPrecedence {
    associativity: right
    higherThan: ComparisonPrecedence
}

precedencegroup RangeFormationPrecedence {
    higherThan: CastingPrecedence
}

precedencegroup TernaryPrecedence {
    associativity: right
    higherThan: FunctionArrowPrecedence
}

precedencegroup DefaultPrecedence {
    higherThan: TernaryPrecedence
}

precedencegroup LogicalDisjunctionPrecedence {
    associativity: left
    higherThan: TernaryPrecedence
}

precedencegroup LogicalConjunctionPrecedence {
    associativity: left
    higherThan: LogicalDisjunctionPrecedence
}

precedencegroup CastingPrecedence {
    higherThan: NilCoalescingPrecedence
}

precedencegroup AdditionPrecedence {
    associativity: left
    higherThan: RangeFormationPrecedence
}

precedencegroup MultiplicationPrecedence {
    associativity: left
    higherThan: AdditionPrecedence
}

precedencegroup FunctionArrowPrecedence {
    associativity: right
    higherThan: AssignmentPrecedence
}

infix operator %= : AssignmentPrecedence

infix operator -= : AssignmentPrecedence

infix operator && : LogicalConjunctionPrecedence

infix operator &* : MultiplicationPrecedence

infix operator &+ : AdditionPrecedence

infix operator &- : AdditionPrecedence

infix operator === : ComparisonPrecedence

infix operator == : ComparisonPrecedence

infix operator &<<= : AssignmentPrecedence

infix operator &<< : BitwiseShiftPrecedence

infix operator &= : AssignmentPrecedence

infix operator % : MultiplicationPrecedence

infix operator & : MultiplicationPrecedence

infix operator *= : AssignmentPrecedence

infix operator * : MultiplicationPrecedence

infix operator + : AdditionPrecedence

infix operator - : AdditionPrecedence

infix operator / : MultiplicationPrecedence

infix operator != : ComparisonPrecedence

infix operator | : AdditionPrecedence

infix operator ~> : DefaultPrecedence

infix operator &-= : AssignmentPrecedence

infix operator <<= : AssignmentPrecedence

infix operator ~= : ComparisonPrecedence

infix operator !== : ComparisonPrecedence

infix operator |= : AssignmentPrecedence

infix operator >= : ComparisonPrecedence

infix operator >> : BitwiseShiftPrecedence

infix operator < : ComparisonPrecedence

infix operator > : ComparisonPrecedence

infix operator += : AssignmentPrecedence

infix operator >>= : AssignmentPrecedence

infix operator <= : ComparisonPrecedence

infix operator ... : RangeFormationPrecedence

infix operator /= : AssignmentPrecedence

infix operator &*= : AssignmentPrecedence

infix operator || : LogicalDisjunctionPrecedence

infix operator ..< : RangeFormationPrecedence

infix operator ^= : AssignmentPrecedence

infix operator ^ : AdditionPrecedence

infix operator ?? : NilCoalescingPrecedence

infix operator &>>= : AssignmentPrecedence

infix operator &>> : BitwiseShiftPrecedence

infix operator &+= : AssignmentPrecedence

infix operator << : BitwiseShiftPrecedence

prefix operator ..<

prefix operator ...

prefix operator --

prefix operator ++

prefix operator -

prefix operator +

prefix operator ~

prefix operator !

postfix operator ...

postfix operator --

postfix operator ++

